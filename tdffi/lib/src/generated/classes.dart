// ignore_for_file: overridden_fields, annotate_overrides, camel_case_types, non_constant_identifier_names, unnecessary_question_mark, no_leading_underscores_for_local_identifiers, constant_identifier_names
import './abc.dart';

/// An object of this type can be returned on every function call, in case of an error.
///
class Error extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "error";

  /// Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user.
  late int code;

  /// Error message; subject to future changes.
  late String message;

  /// An object of this type can be returned on every function call, in case of an error
  Error({required this.code, required this.message, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'error',
      if (extra != null) '@extra': extra,
      'code': code,
      'message': message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Error? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = _map['code']! as int;
    var message = _map['message']! as String;
    return Error(
      extra: extra,
      clientId: clientId,
      code: code,
      message: message,
    );
  }
}

/// An object of this type is returned on a successful function call for certain functions.
///
class Ok extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "ok";

  /// An object of this type is returned on a successful function call for certain functions
  Ok({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'ok', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Ok? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return Ok(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// An authentication code is delivered via a private Telegram message, which can be viewed from another active session.
///
class AuthenticationCodeTypeTelegramMessage extends AuthenticationCodeType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authenticationCodeTypeTelegramMessage";

  /// Length of the code.
  late int length;

  /// An authentication code is delivered via a private Telegram message, which can be viewed from another active session
  AuthenticationCodeTypeTelegramMessage(
      {required this.length, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authenticationCodeTypeTelegramMessage',
      if (extra != null) '@extra': extra,
      'length': length
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthenticationCodeTypeTelegramMessage? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var length = _map['length']! as int;
    return AuthenticationCodeTypeTelegramMessage(
      extra: extra,
      clientId: clientId,
      length: length,
    );
  }
}

/// An authentication code is delivered via an SMS message to the specified phone number; applications may not receive this type of code.
///
class AuthenticationCodeTypeSms extends AuthenticationCodeType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authenticationCodeTypeSms";

  /// Length of the code.
  late int length;

  /// An authentication code is delivered via an SMS message to the specified phone number; applications may not receive this type of code
  AuthenticationCodeTypeSms({required this.length, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authenticationCodeTypeSms',
      if (extra != null) '@extra': extra,
      'length': length
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthenticationCodeTypeSms? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var length = _map['length']! as int;
    return AuthenticationCodeTypeSms(
      extra: extra,
      clientId: clientId,
      length: length,
    );
  }
}

/// An authentication code is delivered via a phone call to the specified phone number.
///
class AuthenticationCodeTypeCall extends AuthenticationCodeType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authenticationCodeTypeCall";

  /// Length of the code.
  late int length;

  /// An authentication code is delivered via a phone call to the specified phone number
  AuthenticationCodeTypeCall({required this.length, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authenticationCodeTypeCall',
      if (extra != null) '@extra': extra,
      'length': length
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthenticationCodeTypeCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var length = _map['length']! as int;
    return AuthenticationCodeTypeCall(
      extra: extra,
      clientId: clientId,
      length: length,
    );
  }
}

/// An authentication code is delivered by an immediately canceled call to the specified phone number. The phone number that calls is the code that must be entered automatically.
///
class AuthenticationCodeTypeFlashCall extends AuthenticationCodeType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authenticationCodeTypeFlashCall";

  /// Pattern of the phone number from which the call will be made.
  late String pattern;

  /// An authentication code is delivered by an immediately canceled call to the specified phone number. The phone number that calls is the code that must be entered automatically
  AuthenticationCodeTypeFlashCall(
      {required this.pattern, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authenticationCodeTypeFlashCall',
      if (extra != null) '@extra': extra,
      'pattern': pattern
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthenticationCodeTypeFlashCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var pattern = _map['pattern']! as String;
    return AuthenticationCodeTypeFlashCall(
      extra: extra,
      clientId: clientId,
      pattern: pattern,
    );
  }
}

/// An authentication code is delivered by an immediately canceled call to the specified phone number. The last digits of the phone number that calls are the code that must be entered manually by the user.
///
class AuthenticationCodeTypeMissedCall extends AuthenticationCodeType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authenticationCodeTypeMissedCall";

  /// Prefix of the phone number from which the call will be made.
  late String phone_number_prefix;

  /// Number of digits in the code, excluding the prefix.
  late int length;

  /// An authentication code is delivered by an immediately canceled call to the specified phone number. The last digits of the phone number that calls are the code that must be entered manually by the user
  AuthenticationCodeTypeMissedCall(
      {required this.phone_number_prefix,
      required this.length,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authenticationCodeTypeMissedCall',
      if (extra != null) '@extra': extra,
      'phone_number_prefix': phone_number_prefix,
      'length': length
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthenticationCodeTypeMissedCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number_prefix = _map['phone_number_prefix']! as String;
    var length = _map['length']! as int;
    return AuthenticationCodeTypeMissedCall(
      extra: extra,
      clientId: clientId,
      phone_number_prefix: phone_number_prefix,
      length: length,
    );
  }
}

/// An authentication code is delivered to https://fragment.com. The user must be logged in there via a wallet owning the phone number's NFT.
///
class AuthenticationCodeTypeFragment extends AuthenticationCodeType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authenticationCodeTypeFragment";

  /// URL to open to receive the code.
  late String url;

  /// Length of the code.
  late int length;

  /// An authentication code is delivered to https://fragment.com. The user must be logged in there via a wallet owning the phone number's NFT
  AuthenticationCodeTypeFragment(
      {required this.url, required this.length, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authenticationCodeTypeFragment',
      if (extra != null) '@extra': extra,
      'url': url,
      'length': length
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthenticationCodeTypeFragment? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var length = _map['length']! as int;
    return AuthenticationCodeTypeFragment(
      extra: extra,
      clientId: clientId,
      url: url,
      length: length,
    );
  }
}

/// An authentication code is delivered via Firebase Authentication to the official Android application.
///
class AuthenticationCodeTypeFirebaseAndroid extends AuthenticationCodeType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authenticationCodeTypeFirebaseAndroid";

  /// Nonce to pass to the SafetyNet Attestation API.
  /// ; base64-encoded bytes `List<int>`
  late bytes nonce;

  /// Length of the code.
  late int length;

  /// An authentication code is delivered via Firebase Authentication to the official Android application
  AuthenticationCodeTypeFirebaseAndroid(
      {required this.nonce, required this.length, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authenticationCodeTypeFirebaseAndroid',
      if (extra != null) '@extra': extra,
      'nonce': nonce,
      'length': length
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthenticationCodeTypeFirebaseAndroid? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var nonce = _map['nonce']! as bytes;
    var length = _map['length']! as int;
    return AuthenticationCodeTypeFirebaseAndroid(
      extra: extra,
      clientId: clientId,
      nonce: nonce,
      length: length,
    );
  }
}

/// An authentication code is delivered via Firebase Authentication to the official iOS application.
///
class AuthenticationCodeTypeFirebaseIos extends AuthenticationCodeType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authenticationCodeTypeFirebaseIos";

  /// Receipt of successful application token validation to compare with receipt from push notification.
  late String receipt;

  /// Time after the next authentication method is supposed to be used if verification push notification isn't received, in seconds.
  late int push_timeout;

  /// Length of the code.
  late int length;

  /// An authentication code is delivered via Firebase Authentication to the official iOS application
  AuthenticationCodeTypeFirebaseIos(
      {required this.receipt,
      required this.push_timeout,
      required this.length,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authenticationCodeTypeFirebaseIos',
      if (extra != null) '@extra': extra,
      'receipt': receipt,
      'push_timeout': push_timeout,
      'length': length
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthenticationCodeTypeFirebaseIos? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var receipt = _map['receipt']! as String;
    var push_timeout = _map['push_timeout']! as int;
    var length = _map['length']! as int;
    return AuthenticationCodeTypeFirebaseIos(
      extra: extra,
      clientId: clientId,
      receipt: receipt,
      push_timeout: push_timeout,
      length: length,
    );
  }
}

/// Information about the authentication code that was sent.
///
class AuthenticationCodeInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authenticationCodeInfo";

  /// A phone number that is being authenticated.
  late String phone_number;

  /// The way the code was sent to the user.
  late AuthenticationCodeType type;

  /// The way the next code will be sent to the user; may be null.
  AuthenticationCodeType? next_type;

  /// Timeout before the code can be re-sent, in seconds.
  late int timeout;

  /// Information about the authentication code that was sent
  AuthenticationCodeInfo(
      {required this.phone_number,
      required this.type,
      this.next_type,
      required this.timeout,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authenticationCodeInfo',
      if (extra != null) '@extra': extra,
      'phone_number': phone_number,
      'type': type,
      'next_type': next_type,
      'timeout': timeout
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthenticationCodeInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number = _map['phone_number']! as String;
    var type = AuthenticationCodeType.fromMap(_map['type'])!;
    var next_type = AuthenticationCodeType.fromMap(_map['next_type']);
    var timeout = _map['timeout']! as int;
    return AuthenticationCodeInfo(
      extra: extra,
      clientId: clientId,
      phone_number: phone_number,
      type: type,
      next_type: next_type,
      timeout: timeout,
    );
  }
}

/// Information about the email address authentication code that was sent.
///
class EmailAddressAuthenticationCodeInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emailAddressAuthenticationCodeInfo";

  /// Pattern of the email address to which an authentication code was sent.
  late String email_address_pattern;

  /// Length of the code; 0 if unknown.
  late int length;

  /// Information about the email address authentication code that was sent
  EmailAddressAuthenticationCodeInfo(
      {required this.email_address_pattern,
      required this.length,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emailAddressAuthenticationCodeInfo',
      if (extra != null) '@extra': extra,
      'email_address_pattern': email_address_pattern,
      'length': length
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmailAddressAuthenticationCodeInfo? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var email_address_pattern = _map['email_address_pattern']! as String;
    var length = _map['length']! as int;
    return EmailAddressAuthenticationCodeInfo(
      extra: extra,
      clientId: clientId,
      email_address_pattern: email_address_pattern,
      length: length,
    );
  }
}

/// An authentication code delivered to a user's email address.
///
class EmailAddressAuthenticationCode extends EmailAddressAuthentication {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emailAddressAuthenticationCode";

  /// The code.
  late String code;

  /// An authentication code delivered to a user's email address
  EmailAddressAuthenticationCode(
      {required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emailAddressAuthenticationCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmailAddressAuthenticationCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = _map['code']! as String;
    return EmailAddressAuthenticationCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// An authentication token received through Apple ID.
///
class EmailAddressAuthenticationAppleId extends EmailAddressAuthentication {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emailAddressAuthenticationAppleId";

  /// The token.
  late String token;

  /// An authentication token received through Apple ID
  EmailAddressAuthenticationAppleId(
      {required this.token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emailAddressAuthenticationAppleId',
      if (extra != null) '@extra': extra,
      'token': token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmailAddressAuthenticationAppleId? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    return EmailAddressAuthenticationAppleId(
      extra: extra,
      clientId: clientId,
      token: token,
    );
  }
}

/// An authentication token received through Google ID.
///
class EmailAddressAuthenticationGoogleId extends EmailAddressAuthentication {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emailAddressAuthenticationGoogleId";

  /// The token.
  late String token;

  /// An authentication token received through Google ID
  EmailAddressAuthenticationGoogleId(
      {required this.token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emailAddressAuthenticationGoogleId',
      if (extra != null) '@extra': extra,
      'token': token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmailAddressAuthenticationGoogleId? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    return EmailAddressAuthenticationGoogleId(
      extra: extra,
      clientId: clientId,
      token: token,
    );
  }
}

/// Email address can be reset after the given period. Call resetAuthenticationEmailAddress to reset it and allow the user to authorize with a code sent to the user's phone number.
///
class EmailAddressResetStateAvailable extends EmailAddressResetState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emailAddressResetStateAvailable";

  /// Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium.
  late int wait_period;

  /// Email address can be reset after the given period. Call resetAuthenticationEmailAddress to reset it and allow the user to authorize with a code sent to the user's phone number
  EmailAddressResetStateAvailable(
      {required this.wait_period, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emailAddressResetStateAvailable',
      if (extra != null) '@extra': extra,
      'wait_period': wait_period
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmailAddressResetStateAvailable? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var wait_period = _map['wait_period']! as int;
    return EmailAddressResetStateAvailable(
      extra: extra,
      clientId: clientId,
      wait_period: wait_period,
    );
  }
}

/// Email address reset has already been requested. Call resetAuthenticationEmailAddress to check whether immediate reset is possible.
///
class EmailAddressResetStatePending extends EmailAddressResetState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emailAddressResetStatePending";

  /// Left time before the email address will be reset, in seconds. updateAuthorizationState is not sent when this field changes.
  late int reset_in;

  /// Email address reset has already been requested. Call resetAuthenticationEmailAddress to check whether immediate reset is possible
  EmailAddressResetStatePending(
      {required this.reset_in, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emailAddressResetStatePending',
      if (extra != null) '@extra': extra,
      'reset_in': reset_in
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmailAddressResetStatePending? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reset_in = _map['reset_in']! as int;
    return EmailAddressResetStatePending(
      extra: extra,
      clientId: clientId,
      reset_in: reset_in,
    );
  }
}

/// Represents a part of the text that needs to be formatted in some unusual way.
///
class TextEntity extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntity";

  /// Offset of the entity, in UTF-16 code units.
  late int offset;

  /// Length of the entity, in UTF-16 code units.
  late int length;

  /// Type of the entity.
  late TextEntityType type;

  /// Represents a part of the text that needs to be formatted in some unusual way
  TextEntity(
      {required this.offset,
      required this.length,
      required this.type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntity',
      if (extra != null) '@extra': extra,
      'offset': offset,
      'length': length,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntity? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var offset = _map['offset']! as int;
    var length = _map['length']! as int;
    var type = TextEntityType.fromMap(_map['type'])!;
    return TextEntity(
      extra: extra,
      clientId: clientId,
      offset: offset,
      length: length,
      type: type,
    );
  }
}

/// Contains a list of text entities.
///
class TextEntities extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntities";

  /// List of text entities.
  late List<TextEntity> entities;

  /// Contains a list of text entities
  TextEntities({required this.entities, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntities',
      if (extra != null) '@extra': extra,
      'entities': entities
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntities? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var entities = List<TextEntity>.from(
      (_map["entities"] ?? []).map(
        (e) => TextEntity.fromMap(e),
      ),
    );
    return TextEntities(
      extra: extra,
      clientId: clientId,
      entities: entities,
    );
  }
}

/// A text with some entities.
///
class FormattedText extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "formattedText";

  /// The text.
  late String text;

  /// Entities contained in the text. Entities can be nested, but must not mutually intersect with each other..
  late List<TextEntity> entities;

  /// A text with some entities
  FormattedText(
      {required this.text, required this.entities, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'formattedText',
      if (extra != null) '@extra': extra,
      'text': text,
      'entities': entities
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FormattedText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var entities = List<TextEntity>.from(
      (_map["entities"] ?? []).map(
        (e) => TextEntity.fromMap(e),
      ),
    );
    return FormattedText(
      extra: extra,
      clientId: clientId,
      text: text,
      entities: entities,
    );
  }
}

/// Contains Telegram terms of service.
///
class TermsOfService extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "termsOfService";

  /// Text of the terms of service.
  late FormattedText text;

  /// The minimum age of a user to be able to accept the terms; 0 if age isn't restricted.
  late int min_user_age;

  /// True, if a blocking popup with terms of service must be shown to the user.
  late bool show_popup;

  /// Contains Telegram terms of service
  TermsOfService(
      {required this.text,
      required this.min_user_age,
      required this.show_popup,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'termsOfService',
      if (extra != null) '@extra': extra,
      'text': text,
      'min_user_age': min_user_age,
      'show_popup': show_popup
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TermsOfService? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = FormattedText.fromMap(_map['text'])!;
    var min_user_age = _map['min_user_age']! as int;
    var show_popup = _map['show_popup']! as bool;
    return TermsOfService(
      extra: extra,
      clientId: clientId,
      text: text,
      min_user_age: min_user_age,
      show_popup: show_popup,
    );
  }
}

/// Initialization parameters are needed. Call setTdlibParameters to provide them.
///
class AuthorizationStateWaitTdlibParameters extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateWaitTdlibParameters";

  /// Initialization parameters are needed. Call setTdlibParameters to provide them
  AuthorizationStateWaitTdlibParameters({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateWaitTdlibParameters',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateWaitTdlibParameters? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return AuthorizationStateWaitTdlibParameters(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken for other authentication options.
///
class AuthorizationStateWaitPhoneNumber extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateWaitPhoneNumber";

  /// TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken for other authentication options
  AuthorizationStateWaitPhoneNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateWaitPhoneNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateWaitPhoneNumber? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return AuthorizationStateWaitPhoneNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress to provide the email address, or directly call checkAuthenticationEmailCode with Apple ID/Google ID token if allowed.
///
class AuthorizationStateWaitEmailAddress extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateWaitEmailAddress";

  /// True, if authorization through Apple ID is allowed.
  late bool allow_apple_id;

  /// True, if authorization through Google ID is allowed.
  late bool allow_google_id;

  /// TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress to provide the email address, or directly call checkAuthenticationEmailCode with Apple ID/Google ID token if allowed
  AuthorizationStateWaitEmailAddress(
      {required this.allow_apple_id,
      required this.allow_google_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateWaitEmailAddress',
      if (extra != null) '@extra': extra,
      'allow_apple_id': allow_apple_id,
      'allow_google_id': allow_google_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateWaitEmailAddress? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var allow_apple_id = _map['allow_apple_id']! as bool;
    var allow_google_id = _map['allow_google_id']! as bool;
    return AuthorizationStateWaitEmailAddress(
      extra: extra,
      clientId: clientId,
      allow_apple_id: allow_apple_id,
      allow_google_id: allow_google_id,
    );
  }
}

/// TDLib needs the user's authentication code sent to an email address to authorize. Call checkAuthenticationEmailCode to provide the code.
///
class AuthorizationStateWaitEmailCode extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateWaitEmailCode";

  /// True, if authorization through Apple ID is allowed.
  late bool allow_apple_id;

  /// True, if authorization through Google ID is allowed.
  late bool allow_google_id;

  /// Information about the sent authentication code.
  late EmailAddressAuthenticationCodeInfo code_info;

  /// Reset state of the email address; may be null if the email address can't be reset.
  EmailAddressResetState? email_address_reset_state;

  /// TDLib needs the user's authentication code sent to an email address to authorize. Call checkAuthenticationEmailCode to provide the code
  AuthorizationStateWaitEmailCode(
      {required this.allow_apple_id,
      required this.allow_google_id,
      required this.code_info,
      this.email_address_reset_state,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateWaitEmailCode',
      if (extra != null) '@extra': extra,
      'allow_apple_id': allow_apple_id,
      'allow_google_id': allow_google_id,
      'code_info': code_info,
      'email_address_reset_state': email_address_reset_state
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateWaitEmailCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var allow_apple_id = _map['allow_apple_id']! as bool;
    var allow_google_id = _map['allow_google_id']! as bool;
    var code_info =
        EmailAddressAuthenticationCodeInfo.fromMap(_map['code_info'])!;
    var email_address_reset_state =
        EmailAddressResetState.fromMap(_map['email_address_reset_state']);
    return AuthorizationStateWaitEmailCode(
      extra: extra,
      clientId: clientId,
      allow_apple_id: allow_apple_id,
      allow_google_id: allow_google_id,
      code_info: code_info,
      email_address_reset_state: email_address_reset_state,
    );
  }
}

/// TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode to check the code.
///
class AuthorizationStateWaitCode extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateWaitCode";

  /// Information about the authorization code that was sent.
  late AuthenticationCodeInfo code_info;

  /// TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode to check the code
  AuthorizationStateWaitCode(
      {required this.code_info, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateWaitCode',
      if (extra != null) '@extra': extra,
      'code_info': code_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateWaitCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code_info = AuthenticationCodeInfo.fromMap(_map['code_info'])!;
    return AuthorizationStateWaitCode(
      extra: extra,
      clientId: clientId,
      code_info: code_info,
    );
  }
}

/// The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link.
///
class AuthorizationStateWaitOtherDeviceConfirmation extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "authorizationStateWaitOtherDeviceConfirmation";

  /// A tg:// URL for the QR code. The link will be updated frequently.
  late String link;

  /// The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
  AuthorizationStateWaitOtherDeviceConfirmation(
      {required this.link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateWaitOtherDeviceConfirmation',
      if (extra != null) '@extra': extra,
      'link': link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateWaitOtherDeviceConfirmation? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = _map['link']! as String;
    return AuthorizationStateWaitOtherDeviceConfirmation(
      extra: extra,
      clientId: clientId,
      link: link,
    );
  }
}

/// The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration. Call registerUser to accept the terms of service and provide the data.
///
class AuthorizationStateWaitRegistration extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateWaitRegistration";

  /// Telegram terms of service.
  late TermsOfService terms_of_service;

  /// The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration. Call registerUser to accept the terms of service and provide the data
  AuthorizationStateWaitRegistration(
      {required this.terms_of_service, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateWaitRegistration',
      if (extra != null) '@extra': extra,
      'terms_of_service': terms_of_service
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateWaitRegistration? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var terms_of_service = TermsOfService.fromMap(_map['terms_of_service'])!;
    return AuthorizationStateWaitRegistration(
      extra: extra,
      clientId: clientId,
      terms_of_service: terms_of_service,
    );
  }
}

/// The user has been authorized, but needs to enter a 2-step verification password to start using the application..
///
class AuthorizationStateWaitPassword extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateWaitPassword";

  /// Hint for the password; may be empty.
  late String password_hint;

  /// True, if a recovery email address has been set up.
  late bool has_recovery_email_address;

  /// True, if some Telegram Passport elements were saved.
  late bool has_passport_data;

  /// Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent.
  late String recovery_email_address_pattern;

  /// The user has been authorized, but needs to enter a 2-step verification password to start using the application.
  AuthorizationStateWaitPassword(
      {required this.password_hint,
      required this.has_recovery_email_address,
      required this.has_passport_data,
      required this.recovery_email_address_pattern,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateWaitPassword',
      if (extra != null) '@extra': extra,
      'password_hint': password_hint,
      'has_recovery_email_address': has_recovery_email_address,
      'has_passport_data': has_passport_data,
      'recovery_email_address_pattern': recovery_email_address_pattern
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateWaitPassword? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var password_hint = _map['password_hint']! as String;
    var has_recovery_email_address =
        _map['has_recovery_email_address']! as bool;
    var has_passport_data = _map['has_passport_data']! as bool;
    var recovery_email_address_pattern =
        _map['recovery_email_address_pattern']! as String;
    return AuthorizationStateWaitPassword(
      extra: extra,
      clientId: clientId,
      password_hint: password_hint,
      has_recovery_email_address: has_recovery_email_address,
      has_passport_data: has_passport_data,
      recovery_email_address_pattern: recovery_email_address_pattern,
    );
  }
}

/// The user has been successfully authorized. TDLib is now ready to answer general requests.
///
class AuthorizationStateReady extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateReady";

  /// The user has been successfully authorized. TDLib is now ready to answer general requests
  AuthorizationStateReady({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateReady',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateReady? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return AuthorizationStateReady(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is currently logging out.
///
class AuthorizationStateLoggingOut extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateLoggingOut";

  /// The user is currently logging out
  AuthorizationStateLoggingOut({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateLoggingOut',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateLoggingOut? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return AuthorizationStateLoggingOut(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received.
///
class AuthorizationStateClosing extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateClosing";

  /// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
  AuthorizationStateClosing({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateClosing',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateClosing? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return AuthorizationStateClosing(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to.
///
class AuthorizationStateClosed extends AuthorizationState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "authorizationStateClosed";

  /// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to
  AuthorizationStateClosed({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'authorizationStateClosed',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AuthorizationStateClosed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return AuthorizationStateClosed(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents the current state of 2-step verification.
///
class PasswordState extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passwordState";

  /// True, if a 2-step verification password is set.
  late bool has_password;

  /// Hint for the password; may be empty.
  late String password_hint;

  /// True, if a recovery email is set.
  late bool has_recovery_email_address;

  /// True, if some Telegram Passport elements were saved.
  late bool has_passport_data;

  /// Information about the recovery email address to which the confirmation email was sent; may be null.
  EmailAddressAuthenticationCodeInfo? recovery_email_address_code_info;

  /// Pattern of the email address set up for logging in.
  late String login_email_address_pattern;

  /// If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword.
  late int pending_reset_date;

  /// Represents the current state of 2-step verification
  PasswordState(
      {required this.has_password,
      required this.password_hint,
      required this.has_recovery_email_address,
      required this.has_passport_data,
      this.recovery_email_address_code_info,
      required this.login_email_address_pattern,
      required this.pending_reset_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passwordState',
      if (extra != null) '@extra': extra,
      'has_password': has_password,
      'password_hint': password_hint,
      'has_recovery_email_address': has_recovery_email_address,
      'has_passport_data': has_passport_data,
      'recovery_email_address_code_info': recovery_email_address_code_info,
      'login_email_address_pattern': login_email_address_pattern,
      'pending_reset_date': pending_reset_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PasswordState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var has_password = _map['has_password']! as bool;
    var password_hint = _map['password_hint']! as String;
    var has_recovery_email_address =
        _map['has_recovery_email_address']! as bool;
    var has_passport_data = _map['has_passport_data']! as bool;
    var recovery_email_address_code_info =
        EmailAddressAuthenticationCodeInfo.fromMap(
            _map['recovery_email_address_code_info']);
    var login_email_address_pattern =
        _map['login_email_address_pattern']! as String;
    var pending_reset_date = _map['pending_reset_date']! as int;
    return PasswordState(
      extra: extra,
      clientId: clientId,
      has_password: has_password,
      password_hint: password_hint,
      has_recovery_email_address: has_recovery_email_address,
      has_passport_data: has_passport_data,
      recovery_email_address_code_info: recovery_email_address_code_info,
      login_email_address_pattern: login_email_address_pattern,
      pending_reset_date: pending_reset_date,
    );
  }
}

/// Contains information about the current recovery email address.
///
class RecoveryEmailAddress extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "recoveryEmailAddress";

  /// Recovery email address.
  late String recovery_email_address;

  /// Contains information about the current recovery email address
  RecoveryEmailAddress(
      {required this.recovery_email_address, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'recoveryEmailAddress',
      if (extra != null) '@extra': extra,
      'recovery_email_address': recovery_email_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RecoveryEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var recovery_email_address = _map['recovery_email_address']! as String;
    return RecoveryEmailAddress(
      extra: extra,
      clientId: clientId,
      recovery_email_address: recovery_email_address,
    );
  }
}

/// Returns information about the availability of a temporary password, which can be used for payments.
///
class TemporaryPasswordState extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "temporaryPasswordState";

  /// True, if a temporary password is available.
  late bool has_password;

  /// Time left before the temporary password expires, in seconds.
  late int valid_for;

  /// Returns information about the availability of a temporary password, which can be used for payments
  TemporaryPasswordState(
      {required this.has_password,
      required this.valid_for,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'temporaryPasswordState',
      if (extra != null) '@extra': extra,
      'has_password': has_password,
      'valid_for': valid_for
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TemporaryPasswordState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var has_password = _map['has_password']! as bool;
    var valid_for = _map['valid_for']! as int;
    return TemporaryPasswordState(
      extra: extra,
      clientId: clientId,
      has_password: has_password,
      valid_for: valid_for,
    );
  }
}

/// Represents a local file.
///
class LocalFile extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "localFile";

  /// Local path to the locally available file part; may be empty.
  late String path;

  /// True, if it is possible to download or generate the file.
  late bool can_be_downloaded;

  /// True, if the file can be deleted.
  late bool can_be_deleted;

  /// True, if the file is currently being downloaded (or a local copy is being generated by some other means).
  late bool is_downloading_active;

  /// True, if the local copy is fully available.
  late bool is_downloading_completed;

  /// Download will be started from this offset. downloaded_prefix_size is calculated from this offset.
  late int download_offset;

  /// If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes.
  late int downloaded_prefix_size;

  /// Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage.
  late int downloaded_size;

  /// Represents a local file
  LocalFile(
      {required this.path,
      required this.can_be_downloaded,
      required this.can_be_deleted,
      required this.is_downloading_active,
      required this.is_downloading_completed,
      required this.download_offset,
      required this.downloaded_prefix_size,
      required this.downloaded_size,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'localFile',
      if (extra != null) '@extra': extra,
      'path': path,
      'can_be_downloaded': can_be_downloaded,
      'can_be_deleted': can_be_deleted,
      'is_downloading_active': is_downloading_active,
      'is_downloading_completed': is_downloading_completed,
      'download_offset': download_offset,
      'downloaded_prefix_size': downloaded_prefix_size,
      'downloaded_size': downloaded_size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LocalFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var path = _map['path']! as String;
    var can_be_downloaded = _map['can_be_downloaded']! as bool;
    var can_be_deleted = _map['can_be_deleted']! as bool;
    var is_downloading_active = _map['is_downloading_active']! as bool;
    var is_downloading_completed = _map['is_downloading_completed']! as bool;
    var download_offset = _map['download_offset']! as int;
    var downloaded_prefix_size = _map['downloaded_prefix_size']! as int;
    var downloaded_size = _map['downloaded_size']! as int;
    return LocalFile(
      extra: extra,
      clientId: clientId,
      path: path,
      can_be_downloaded: can_be_downloaded,
      can_be_deleted: can_be_deleted,
      is_downloading_active: is_downloading_active,
      is_downloading_completed: is_downloading_completed,
      download_offset: download_offset,
      downloaded_prefix_size: downloaded_prefix_size,
      downloaded_size: downloaded_size,
    );
  }
}

/// Represents a remote file.
///
class RemoteFile extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "remoteFile";

  /// Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers..
  late String id;

  /// Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time.
  late String unique_id;

  /// True, if the file is currently being uploaded (or a remote copy is being generated by some other means).
  late bool is_uploading_active;

  /// True, if a remote copy is fully available.
  late bool is_uploading_completed;

  /// Size of the remote available part of the file, in bytes; 0 if unknown.
  late int uploaded_size;

  /// Represents a remote file
  RemoteFile(
      {required this.id,
      required this.unique_id,
      required this.is_uploading_active,
      required this.is_uploading_completed,
      required this.uploaded_size,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'remoteFile',
      if (extra != null) '@extra': extra,
      'id': id,
      'unique_id': unique_id,
      'is_uploading_active': is_uploading_active,
      'is_uploading_completed': is_uploading_completed,
      'uploaded_size': uploaded_size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoteFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var unique_id = _map['unique_id']! as String;
    var is_uploading_active = _map['is_uploading_active']! as bool;
    var is_uploading_completed = _map['is_uploading_completed']! as bool;
    var uploaded_size = _map['uploaded_size']! as int;
    return RemoteFile(
      extra: extra,
      clientId: clientId,
      id: id,
      unique_id: unique_id,
      is_uploading_active: is_uploading_active,
      is_uploading_completed: is_uploading_completed,
      uploaded_size: uploaded_size,
    );
  }
}

/// Represents a file.
///
class File extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "file";

  /// Unique file identifier.
  late int id;

  /// File size, in bytes; 0 if unknown.
  late int size;

  /// Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress.
  late int expected_size;

  /// Information about the local copy of the file.
  late LocalFile local;

  /// Information about the remote copy of the file.
  late RemoteFile remote;

  /// Represents a file
  File(
      {required this.id,
      required this.size,
      required this.expected_size,
      required this.local,
      required this.remote,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'file',
      if (extra != null) '@extra': extra,
      'id': id,
      'size': size,
      'expected_size': expected_size,
      'local': local,
      'remote': remote
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static File? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var size = _map['size']! as int;
    var expected_size = _map['expected_size']! as int;
    var local = LocalFile.fromMap(_map['local'])!;
    var remote = RemoteFile.fromMap(_map['remote'])!;
    return File(
      extra: extra,
      clientId: clientId,
      id: id,
      size: size,
      expected_size: expected_size,
      local: local,
      remote: remote,
    );
  }
}

/// A file defined by its unique identifier.
///
class InputFileId extends InputFile {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputFileId";

  /// Unique file identifier.
  late int id;

  /// A file defined by its unique identifier
  InputFileId({required this.id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputFileId',
      if (extra != null) '@extra': extra,
      'id': id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputFileId? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    return InputFileId(
      extra: extra,
      clientId: clientId,
      id: id,
    );
  }
}

/// A file defined by its remote identifier. The remote identifier is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib..
///
class InputFileRemote extends InputFile {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputFileRemote";

  /// Remote file identifier.
  late String id;

  /// A file defined by its remote identifier. The remote identifier is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib.
  InputFileRemote({required this.id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputFileRemote',
      if (extra != null) '@extra': extra,
      'id': id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputFileRemote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    return InputFileRemote(
      extra: extra,
      clientId: clientId,
      id: id,
    );
  }
}

/// A file defined by a local path.
///
class InputFileLocal extends InputFile {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputFileLocal";

  /// Local path to the file.
  late String path;

  /// A file defined by a local path
  InputFileLocal({required this.path, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputFileLocal',
      if (extra != null) '@extra': extra,
      'path': path
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputFileLocal? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var path = _map['path']! as String;
    return InputFileLocal(
      extra: extra,
      clientId: clientId,
      path: path,
    );
  }
}

/// A file generated by the application.
///
class InputFileGenerated extends InputFile {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputFileGenerated";

  /// Local path to a file from which the file is generated; may be empty if there is no such file.
  late String original_path;

  /// String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage.
  late String conversion;

  /// Expected size of the generated file, in bytes; 0 if unknown.
  late int expected_size;

  /// A file generated by the application
  InputFileGenerated(
      {required this.original_path,
      required this.conversion,
      required this.expected_size,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputFileGenerated',
      if (extra != null) '@extra': extra,
      'original_path': original_path,
      'conversion': conversion,
      'expected_size': expected_size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputFileGenerated? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var original_path = _map['original_path']! as String;
    var conversion = _map['conversion']! as String;
    var expected_size = _map['expected_size']! as int;
    return InputFileGenerated(
      extra: extra,
      clientId: clientId,
      original_path: original_path,
      conversion: conversion,
      expected_size: expected_size,
    );
  }
}

/// Describes an image in JPEG format.
///
class PhotoSize extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "photoSize";

  /// Image type (see https://core.telegram.org/constructor/photoSize).
  late String type;

  /// Information about the image file.
  late File photo;

  /// Image width.
  late int width;

  /// Image height.
  late int height;

  /// Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes.
  late List<int> progressive_sizes;

  /// Describes an image in JPEG format
  PhotoSize(
      {required this.type,
      required this.photo,
      required this.width,
      required this.height,
      required this.progressive_sizes,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'photoSize',
      if (extra != null) '@extra': extra,
      'type': type,
      'photo': photo,
      'width': width,
      'height': height,
      'progressive_sizes': progressive_sizes
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PhotoSize? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = _map['type']! as String;
    var photo = File.fromMap(_map['photo'])!;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var progressive_sizes = List<int>.from(
      (_map["progressive_sizes"] ?? []).map(
        (e) => e as int,
      ),
    );
    return PhotoSize(
      extra: extra,
      clientId: clientId,
      type: type,
      photo: photo,
      width: width,
      height: height,
      progressive_sizes: progressive_sizes,
    );
  }
}

/// Thumbnail image of a very poor quality and low resolution.
///
class Minithumbnail extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "minithumbnail";

  /// Thumbnail width, usually doesn't exceed 40.
  late int width;

  /// Thumbnail height, usually doesn't exceed 40.
  late int height;

  /// The thumbnail in JPEG format.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// Thumbnail image of a very poor quality and low resolution
  Minithumbnail(
      {required this.width,
      required this.height,
      required this.data,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'minithumbnail',
      if (extra != null) '@extra': extra,
      'width': width,
      'height': height,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Minithumbnail? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var data = _map['data']! as bytes;
    return Minithumbnail(
      extra: extra,
      clientId: clientId,
      width: width,
      height: height,
      data: data,
    );
  }
}

/// The thumbnail is in JPEG format.
///
class ThumbnailFormatJpeg extends ThumbnailFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "thumbnailFormatJpeg";

  /// The thumbnail is in JPEG format
  ThumbnailFormatJpeg({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'thumbnailFormatJpeg', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ThumbnailFormatJpeg? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ThumbnailFormatJpeg(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The thumbnail is in static GIF format. It will be used only for some bot inline query results.
///
class ThumbnailFormatGif extends ThumbnailFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "thumbnailFormatGif";

  /// The thumbnail is in static GIF format. It will be used only for some bot inline query results
  ThumbnailFormatGif({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'thumbnailFormatGif', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ThumbnailFormatGif? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ThumbnailFormatGif(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The thumbnail is in MPEG4 format. It will be used only for some animations and videos.
///
class ThumbnailFormatMpeg4 extends ThumbnailFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "thumbnailFormatMpeg4";

  /// The thumbnail is in MPEG4 format. It will be used only for some animations and videos
  ThumbnailFormatMpeg4({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'thumbnailFormatMpeg4',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ThumbnailFormatMpeg4? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ThumbnailFormatMpeg4(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The thumbnail is in PNG format. It will be used only for background patterns.
///
class ThumbnailFormatPng extends ThumbnailFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "thumbnailFormatPng";

  /// The thumbnail is in PNG format. It will be used only for background patterns
  ThumbnailFormatPng({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'thumbnailFormatPng', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ThumbnailFormatPng? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ThumbnailFormatPng(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The thumbnail is in TGS format. It will be used only for TGS sticker sets.
///
class ThumbnailFormatTgs extends ThumbnailFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "thumbnailFormatTgs";

  /// The thumbnail is in TGS format. It will be used only for TGS sticker sets
  ThumbnailFormatTgs({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'thumbnailFormatTgs', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ThumbnailFormatTgs? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ThumbnailFormatTgs(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The thumbnail is in WEBM format. It will be used only for WEBM sticker sets.
///
class ThumbnailFormatWebm extends ThumbnailFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "thumbnailFormatWebm";

  /// The thumbnail is in WEBM format. It will be used only for WEBM sticker sets
  ThumbnailFormatWebm({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'thumbnailFormatWebm', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ThumbnailFormatWebm? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ThumbnailFormatWebm(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The thumbnail is in WEBP format. It will be used only for some stickers.
///
class ThumbnailFormatWebp extends ThumbnailFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "thumbnailFormatWebp";

  /// The thumbnail is in WEBP format. It will be used only for some stickers
  ThumbnailFormatWebp({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'thumbnailFormatWebp', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ThumbnailFormatWebp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ThumbnailFormatWebp(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents a thumbnail.
///
class Thumbnail extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "thumbnail";

  /// Thumbnail format.
  late ThumbnailFormat format;

  /// Thumbnail width.
  late int width;

  /// Thumbnail height.
  late int height;

  /// The thumbnail.
  late File file;

  /// Represents a thumbnail
  Thumbnail(
      {required this.format,
      required this.width,
      required this.height,
      required this.file,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'thumbnail',
      if (extra != null) '@extra': extra,
      'format': format,
      'width': width,
      'height': height,
      'file': file
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Thumbnail? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var format = ThumbnailFormat.fromMap(_map['format'])!;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var file = File.fromMap(_map['file'])!;
    return Thumbnail(
      extra: extra,
      clientId: clientId,
      format: format,
      width: width,
      height: height,
      file: file,
    );
  }
}

/// The mask is placed relatively to the forehead.
///
class MaskPointForehead extends MaskPoint {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "maskPointForehead";

  /// The mask is placed relatively to the forehead
  MaskPointForehead({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'maskPointForehead', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MaskPointForehead? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MaskPointForehead(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The mask is placed relatively to the eyes.
///
class MaskPointEyes extends MaskPoint {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "maskPointEyes";

  /// The mask is placed relatively to the eyes
  MaskPointEyes({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'maskPointEyes', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MaskPointEyes? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MaskPointEyes(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The mask is placed relatively to the mouth.
///
class MaskPointMouth extends MaskPoint {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "maskPointMouth";

  /// The mask is placed relatively to the mouth
  MaskPointMouth({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'maskPointMouth', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MaskPointMouth? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MaskPointMouth(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The mask is placed relatively to the chin.
///
class MaskPointChin extends MaskPoint {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "maskPointChin";

  /// The mask is placed relatively to the chin
  MaskPointChin({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'maskPointChin', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MaskPointChin? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MaskPointChin(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Position on a photo where a mask is placed.
///
class MaskPosition extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "maskPosition";

  /// Part of the face, relative to which the mask is placed.
  late MaskPoint point;

  /// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position).
  late double x_shift;

  /// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position).
  late double y_shift;

  /// Mask scaling coefficient. (For example, 2.0 means a doubled size).
  late double scale;

  /// Position on a photo where a mask is placed
  MaskPosition(
      {required this.point,
      required this.x_shift,
      required this.y_shift,
      required this.scale,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'maskPosition',
      if (extra != null) '@extra': extra,
      'point': point,
      'x_shift': x_shift,
      'y_shift': y_shift,
      'scale': scale
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MaskPosition? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var point = MaskPoint.fromMap(_map['point'])!;
    var x_shift = _map['x_shift']! as double;
    var y_shift = _map['y_shift']! as double;
    var scale = _map['scale']! as double;
    return MaskPosition(
      extra: extra,
      clientId: clientId,
      point: point,
      x_shift: x_shift,
      y_shift: y_shift,
      scale: scale,
    );
  }
}

/// The sticker is an image in WEBP format.
///
class StickerFormatWebp extends StickerFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerFormatWebp";

  /// The sticker is an image in WEBP format
  StickerFormatWebp({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'stickerFormatWebp', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerFormatWebp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StickerFormatWebp(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The sticker is an animation in TGS format.
///
class StickerFormatTgs extends StickerFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerFormatTgs";

  /// The sticker is an animation in TGS format
  StickerFormatTgs({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'stickerFormatTgs', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerFormatTgs? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StickerFormatTgs(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The sticker is a video in WEBM format.
///
class StickerFormatWebm extends StickerFormat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerFormatWebm";

  /// The sticker is a video in WEBM format
  StickerFormatWebm({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'stickerFormatWebm', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerFormatWebm? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StickerFormatWebm(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The sticker is a regular sticker.
///
class StickerTypeRegular extends StickerType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerTypeRegular";

  /// The sticker is a regular sticker
  StickerTypeRegular({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'stickerTypeRegular', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerTypeRegular? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StickerTypeRegular(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The sticker is a mask in WEBP format to be placed on photos or videos.
///
class StickerTypeMask extends StickerType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerTypeMask";

  /// The sticker is a mask in WEBP format to be placed on photos or videos
  StickerTypeMask({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'stickerTypeMask', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerTypeMask? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StickerTypeMask(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The sticker is a custom emoji to be used inside message text and caption.
///
class StickerTypeCustomEmoji extends StickerType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerTypeCustomEmoji";

  /// The sticker is a custom emoji to be used inside message text and caption
  StickerTypeCustomEmoji({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stickerTypeCustomEmoji',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerTypeCustomEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StickerTypeCustomEmoji(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The sticker is a regular sticker.
///
class StickerFullTypeRegular extends StickerFullType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerFullTypeRegular";

  /// Premium animation of the sticker; may be null. If present, only Telegram Premium users can use the sticker.
  File? premium_animation;

  /// The sticker is a regular sticker
  StickerFullTypeRegular({this.premium_animation, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stickerFullTypeRegular',
      if (extra != null) '@extra': extra,
      'premium_animation': premium_animation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerFullTypeRegular? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var premium_animation = File.fromMap(_map['premium_animation']);
    return StickerFullTypeRegular(
      extra: extra,
      clientId: clientId,
      premium_animation: premium_animation,
    );
  }
}

/// The sticker is a mask in WEBP format to be placed on photos or videos.
///
class StickerFullTypeMask extends StickerFullType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerFullTypeMask";

  /// Position where the mask is placed; may be null.
  MaskPosition? mask_position;

  /// The sticker is a mask in WEBP format to be placed on photos or videos
  StickerFullTypeMask({this.mask_position, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stickerFullTypeMask',
      if (extra != null) '@extra': extra,
      'mask_position': mask_position
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerFullTypeMask? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var mask_position = MaskPosition.fromMap(_map['mask_position']);
    return StickerFullTypeMask(
      extra: extra,
      clientId: clientId,
      mask_position: mask_position,
    );
  }
}

/// The sticker is a custom emoji to be used inside message text and caption. Currently, only Telegram Premium users can use custom emoji.
///
class StickerFullTypeCustomEmoji extends StickerFullType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerFullTypeCustomEmoji";

  /// Identifier of the custom emoji.
  /// ; string representation of int, use `int.parse`
  late int64 custom_emoji_id;

  /// True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places.
  late bool needs_repainting;

  /// The sticker is a custom emoji to be used inside message text and caption. Currently, only Telegram Premium users can use custom emoji
  StickerFullTypeCustomEmoji(
      {required this.custom_emoji_id,
      required this.needs_repainting,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stickerFullTypeCustomEmoji',
      if (extra != null) '@extra': extra,
      'custom_emoji_id': custom_emoji_id,
      'needs_repainting': needs_repainting
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerFullTypeCustomEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_emoji_id = _map['custom_emoji_id']! as int64;
    var needs_repainting = _map['needs_repainting']! as bool;
    return StickerFullTypeCustomEmoji(
      extra: extra,
      clientId: clientId,
      custom_emoji_id: custom_emoji_id,
      needs_repainting: needs_repainting,
    );
  }
}

/// Represents a closed vector path. The path begins at the end point of the last command.
///
class ClosedVectorPath extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "closedVectorPath";

  /// List of vector path commands.
  late List<VectorPathCommand> commands;

  /// Represents a closed vector path. The path begins at the end point of the last command
  ClosedVectorPath({required this.commands, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'closedVectorPath',
      if (extra != null) '@extra': extra,
      'commands': commands
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClosedVectorPath? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var commands = List<VectorPathCommand>.from(
      (_map["commands"] ?? []).map(
        (e) => VectorPathCommand.fromMap(e),
      ),
    );
    return ClosedVectorPath(
      extra: extra,
      clientId: clientId,
      commands: commands,
    );
  }
}

/// Describes one answer option of a poll.
///
class PollOption extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pollOption";

  /// Option text; 1-100 characters.
  late String text;

  /// Number of voters for this option, available only for closed or voted polls.
  late int voter_count;

  /// The percentage of votes for this option; 0-100.
  late int vote_percentage;

  /// True, if the option was chosen by the user.
  late bool is_chosen;

  /// True, if the option is being chosen by a pending setPollAnswer request.
  late bool is_being_chosen;

  /// Describes one answer option of a poll
  PollOption(
      {required this.text,
      required this.voter_count,
      required this.vote_percentage,
      required this.is_chosen,
      required this.is_being_chosen,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pollOption',
      if (extra != null) '@extra': extra,
      'text': text,
      'voter_count': voter_count,
      'vote_percentage': vote_percentage,
      'is_chosen': is_chosen,
      'is_being_chosen': is_being_chosen
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PollOption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var voter_count = _map['voter_count']! as int;
    var vote_percentage = _map['vote_percentage']! as int;
    var is_chosen = _map['is_chosen']! as bool;
    var is_being_chosen = _map['is_being_chosen']! as bool;
    return PollOption(
      extra: extra,
      clientId: clientId,
      text: text,
      voter_count: voter_count,
      vote_percentage: vote_percentage,
      is_chosen: is_chosen,
      is_being_chosen: is_being_chosen,
    );
  }
}

/// A regular poll.
///
class PollTypeRegular extends PollType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pollTypeRegular";

  /// True, if multiple answer options can be chosen simultaneously.
  late bool allow_multiple_answers;

  /// A regular poll
  PollTypeRegular(
      {required this.allow_multiple_answers, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pollTypeRegular',
      if (extra != null) '@extra': extra,
      'allow_multiple_answers': allow_multiple_answers
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PollTypeRegular? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var allow_multiple_answers = _map['allow_multiple_answers']! as bool;
    return PollTypeRegular(
      extra: extra,
      clientId: clientId,
      allow_multiple_answers: allow_multiple_answers,
    );
  }
}

/// A poll in quiz mode, which has exactly one correct answer option and can be answered only once.
///
class PollTypeQuiz extends PollType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pollTypeQuiz";

  /// 0-based identifier of the correct answer option; -1 for a yet unanswered poll.
  late int correct_option_id;

  /// Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll.
  late FormattedText explanation;

  /// A poll in quiz mode, which has exactly one correct answer option and can be answered only once
  PollTypeQuiz(
      {required this.correct_option_id,
      required this.explanation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pollTypeQuiz',
      if (extra != null) '@extra': extra,
      'correct_option_id': correct_option_id,
      'explanation': explanation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PollTypeQuiz? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var correct_option_id = _map['correct_option_id']! as int;
    var explanation = FormattedText.fromMap(_map['explanation'])!;
    return PollTypeQuiz(
      extra: extra,
      clientId: clientId,
      correct_option_id: correct_option_id,
      explanation: explanation,
    );
  }
}

/// Describes an animation file. The animation must be encoded in GIF or MPEG4 format.
///
class Animation extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "animation";

  /// Duration of the animation, in seconds; as defined by the sender.
  late int duration;

  /// Width of the animation.
  late int width;

  /// Height of the animation.
  late int height;

  /// Original name of the file; as defined by the sender.
  late String file_name;

  /// MIME type of the file, usually "image/gif" or "video/mp4".
  late String mime_type;

  /// True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets.
  late bool has_stickers;

  /// Animation minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// Animation thumbnail in JPEG or MPEG4 format; may be null.
  Thumbnail? thumbnail;

  /// File containing the animation.
  late File animation;

  /// Describes an animation file. The animation must be encoded in GIF or MPEG4 format
  Animation(
      {required this.duration,
      required this.width,
      required this.height,
      required this.file_name,
      required this.mime_type,
      required this.has_stickers,
      this.minithumbnail,
      this.thumbnail,
      required this.animation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'animation',
      if (extra != null) '@extra': extra,
      'duration': duration,
      'width': width,
      'height': height,
      'file_name': file_name,
      'mime_type': mime_type,
      'has_stickers': has_stickers,
      'minithumbnail': minithumbnail,
      'thumbnail': thumbnail,
      'animation': animation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Animation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var duration = _map['duration']! as int;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var file_name = _map['file_name']! as String;
    var mime_type = _map['mime_type']! as String;
    var has_stickers = _map['has_stickers']! as bool;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    var animation = File.fromMap(_map['animation'])!;
    return Animation(
      extra: extra,
      clientId: clientId,
      duration: duration,
      width: width,
      height: height,
      file_name: file_name,
      mime_type: mime_type,
      has_stickers: has_stickers,
      minithumbnail: minithumbnail,
      thumbnail: thumbnail,
      animation: animation,
    );
  }
}

/// Describes an audio file. Audio is usually in MP3 or M4A format.
///
class Audio extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "audio";

  /// Duration of the audio, in seconds; as defined by the sender.
  late int duration;

  /// Title of the audio; as defined by the sender.
  late String title;

  /// Performer of the audio; as defined by the sender.
  late String performer;

  /// Original name of the file; as defined by the sender.
  late String file_name;

  /// The MIME type of the file; as defined by the sender.
  late String mime_type;

  /// The minithumbnail of the album cover; may be null.
  Minithumbnail? album_cover_minithumbnail;

  /// The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is supposed to be extracted from the downloaded audio file; may be null.
  Thumbnail? album_cover_thumbnail;

  /// Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate.
  late List<Thumbnail> external_album_covers;

  /// File containing the audio.
  late File audio;

  /// Describes an audio file. Audio is usually in MP3 or M4A format
  Audio(
      {required this.duration,
      required this.title,
      required this.performer,
      required this.file_name,
      required this.mime_type,
      this.album_cover_minithumbnail,
      this.album_cover_thumbnail,
      required this.external_album_covers,
      required this.audio,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'audio',
      if (extra != null) '@extra': extra,
      'duration': duration,
      'title': title,
      'performer': performer,
      'file_name': file_name,
      'mime_type': mime_type,
      'album_cover_minithumbnail': album_cover_minithumbnail,
      'album_cover_thumbnail': album_cover_thumbnail,
      'external_album_covers': external_album_covers,
      'audio': audio
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Audio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var duration = _map['duration']! as int;
    var title = _map['title']! as String;
    var performer = _map['performer']! as String;
    var file_name = _map['file_name']! as String;
    var mime_type = _map['mime_type']! as String;
    var album_cover_minithumbnail =
        Minithumbnail.fromMap(_map['album_cover_minithumbnail']);
    var album_cover_thumbnail =
        Thumbnail.fromMap(_map['album_cover_thumbnail']);
    var external_album_covers = List<Thumbnail>.from(
      (_map["external_album_covers"] ?? []).map(
        (e) => Thumbnail.fromMap(e),
      ),
    );
    var audio = File.fromMap(_map['audio'])!;
    return Audio(
      extra: extra,
      clientId: clientId,
      duration: duration,
      title: title,
      performer: performer,
      file_name: file_name,
      mime_type: mime_type,
      album_cover_minithumbnail: album_cover_minithumbnail,
      album_cover_thumbnail: album_cover_thumbnail,
      external_album_covers: external_album_covers,
      audio: audio,
    );
  }
}

/// Describes a document of any type.
///
class Document extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "document";

  /// Original name of the file; as defined by the sender.
  late String file_name;

  /// MIME type of the file; as defined by the sender.
  late String mime_type;

  /// Document minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null.
  Thumbnail? thumbnail;

  /// File containing the document.
  late File document;

  /// Describes a document of any type
  Document(
      {required this.file_name,
      required this.mime_type,
      this.minithumbnail,
      this.thumbnail,
      required this.document,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'document',
      if (extra != null) '@extra': extra,
      'file_name': file_name,
      'mime_type': mime_type,
      'minithumbnail': minithumbnail,
      'thumbnail': thumbnail,
      'document': document
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Document? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_name = _map['file_name']! as String;
    var mime_type = _map['mime_type']! as String;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    var document = File.fromMap(_map['document'])!;
    return Document(
      extra: extra,
      clientId: clientId,
      file_name: file_name,
      mime_type: mime_type,
      minithumbnail: minithumbnail,
      thumbnail: thumbnail,
      document: document,
    );
  }
}

/// Describes a photo.
///
class Photo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "photo";

  /// True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets.
  late bool has_stickers;

  /// Photo minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// Available variants of the photo, in different sizes.
  late List<PhotoSize> sizes;

  /// Describes a photo
  Photo(
      {required this.has_stickers,
      this.minithumbnail,
      required this.sizes,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'photo',
      if (extra != null) '@extra': extra,
      'has_stickers': has_stickers,
      'minithumbnail': minithumbnail,
      'sizes': sizes
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Photo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var has_stickers = _map['has_stickers']! as bool;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var sizes = List<PhotoSize>.from(
      (_map["sizes"] ?? []).map(
        (e) => PhotoSize.fromMap(e),
      ),
    );
    return Photo(
      extra: extra,
      clientId: clientId,
      has_stickers: has_stickers,
      minithumbnail: minithumbnail,
      sizes: sizes,
    );
  }
}

/// Describes a sticker.
///
class Sticker extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sticker";

  /// Unique sticker identifier within the set; 0 if none.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Identifier of the sticker set to which the sticker belongs; 0 if none.
  /// ; string representation of int, use `int.parse`
  late int64 set_id;

  /// Sticker width; as defined by the sender.
  late int width;

  /// Sticker height; as defined by the sender.
  late int height;

  /// Emoji corresponding to the sticker.
  late String emoji;

  /// Sticker format.
  late StickerFormat format;

  /// Sticker's full type.
  late StickerFullType full_type;

  /// Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner.
  late List<ClosedVectorPath> outline;

  /// Sticker thumbnail in WEBP or JPEG format; may be null.
  Thumbnail? thumbnail;

  /// File containing the sticker.
  late File sticker;

  /// Describes a sticker
  Sticker(
      {required this.id,
      required this.set_id,
      required this.width,
      required this.height,
      required this.emoji,
      required this.format,
      required this.full_type,
      required this.outline,
      this.thumbnail,
      required this.sticker,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sticker',
      if (extra != null) '@extra': extra,
      'id': id,
      'set_id': set_id,
      'width': width,
      'height': height,
      'emoji': emoji,
      'format': format,
      'full_type': full_type,
      'outline': outline,
      'thumbnail': thumbnail,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Sticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var set_id = _map['set_id']! as int64;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var emoji = _map['emoji']! as String;
    var format = StickerFormat.fromMap(_map['format'])!;
    var full_type = StickerFullType.fromMap(_map['full_type'])!;
    var outline = List<ClosedVectorPath>.from(
      (_map["outline"] ?? []).map(
        (e) => ClosedVectorPath.fromMap(e),
      ),
    );
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    var sticker = File.fromMap(_map['sticker'])!;
    return Sticker(
      extra: extra,
      clientId: clientId,
      id: id,
      set_id: set_id,
      width: width,
      height: height,
      emoji: emoji,
      format: format,
      full_type: full_type,
      outline: outline,
      thumbnail: thumbnail,
      sticker: sticker,
    );
  }
}

/// Describes a video file.
///
class Video extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "video";

  /// Duration of the video, in seconds; as defined by the sender.
  late int duration;

  /// Video width; as defined by the sender.
  late int width;

  /// Video height; as defined by the sender.
  late int height;

  /// Original name of the file; as defined by the sender.
  late String file_name;

  /// MIME type of the file; as defined by the sender.
  late String mime_type;

  /// True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets.
  late bool has_stickers;

  /// True, if the video is supposed to be streamed.
  late bool supports_streaming;

  /// Video minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null.
  Thumbnail? thumbnail;

  /// File containing the video.
  late File video;

  /// Describes a video file
  Video(
      {required this.duration,
      required this.width,
      required this.height,
      required this.file_name,
      required this.mime_type,
      required this.has_stickers,
      required this.supports_streaming,
      this.minithumbnail,
      this.thumbnail,
      required this.video,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'video',
      if (extra != null) '@extra': extra,
      'duration': duration,
      'width': width,
      'height': height,
      'file_name': file_name,
      'mime_type': mime_type,
      'has_stickers': has_stickers,
      'supports_streaming': supports_streaming,
      'minithumbnail': minithumbnail,
      'thumbnail': thumbnail,
      'video': video
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Video? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var duration = _map['duration']! as int;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var file_name = _map['file_name']! as String;
    var mime_type = _map['mime_type']! as String;
    var has_stickers = _map['has_stickers']! as bool;
    var supports_streaming = _map['supports_streaming']! as bool;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    var video = File.fromMap(_map['video'])!;
    return Video(
      extra: extra,
      clientId: clientId,
      duration: duration,
      width: width,
      height: height,
      file_name: file_name,
      mime_type: mime_type,
      has_stickers: has_stickers,
      supports_streaming: supports_streaming,
      minithumbnail: minithumbnail,
      thumbnail: thumbnail,
      video: video,
    );
  }
}

/// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format.
///
class VideoNote extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "videoNote";

  /// Duration of the video, in seconds; as defined by the sender.
  late int duration;

  /// A waveform representation of the video note's audio in 5-bit format; may be empty if unknown.
  /// ; base64-encoded bytes `List<int>`
  late bytes waveform;

  /// Video width and height; as defined by the sender.
  late int length;

  /// Video minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// Video thumbnail in JPEG format; as defined by the sender; may be null.
  Thumbnail? thumbnail;

  /// Result of speech recognition in the video note; may be null.
  SpeechRecognitionResult? speech_recognition_result;

  /// File containing the video.
  late File video;

  /// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
  VideoNote(
      {required this.duration,
      required this.waveform,
      required this.length,
      this.minithumbnail,
      this.thumbnail,
      this.speech_recognition_result,
      required this.video,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'videoNote',
      if (extra != null) '@extra': extra,
      'duration': duration,
      'waveform': waveform,
      'length': length,
      'minithumbnail': minithumbnail,
      'thumbnail': thumbnail,
      'speech_recognition_result': speech_recognition_result,
      'video': video
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static VideoNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var duration = _map['duration']! as int;
    var waveform = _map['waveform']! as bytes;
    var length = _map['length']! as int;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    var speech_recognition_result =
        SpeechRecognitionResult.fromMap(_map['speech_recognition_result']);
    var video = File.fromMap(_map['video'])!;
    return VideoNote(
      extra: extra,
      clientId: clientId,
      duration: duration,
      waveform: waveform,
      length: length,
      minithumbnail: minithumbnail,
      thumbnail: thumbnail,
      speech_recognition_result: speech_recognition_result,
      video: video,
    );
  }
}

/// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel.
///
class VoiceNote extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "voiceNote";

  /// Duration of the voice note, in seconds; as defined by the sender.
  late int duration;

  /// A waveform representation of the voice note in 5-bit format.
  /// ; base64-encoded bytes `List<int>`
  late bytes waveform;

  /// MIME type of the file; as defined by the sender.
  late String mime_type;

  /// Result of speech recognition in the voice note; may be null.
  SpeechRecognitionResult? speech_recognition_result;

  /// File containing the voice note.
  late File voice;

  /// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel
  VoiceNote(
      {required this.duration,
      required this.waveform,
      required this.mime_type,
      this.speech_recognition_result,
      required this.voice,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'voiceNote',
      if (extra != null) '@extra': extra,
      'duration': duration,
      'waveform': waveform,
      'mime_type': mime_type,
      'speech_recognition_result': speech_recognition_result,
      'voice': voice
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static VoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var duration = _map['duration']! as int;
    var waveform = _map['waveform']! as bytes;
    var mime_type = _map['mime_type']! as String;
    var speech_recognition_result =
        SpeechRecognitionResult.fromMap(_map['speech_recognition_result']);
    var voice = File.fromMap(_map['voice'])!;
    return VoiceNote(
      extra: extra,
      clientId: clientId,
      duration: duration,
      waveform: waveform,
      mime_type: mime_type,
      speech_recognition_result: speech_recognition_result,
      voice: voice,
    );
  }
}

/// Describes an animated or custom representation of an emoji.
///
class AnimatedEmoji extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "animatedEmoji";

  /// Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, it can have arbitrary format different from stickerFormatTgs.
  Sticker? sticker;

  /// Expected width of the sticker, which can be used if the sticker is null.
  late int sticker_width;

  /// Expected height of the sticker, which can be used if the sticker is null.
  late int sticker_height;

  /// Emoji modifier fitzpatrick type; 0-6; 0 if none.
  late int fitzpatrick_type;

  /// File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container.
  File? sound;

  /// Describes an animated or custom representation of an emoji
  AnimatedEmoji(
      {this.sticker,
      required this.sticker_width,
      required this.sticker_height,
      required this.fitzpatrick_type,
      this.sound,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'animatedEmoji',
      if (extra != null) '@extra': extra,
      'sticker': sticker,
      'sticker_width': sticker_width,
      'sticker_height': sticker_height,
      'fitzpatrick_type': fitzpatrick_type,
      'sound': sound
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AnimatedEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = Sticker.fromMap(_map['sticker']);
    var sticker_width = _map['sticker_width']! as int;
    var sticker_height = _map['sticker_height']! as int;
    var fitzpatrick_type = _map['fitzpatrick_type']! as int;
    var sound = File.fromMap(_map['sound']);
    return AnimatedEmoji(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
      sticker_width: sticker_width,
      sticker_height: sticker_height,
      fitzpatrick_type: fitzpatrick_type,
      sound: sound,
    );
  }
}

/// Describes a user contact.
///
class Contact extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "contact";

  /// Phone number of the user.
  late String phone_number;

  /// First name of the user; 1-255 characters in length.
  late String first_name;

  /// Last name of the user.
  late String last_name;

  /// Additional data about the user in a form of vCard; 0-2048 bytes in length.
  late String vcard;

  /// Identifier of the user, if known; 0 otherwise.
  late int user_id;

  /// Describes a user contact
  Contact(
      {required this.phone_number,
      required this.first_name,
      required this.last_name,
      required this.vcard,
      required this.user_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'contact',
      if (extra != null) '@extra': extra,
      'phone_number': phone_number,
      'first_name': first_name,
      'last_name': last_name,
      'vcard': vcard,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Contact? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number = _map['phone_number']! as String;
    var first_name = _map['first_name']! as String;
    var last_name = _map['last_name']! as String;
    var vcard = _map['vcard']! as String;
    var user_id = _map['user_id']! as int;
    return Contact(
      extra: extra,
      clientId: clientId,
      phone_number: phone_number,
      first_name: first_name,
      last_name: last_name,
      vcard: vcard,
      user_id: user_id,
    );
  }
}

/// Describes a location on planet Earth.
///
class Location extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "location";

  /// Latitude of the location in degrees; as defined by the sender.
  late double latitude;

  /// Longitude of the location, in degrees; as defined by the sender.
  late double longitude;

  /// The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown.
  late double horizontal_accuracy;

  /// Describes a location on planet Earth
  Location(
      {required this.latitude,
      required this.longitude,
      required this.horizontal_accuracy,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'location',
      if (extra != null) '@extra': extra,
      'latitude': latitude,
      'longitude': longitude,
      'horizontal_accuracy': horizontal_accuracy
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Location? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var latitude = _map['latitude']! as double;
    var longitude = _map['longitude']! as double;
    var horizontal_accuracy = _map['horizontal_accuracy']! as double;
    return Location(
      extra: extra,
      clientId: clientId,
      latitude: latitude,
      longitude: longitude,
      horizontal_accuracy: horizontal_accuracy,
    );
  }
}

/// Describes a venue.
///
class Venue extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "venue";

  /// Venue location; as defined by the sender.
  late Location location;

  /// Venue name; as defined by the sender.
  late String title;

  /// Venue address; as defined by the sender.
  late String address;

  /// Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported.
  late String provider;

  /// Identifier of the venue in the provider database; as defined by the sender.
  late String id;

  /// Type of the venue in the provider database; as defined by the sender.
  late String type;

  /// Describes a venue
  Venue(
      {required this.location,
      required this.title,
      required this.address,
      required this.provider,
      required this.id,
      required this.type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'venue',
      if (extra != null) '@extra': extra,
      'location': location,
      'title': title,
      'address': address,
      'provider': provider,
      'id': id,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Venue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    var title = _map['title']! as String;
    var address = _map['address']! as String;
    var provider = _map['provider']! as String;
    var id = _map['id']! as String;
    var type = _map['type']! as String;
    return Venue(
      extra: extra,
      clientId: clientId,
      location: location,
      title: title,
      address: address,
      provider: provider,
      id: id,
      type: type,
    );
  }
}

/// Describes a game. Use getInternalLink with internalLinkTypeGame to share the game.
///
class Game extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "game";

  /// Unique game identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Game short name.
  late String short_name;

  /// Game title.
  late String title;

  /// Game text, usually containing scoreboards for a game.
  late FormattedText text;

  /// Game description.
  late String description;

  /// Game photo.
  late Photo photo;

  /// Game animation; may be null.
  Animation? animation;

  /// Describes a game. Use getInternalLink with internalLinkTypeGame to share the game
  Game(
      {required this.id,
      required this.short_name,
      required this.title,
      required this.text,
      required this.description,
      required this.photo,
      this.animation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'game',
      if (extra != null) '@extra': extra,
      'id': id,
      'short_name': short_name,
      'title': title,
      'text': text,
      'description': description,
      'photo': photo,
      'animation': animation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Game? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var short_name = _map['short_name']! as String;
    var title = _map['title']! as String;
    var text = FormattedText.fromMap(_map['text'])!;
    var description = _map['description']! as String;
    var photo = Photo.fromMap(_map['photo'])!;
    var animation = Animation.fromMap(_map['animation']);
    return Game(
      extra: extra,
      clientId: clientId,
      id: id,
      short_name: short_name,
      title: title,
      text: text,
      description: description,
      photo: photo,
      animation: animation,
    );
  }
}

/// Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App.
///
class WebApp extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "webApp";

  /// Web App short name.
  late String short_name;

  /// Web App title.
  late String title;

  /// Web App description.
  late String description;

  /// Web App photo.
  late Photo photo;

  /// Web App animation; may be null.
  Animation? animation;

  /// Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App
  WebApp(
      {required this.short_name,
      required this.title,
      required this.description,
      required this.photo,
      this.animation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'webApp',
      if (extra != null) '@extra': extra,
      'short_name': short_name,
      'title': title,
      'description': description,
      'photo': photo,
      'animation': animation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static WebApp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var short_name = _map['short_name']! as String;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    var photo = Photo.fromMap(_map['photo'])!;
    var animation = Animation.fromMap(_map['animation']);
    return WebApp(
      extra: extra,
      clientId: clientId,
      short_name: short_name,
      title: title,
      description: description,
      photo: photo,
      animation: animation,
    );
  }
}

/// Describes a poll.
///
class Poll extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "poll";

  /// Unique poll identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Poll question; 1-300 characters.
  late String question;

  /// List of poll answer options.
  late List<PollOption> options;

  /// Total number of voters, participating in the poll.
  late int total_voter_count;

  /// Identifiers of recent voters, if the poll is non-anonymous.
  late List<MessageSender> recent_voter_ids;

  /// True, if the poll is anonymous.
  late bool is_anonymous;

  /// Type of the poll.
  late PollType type;

  /// Amount of time the poll will be active after creation, in seconds.
  late int open_period;

  /// Point in time (Unix timestamp) when the poll will automatically be closed.
  late int close_date;

  /// True, if the poll is closed.
  late bool is_closed;

  /// Describes a poll
  Poll(
      {required this.id,
      required this.question,
      required this.options,
      required this.total_voter_count,
      required this.recent_voter_ids,
      required this.is_anonymous,
      required this.type,
      required this.open_period,
      required this.close_date,
      required this.is_closed,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'poll',
      if (extra != null) '@extra': extra,
      'id': id,
      'question': question,
      'options': options,
      'total_voter_count': total_voter_count,
      'recent_voter_ids': recent_voter_ids,
      'is_anonymous': is_anonymous,
      'type': type,
      'open_period': open_period,
      'close_date': close_date,
      'is_closed': is_closed
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Poll? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var question = _map['question']! as String;
    var options = List<PollOption>.from(
      (_map["options"] ?? []).map(
        (e) => PollOption.fromMap(e),
      ),
    );
    var total_voter_count = _map['total_voter_count']! as int;
    var recent_voter_ids = List<MessageSender>.from(
      (_map["recent_voter_ids"] ?? []).map(
        (e) => MessageSender.fromMap(e),
      ),
    );
    var is_anonymous = _map['is_anonymous']! as bool;
    var type = PollType.fromMap(_map['type'])!;
    var open_period = _map['open_period']! as int;
    var close_date = _map['close_date']! as int;
    var is_closed = _map['is_closed']! as bool;
    return Poll(
      extra: extra,
      clientId: clientId,
      id: id,
      question: question,
      options: options,
      total_voter_count: total_voter_count,
      recent_voter_ids: recent_voter_ids,
      is_anonymous: is_anonymous,
      type: type,
      open_period: open_period,
      close_date: close_date,
      is_closed: is_closed,
    );
  }
}

/// Describes a chat background.
///
class Background extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "background";

  /// Unique background identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// True, if this is one of default backgrounds.
  late bool is_default;

  /// True, if the background is dark and is recommended to be used with dark theme.
  late bool is_dark;

  /// Unique background name.
  late String name;

  /// Document with the background; may be null. Null only for filled backgrounds.
  Document? document;

  /// Type of the background.
  late BackgroundType type;

  /// Describes a chat background
  Background(
      {required this.id,
      required this.is_default,
      required this.is_dark,
      required this.name,
      this.document,
      required this.type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'background',
      if (extra != null) '@extra': extra,
      'id': id,
      'is_default': is_default,
      'is_dark': is_dark,
      'name': name,
      'document': document,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Background? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var is_default = _map['is_default']! as bool;
    var is_dark = _map['is_dark']! as bool;
    var name = _map['name']! as String;
    var document = Document.fromMap(_map['document']);
    var type = BackgroundType.fromMap(_map['type'])!;
    return Background(
      extra: extra,
      clientId: clientId,
      id: id,
      is_default: is_default,
      is_dark: is_dark,
      name: name,
      document: document,
      type: type,
    );
  }
}

/// Contains a list of backgrounds.
///
class Backgrounds extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "backgrounds";

  /// A list of backgrounds.
  late List<Background> backgrounds;

  /// Contains a list of backgrounds
  Backgrounds({required this.backgrounds, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'backgrounds',
      if (extra != null) '@extra': extra,
      'backgrounds': backgrounds
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Backgrounds? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var backgrounds = List<Background>.from(
      (_map["backgrounds"] ?? []).map(
        (e) => Background.fromMap(e),
      ),
    );
    return Backgrounds(
      extra: extra,
      clientId: clientId,
      backgrounds: backgrounds,
    );
  }
}

/// Describes a background set for a specific chat.
///
class ChatBackground extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatBackground";

  /// The background.
  late Background background;

  /// Dimming of the background in dark themes, as a percentage; 0-100.
  late int dark_theme_dimming;

  /// Describes a background set for a specific chat
  ChatBackground(
      {required this.background,
      required this.dark_theme_dimming,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatBackground',
      if (extra != null) '@extra': extra,
      'background': background,
      'dark_theme_dimming': dark_theme_dimming
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatBackground? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var background = Background.fromMap(_map['background'])!;
    var dark_theme_dimming = _map['dark_theme_dimming']! as int;
    return ChatBackground(
      extra: extra,
      clientId: clientId,
      background: background,
      dark_theme_dimming: dark_theme_dimming,
    );
  }
}

/// Describes a user profile photo.
///
class ProfilePhoto extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "profilePhoto";

  /// Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// A small (160x160) user profile photo. The file can be downloaded only before the photo is changed.
  late File small;

  /// A big (640x640) user profile photo. The file can be downloaded only before the photo is changed.
  late File big;

  /// User profile photo minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// True, if the photo has animated variant.
  late bool has_animation;

  /// True, if the photo is visible only for the current user.
  late bool is_personal;

  /// Describes a user profile photo
  ProfilePhoto(
      {required this.id,
      required this.small,
      required this.big,
      this.minithumbnail,
      required this.has_animation,
      required this.is_personal,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'profilePhoto',
      if (extra != null) '@extra': extra,
      'id': id,
      'small': small,
      'big': big,
      'minithumbnail': minithumbnail,
      'has_animation': has_animation,
      'is_personal': is_personal
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ProfilePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var small = File.fromMap(_map['small'])!;
    var big = File.fromMap(_map['big'])!;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var has_animation = _map['has_animation']! as bool;
    var is_personal = _map['is_personal']! as bool;
    return ProfilePhoto(
      extra: extra,
      clientId: clientId,
      id: id,
      small: small,
      big: big,
      minithumbnail: minithumbnail,
      has_animation: has_animation,
      is_personal: is_personal,
    );
  }
}

/// Contains basic information about the photo of a chat.
///
class ChatPhotoInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatPhotoInfo";

  /// A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed.
  late File small;

  /// A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed.
  late File big;

  /// Chat photo minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// True, if the photo has animated variant.
  late bool has_animation;

  /// True, if the photo is visible only for the current user.
  late bool is_personal;

  /// Contains basic information about the photo of a chat
  ChatPhotoInfo(
      {required this.small,
      required this.big,
      this.minithumbnail,
      required this.has_animation,
      required this.is_personal,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatPhotoInfo',
      if (extra != null) '@extra': extra,
      'small': small,
      'big': big,
      'minithumbnail': minithumbnail,
      'has_animation': has_animation,
      'is_personal': is_personal
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatPhotoInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var small = File.fromMap(_map['small'])!;
    var big = File.fromMap(_map['big'])!;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var has_animation = _map['has_animation']! as bool;
    var is_personal = _map['is_personal']! as bool;
    return ChatPhotoInfo(
      extra: extra,
      clientId: clientId,
      small: small,
      big: big,
      minithumbnail: minithumbnail,
      has_animation: has_animation,
      is_personal: is_personal,
    );
  }
}

/// A regular user.
///
class UserTypeRegular extends UserType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userTypeRegular";

  /// A regular user
  UserTypeRegular({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'userTypeRegular', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserTypeRegular? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserTypeRegular(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user.
///
class UserTypeDeleted extends UserType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userTypeDeleted";

  /// A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
  UserTypeDeleted({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'userTypeDeleted', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserTypeDeleted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserTypeDeleted(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A bot (see https://core.telegram.org/bots).
///
class UserTypeBot extends UserType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userTypeBot";

  /// True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription.
  late bool can_be_edited;

  /// True, if the bot can be invited to basic group and supergroup chats.
  late bool can_join_groups;

  /// True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages.
  late bool can_read_all_group_messages;

  /// True, if the bot supports inline queries.
  late bool is_inline;

  /// Placeholder for inline queries (displayed on the application input field).
  late String inline_query_placeholder;

  /// True, if the location of the user is expected to be sent with every inline query to this bot.
  late bool need_location;

  /// True, if the bot can be added to attachment or side menu.
  late bool can_be_added_to_attachment_menu;

  /// A bot (see https://core.telegram.org/bots)
  UserTypeBot(
      {required this.can_be_edited,
      required this.can_join_groups,
      required this.can_read_all_group_messages,
      required this.is_inline,
      required this.inline_query_placeholder,
      required this.need_location,
      required this.can_be_added_to_attachment_menu,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userTypeBot',
      if (extra != null) '@extra': extra,
      'can_be_edited': can_be_edited,
      'can_join_groups': can_join_groups,
      'can_read_all_group_messages': can_read_all_group_messages,
      'is_inline': is_inline,
      'inline_query_placeholder': inline_query_placeholder,
      'need_location': need_location,
      'can_be_added_to_attachment_menu': can_be_added_to_attachment_menu
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserTypeBot? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var can_be_edited = _map['can_be_edited']! as bool;
    var can_join_groups = _map['can_join_groups']! as bool;
    var can_read_all_group_messages =
        _map['can_read_all_group_messages']! as bool;
    var is_inline = _map['is_inline']! as bool;
    var inline_query_placeholder = _map['inline_query_placeholder']! as String;
    var need_location = _map['need_location']! as bool;
    var can_be_added_to_attachment_menu =
        _map['can_be_added_to_attachment_menu']! as bool;
    return UserTypeBot(
      extra: extra,
      clientId: clientId,
      can_be_edited: can_be_edited,
      can_join_groups: can_join_groups,
      can_read_all_group_messages: can_read_all_group_messages,
      is_inline: is_inline,
      inline_query_placeholder: inline_query_placeholder,
      need_location: need_location,
      can_be_added_to_attachment_menu: can_be_added_to_attachment_menu,
    );
  }
}

/// No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type.
///
class UserTypeUnknown extends UserType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userTypeUnknown";

  /// No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
  UserTypeUnknown({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'userTypeUnknown', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserTypeUnknown? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserTypeUnknown(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents a command supported by a bot.
///
class BotCommand extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botCommand";

  /// Text of the bot command.
  late String command;

  /// Description of the bot command.
  late String description;

  /// Represents a command supported by a bot
  BotCommand(
      {required this.command,
      required this.description,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botCommand',
      if (extra != null) '@extra': extra,
      'command': command,
      'description': description
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotCommand? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var command = _map['command']! as String;
    var description = _map['description']! as String;
    return BotCommand(
      extra: extra,
      clientId: clientId,
      command: command,
      description: description,
    );
  }
}

/// Contains a list of bot commands.
///
class BotCommands extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botCommands";

  /// Bot's user identifier.
  late int bot_user_id;

  /// List of bot commands.
  late List<BotCommand> commands;

  /// Contains a list of bot commands
  BotCommands(
      {required this.bot_user_id,
      required this.commands,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botCommands',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'commands': commands
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotCommands? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var commands = List<BotCommand>.from(
      (_map["commands"] ?? []).map(
        (e) => BotCommand.fromMap(e),
      ),
    );
    return BotCommands(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      commands: commands,
    );
  }
}

/// Describes a button to be shown instead of bot commands menu button.
///
class BotMenuButton extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botMenuButton";

  /// Text of the button.
  late String text;

  /// URL to be passed to openWebApp.
  late String url;

  /// Describes a button to be shown instead of bot commands menu button
  BotMenuButton(
      {required this.text, required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botMenuButton',
      if (extra != null) '@extra': extra,
      'text': text,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotMenuButton? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var url = _map['url']! as String;
    return BotMenuButton(
      extra: extra,
      clientId: clientId,
      text: text,
      url: url,
    );
  }
}

/// Represents a location to which a chat is connected.
///
class ChatLocation extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatLocation";

  /// The location.
  late Location location;

  /// Location address; 1-64 characters, as defined by the chat owner.
  late String address;

  /// Represents a location to which a chat is connected
  ChatLocation(
      {required this.location,
      required this.address,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatLocation',
      if (extra != null) '@extra': extra,
      'location': location,
      'address': address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    var address = _map['address']! as String;
    return ChatLocation(
      extra: extra,
      clientId: clientId,
      location: location,
      address: address,
    );
  }
}

/// Information about the sticker, which was used to create the chat photo.
///
class ChatPhotoStickerTypeRegularOrMask extends ChatPhotoStickerType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatPhotoStickerTypeRegularOrMask";

  /// Sticker set identifier.
  /// ; string representation of int, use `int.parse`
  late int64 sticker_set_id;

  /// Identifier of the sticker in the set.
  /// ; string representation of int, use `int.parse`
  late int64 sticker_id;

  /// Information about the sticker, which was used to create the chat photo
  ChatPhotoStickerTypeRegularOrMask(
      {required this.sticker_set_id,
      required this.sticker_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatPhotoStickerTypeRegularOrMask',
      if (extra != null) '@extra': extra,
      'sticker_set_id': sticker_set_id,
      'sticker_id': sticker_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatPhotoStickerTypeRegularOrMask? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_set_id = _map['sticker_set_id']! as int64;
    var sticker_id = _map['sticker_id']! as int64;
    return ChatPhotoStickerTypeRegularOrMask(
      extra: extra,
      clientId: clientId,
      sticker_set_id: sticker_set_id,
      sticker_id: sticker_id,
    );
  }
}

/// Information about the custom emoji, which was used to create the chat photo.
///
class ChatPhotoStickerTypeCustomEmoji extends ChatPhotoStickerType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatPhotoStickerTypeCustomEmoji";

  /// Identifier of the custom emoji.
  /// ; string representation of int, use `int.parse`
  late int64 custom_emoji_id;

  /// Information about the custom emoji, which was used to create the chat photo
  ChatPhotoStickerTypeCustomEmoji(
      {required this.custom_emoji_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatPhotoStickerTypeCustomEmoji',
      if (extra != null) '@extra': extra,
      'custom_emoji_id': custom_emoji_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatPhotoStickerTypeCustomEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_emoji_id = _map['custom_emoji_id']! as int64;
    return ChatPhotoStickerTypeCustomEmoji(
      extra: extra,
      clientId: clientId,
      custom_emoji_id: custom_emoji_id,
    );
  }
}

/// Information about the sticker, which was used to create the chat photo. The sticker is shown at the center of the photo and occupies at most 67% of it.
///
class ChatPhotoSticker extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatPhotoSticker";

  /// Type of the sticker.
  late ChatPhotoStickerType type;

  /// The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported.
  late BackgroundFill background_fill;

  /// Information about the sticker, which was used to create the chat photo. The sticker is shown at the center of the photo and occupies at most 67% of it
  ChatPhotoSticker(
      {required this.type,
      required this.background_fill,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatPhotoSticker',
      if (extra != null) '@extra': extra,
      'type': type,
      'background_fill': background_fill
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatPhotoSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = ChatPhotoStickerType.fromMap(_map['type'])!;
    var background_fill = BackgroundFill.fromMap(_map['background_fill'])!;
    return ChatPhotoSticker(
      extra: extra,
      clientId: clientId,
      type: type,
      background_fill: background_fill,
    );
  }
}

/// Animated variant of a chat photo in MPEG4 format.
///
class AnimatedChatPhoto extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "animatedChatPhoto";

  /// Animation width and height.
  late int length;

  /// Information about the animation file.
  late File file;

  /// Timestamp of the frame, used as a static chat photo.
  late double main_frame_timestamp;

  /// Animated variant of a chat photo in MPEG4 format
  AnimatedChatPhoto(
      {required this.length,
      required this.file,
      required this.main_frame_timestamp,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'animatedChatPhoto',
      if (extra != null) '@extra': extra,
      'length': length,
      'file': file,
      'main_frame_timestamp': main_frame_timestamp
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AnimatedChatPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var length = _map['length']! as int;
    var file = File.fromMap(_map['file'])!;
    var main_frame_timestamp = _map['main_frame_timestamp']! as double;
    return AnimatedChatPhoto(
      extra: extra,
      clientId: clientId,
      length: length,
      file: file,
      main_frame_timestamp: main_frame_timestamp,
    );
  }
}

/// Describes a chat or user profile photo.
///
class ChatPhoto extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatPhoto";

  /// Unique photo identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Point in time (Unix timestamp) when the photo has been added.
  late int added_date;

  /// Photo minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// Available variants of the photo in JPEG format, in different size.
  late List<PhotoSize> sizes;

  /// A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be null.
  AnimatedChatPhoto? animation;

  /// A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available.
  AnimatedChatPhoto? small_animation;

  /// Sticker-based version of the chat photo; may be null.
  ChatPhotoSticker? sticker;

  /// Describes a chat or user profile photo
  ChatPhoto(
      {required this.id,
      required this.added_date,
      this.minithumbnail,
      required this.sizes,
      this.animation,
      this.small_animation,
      this.sticker,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatPhoto',
      if (extra != null) '@extra': extra,
      'id': id,
      'added_date': added_date,
      'minithumbnail': minithumbnail,
      'sizes': sizes,
      'animation': animation,
      'small_animation': small_animation,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var added_date = _map['added_date']! as int;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var sizes = List<PhotoSize>.from(
      (_map["sizes"] ?? []).map(
        (e) => PhotoSize.fromMap(e),
      ),
    );
    var animation = AnimatedChatPhoto.fromMap(_map['animation']);
    var small_animation = AnimatedChatPhoto.fromMap(_map['small_animation']);
    var sticker = ChatPhotoSticker.fromMap(_map['sticker']);
    return ChatPhoto(
      extra: extra,
      clientId: clientId,
      id: id,
      added_date: added_date,
      minithumbnail: minithumbnail,
      sizes: sizes,
      animation: animation,
      small_animation: small_animation,
      sticker: sticker,
    );
  }
}

/// Contains a list of chat or user profile photos.
///
class ChatPhotos extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatPhotos";

  /// Total number of photos.
  late int total_count;

  /// List of photos.
  late List<ChatPhoto> photos;

  /// Contains a list of chat or user profile photos
  ChatPhotos(
      {required this.total_count,
      required this.photos,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatPhotos',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'photos': photos
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatPhotos? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var photos = List<ChatPhoto>.from(
      (_map["photos"] ?? []).map(
        (e) => ChatPhoto.fromMap(e),
      ),
    );
    return ChatPhotos(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      photos: photos,
    );
  }
}

/// A previously used profile photo of the current user.
///
class InputChatPhotoPrevious extends InputChatPhoto {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputChatPhotoPrevious";

  /// Identifier of the current user's profile photo to reuse.
  /// ; string representation of int, use `int.parse`
  late int64 chat_photo_id;

  /// A previously used profile photo of the current user
  InputChatPhotoPrevious(
      {required this.chat_photo_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputChatPhotoPrevious',
      if (extra != null) '@extra': extra,
      'chat_photo_id': chat_photo_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputChatPhotoPrevious? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_photo_id = _map['chat_photo_id']! as int64;
    return InputChatPhotoPrevious(
      extra: extra,
      clientId: clientId,
      chat_photo_id: chat_photo_id,
    );
  }
}

/// A static photo in JPEG format.
///
class InputChatPhotoStatic extends InputChatPhoto {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputChatPhotoStatic";

  /// Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed.
  late InputFile photo;

  /// A static photo in JPEG format
  InputChatPhotoStatic({required this.photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputChatPhotoStatic',
      if (extra != null) '@extra': extra,
      'photo': photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputChatPhotoStatic? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = InputFile.fromMap(_map['photo'])!;
    return InputChatPhotoStatic(
      extra: extra,
      clientId: clientId,
      photo: photo,
    );
  }
}

/// An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 1280 and be at most 2MB in size.
///
class InputChatPhotoAnimation extends InputChatPhoto {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputChatPhotoAnimation";

  /// Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed.
  late InputFile animation;

  /// Timestamp of the frame, which will be used as static chat photo.
  late double main_frame_timestamp;

  /// An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 1280 and be at most 2MB in size
  InputChatPhotoAnimation(
      {required this.animation,
      required this.main_frame_timestamp,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputChatPhotoAnimation',
      if (extra != null) '@extra': extra,
      'animation': animation,
      'main_frame_timestamp': main_frame_timestamp
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputChatPhotoAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animation = InputFile.fromMap(_map['animation'])!;
    var main_frame_timestamp = _map['main_frame_timestamp']! as double;
    return InputChatPhotoAnimation(
      extra: extra,
      clientId: clientId,
      animation: animation,
      main_frame_timestamp: main_frame_timestamp,
    );
  }
}

/// A sticker on a custom background.
///
class InputChatPhotoSticker extends InputChatPhoto {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputChatPhotoSticker";

  /// Information about the sticker.
  late ChatPhotoSticker sticker;

  /// A sticker on a custom background
  InputChatPhotoSticker({required this.sticker, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputChatPhotoSticker',
      if (extra != null) '@extra': extra,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputChatPhotoSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = ChatPhotoSticker.fromMap(_map['sticker'])!;
    return InputChatPhotoSticker(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
    );
  }
}

/// Describes actions that a user is allowed to take in a chat.
///
class ChatPermissions extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatPermissions";

  /// True, if the user can send text messages, contacts, invoices, locations, and venues.
  late bool can_send_basic_messages;

  /// True, if the user can send music files.
  late bool can_send_audios;

  /// True, if the user can send documents.
  late bool can_send_documents;

  /// True, if the user can send audio photos.
  late bool can_send_photos;

  /// True, if the user can send audio videos.
  late bool can_send_videos;

  /// True, if the user can send video notes.
  late bool can_send_video_notes;

  /// True, if the user can send voice notes.
  late bool can_send_voice_notes;

  /// True, if the user can send polls.
  late bool can_send_polls;

  /// True, if the user can send animations, games, stickers, and dice and use inline bots.
  late bool can_send_other_messages;

  /// True, if the user may add a web page preview to their messages.
  late bool can_add_web_page_previews;

  /// True, if the user can change the chat title, photo, and other settings.
  late bool can_change_info;

  /// True, if the user can invite new users to the chat.
  late bool can_invite_users;

  /// True, if the user can pin messages.
  late bool can_pin_messages;

  /// True, if the user can manage topics.
  late bool can_manage_topics;

  /// Describes actions that a user is allowed to take in a chat
  ChatPermissions(
      {required this.can_send_basic_messages,
      required this.can_send_audios,
      required this.can_send_documents,
      required this.can_send_photos,
      required this.can_send_videos,
      required this.can_send_video_notes,
      required this.can_send_voice_notes,
      required this.can_send_polls,
      required this.can_send_other_messages,
      required this.can_add_web_page_previews,
      required this.can_change_info,
      required this.can_invite_users,
      required this.can_pin_messages,
      required this.can_manage_topics,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatPermissions',
      if (extra != null) '@extra': extra,
      'can_send_basic_messages': can_send_basic_messages,
      'can_send_audios': can_send_audios,
      'can_send_documents': can_send_documents,
      'can_send_photos': can_send_photos,
      'can_send_videos': can_send_videos,
      'can_send_video_notes': can_send_video_notes,
      'can_send_voice_notes': can_send_voice_notes,
      'can_send_polls': can_send_polls,
      'can_send_other_messages': can_send_other_messages,
      'can_add_web_page_previews': can_add_web_page_previews,
      'can_change_info': can_change_info,
      'can_invite_users': can_invite_users,
      'can_pin_messages': can_pin_messages,
      'can_manage_topics': can_manage_topics
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatPermissions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var can_send_basic_messages = _map['can_send_basic_messages']! as bool;
    var can_send_audios = _map['can_send_audios']! as bool;
    var can_send_documents = _map['can_send_documents']! as bool;
    var can_send_photos = _map['can_send_photos']! as bool;
    var can_send_videos = _map['can_send_videos']! as bool;
    var can_send_video_notes = _map['can_send_video_notes']! as bool;
    var can_send_voice_notes = _map['can_send_voice_notes']! as bool;
    var can_send_polls = _map['can_send_polls']! as bool;
    var can_send_other_messages = _map['can_send_other_messages']! as bool;
    var can_add_web_page_previews = _map['can_add_web_page_previews']! as bool;
    var can_change_info = _map['can_change_info']! as bool;
    var can_invite_users = _map['can_invite_users']! as bool;
    var can_pin_messages = _map['can_pin_messages']! as bool;
    var can_manage_topics = _map['can_manage_topics']! as bool;
    return ChatPermissions(
      extra: extra,
      clientId: clientId,
      can_send_basic_messages: can_send_basic_messages,
      can_send_audios: can_send_audios,
      can_send_documents: can_send_documents,
      can_send_photos: can_send_photos,
      can_send_videos: can_send_videos,
      can_send_video_notes: can_send_video_notes,
      can_send_voice_notes: can_send_voice_notes,
      can_send_polls: can_send_polls,
      can_send_other_messages: can_send_other_messages,
      can_add_web_page_previews: can_add_web_page_previews,
      can_change_info: can_change_info,
      can_invite_users: can_invite_users,
      can_pin_messages: can_pin_messages,
      can_manage_topics: can_manage_topics,
    );
  }
}

/// Describes rights of the administrator.
///
class ChatAdministratorRights extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatAdministratorRights";

  /// True, if the administrator can get chat event log, get chat statistics, get chat boosts in channels, get message statistics in channels, get channel members,.
  late bool can_manage_chat;

  /// True, if the administrator can change the chat title, photo, and other settings.
  late bool can_change_info;

  /// True, if the administrator can create channel posts; applicable to channels only.
  late bool can_post_messages;

  /// True, if the administrator can edit messages of other users and pin messages; applicable to channels only.
  late bool can_edit_messages;

  /// True, if the administrator can delete messages of other users.
  late bool can_delete_messages;

  /// True, if the administrator can invite new users to the chat.
  late bool can_invite_users;

  /// True, if the administrator can restrict, ban, or unban chat members; always true for channels.
  late bool can_restrict_members;

  /// True, if the administrator can pin messages; applicable to basic groups and supergroups only.
  late bool can_pin_messages;

  /// True, if the administrator can manage topics; applicable to forum supergroups only.
  late bool can_manage_topics;

  /// True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them.
  late bool can_promote_members;

  /// True, if the administrator can manage video chats.
  late bool can_manage_video_chats;

  /// True, if the administrator can create new channel stories, or edit and delete posted stories; applicable to channels only.
  late bool can_post_stories;

  /// True, if the administrator can edit stories posted by other users, pin stories and access story archive; applicable to channels only.
  late bool can_edit_stories;

  /// True, if the administrator can delete stories posted by other users; applicable to channels only.
  late bool can_delete_stories;

  /// True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only.
  late bool is_anonymous;

  /// Describes rights of the administrator
  ChatAdministratorRights(
      {required this.can_manage_chat,
      required this.can_change_info,
      required this.can_post_messages,
      required this.can_edit_messages,
      required this.can_delete_messages,
      required this.can_invite_users,
      required this.can_restrict_members,
      required this.can_pin_messages,
      required this.can_manage_topics,
      required this.can_promote_members,
      required this.can_manage_video_chats,
      required this.can_post_stories,
      required this.can_edit_stories,
      required this.can_delete_stories,
      required this.is_anonymous,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatAdministratorRights',
      if (extra != null) '@extra': extra,
      'can_manage_chat': can_manage_chat,
      'can_change_info': can_change_info,
      'can_post_messages': can_post_messages,
      'can_edit_messages': can_edit_messages,
      'can_delete_messages': can_delete_messages,
      'can_invite_users': can_invite_users,
      'can_restrict_members': can_restrict_members,
      'can_pin_messages': can_pin_messages,
      'can_manage_topics': can_manage_topics,
      'can_promote_members': can_promote_members,
      'can_manage_video_chats': can_manage_video_chats,
      'can_post_stories': can_post_stories,
      'can_edit_stories': can_edit_stories,
      'can_delete_stories': can_delete_stories,
      'is_anonymous': is_anonymous
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatAdministratorRights? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var can_manage_chat = _map['can_manage_chat']! as bool;
    var can_change_info = _map['can_change_info']! as bool;
    var can_post_messages = _map['can_post_messages']! as bool;
    var can_edit_messages = _map['can_edit_messages']! as bool;
    var can_delete_messages = _map['can_delete_messages']! as bool;
    var can_invite_users = _map['can_invite_users']! as bool;
    var can_restrict_members = _map['can_restrict_members']! as bool;
    var can_pin_messages = _map['can_pin_messages']! as bool;
    var can_manage_topics = _map['can_manage_topics']! as bool;
    var can_promote_members = _map['can_promote_members']! as bool;
    var can_manage_video_chats = _map['can_manage_video_chats']! as bool;
    var can_post_stories = _map['can_post_stories']! as bool;
    var can_edit_stories = _map['can_edit_stories']! as bool;
    var can_delete_stories = _map['can_delete_stories']! as bool;
    var is_anonymous = _map['is_anonymous']! as bool;
    return ChatAdministratorRights(
      extra: extra,
      clientId: clientId,
      can_manage_chat: can_manage_chat,
      can_change_info: can_change_info,
      can_post_messages: can_post_messages,
      can_edit_messages: can_edit_messages,
      can_delete_messages: can_delete_messages,
      can_invite_users: can_invite_users,
      can_restrict_members: can_restrict_members,
      can_pin_messages: can_pin_messages,
      can_manage_topics: can_manage_topics,
      can_promote_members: can_promote_members,
      can_manage_video_chats: can_manage_video_chats,
      can_post_stories: can_post_stories,
      can_edit_stories: can_edit_stories,
      can_delete_stories: can_delete_stories,
      is_anonymous: is_anonymous,
    );
  }
}

/// Describes an option for buying Telegram Premium to a user.
///
class PremiumPaymentOption extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumPaymentOption";

  /// ISO 4217 currency code for Telegram Premium subscription payment.
  late String currency;

  /// The amount to pay, in the smallest units of the currency.
  late int amount;

  /// The discount associated with this option, as a percentage.
  late int discount_percentage;

  /// Number of month the Telegram Premium subscription will be active.
  late int month_count;

  /// Identifier of the store product associated with the option.
  late String store_product_id;

  /// An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available.
  InternalLinkType? payment_link;

  /// Describes an option for buying Telegram Premium to a user
  PremiumPaymentOption(
      {required this.currency,
      required this.amount,
      required this.discount_percentage,
      required this.month_count,
      required this.store_product_id,
      this.payment_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumPaymentOption',
      if (extra != null) '@extra': extra,
      'currency': currency,
      'amount': amount,
      'discount_percentage': discount_percentage,
      'month_count': month_count,
      'store_product_id': store_product_id,
      'payment_link': payment_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumPaymentOption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var currency = _map['currency']! as String;
    var amount = _map['amount']! as int;
    var discount_percentage = _map['discount_percentage']! as int;
    var month_count = _map['month_count']! as int;
    var store_product_id = _map['store_product_id']! as String;
    var payment_link = InternalLinkType.fromMap(_map['payment_link']);
    return PremiumPaymentOption(
      extra: extra,
      clientId: clientId,
      currency: currency,
      amount: amount,
      discount_percentage: discount_percentage,
      month_count: month_count,
      store_product_id: store_product_id,
      payment_link: payment_link,
    );
  }
}

/// Describes an option for buying or upgrading Telegram Premium for self.
///
class PremiumStatePaymentOption extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumStatePaymentOption";

  /// Information about the payment option.
  late PremiumPaymentOption payment_option;

  /// True, if this is the currently used Telegram Premium subscription option.
  late bool is_current;

  /// True, if the payment option can be used to upgrade the existing Telegram Premium subscription.
  late bool is_upgrade;

  /// Identifier of the last in-store transaction for the currently used option.
  late String last_transaction_id;

  /// Describes an option for buying or upgrading Telegram Premium for self
  PremiumStatePaymentOption(
      {required this.payment_option,
      required this.is_current,
      required this.is_upgrade,
      required this.last_transaction_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumStatePaymentOption',
      if (extra != null) '@extra': extra,
      'payment_option': payment_option,
      'is_current': is_current,
      'is_upgrade': is_upgrade,
      'last_transaction_id': last_transaction_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumStatePaymentOption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var payment_option = PremiumPaymentOption.fromMap(_map['payment_option'])!;
    var is_current = _map['is_current']! as bool;
    var is_upgrade = _map['is_upgrade']! as bool;
    var last_transaction_id = _map['last_transaction_id']! as String;
    return PremiumStatePaymentOption(
      extra: extra,
      clientId: clientId,
      payment_option: payment_option,
      is_current: is_current,
      is_upgrade: is_upgrade,
      last_transaction_id: last_transaction_id,
    );
  }
}

/// Describes a custom emoji to be shown instead of the Telegram Premium badge.
///
class EmojiStatus extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emojiStatus";

  /// Identifier of the custom emoji in stickerFormatTgs format.
  /// ; string representation of int, use `int.parse`
  late int64 custom_emoji_id;

  /// Point in time (Unix timestamp) when the status will expire; 0 if never.
  late int expiration_date;

  /// Describes a custom emoji to be shown instead of the Telegram Premium badge
  EmojiStatus(
      {required this.custom_emoji_id,
      required this.expiration_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emojiStatus',
      if (extra != null) '@extra': extra,
      'custom_emoji_id': custom_emoji_id,
      'expiration_date': expiration_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmojiStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_emoji_id = _map['custom_emoji_id']! as int64;
    var expiration_date = _map['expiration_date']! as int;
    return EmojiStatus(
      extra: extra,
      clientId: clientId,
      custom_emoji_id: custom_emoji_id,
      expiration_date: expiration_date,
    );
  }
}

/// Contains a list of custom emoji identifiers, which can be set as emoji statuses.
///
class EmojiStatuses extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emojiStatuses";

  /// The list of custom emoji identifiers.
  late List<int64> custom_emoji_ids;

  /// Contains a list of custom emoji identifiers, which can be set as emoji statuses
  EmojiStatuses({required this.custom_emoji_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emojiStatuses',
      if (extra != null) '@extra': extra,
      'custom_emoji_ids': custom_emoji_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmojiStatuses? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_emoji_ids = List<int64>.from(
      (_map["custom_emoji_ids"] ?? []).map(
        (e) => e as int64,
      ),
    );
    return EmojiStatuses(
      extra: extra,
      clientId: clientId,
      custom_emoji_ids: custom_emoji_ids,
    );
  }
}

/// Describes usernames assigned to a user, a supergroup, or a channel.
///
class Usernames extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "usernames";

  /// List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames.
  late List<String> active_usernames;

  /// List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive.
  late List<String> disabled_usernames;

  /// The active username, which can be changed with setUsername or setSupergroupUsername.
  late String editable_username;

  /// Describes usernames assigned to a user, a supergroup, or a channel
  Usernames(
      {required this.active_usernames,
      required this.disabled_usernames,
      required this.editable_username,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'usernames',
      if (extra != null) '@extra': extra,
      'active_usernames': active_usernames,
      'disabled_usernames': disabled_usernames,
      'editable_username': editable_username
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Usernames? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var active_usernames = List<String>.from(
      (_map["active_usernames"] ?? []).map(
        (e) => e as String,
      ),
    );
    var disabled_usernames = List<String>.from(
      (_map["disabled_usernames"] ?? []).map(
        (e) => e as String,
      ),
    );
    var editable_username = _map['editable_username']! as String;
    return Usernames(
      extra: extra,
      clientId: clientId,
      active_usernames: active_usernames,
      disabled_usernames: disabled_usernames,
      editable_username: editable_username,
    );
  }
}

/// Represents a user.
///
class User extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "user";

  /// User identifier.
  late int id;

  /// First name of the user.
  late String first_name;

  /// Last name of the user.
  late String last_name;

  /// Usernames of the user; may be null.
  Usernames? usernames;

  /// Phone number of the user.
  late String phone_number;

  /// Current online status of the user.
  late UserStatus status;

  /// Profile photo of the user; may be null.
  ProfilePhoto? profile_photo;

  /// Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only.
  EmojiStatus? emoji_status;

  /// The user is a contact of the current user.
  late bool is_contact;

  /// The user is a contact of the current user and the current user is a contact of the user.
  late bool is_mutual_contact;

  /// The user is a close friend of the current user; implies that the user is a contact.
  late bool is_close_friend;

  /// True, if the user is verified.
  late bool is_verified;

  /// True, if the user is a Telegram Premium user.
  late bool is_premium;

  /// True, if the user is Telegram support account.
  late bool is_support;

  /// If non-empty, it contains a human-readable description of the reason why access to this user must be restricted.
  late String restriction_reason;

  /// True, if many users reported this user as a scam.
  late bool is_scam;

  /// True, if many users reported this user as a fake account.
  late bool is_fake;

  /// True, if the user has non-expired stories available to the current user.
  late bool has_active_stories;

  /// True, if the user has unread non-expired stories available to the current user.
  late bool has_unread_active_stories;

  /// If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method.
  late bool have_access;

  /// Type of the user.
  late UserType type;

  /// IETF language tag of the user's language; only available to bots.
  late String language_code;

  /// True, if the user added the current bot to attachment menu; only available to bots.
  late bool added_to_attachment_menu;

  /// Represents a user
  User(
      {required this.id,
      required this.first_name,
      required this.last_name,
      this.usernames,
      required this.phone_number,
      required this.status,
      this.profile_photo,
      this.emoji_status,
      required this.is_contact,
      required this.is_mutual_contact,
      required this.is_close_friend,
      required this.is_verified,
      required this.is_premium,
      required this.is_support,
      required this.restriction_reason,
      required this.is_scam,
      required this.is_fake,
      required this.has_active_stories,
      required this.has_unread_active_stories,
      required this.have_access,
      required this.type,
      required this.language_code,
      required this.added_to_attachment_menu,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'user',
      if (extra != null) '@extra': extra,
      'id': id,
      'first_name': first_name,
      'last_name': last_name,
      'usernames': usernames,
      'phone_number': phone_number,
      'status': status,
      'profile_photo': profile_photo,
      'emoji_status': emoji_status,
      'is_contact': is_contact,
      'is_mutual_contact': is_mutual_contact,
      'is_close_friend': is_close_friend,
      'is_verified': is_verified,
      'is_premium': is_premium,
      'is_support': is_support,
      'restriction_reason': restriction_reason,
      'is_scam': is_scam,
      'is_fake': is_fake,
      'has_active_stories': has_active_stories,
      'has_unread_active_stories': has_unread_active_stories,
      'have_access': have_access,
      'type': type,
      'language_code': language_code,
      'added_to_attachment_menu': added_to_attachment_menu
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static User? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var first_name = _map['first_name']! as String;
    var last_name = _map['last_name']! as String;
    var usernames = Usernames.fromMap(_map['usernames']);
    var phone_number = _map['phone_number']! as String;
    var status = UserStatus.fromMap(_map['status'])!;
    var profile_photo = ProfilePhoto.fromMap(_map['profile_photo']);
    var emoji_status = EmojiStatus.fromMap(_map['emoji_status']);
    var is_contact = _map['is_contact']! as bool;
    var is_mutual_contact = _map['is_mutual_contact']! as bool;
    var is_close_friend = _map['is_close_friend']! as bool;
    var is_verified = _map['is_verified']! as bool;
    var is_premium = _map['is_premium']! as bool;
    var is_support = _map['is_support']! as bool;
    var restriction_reason = _map['restriction_reason']! as String;
    var is_scam = _map['is_scam']! as bool;
    var is_fake = _map['is_fake']! as bool;
    var has_active_stories = _map['has_active_stories']! as bool;
    var has_unread_active_stories = _map['has_unread_active_stories']! as bool;
    var have_access = _map['have_access']! as bool;
    var type = UserType.fromMap(_map['type'])!;
    var language_code = _map['language_code']! as String;
    var added_to_attachment_menu = _map['added_to_attachment_menu']! as bool;
    return User(
      extra: extra,
      clientId: clientId,
      id: id,
      first_name: first_name,
      last_name: last_name,
      usernames: usernames,
      phone_number: phone_number,
      status: status,
      profile_photo: profile_photo,
      emoji_status: emoji_status,
      is_contact: is_contact,
      is_mutual_contact: is_mutual_contact,
      is_close_friend: is_close_friend,
      is_verified: is_verified,
      is_premium: is_premium,
      is_support: is_support,
      restriction_reason: restriction_reason,
      is_scam: is_scam,
      is_fake: is_fake,
      has_active_stories: has_active_stories,
      has_unread_active_stories: has_unread_active_stories,
      have_access: have_access,
      type: type,
      language_code: language_code,
      added_to_attachment_menu: added_to_attachment_menu,
    );
  }
}

/// Contains information about a bot.
///
class BotInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botInfo";

  /// The text that is shown on the bot's profile page and is sent together with the link when users share the bot.
  late String short_description;

  /// The text shown in the chat with the bot if the chat is empty.
  late String description;

  /// Photo shown in the chat with the bot if the chat is empty; may be null.
  Photo? photo;

  /// Animation shown in the chat with the bot if the chat is empty; may be null.
  Animation? animation;

  /// Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown.
  BotMenuButton? menu_button;

  /// List of the bot commands.
  late List<BotCommand> commands;

  /// Default administrator rights for adding the bot to basic group and supergroup chats; may be null.
  ChatAdministratorRights? default_group_administrator_rights;

  /// Default administrator rights for adding the bot to channels; may be null.
  ChatAdministratorRights? default_channel_administrator_rights;

  /// The internal link, which can be used to edit bot commands; may be null.
  InternalLinkType? edit_commands_link;

  /// The internal link, which can be used to edit bot description; may be null.
  InternalLinkType? edit_description_link;

  /// The internal link, which can be used to edit the photo or animation shown in the chat with the bot if the chat is empty; may be null.
  InternalLinkType? edit_description_media_link;

  /// The internal link, which can be used to edit bot settings; may be null.
  InternalLinkType? edit_settings_link;

  /// Contains information about a bot
  BotInfo(
      {required this.short_description,
      required this.description,
      this.photo,
      this.animation,
      this.menu_button,
      required this.commands,
      this.default_group_administrator_rights,
      this.default_channel_administrator_rights,
      this.edit_commands_link,
      this.edit_description_link,
      this.edit_description_media_link,
      this.edit_settings_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botInfo',
      if (extra != null) '@extra': extra,
      'short_description': short_description,
      'description': description,
      'photo': photo,
      'animation': animation,
      'menu_button': menu_button,
      'commands': commands,
      'default_group_administrator_rights': default_group_administrator_rights,
      'default_channel_administrator_rights':
          default_channel_administrator_rights,
      'edit_commands_link': edit_commands_link,
      'edit_description_link': edit_description_link,
      'edit_description_media_link': edit_description_media_link,
      'edit_settings_link': edit_settings_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var short_description = _map['short_description']! as String;
    var description = _map['description']! as String;
    var photo = Photo.fromMap(_map['photo']);
    var animation = Animation.fromMap(_map['animation']);
    var menu_button = BotMenuButton.fromMap(_map['menu_button']);
    var commands = List<BotCommand>.from(
      (_map["commands"] ?? []).map(
        (e) => BotCommand.fromMap(e),
      ),
    );
    var default_group_administrator_rights = ChatAdministratorRights.fromMap(
        _map['default_group_administrator_rights']);
    var default_channel_administrator_rights = ChatAdministratorRights.fromMap(
        _map['default_channel_administrator_rights']);
    var edit_commands_link =
        InternalLinkType.fromMap(_map['edit_commands_link']);
    var edit_description_link =
        InternalLinkType.fromMap(_map['edit_description_link']);
    var edit_description_media_link =
        InternalLinkType.fromMap(_map['edit_description_media_link']);
    var edit_settings_link =
        InternalLinkType.fromMap(_map['edit_settings_link']);
    return BotInfo(
      extra: extra,
      clientId: clientId,
      short_description: short_description,
      description: description,
      photo: photo,
      animation: animation,
      menu_button: menu_button,
      commands: commands,
      default_group_administrator_rights: default_group_administrator_rights,
      default_channel_administrator_rights:
          default_channel_administrator_rights,
      edit_commands_link: edit_commands_link,
      edit_description_link: edit_description_link,
      edit_description_media_link: edit_description_media_link,
      edit_settings_link: edit_settings_link,
    );
  }
}

/// Contains full information about a user.
///
class UserFullInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userFullInfo";

  /// User profile photo set by the current user for the contact; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown..
  ChatPhoto? personal_photo;

  /// User profile photo; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown..
  ChatPhoto? photo;

  /// User profile photo visible if the main photo is hidden by privacy settings; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown..
  ChatPhoto? public_photo;

  /// Block list to which the user is added; may be null if none.
  BlockList? block_list;

  /// True, if the user can be called.
  late bool can_be_called;

  /// True, if a video call can be created with the user.
  late bool supports_video_calls;

  /// True, if the user can't be called due to their privacy settings.
  late bool has_private_calls;

  /// True, if the user can't be linked in forwarded messages due to their privacy settings.
  late bool has_private_forwards;

  /// True, if voice and video notes can't be sent or forwarded to the user.
  late bool has_restricted_voice_and_video_note_messages;

  /// True, if the user has pinned stories.
  late bool has_pinned_stories;

  /// True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used.
  late bool need_phone_number_privacy_exception;

  /// A short user bio; may be null for bots.
  FormattedText? bio;

  /// The list of available options for gifting Telegram Premium to the user.
  late List<PremiumPaymentOption> premium_gift_options;

  /// Number of group chats where both the other user and the current user are a member; 0 for the current user.
  late int group_in_common_count;

  /// For bots, information about the bot; may be null if the user isn't a bot.
  BotInfo? bot_info;

  /// Contains full information about a user
  UserFullInfo(
      {this.personal_photo,
      this.photo,
      this.public_photo,
      this.block_list,
      required this.can_be_called,
      required this.supports_video_calls,
      required this.has_private_calls,
      required this.has_private_forwards,
      required this.has_restricted_voice_and_video_note_messages,
      required this.has_pinned_stories,
      required this.need_phone_number_privacy_exception,
      this.bio,
      required this.premium_gift_options,
      required this.group_in_common_count,
      this.bot_info,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userFullInfo',
      if (extra != null) '@extra': extra,
      'personal_photo': personal_photo,
      'photo': photo,
      'public_photo': public_photo,
      'block_list': block_list,
      'can_be_called': can_be_called,
      'supports_video_calls': supports_video_calls,
      'has_private_calls': has_private_calls,
      'has_private_forwards': has_private_forwards,
      'has_restricted_voice_and_video_note_messages':
          has_restricted_voice_and_video_note_messages,
      'has_pinned_stories': has_pinned_stories,
      'need_phone_number_privacy_exception':
          need_phone_number_privacy_exception,
      'bio': bio,
      'premium_gift_options': premium_gift_options,
      'group_in_common_count': group_in_common_count,
      'bot_info': bot_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserFullInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var personal_photo = ChatPhoto.fromMap(_map['personal_photo']);
    var photo = ChatPhoto.fromMap(_map['photo']);
    var public_photo = ChatPhoto.fromMap(_map['public_photo']);
    var block_list = BlockList.fromMap(_map['block_list']);
    var can_be_called = _map['can_be_called']! as bool;
    var supports_video_calls = _map['supports_video_calls']! as bool;
    var has_private_calls = _map['has_private_calls']! as bool;
    var has_private_forwards = _map['has_private_forwards']! as bool;
    var has_restricted_voice_and_video_note_messages =
        _map['has_restricted_voice_and_video_note_messages']! as bool;
    var has_pinned_stories = _map['has_pinned_stories']! as bool;
    var need_phone_number_privacy_exception =
        _map['need_phone_number_privacy_exception']! as bool;
    var bio = FormattedText.fromMap(_map['bio']);
    var premium_gift_options = List<PremiumPaymentOption>.from(
      (_map["premium_gift_options"] ?? []).map(
        (e) => PremiumPaymentOption.fromMap(e),
      ),
    );
    var group_in_common_count = _map['group_in_common_count']! as int;
    var bot_info = BotInfo.fromMap(_map['bot_info']);
    return UserFullInfo(
      extra: extra,
      clientId: clientId,
      personal_photo: personal_photo,
      photo: photo,
      public_photo: public_photo,
      block_list: block_list,
      can_be_called: can_be_called,
      supports_video_calls: supports_video_calls,
      has_private_calls: has_private_calls,
      has_private_forwards: has_private_forwards,
      has_restricted_voice_and_video_note_messages:
          has_restricted_voice_and_video_note_messages,
      has_pinned_stories: has_pinned_stories,
      need_phone_number_privacy_exception: need_phone_number_privacy_exception,
      bio: bio,
      premium_gift_options: premium_gift_options,
      group_in_common_count: group_in_common_count,
      bot_info: bot_info,
    );
  }
}

/// Represents a list of users.
///
class Users extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "users";

  /// Approximate total number of users found.
  late int total_count;

  /// A list of user identifiers.
  late List<int> user_ids;

  /// Represents a list of users
  Users(
      {required this.total_count,
      required this.user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'users',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Users? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return Users(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      user_ids: user_ids,
    );
  }
}

/// Contains information about a chat administrator.
///
class ChatAdministrator extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatAdministrator";

  /// User identifier of the administrator.
  late int user_id;

  /// Custom title of the administrator.
  late String custom_title;

  /// True, if the user is the owner of the chat.
  late bool is_owner;

  /// Contains information about a chat administrator
  ChatAdministrator(
      {required this.user_id,
      required this.custom_title,
      required this.is_owner,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatAdministrator',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'custom_title': custom_title,
      'is_owner': is_owner
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatAdministrator? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var custom_title = _map['custom_title']! as String;
    var is_owner = _map['is_owner']! as bool;
    return ChatAdministrator(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      custom_title: custom_title,
      is_owner: is_owner,
    );
  }
}

/// Represents a list of chat administrators.
///
class ChatAdministrators extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatAdministrators";

  /// A list of chat administrators.
  late List<ChatAdministrator> administrators;

  /// Represents a list of chat administrators
  ChatAdministrators({required this.administrators, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatAdministrators',
      if (extra != null) '@extra': extra,
      'administrators': administrators
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatAdministrators? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var administrators = List<ChatAdministrator>.from(
      (_map["administrators"] ?? []).map(
        (e) => ChatAdministrator.fromMap(e),
      ),
    );
    return ChatAdministrators(
      extra: extra,
      clientId: clientId,
      administrators: administrators,
    );
  }
}

/// The user is the owner of the chat and has all the administrator privileges.
///
class ChatMemberStatusCreator extends ChatMemberStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMemberStatusCreator";

  /// A custom title of the owner; 0-16 characters without emojis; applicable to supergroups only.
  late String custom_title;

  /// True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only.
  late bool is_anonymous;

  /// True, if the user is a member of the chat.
  late bool is_member;

  /// The user is the owner of the chat and has all the administrator privileges
  ChatMemberStatusCreator(
      {required this.custom_title,
      required this.is_anonymous,
      required this.is_member,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMemberStatusCreator',
      if (extra != null) '@extra': extra,
      'custom_title': custom_title,
      'is_anonymous': is_anonymous,
      'is_member': is_member
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMemberStatusCreator? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_title = _map['custom_title']! as String;
    var is_anonymous = _map['is_anonymous']! as bool;
    var is_member = _map['is_member']! as bool;
    return ChatMemberStatusCreator(
      extra: extra,
      clientId: clientId,
      custom_title: custom_title,
      is_anonymous: is_anonymous,
      is_member: is_member,
    );
  }
}

/// The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats..
///
class ChatMemberStatusAdministrator extends ChatMemberStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMemberStatusAdministrator";

  /// A custom title of the administrator; 0-16 characters without emojis; applicable to supergroups only.
  late String custom_title;

  /// True, if the current user can edit the administrator privileges for the called user.
  late bool can_be_edited;

  /// Rights of the administrator.
  late ChatAdministratorRights rights;

  /// The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats.
  ChatMemberStatusAdministrator(
      {required this.custom_title,
      required this.can_be_edited,
      required this.rights,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMemberStatusAdministrator',
      if (extra != null) '@extra': extra,
      'custom_title': custom_title,
      'can_be_edited': can_be_edited,
      'rights': rights
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMemberStatusAdministrator? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_title = _map['custom_title']! as String;
    var can_be_edited = _map['can_be_edited']! as bool;
    var rights = ChatAdministratorRights.fromMap(_map['rights'])!;
    return ChatMemberStatusAdministrator(
      extra: extra,
      clientId: clientId,
      custom_title: custom_title,
      can_be_edited: can_be_edited,
      rights: rights,
    );
  }
}

/// The user is a member of the chat, without any additional privileges or restrictions.
///
class ChatMemberStatusMember extends ChatMemberStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMemberStatusMember";

  /// The user is a member of the chat, without any additional privileges or restrictions
  ChatMemberStatusMember({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMemberStatusMember',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMemberStatusMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatMemberStatusMember(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is under certain restrictions in the chat. Not supported in basic groups and channels.
///
class ChatMemberStatusRestricted extends ChatMemberStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMemberStatusRestricted";

  /// True, if the user is a member of the chat.
  late bool is_member;

  /// Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever.
  late int restricted_until_date;

  /// User permissions in the chat.
  late ChatPermissions permissions;

  /// The user is under certain restrictions in the chat. Not supported in basic groups and channels
  ChatMemberStatusRestricted(
      {required this.is_member,
      required this.restricted_until_date,
      required this.permissions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMemberStatusRestricted',
      if (extra != null) '@extra': extra,
      'is_member': is_member,
      'restricted_until_date': restricted_until_date,
      'permissions': permissions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMemberStatusRestricted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_member = _map['is_member']! as bool;
    var restricted_until_date = _map['restricted_until_date']! as int;
    var permissions = ChatPermissions.fromMap(_map['permissions'])!;
    return ChatMemberStatusRestricted(
      extra: extra,
      clientId: clientId,
      is_member: is_member,
      restricted_until_date: restricted_until_date,
      permissions: permissions,
    );
  }
}

/// The user or the chat is not a chat member.
///
class ChatMemberStatusLeft extends ChatMemberStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMemberStatusLeft";

  /// The user or the chat is not a chat member
  ChatMemberStatusLeft({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMemberStatusLeft',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMemberStatusLeft? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatMemberStatusLeft(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat.
///
class ChatMemberStatusBanned extends ChatMemberStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMemberStatusBanned";

  /// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups.
  late int banned_until_date;

  /// The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat
  ChatMemberStatusBanned(
      {required this.banned_until_date, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMemberStatusBanned',
      if (extra != null) '@extra': extra,
      'banned_until_date': banned_until_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMemberStatusBanned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var banned_until_date = _map['banned_until_date']! as int;
    return ChatMemberStatusBanned(
      extra: extra,
      clientId: clientId,
      banned_until_date: banned_until_date,
    );
  }
}

/// Describes a user or a chat as a member of another chat.
///
class ChatMember extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMember";

  /// Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels.
  late MessageSender member_id;

  /// Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown.
  late int inviter_user_id;

  /// Point in time (Unix timestamp) when the user joined/was promoted/was banned in the chat.
  late int joined_chat_date;

  /// Status of the member in the chat.
  late ChatMemberStatus status;

  /// Describes a user or a chat as a member of another chat
  ChatMember(
      {required this.member_id,
      required this.inviter_user_id,
      required this.joined_chat_date,
      required this.status,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMember',
      if (extra != null) '@extra': extra,
      'member_id': member_id,
      'inviter_user_id': inviter_user_id,
      'joined_chat_date': joined_chat_date,
      'status': status
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var member_id = MessageSender.fromMap(_map['member_id'])!;
    var inviter_user_id = _map['inviter_user_id']! as int;
    var joined_chat_date = _map['joined_chat_date']! as int;
    var status = ChatMemberStatus.fromMap(_map['status'])!;
    return ChatMember(
      extra: extra,
      clientId: clientId,
      member_id: member_id,
      inviter_user_id: inviter_user_id,
      joined_chat_date: joined_chat_date,
      status: status,
    );
  }
}

/// Contains a list of chat members.
///
class ChatMembers extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMembers";

  /// Approximate total number of chat members found.
  late int total_count;

  /// A list of chat members.
  late List<ChatMember> members;

  /// Contains a list of chat members
  ChatMembers(
      {required this.total_count,
      required this.members,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMembers',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'members': members
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var members = List<ChatMember>.from(
      (_map["members"] ?? []).map(
        (e) => ChatMember.fromMap(e),
      ),
    );
    return ChatMembers(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      members: members,
    );
  }
}

/// Returns contacts of the user.
///
class ChatMembersFilterContacts extends ChatMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMembersFilterContacts";

  /// Returns contacts of the user
  ChatMembersFilterContacts({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMembersFilterContacts',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMembersFilterContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatMembersFilterContacts(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns the owner and administrators.
///
class ChatMembersFilterAdministrators extends ChatMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMembersFilterAdministrators";

  /// Returns the owner and administrators
  ChatMembersFilterAdministrators({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMembersFilterAdministrators',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMembersFilterAdministrators? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatMembersFilterAdministrators(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns all chat members, including restricted chat members.
///
class ChatMembersFilterMembers extends ChatMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMembersFilterMembers";

  /// Returns all chat members, including restricted chat members
  ChatMembersFilterMembers({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMembersFilterMembers',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMembersFilterMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatMembersFilterMembers(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns users which can be mentioned in the chat.
///
class ChatMembersFilterMention extends ChatMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMembersFilterMention";

  /// If non-zero, the identifier of the current message thread.
  late int message_thread_id;

  /// Returns users which can be mentioned in the chat
  ChatMembersFilterMention(
      {required this.message_thread_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMembersFilterMention',
      if (extra != null) '@extra': extra,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMembersFilterMention? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_thread_id = _map['message_thread_id']! as int;
    return ChatMembersFilterMention(
      extra: extra,
      clientId: clientId,
      message_thread_id: message_thread_id,
    );
  }
}

/// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup.
///
class ChatMembersFilterRestricted extends ChatMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMembersFilterRestricted";

  /// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
  ChatMembersFilterRestricted({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMembersFilterRestricted',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMembersFilterRestricted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatMembersFilterRestricted(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel.
///
class ChatMembersFilterBanned extends ChatMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMembersFilterBanned";

  /// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
  ChatMembersFilterBanned({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMembersFilterBanned',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMembersFilterBanned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatMembersFilterBanned(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns bot members of the chat.
///
class ChatMembersFilterBots extends ChatMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMembersFilterBots";

  /// Returns bot members of the chat
  ChatMembersFilterBots({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMembersFilterBots',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMembersFilterBots? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatMembersFilterBots(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns recently active users in reverse chronological order.
///
class SupergroupMembersFilterRecent extends SupergroupMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroupMembersFilterRecent";

  /// Returns recently active users in reverse chronological order
  SupergroupMembersFilterRecent({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroupMembersFilterRecent',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SupergroupMembersFilterRecent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SupergroupMembersFilterRecent(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns contacts of the user, which are members of the supergroup or channel.
///
class SupergroupMembersFilterContacts extends SupergroupMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroupMembersFilterContacts";

  /// Query to search for.
  late String query;

  /// Returns contacts of the user, which are members of the supergroup or channel
  SupergroupMembersFilterContacts(
      {required this.query, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroupMembersFilterContacts',
      if (extra != null) '@extra': extra,
      'query': query
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SupergroupMembersFilterContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    return SupergroupMembersFilterContacts(
      extra: extra,
      clientId: clientId,
      query: query,
    );
  }
}

/// Returns the owner and administrators.
///
class SupergroupMembersFilterAdministrators extends SupergroupMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroupMembersFilterAdministrators";

  /// Returns the owner and administrators
  SupergroupMembersFilterAdministrators({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroupMembersFilterAdministrators',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SupergroupMembersFilterAdministrators? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SupergroupMembersFilterAdministrators(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Used to search for supergroup or channel members via a (string) query.
///
class SupergroupMembersFilterSearch extends SupergroupMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroupMembersFilterSearch";

  /// Query to search for.
  late String query;

  /// Used to search for supergroup or channel members via a (string) query
  SupergroupMembersFilterSearch(
      {required this.query, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroupMembersFilterSearch',
      if (extra != null) '@extra': extra,
      'query': query
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SupergroupMembersFilterSearch? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    return SupergroupMembersFilterSearch(
      extra: extra,
      clientId: clientId,
      query: query,
    );
  }
}

/// Returns restricted supergroup members; can be used only by administrators.
///
class SupergroupMembersFilterRestricted extends SupergroupMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroupMembersFilterRestricted";

  /// Query to search for.
  late String query;

  /// Returns restricted supergroup members; can be used only by administrators
  SupergroupMembersFilterRestricted(
      {required this.query, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroupMembersFilterRestricted',
      if (extra != null) '@extra': extra,
      'query': query
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SupergroupMembersFilterRestricted? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    return SupergroupMembersFilterRestricted(
      extra: extra,
      clientId: clientId,
      query: query,
    );
  }
}

/// Returns users banned from the supergroup or channel; can be used only by administrators.
///
class SupergroupMembersFilterBanned extends SupergroupMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroupMembersFilterBanned";

  /// Query to search for.
  late String query;

  /// Returns users banned from the supergroup or channel; can be used only by administrators
  SupergroupMembersFilterBanned(
      {required this.query, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroupMembersFilterBanned',
      if (extra != null) '@extra': extra,
      'query': query
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SupergroupMembersFilterBanned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    return SupergroupMembersFilterBanned(
      extra: extra,
      clientId: clientId,
      query: query,
    );
  }
}

/// Returns users which can be mentioned in the supergroup.
///
class SupergroupMembersFilterMention extends SupergroupMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroupMembersFilterMention";

  /// Query to search for.
  late String query;

  /// If non-zero, the identifier of the current message thread.
  late int message_thread_id;

  /// Returns users which can be mentioned in the supergroup
  SupergroupMembersFilterMention(
      {required this.query,
      required this.message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroupMembersFilterMention',
      if (extra != null) '@extra': extra,
      'query': query,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SupergroupMembersFilterMention? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    var message_thread_id = _map['message_thread_id']! as int;
    return SupergroupMembersFilterMention(
      extra: extra,
      clientId: clientId,
      query: query,
      message_thread_id: message_thread_id,
    );
  }
}

/// Returns bot members of the supergroup or channel.
///
class SupergroupMembersFilterBots extends SupergroupMembersFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroupMembersFilterBots";

  /// Returns bot members of the supergroup or channel
  SupergroupMembersFilterBots({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroupMembersFilterBots',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SupergroupMembersFilterBots? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SupergroupMembersFilterBots(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains a chat invite link.
///
class ChatInviteLink extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatInviteLink";

  /// Chat invite link.
  late String invite_link;

  /// Name of the link.
  late String name;

  /// User identifier of an administrator created the link.
  late int creator_user_id;

  /// Point in time (Unix timestamp) when the link was created.
  late int date;

  /// Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown.
  late int edit_date;

  /// Point in time (Unix timestamp) when the link will expire; 0 if never.
  late int expiration_date;

  /// The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval.
  late int member_limit;

  /// Number of chat members, which joined the chat using the link.
  late int member_count;

  /// Number of pending join requests created using this link.
  late int pending_join_request_count;

  /// True, if the link only creates join request. If true, total number of joining members will be unlimited.
  late bool creates_join_request;

  /// True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time.
  late bool is_primary;

  /// True, if the link was revoked.
  late bool is_revoked;

  /// Contains a chat invite link
  ChatInviteLink(
      {required this.invite_link,
      required this.name,
      required this.creator_user_id,
      required this.date,
      required this.edit_date,
      required this.expiration_date,
      required this.member_limit,
      required this.member_count,
      required this.pending_join_request_count,
      required this.creates_join_request,
      required this.is_primary,
      required this.is_revoked,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatInviteLink',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link,
      'name': name,
      'creator_user_id': creator_user_id,
      'date': date,
      'edit_date': edit_date,
      'expiration_date': expiration_date,
      'member_limit': member_limit,
      'member_count': member_count,
      'pending_join_request_count': pending_join_request_count,
      'creates_join_request': creates_join_request,
      'is_primary': is_primary,
      'is_revoked': is_revoked
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = _map['invite_link']! as String;
    var name = _map['name']! as String;
    var creator_user_id = _map['creator_user_id']! as int;
    var date = _map['date']! as int;
    var edit_date = _map['edit_date']! as int;
    var expiration_date = _map['expiration_date']! as int;
    var member_limit = _map['member_limit']! as int;
    var member_count = _map['member_count']! as int;
    var pending_join_request_count = _map['pending_join_request_count']! as int;
    var creates_join_request = _map['creates_join_request']! as bool;
    var is_primary = _map['is_primary']! as bool;
    var is_revoked = _map['is_revoked']! as bool;
    return ChatInviteLink(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
      name: name,
      creator_user_id: creator_user_id,
      date: date,
      edit_date: edit_date,
      expiration_date: expiration_date,
      member_limit: member_limit,
      member_count: member_count,
      pending_join_request_count: pending_join_request_count,
      creates_join_request: creates_join_request,
      is_primary: is_primary,
      is_revoked: is_revoked,
    );
  }
}

/// Contains a list of chat invite links.
///
class ChatInviteLinks extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatInviteLinks";

  /// Approximate total number of chat invite links found.
  late int total_count;

  /// List of invite links.
  late List<ChatInviteLink> invite_links;

  /// Contains a list of chat invite links
  ChatInviteLinks(
      {required this.total_count,
      required this.invite_links,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatInviteLinks',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'invite_links': invite_links
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatInviteLinks? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var invite_links = List<ChatInviteLink>.from(
      (_map["invite_links"] ?? []).map(
        (e) => ChatInviteLink.fromMap(e),
      ),
    );
    return ChatInviteLinks(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      invite_links: invite_links,
    );
  }
}

/// Describes a chat administrator with a number of active and revoked chat invite links.
///
class ChatInviteLinkCount extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatInviteLinkCount";

  /// Administrator's user identifier.
  late int user_id;

  /// Number of active invite links.
  late int invite_link_count;

  /// Number of revoked invite links.
  late int revoked_invite_link_count;

  /// Describes a chat administrator with a number of active and revoked chat invite links
  ChatInviteLinkCount(
      {required this.user_id,
      required this.invite_link_count,
      required this.revoked_invite_link_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatInviteLinkCount',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'invite_link_count': invite_link_count,
      'revoked_invite_link_count': revoked_invite_link_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatInviteLinkCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var invite_link_count = _map['invite_link_count']! as int;
    var revoked_invite_link_count = _map['revoked_invite_link_count']! as int;
    return ChatInviteLinkCount(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      invite_link_count: invite_link_count,
      revoked_invite_link_count: revoked_invite_link_count,
    );
  }
}

/// Contains a list of chat invite link counts.
///
class ChatInviteLinkCounts extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatInviteLinkCounts";

  /// List of invite link counts.
  late List<ChatInviteLinkCount> invite_link_counts;

  /// Contains a list of chat invite link counts
  ChatInviteLinkCounts(
      {required this.invite_link_counts, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatInviteLinkCounts',
      if (extra != null) '@extra': extra,
      'invite_link_counts': invite_link_counts
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatInviteLinkCounts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link_counts = List<ChatInviteLinkCount>.from(
      (_map["invite_link_counts"] ?? []).map(
        (e) => ChatInviteLinkCount.fromMap(e),
      ),
    );
    return ChatInviteLinkCounts(
      extra: extra,
      clientId: clientId,
      invite_link_counts: invite_link_counts,
    );
  }
}

/// Describes a chat member joined a chat via an invite link.
///
class ChatInviteLinkMember extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatInviteLinkMember";

  /// User identifier.
  late int user_id;

  /// Point in time (Unix timestamp) when the user joined the chat.
  late int joined_chat_date;

  /// True, if the user has joined the chat using an invite link for a chat folder.
  late bool via_chat_folder_invite_link;

  /// User identifier of the chat administrator, approved user join request.
  late int approver_user_id;

  /// Describes a chat member joined a chat via an invite link
  ChatInviteLinkMember(
      {required this.user_id,
      required this.joined_chat_date,
      required this.via_chat_folder_invite_link,
      required this.approver_user_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatInviteLinkMember',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'joined_chat_date': joined_chat_date,
      'via_chat_folder_invite_link': via_chat_folder_invite_link,
      'approver_user_id': approver_user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatInviteLinkMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var joined_chat_date = _map['joined_chat_date']! as int;
    var via_chat_folder_invite_link =
        _map['via_chat_folder_invite_link']! as bool;
    var approver_user_id = _map['approver_user_id']! as int;
    return ChatInviteLinkMember(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      joined_chat_date: joined_chat_date,
      via_chat_folder_invite_link: via_chat_folder_invite_link,
      approver_user_id: approver_user_id,
    );
  }
}

/// Contains a list of chat members joined a chat via an invite link.
///
class ChatInviteLinkMembers extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatInviteLinkMembers";

  /// Approximate total number of chat members found.
  late int total_count;

  /// List of chat members, joined a chat via an invite link.
  late List<ChatInviteLinkMember> members;

  /// Contains a list of chat members joined a chat via an invite link
  ChatInviteLinkMembers(
      {required this.total_count,
      required this.members,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatInviteLinkMembers',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'members': members
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatInviteLinkMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var members = List<ChatInviteLinkMember>.from(
      (_map["members"] ?? []).map(
        (e) => ChatInviteLinkMember.fromMap(e),
      ),
    );
    return ChatInviteLinkMembers(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      members: members,
    );
  }
}

/// The link is an invite link for a basic group.
///
class InviteLinkChatTypeBasicGroup extends InviteLinkChatType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inviteLinkChatTypeBasicGroup";

  /// The link is an invite link for a basic group
  InviteLinkChatTypeBasicGroup({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inviteLinkChatTypeBasicGroup',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InviteLinkChatTypeBasicGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InviteLinkChatTypeBasicGroup(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is an invite link for a supergroup.
///
class InviteLinkChatTypeSupergroup extends InviteLinkChatType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inviteLinkChatTypeSupergroup";

  /// The link is an invite link for a supergroup
  InviteLinkChatTypeSupergroup({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inviteLinkChatTypeSupergroup',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InviteLinkChatTypeSupergroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InviteLinkChatTypeSupergroup(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is an invite link for a channel.
///
class InviteLinkChatTypeChannel extends InviteLinkChatType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inviteLinkChatTypeChannel";

  /// The link is an invite link for a channel
  InviteLinkChatTypeChannel({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inviteLinkChatTypeChannel',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InviteLinkChatTypeChannel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InviteLinkChatTypeChannel(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains information about a chat invite link.
///
class ChatInviteLinkInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatInviteLinkInfo";

  /// Chat identifier of the invite link; 0 if the user has no access to the chat before joining.
  late int chat_id;

  /// If non-zero, the amount of time for which read access to the chat will remain available, in seconds.
  late int accessible_for;

  /// Type of the chat.
  late InviteLinkChatType type;

  /// Title of the chat.
  late String title;

  /// Chat photo; may be null.
  ChatPhotoInfo? photo;

  /// Chat description.
  late String description;

  /// Number of members in the chat.
  late int member_count;

  /// User identifiers of some chat members that may be known to the current user.
  late List<int> member_user_ids;

  /// True, if the link only creates join request.
  late bool creates_join_request;

  /// True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup.
  late bool is_public;

  /// True, if the chat is verified.
  late bool is_verified;

  /// True, if many users reported this chat as a scam.
  late bool is_scam;

  /// True, if many users reported this chat as a fake account.
  late bool is_fake;

  /// Contains information about a chat invite link
  ChatInviteLinkInfo(
      {required this.chat_id,
      required this.accessible_for,
      required this.type,
      required this.title,
      this.photo,
      required this.description,
      required this.member_count,
      required this.member_user_ids,
      required this.creates_join_request,
      required this.is_public,
      required this.is_verified,
      required this.is_scam,
      required this.is_fake,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatInviteLinkInfo',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'accessible_for': accessible_for,
      'type': type,
      'title': title,
      'photo': photo,
      'description': description,
      'member_count': member_count,
      'member_user_ids': member_user_ids,
      'creates_join_request': creates_join_request,
      'is_public': is_public,
      'is_verified': is_verified,
      'is_scam': is_scam,
      'is_fake': is_fake
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatInviteLinkInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var accessible_for = _map['accessible_for']! as int;
    var type = InviteLinkChatType.fromMap(_map['type'])!;
    var title = _map['title']! as String;
    var photo = ChatPhotoInfo.fromMap(_map['photo']);
    var description = _map['description']! as String;
    var member_count = _map['member_count']! as int;
    var member_user_ids = List<int>.from(
      (_map["member_user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var creates_join_request = _map['creates_join_request']! as bool;
    var is_public = _map['is_public']! as bool;
    var is_verified = _map['is_verified']! as bool;
    var is_scam = _map['is_scam']! as bool;
    var is_fake = _map['is_fake']! as bool;
    return ChatInviteLinkInfo(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      accessible_for: accessible_for,
      type: type,
      title: title,
      photo: photo,
      description: description,
      member_count: member_count,
      member_user_ids: member_user_ids,
      creates_join_request: creates_join_request,
      is_public: is_public,
      is_verified: is_verified,
      is_scam: is_scam,
      is_fake: is_fake,
    );
  }
}

/// Describes a user that sent a join request and waits for administrator approval.
///
class ChatJoinRequest extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatJoinRequest";

  /// User identifier.
  late int user_id;

  /// Point in time (Unix timestamp) when the user sent the join request.
  late int date;

  /// A short bio of the user.
  late String bio;

  /// Describes a user that sent a join request and waits for administrator approval
  ChatJoinRequest(
      {required this.user_id,
      required this.date,
      required this.bio,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatJoinRequest',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'date': date,
      'bio': bio
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatJoinRequest? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var date = _map['date']! as int;
    var bio = _map['bio']! as String;
    return ChatJoinRequest(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      date: date,
      bio: bio,
    );
  }
}

/// Contains a list of requests to join a chat.
///
class ChatJoinRequests extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatJoinRequests";

  /// Approximate total number of requests found.
  late int total_count;

  /// List of the requests.
  late List<ChatJoinRequest> requests;

  /// Contains a list of requests to join a chat
  ChatJoinRequests(
      {required this.total_count,
      required this.requests,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatJoinRequests',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'requests': requests
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatJoinRequests? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var requests = List<ChatJoinRequest>.from(
      (_map["requests"] ?? []).map(
        (e) => ChatJoinRequest.fromMap(e),
      ),
    );
    return ChatJoinRequests(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      requests: requests,
    );
  }
}

/// Contains information about pending join requests for a chat.
///
class ChatJoinRequestsInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatJoinRequestsInfo";

  /// Total number of pending join requests.
  late int total_count;

  /// Identifiers of at most 3 users sent the newest pending join requests.
  late List<int> user_ids;

  /// Contains information about pending join requests for a chat
  ChatJoinRequestsInfo(
      {required this.total_count,
      required this.user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatJoinRequestsInfo',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatJoinRequestsInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return ChatJoinRequestsInfo(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      user_ids: user_ids,
    );
  }
}

/// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users).
///
class BasicGroup extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "basicGroup";

  /// Group identifier.
  late int id;

  /// Number of members in the group.
  late int member_count;

  /// Status of the current user in the group.
  late ChatMemberStatus status;

  /// True, if the group is active.
  late bool is_active;

  /// Identifier of the supergroup to which this group was upgraded; 0 if none.
  late int upgraded_to_supergroup_id;

  /// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
  BasicGroup(
      {required this.id,
      required this.member_count,
      required this.status,
      required this.is_active,
      required this.upgraded_to_supergroup_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'basicGroup',
      if (extra != null) '@extra': extra,
      'id': id,
      'member_count': member_count,
      'status': status,
      'is_active': is_active,
      'upgraded_to_supergroup_id': upgraded_to_supergroup_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BasicGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var member_count = _map['member_count']! as int;
    var status = ChatMemberStatus.fromMap(_map['status'])!;
    var is_active = _map['is_active']! as bool;
    var upgraded_to_supergroup_id = _map['upgraded_to_supergroup_id']! as int;
    return BasicGroup(
      extra: extra,
      clientId: clientId,
      id: id,
      member_count: member_count,
      status: status,
      is_active: is_active,
      upgraded_to_supergroup_id: upgraded_to_supergroup_id,
    );
  }
}

/// Contains full information about a basic group.
///
class BasicGroupFullInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "basicGroupFullInfo";

  /// Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo.
  ChatPhoto? photo;

  /// Group description. Updated only after the basic group is opened.
  late String description;

  /// User identifier of the creator of the group; 0 if unknown.
  late int creator_user_id;

  /// Group members.
  late List<ChatMember> members;

  /// True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators after upgrading the basic group to a supergroup.
  late bool can_hide_members;

  /// True, if aggressive anti-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup.
  late bool can_toggle_aggressive_anti_spam;

  /// Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened.
  ChatInviteLink? invite_link;

  /// List of commands of bots in the group.
  late List<BotCommands> bot_commands;

  /// Contains full information about a basic group
  BasicGroupFullInfo(
      {this.photo,
      required this.description,
      required this.creator_user_id,
      required this.members,
      required this.can_hide_members,
      required this.can_toggle_aggressive_anti_spam,
      this.invite_link,
      required this.bot_commands,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'basicGroupFullInfo',
      if (extra != null) '@extra': extra,
      'photo': photo,
      'description': description,
      'creator_user_id': creator_user_id,
      'members': members,
      'can_hide_members': can_hide_members,
      'can_toggle_aggressive_anti_spam': can_toggle_aggressive_anti_spam,
      'invite_link': invite_link,
      'bot_commands': bot_commands
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BasicGroupFullInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = ChatPhoto.fromMap(_map['photo']);
    var description = _map['description']! as String;
    var creator_user_id = _map['creator_user_id']! as int;
    var members = List<ChatMember>.from(
      (_map["members"] ?? []).map(
        (e) => ChatMember.fromMap(e),
      ),
    );
    var can_hide_members = _map['can_hide_members']! as bool;
    var can_toggle_aggressive_anti_spam =
        _map['can_toggle_aggressive_anti_spam']! as bool;
    var invite_link = ChatInviteLink.fromMap(_map['invite_link']);
    var bot_commands = List<BotCommands>.from(
      (_map["bot_commands"] ?? []).map(
        (e) => BotCommands.fromMap(e),
      ),
    );
    return BasicGroupFullInfo(
      extra: extra,
      clientId: clientId,
      photo: photo,
      description: description,
      creator_user_id: creator_user_id,
      members: members,
      can_hide_members: can_hide_members,
      can_toggle_aggressive_anti_spam: can_toggle_aggressive_anti_spam,
      invite_link: invite_link,
      bot_commands: bot_commands,
    );
  }
}

/// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup:.
///
class Supergroup extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroup";

  /// Supergroup or channel identifier.
  late int id;

  /// Usernames of the supergroup or channel; may be null.
  Usernames? usernames;

  /// Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member.
  late int date;

  /// Status of the current user in the supergroup or channel; custom title will always be empty.
  late ChatMemberStatus status;

  /// Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received.
  late int member_count;

  /// True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel.
  late bool has_linked_chat;

  /// True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup.
  late bool has_location;

  /// True, if messages sent to the channel need to contain information about the sender. This field is only applicable to channels.
  late bool sign_messages;

  /// True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups.
  late bool join_to_send_messages;

  /// True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat.
  late bool join_by_request;

  /// True, if the slow mode is enabled in the supergroup.
  late bool is_slow_mode_enabled;

  /// True, if the supergroup is a channel.
  late bool is_channel;

  /// True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members.
  late bool is_broadcast_group;

  /// True, if the supergroup must be shown as a forum by default.
  late bool is_forum;

  /// True, if the supergroup or channel is verified.
  late bool is_verified;

  /// If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted.
  late String restriction_reason;

  /// True, if many users reported this supergroup or channel as a scam.
  late bool is_scam;

  /// True, if many users reported this supergroup or channel as a fake account.
  late bool is_fake;

  /// True, if the channel has non-expired stories available to the current user.
  late bool has_active_stories;

  /// True, if the channel has unread non-expired stories available to the current user.
  late bool has_unread_active_stories;

  /// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup:
  Supergroup(
      {required this.id,
      this.usernames,
      required this.date,
      required this.status,
      required this.member_count,
      required this.has_linked_chat,
      required this.has_location,
      required this.sign_messages,
      required this.join_to_send_messages,
      required this.join_by_request,
      required this.is_slow_mode_enabled,
      required this.is_channel,
      required this.is_broadcast_group,
      required this.is_forum,
      required this.is_verified,
      required this.restriction_reason,
      required this.is_scam,
      required this.is_fake,
      required this.has_active_stories,
      required this.has_unread_active_stories,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroup',
      if (extra != null) '@extra': extra,
      'id': id,
      'usernames': usernames,
      'date': date,
      'status': status,
      'member_count': member_count,
      'has_linked_chat': has_linked_chat,
      'has_location': has_location,
      'sign_messages': sign_messages,
      'join_to_send_messages': join_to_send_messages,
      'join_by_request': join_by_request,
      'is_slow_mode_enabled': is_slow_mode_enabled,
      'is_channel': is_channel,
      'is_broadcast_group': is_broadcast_group,
      'is_forum': is_forum,
      'is_verified': is_verified,
      'restriction_reason': restriction_reason,
      'is_scam': is_scam,
      'is_fake': is_fake,
      'has_active_stories': has_active_stories,
      'has_unread_active_stories': has_unread_active_stories
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Supergroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var usernames = Usernames.fromMap(_map['usernames']);
    var date = _map['date']! as int;
    var status = ChatMemberStatus.fromMap(_map['status'])!;
    var member_count = _map['member_count']! as int;
    var has_linked_chat = _map['has_linked_chat']! as bool;
    var has_location = _map['has_location']! as bool;
    var sign_messages = _map['sign_messages']! as bool;
    var join_to_send_messages = _map['join_to_send_messages']! as bool;
    var join_by_request = _map['join_by_request']! as bool;
    var is_slow_mode_enabled = _map['is_slow_mode_enabled']! as bool;
    var is_channel = _map['is_channel']! as bool;
    var is_broadcast_group = _map['is_broadcast_group']! as bool;
    var is_forum = _map['is_forum']! as bool;
    var is_verified = _map['is_verified']! as bool;
    var restriction_reason = _map['restriction_reason']! as String;
    var is_scam = _map['is_scam']! as bool;
    var is_fake = _map['is_fake']! as bool;
    var has_active_stories = _map['has_active_stories']! as bool;
    var has_unread_active_stories = _map['has_unread_active_stories']! as bool;
    return Supergroup(
      extra: extra,
      clientId: clientId,
      id: id,
      usernames: usernames,
      date: date,
      status: status,
      member_count: member_count,
      has_linked_chat: has_linked_chat,
      has_location: has_location,
      sign_messages: sign_messages,
      join_to_send_messages: join_to_send_messages,
      join_by_request: join_by_request,
      is_slow_mode_enabled: is_slow_mode_enabled,
      is_channel: is_channel,
      is_broadcast_group: is_broadcast_group,
      is_forum: is_forum,
      is_verified: is_verified,
      restriction_reason: restriction_reason,
      is_scam: is_scam,
      is_fake: is_fake,
      has_active_stories: has_active_stories,
      has_unread_active_stories: has_unread_active_stories,
    );
  }
}

/// Contains full information about a supergroup or channel.
///
class SupergroupFullInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "supergroupFullInfo";

  /// Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo.
  ChatPhoto? photo;

  /// Supergroup or channel description.
  late String description;

  /// Number of members in the supergroup or channel; 0 if unknown.
  late int member_count;

  /// Number of privileged users in the supergroup or channel; 0 if unknown.
  late int administrator_count;

  /// Number of restricted users in the supergroup; 0 if unknown.
  late int restricted_count;

  /// Number of users banned from chat; 0 if unknown.
  late int banned_count;

  /// Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown.
  late int linked_chat_id;

  /// Delay between consecutive sent messages for non-administrator supergroup members, in seconds.
  late int slow_mode_delay;

  /// Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero.
  late double slow_mode_delay_expires_in;

  /// True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers.
  late bool can_get_members;

  /// True, if non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers.
  late bool has_hidden_members;

  /// True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators.
  late bool can_hide_members;

  /// True, if the supergroup sticker set can be changed.
  late bool can_set_sticker_set;

  /// True, if the supergroup location can be changed.
  late bool can_set_location;

  /// True, if the supergroup or channel statistics are available.
  late bool can_get_statistics;

  /// True, if aggressive anti-spam checks can be enabled or disabled in the supergroup.
  late bool can_toggle_aggressive_anti_spam;

  /// True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available,.
  late bool is_all_history_available;

  /// True, if aggressive anti-spam checks are enabled in the supergroup. The value of this field is only available to chat administrators.
  late bool has_aggressive_anti_spam_enabled;

  /// True, if the channel has pinned stories.
  late bool has_pinned_stories;

  /// Identifier of the supergroup sticker set; 0 if none.
  /// ; string representation of int, use `int.parse`
  late int64 sticker_set_id;

  /// Location to which the supergroup is connected; may be null if none.
  ChatLocation? location;

  /// Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only.
  ChatInviteLink? invite_link;

  /// List of commands of bots in the group.
  late List<BotCommands> bot_commands;

  /// Identifier of the basic group from which supergroup was upgraded; 0 if none.
  late int upgraded_from_basic_group_id;

  /// Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none.
  late int upgraded_from_max_message_id;

  /// Contains full information about a supergroup or channel
  SupergroupFullInfo(
      {this.photo,
      required this.description,
      required this.member_count,
      required this.administrator_count,
      required this.restricted_count,
      required this.banned_count,
      required this.linked_chat_id,
      required this.slow_mode_delay,
      required this.slow_mode_delay_expires_in,
      required this.can_get_members,
      required this.has_hidden_members,
      required this.can_hide_members,
      required this.can_set_sticker_set,
      required this.can_set_location,
      required this.can_get_statistics,
      required this.can_toggle_aggressive_anti_spam,
      required this.is_all_history_available,
      required this.has_aggressive_anti_spam_enabled,
      required this.has_pinned_stories,
      required this.sticker_set_id,
      this.location,
      this.invite_link,
      required this.bot_commands,
      required this.upgraded_from_basic_group_id,
      required this.upgraded_from_max_message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'supergroupFullInfo',
      if (extra != null) '@extra': extra,
      'photo': photo,
      'description': description,
      'member_count': member_count,
      'administrator_count': administrator_count,
      'restricted_count': restricted_count,
      'banned_count': banned_count,
      'linked_chat_id': linked_chat_id,
      'slow_mode_delay': slow_mode_delay,
      'slow_mode_delay_expires_in': slow_mode_delay_expires_in,
      'can_get_members': can_get_members,
      'has_hidden_members': has_hidden_members,
      'can_hide_members': can_hide_members,
      'can_set_sticker_set': can_set_sticker_set,
      'can_set_location': can_set_location,
      'can_get_statistics': can_get_statistics,
      'can_toggle_aggressive_anti_spam': can_toggle_aggressive_anti_spam,
      'is_all_history_available': is_all_history_available,
      'has_aggressive_anti_spam_enabled': has_aggressive_anti_spam_enabled,
      'has_pinned_stories': has_pinned_stories,
      'sticker_set_id': sticker_set_id,
      'location': location,
      'invite_link': invite_link,
      'bot_commands': bot_commands,
      'upgraded_from_basic_group_id': upgraded_from_basic_group_id,
      'upgraded_from_max_message_id': upgraded_from_max_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SupergroupFullInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = ChatPhoto.fromMap(_map['photo']);
    var description = _map['description']! as String;
    var member_count = _map['member_count']! as int;
    var administrator_count = _map['administrator_count']! as int;
    var restricted_count = _map['restricted_count']! as int;
    var banned_count = _map['banned_count']! as int;
    var linked_chat_id = _map['linked_chat_id']! as int;
    var slow_mode_delay = _map['slow_mode_delay']! as int;
    var slow_mode_delay_expires_in =
        _map['slow_mode_delay_expires_in']! as double;
    var can_get_members = _map['can_get_members']! as bool;
    var has_hidden_members = _map['has_hidden_members']! as bool;
    var can_hide_members = _map['can_hide_members']! as bool;
    var can_set_sticker_set = _map['can_set_sticker_set']! as bool;
    var can_set_location = _map['can_set_location']! as bool;
    var can_get_statistics = _map['can_get_statistics']! as bool;
    var can_toggle_aggressive_anti_spam =
        _map['can_toggle_aggressive_anti_spam']! as bool;
    var is_all_history_available = _map['is_all_history_available']! as bool;
    var has_aggressive_anti_spam_enabled =
        _map['has_aggressive_anti_spam_enabled']! as bool;
    var has_pinned_stories = _map['has_pinned_stories']! as bool;
    var sticker_set_id = _map['sticker_set_id']! as int64;
    var location = ChatLocation.fromMap(_map['location']);
    var invite_link = ChatInviteLink.fromMap(_map['invite_link']);
    var bot_commands = List<BotCommands>.from(
      (_map["bot_commands"] ?? []).map(
        (e) => BotCommands.fromMap(e),
      ),
    );
    var upgraded_from_basic_group_id =
        _map['upgraded_from_basic_group_id']! as int;
    var upgraded_from_max_message_id =
        _map['upgraded_from_max_message_id']! as int;
    return SupergroupFullInfo(
      extra: extra,
      clientId: clientId,
      photo: photo,
      description: description,
      member_count: member_count,
      administrator_count: administrator_count,
      restricted_count: restricted_count,
      banned_count: banned_count,
      linked_chat_id: linked_chat_id,
      slow_mode_delay: slow_mode_delay,
      slow_mode_delay_expires_in: slow_mode_delay_expires_in,
      can_get_members: can_get_members,
      has_hidden_members: has_hidden_members,
      can_hide_members: can_hide_members,
      can_set_sticker_set: can_set_sticker_set,
      can_set_location: can_set_location,
      can_get_statistics: can_get_statistics,
      can_toggle_aggressive_anti_spam: can_toggle_aggressive_anti_spam,
      is_all_history_available: is_all_history_available,
      has_aggressive_anti_spam_enabled: has_aggressive_anti_spam_enabled,
      has_pinned_stories: has_pinned_stories,
      sticker_set_id: sticker_set_id,
      location: location,
      invite_link: invite_link,
      bot_commands: bot_commands,
      upgraded_from_basic_group_id: upgraded_from_basic_group_id,
      upgraded_from_max_message_id: upgraded_from_max_message_id,
    );
  }
}

/// The secret chat is not yet created; waiting for the other user to get online.
///
class SecretChatStatePending extends SecretChatState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "secretChatStatePending";

  /// The secret chat is not yet created; waiting for the other user to get online
  SecretChatStatePending({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'secretChatStatePending',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SecretChatStatePending? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SecretChatStatePending(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The secret chat is ready to use.
///
class SecretChatStateReady extends SecretChatState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "secretChatStateReady";

  /// The secret chat is ready to use
  SecretChatStateReady({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'secretChatStateReady',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SecretChatStateReady? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SecretChatStateReady(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The secret chat is closed.
///
class SecretChatStateClosed extends SecretChatState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "secretChatStateClosed";

  /// The secret chat is closed
  SecretChatStateClosed({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'secretChatStateClosed',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SecretChatStateClosed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SecretChatStateClosed(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents a secret chat.
///
class SecretChat extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "secretChat";

  /// Secret chat identifier.
  late int id;

  /// Identifier of the chat partner.
  late int user_id;

  /// State of the secret chat.
  late SecretChatState state;

  /// True, if the chat was created by the current user; false otherwise.
  late bool is_outbound;

  /// Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9..
  /// ; base64-encoded bytes `List<int>`
  late bytes key_hash;

  /// Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101,.
  late int layer;

  /// Represents a secret chat
  SecretChat(
      {required this.id,
      required this.user_id,
      required this.state,
      required this.is_outbound,
      required this.key_hash,
      required this.layer,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'secretChat',
      if (extra != null) '@extra': extra,
      'id': id,
      'user_id': user_id,
      'state': state,
      'is_outbound': is_outbound,
      'key_hash': key_hash,
      'layer': layer
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SecretChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var user_id = _map['user_id']! as int;
    var state = SecretChatState.fromMap(_map['state'])!;
    var is_outbound = _map['is_outbound']! as bool;
    var key_hash = _map['key_hash']! as bytes;
    var layer = _map['layer']! as int;
    return SecretChat(
      extra: extra,
      clientId: clientId,
      id: id,
      user_id: user_id,
      state: state,
      is_outbound: is_outbound,
      key_hash: key_hash,
      layer: layer,
    );
  }
}

/// The message was sent by a known user.
///
class MessageSenderUser extends MessageSender {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSenderUser";

  /// Identifier of the user that sent the message.
  late int user_id;

  /// The message was sent by a known user
  MessageSenderUser({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSenderUser',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSenderUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return MessageSenderUser(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// The message was sent on behalf of a chat.
///
class MessageSenderChat extends MessageSender {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSenderChat";

  /// Identifier of the chat that sent the message.
  late int chat_id;

  /// The message was sent on behalf of a chat
  MessageSenderChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSenderChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSenderChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return MessageSenderChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Represents a list of message senders.
///
class MessageSenders extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSenders";

  /// Approximate total number of messages senders found.
  late int total_count;

  /// List of message senders.
  late List<MessageSender> senders;

  /// Represents a list of message senders
  MessageSenders(
      {required this.total_count,
      required this.senders,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSenders',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'senders': senders
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSenders? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var senders = List<MessageSender>.from(
      (_map["senders"] ?? []).map(
        (e) => MessageSender.fromMap(e),
      ),
    );
    return MessageSenders(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      senders: senders,
    );
  }
}

/// Represents a message sender, which can be used to send messages in a chat.
///
class ChatMessageSender extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMessageSender";

  /// Available message senders.
  late MessageSender sender;

  /// True, if Telegram Premium is needed to use the message sender.
  late bool needs_premium;

  /// Represents a message sender, which can be used to send messages in a chat
  ChatMessageSender(
      {required this.sender,
      required this.needs_premium,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMessageSender',
      if (extra != null) '@extra': extra,
      'sender': sender,
      'needs_premium': needs_premium
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMessageSender? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sender = MessageSender.fromMap(_map['sender'])!;
    var needs_premium = _map['needs_premium']! as bool;
    return ChatMessageSender(
      extra: extra,
      clientId: clientId,
      sender: sender,
      needs_premium: needs_premium,
    );
  }
}

/// Represents a list of message senders, which can be used to send messages in a chat.
///
class ChatMessageSenders extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatMessageSenders";

  /// List of available message senders.
  late List<ChatMessageSender> senders;

  /// Represents a list of message senders, which can be used to send messages in a chat
  ChatMessageSenders({required this.senders, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatMessageSenders',
      if (extra != null) '@extra': extra,
      'senders': senders
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatMessageSenders? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var senders = List<ChatMessageSender>.from(
      (_map["senders"] ?? []).map(
        (e) => ChatMessageSender.fromMap(e),
      ),
    );
    return ChatMessageSenders(
      extra: extra,
      clientId: clientId,
      senders: senders,
    );
  }
}

/// Represents a viewer of a message.
///
class MessageViewer extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageViewer";

  /// User identifier of the viewer.
  late int user_id;

  /// Approximate point in time (Unix timestamp) when the message was viewed.
  late int view_date;

  /// Represents a viewer of a message
  MessageViewer(
      {required this.user_id,
      required this.view_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageViewer',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'view_date': view_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageViewer? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var view_date = _map['view_date']! as int;
    return MessageViewer(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      view_date: view_date,
    );
  }
}

/// Represents a list of message viewers.
///
class MessageViewers extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageViewers";

  /// List of message viewers.
  late List<MessageViewer> viewers;

  /// Represents a list of message viewers
  MessageViewers({required this.viewers, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageViewers',
      if (extra != null) '@extra': extra,
      'viewers': viewers
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageViewers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var viewers = List<MessageViewer>.from(
      (_map["viewers"] ?? []).map(
        (e) => MessageViewer.fromMap(e),
      ),
    );
    return MessageViewers(
      extra: extra,
      clientId: clientId,
      viewers: viewers,
    );
  }
}

/// The message was originally sent by a known user.
///
class MessageForwardOriginUser extends MessageForwardOrigin {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForwardOriginUser";

  /// Identifier of the user that originally sent the message.
  late int sender_user_id;

  /// The message was originally sent by a known user
  MessageForwardOriginUser(
      {required this.sender_user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForwardOriginUser',
      if (extra != null) '@extra': extra,
      'sender_user_id': sender_user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForwardOriginUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sender_user_id = _map['sender_user_id']! as int;
    return MessageForwardOriginUser(
      extra: extra,
      clientId: clientId,
      sender_user_id: sender_user_id,
    );
  }
}

/// The message was originally sent on behalf of a chat.
///
class MessageForwardOriginChat extends MessageForwardOrigin {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForwardOriginChat";

  /// Identifier of the chat that originally sent the message.
  late int sender_chat_id;

  /// For messages originally sent by an anonymous chat administrator, original message author signature.
  late String author_signature;

  /// The message was originally sent on behalf of a chat
  MessageForwardOriginChat(
      {required this.sender_chat_id,
      required this.author_signature,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForwardOriginChat',
      if (extra != null) '@extra': extra,
      'sender_chat_id': sender_chat_id,
      'author_signature': author_signature
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForwardOriginChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sender_chat_id = _map['sender_chat_id']! as int;
    var author_signature = _map['author_signature']! as String;
    return MessageForwardOriginChat(
      extra: extra,
      clientId: clientId,
      sender_chat_id: sender_chat_id,
      author_signature: author_signature,
    );
  }
}

/// The message was originally sent by a user, which is hidden by their privacy settings.
///
class MessageForwardOriginHiddenUser extends MessageForwardOrigin {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForwardOriginHiddenUser";

  /// Name of the sender.
  late String sender_name;

  /// The message was originally sent by a user, which is hidden by their privacy settings
  MessageForwardOriginHiddenUser(
      {required this.sender_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForwardOriginHiddenUser',
      if (extra != null) '@extra': extra,
      'sender_name': sender_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForwardOriginHiddenUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sender_name = _map['sender_name']! as String;
    return MessageForwardOriginHiddenUser(
      extra: extra,
      clientId: clientId,
      sender_name: sender_name,
    );
  }
}

/// The message was originally a post in a channel.
///
class MessageForwardOriginChannel extends MessageForwardOrigin {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForwardOriginChannel";

  /// Identifier of the chat from which the message was originally forwarded.
  late int chat_id;

  /// Message identifier of the original message.
  late int message_id;

  /// Original post author signature.
  late String author_signature;

  /// The message was originally a post in a channel
  MessageForwardOriginChannel(
      {required this.chat_id,
      required this.message_id,
      required this.author_signature,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForwardOriginChannel',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'author_signature': author_signature
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForwardOriginChannel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var author_signature = _map['author_signature']! as String;
    return MessageForwardOriginChannel(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      author_signature: author_signature,
    );
  }
}

/// The message was imported from an exported message history.
///
class MessageForwardOriginMessageImport extends MessageForwardOrigin {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForwardOriginMessageImport";

  /// Name of the sender.
  late String sender_name;

  /// The message was imported from an exported message history
  MessageForwardOriginMessageImport(
      {required this.sender_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForwardOriginMessageImport',
      if (extra != null) '@extra': extra,
      'sender_name': sender_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForwardOriginMessageImport? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sender_name = _map['sender_name']! as String;
    return MessageForwardOriginMessageImport(
      extra: extra,
      clientId: clientId,
      sender_name: sender_name,
    );
  }
}

/// A reaction with an emoji.
///
class ReactionTypeEmoji extends ReactionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reactionTypeEmoji";

  /// Text representation of the reaction.
  late String emoji;

  /// A reaction with an emoji
  ReactionTypeEmoji({required this.emoji, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reactionTypeEmoji',
      if (extra != null) '@extra': extra,
      'emoji': emoji
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReactionTypeEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emoji = _map['emoji']! as String;
    return ReactionTypeEmoji(
      extra: extra,
      clientId: clientId,
      emoji: emoji,
    );
  }
}

/// A reaction with a custom emoji.
///
class ReactionTypeCustomEmoji extends ReactionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reactionTypeCustomEmoji";

  /// Unique identifier of the custom emoji.
  /// ; string representation of int, use `int.parse`
  late int64 custom_emoji_id;

  /// A reaction with a custom emoji
  ReactionTypeCustomEmoji(
      {required this.custom_emoji_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reactionTypeCustomEmoji',
      if (extra != null) '@extra': extra,
      'custom_emoji_id': custom_emoji_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReactionTypeCustomEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_emoji_id = _map['custom_emoji_id']! as int64;
    return ReactionTypeCustomEmoji(
      extra: extra,
      clientId: clientId,
      custom_emoji_id: custom_emoji_id,
    );
  }
}

/// Contains information about a forwarded message.
///
class MessageForwardInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForwardInfo";

  /// Origin of a forwarded message.
  late MessageForwardOrigin origin;

  /// Point in time (Unix timestamp) when the message was originally sent.
  late int date;

  /// The type of a public service announcement for the forwarded message.
  late String public_service_announcement_type;

  /// For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the chat from which the message was forwarded last time; 0 if unknown.
  late int from_chat_id;

  /// For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the original message from which the new message was forwarded last time; 0 if unknown.
  late int from_message_id;

  /// Contains information about a forwarded message
  MessageForwardInfo(
      {required this.origin,
      required this.date,
      required this.public_service_announcement_type,
      required this.from_chat_id,
      required this.from_message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForwardInfo',
      if (extra != null) '@extra': extra,
      'origin': origin,
      'date': date,
      'public_service_announcement_type': public_service_announcement_type,
      'from_chat_id': from_chat_id,
      'from_message_id': from_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForwardInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var origin = MessageForwardOrigin.fromMap(_map['origin'])!;
    var date = _map['date']! as int;
    var public_service_announcement_type =
        _map['public_service_announcement_type']! as String;
    var from_chat_id = _map['from_chat_id']! as int;
    var from_message_id = _map['from_message_id']! as int;
    return MessageForwardInfo(
      extra: extra,
      clientId: clientId,
      origin: origin,
      date: date,
      public_service_announcement_type: public_service_announcement_type,
      from_chat_id: from_chat_id,
      from_message_id: from_message_id,
    );
  }
}

/// Contains information about replies to a message.
///
class MessageReplyInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageReplyInfo";

  /// Number of times the message was directly or indirectly replied.
  late int reply_count;

  /// Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available.
  late List<MessageSender> recent_replier_ids;

  /// Identifier of the last read incoming reply to the message.
  late int last_read_inbox_message_id;

  /// Identifier of the last read outgoing reply to the message.
  late int last_read_outbox_message_id;

  /// Identifier of the last reply to the message.
  late int last_message_id;

  /// Contains information about replies to a message
  MessageReplyInfo(
      {required this.reply_count,
      required this.recent_replier_ids,
      required this.last_read_inbox_message_id,
      required this.last_read_outbox_message_id,
      required this.last_message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageReplyInfo',
      if (extra != null) '@extra': extra,
      'reply_count': reply_count,
      'recent_replier_ids': recent_replier_ids,
      'last_read_inbox_message_id': last_read_inbox_message_id,
      'last_read_outbox_message_id': last_read_outbox_message_id,
      'last_message_id': last_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageReplyInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reply_count = _map['reply_count']! as int;
    var recent_replier_ids = List<MessageSender>.from(
      (_map["recent_replier_ids"] ?? []).map(
        (e) => MessageSender.fromMap(e),
      ),
    );
    var last_read_inbox_message_id = _map['last_read_inbox_message_id']! as int;
    var last_read_outbox_message_id =
        _map['last_read_outbox_message_id']! as int;
    var last_message_id = _map['last_message_id']! as int;
    return MessageReplyInfo(
      extra: extra,
      clientId: clientId,
      reply_count: reply_count,
      recent_replier_ids: recent_replier_ids,
      last_read_inbox_message_id: last_read_inbox_message_id,
      last_read_outbox_message_id: last_read_outbox_message_id,
      last_message_id: last_message_id,
    );
  }
}

/// Contains information about a reaction to a message.
///
class MessageReaction extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageReaction";

  /// Type of the reaction.
  late ReactionType type;

  /// Number of times the reaction was added.
  late int total_count;

  /// True, if the reaction is chosen by the current user.
  late bool is_chosen;

  /// Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats.
  late List<MessageSender> recent_sender_ids;

  /// Contains information about a reaction to a message
  MessageReaction(
      {required this.type,
      required this.total_count,
      required this.is_chosen,
      required this.recent_sender_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageReaction',
      if (extra != null) '@extra': extra,
      'type': type,
      'total_count': total_count,
      'is_chosen': is_chosen,
      'recent_sender_ids': recent_sender_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = ReactionType.fromMap(_map['type'])!;
    var total_count = _map['total_count']! as int;
    var is_chosen = _map['is_chosen']! as bool;
    var recent_sender_ids = List<MessageSender>.from(
      (_map["recent_sender_ids"] ?? []).map(
        (e) => MessageSender.fromMap(e),
      ),
    );
    return MessageReaction(
      extra: extra,
      clientId: clientId,
      type: type,
      total_count: total_count,
      is_chosen: is_chosen,
      recent_sender_ids: recent_sender_ids,
    );
  }
}

/// Contains information about interactions with a message.
///
class MessageInteractionInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageInteractionInfo";

  /// Number of times the message was viewed.
  late int view_count;

  /// Number of times the message was forwarded.
  late int forward_count;

  /// Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself.
  MessageReplyInfo? reply_info;

  /// The list of reactions added to the message.
  late List<MessageReaction> reactions;

  /// Contains information about interactions with a message
  MessageInteractionInfo(
      {required this.view_count,
      required this.forward_count,
      this.reply_info,
      required this.reactions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageInteractionInfo',
      if (extra != null) '@extra': extra,
      'view_count': view_count,
      'forward_count': forward_count,
      'reply_info': reply_info,
      'reactions': reactions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageInteractionInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var view_count = _map['view_count']! as int;
    var forward_count = _map['forward_count']! as int;
    var reply_info = MessageReplyInfo.fromMap(_map['reply_info']);
    var reactions = List<MessageReaction>.from(
      (_map["reactions"] ?? []).map(
        (e) => MessageReaction.fromMap(e),
      ),
    );
    return MessageInteractionInfo(
      extra: extra,
      clientId: clientId,
      view_count: view_count,
      forward_count: forward_count,
      reply_info: reply_info,
      reactions: reactions,
    );
  }
}

/// Contains information about an unread reaction to a message.
///
class UnreadReaction extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "unreadReaction";

  /// Type of the reaction.
  late ReactionType type;

  /// Identifier of the sender, added the reaction.
  late MessageSender sender_id;

  /// True, if the reaction was added with a big animation.
  late bool is_big;

  /// Contains information about an unread reaction to a message
  UnreadReaction(
      {required this.type,
      required this.sender_id,
      required this.is_big,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'unreadReaction',
      if (extra != null) '@extra': extra,
      'type': type,
      'sender_id': sender_id,
      'is_big': is_big
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UnreadReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = ReactionType.fromMap(_map['type'])!;
    var sender_id = MessageSender.fromMap(_map['sender_id'])!;
    var is_big = _map['is_big']! as bool;
    return UnreadReaction(
      extra: extra,
      clientId: clientId,
      type: type,
      sender_id: sender_id,
      is_big: is_big,
    );
  }
}

/// The message is being sent now, but has not yet been delivered to the server.
///
class MessageSendingStatePending extends MessageSendingState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSendingStatePending";

  /// Non-persistent message sending identifier, specified by the application.
  late int sending_id;

  /// The message is being sent now, but has not yet been delivered to the server
  MessageSendingStatePending(
      {required this.sending_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSendingStatePending',
      if (extra != null) '@extra': extra,
      'sending_id': sending_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSendingStatePending? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sending_id = _map['sending_id']! as int;
    return MessageSendingStatePending(
      extra: extra,
      clientId: clientId,
      sending_id: sending_id,
    );
  }
}

/// The message failed to be sent.
///
class MessageSendingStateFailed extends MessageSendingState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSendingStateFailed";

  /// The cause of the message sending failure.
  late Error error;

  /// True, if the message can be re-sent.
  late bool can_retry;

  /// True, if the message can be re-sent only on behalf of a different sender.
  late bool need_another_sender;

  /// Time left before the message can be re-sent, in seconds. No update is sent when this field changes.
  late double retry_after;

  /// The message failed to be sent
  MessageSendingStateFailed(
      {required this.error,
      required this.can_retry,
      required this.need_another_sender,
      required this.retry_after,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSendingStateFailed',
      if (extra != null) '@extra': extra,
      'error': error,
      'can_retry': can_retry,
      'need_another_sender': need_another_sender,
      'retry_after': retry_after
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSendingStateFailed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var error = Error.fromMap(_map['error'])!;
    var can_retry = _map['can_retry']! as bool;
    var need_another_sender = _map['need_another_sender']! as bool;
    var retry_after = _map['retry_after']! as double;
    return MessageSendingStateFailed(
      extra: extra,
      clientId: clientId,
      error: error,
      can_retry: can_retry,
      need_another_sender: need_another_sender,
      retry_after: retry_after,
    );
  }
}

/// Describes a replied message.
///
class MessageReplyToMessage extends MessageReplyTo {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageReplyToMessage";

  /// The identifier of the chat to which the replied message belongs; ignored for outgoing replies. For example, messages in the Replies chat are replies to messages in different chats.
  late int chat_id;

  /// The identifier of the replied message.
  late int message_id;

  /// Describes a replied message
  MessageReplyToMessage(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageReplyToMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageReplyToMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return MessageReplyToMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Describes a replied story.
///
class MessageReplyToStory extends MessageReplyTo {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageReplyToStory";

  /// The identifier of the sender of the replied story. Currently, stories can be replied only in the sender's chat.
  late int story_sender_chat_id;

  /// The identifier of the replied story.
  late int story_id;

  /// Describes a replied story
  MessageReplyToStory(
      {required this.story_sender_chat_id,
      required this.story_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageReplyToStory',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageReplyToStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    return MessageReplyToStory(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
    );
  }
}

/// Describes a message.
///
class Message extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "message";

  /// Message identifier; unique for the chat to which the message belongs.
  late int id;

  /// Identifier of the sender of the message.
  late MessageSender sender_id;

  /// Chat identifier.
  late int chat_id;

  /// The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent.
  MessageSendingState? sending_state;

  /// The scheduling state of the message; may be null if the message isn't scheduled.
  MessageSchedulingState? scheduling_state;

  /// True, if the message is outgoing.
  late bool is_outgoing;

  /// True, if the message is pinned.
  late bool is_pinned;

  /// True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application.
  late bool can_be_edited;

  /// True, if the message can be forwarded.
  late bool can_be_forwarded;

  /// True, if content of the message can be saved locally or copied.
  late bool can_be_saved;

  /// True, if the message can be deleted only for the current user while other users will continue to see it.
  late bool can_be_deleted_only_for_self;

  /// True, if the message can be deleted for all users.
  late bool can_be_deleted_for_all_users;

  /// True, if the list of added reactions is available through getMessageAddedReactions.
  late bool can_get_added_reactions;

  /// True, if the message statistics are available through getMessageStatistics.
  late bool can_get_statistics;

  /// True, if information about the message thread is available through getMessageThread and getMessageThreadHistory.
  late bool can_get_message_thread;

  /// True, if chat members already viewed the message can be received through getMessageViewers.
  late bool can_get_viewers;

  /// True, if media timestamp links can be generated for media timestamp entities in the message text, caption or web page description through getMessageLink.
  late bool can_get_media_timestamp_links;

  /// True, if reactions on the message can be reported through reportMessageReactions.
  late bool can_report_reactions;

  /// True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message.
  late bool has_timestamped_media;

  /// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts.
  late bool is_channel_post;

  /// True, if the message is a forum topic message.
  late bool is_topic_message;

  /// True, if the message contains an unread mention for the current user.
  late bool contains_unread_mention;

  /// Point in time (Unix timestamp) when the message was sent.
  late int date;

  /// Point in time (Unix timestamp) when the message was last edited.
  late int edit_date;

  /// Information about the initial message sender; may be null if none or unknown.
  MessageForwardInfo? forward_info;

  /// Information about interactions with the message; may be null if none.
  MessageInteractionInfo? interaction_info;

  /// Information about unread reactions added to the message.
  late List<UnreadReaction> unread_reactions;

  /// Information about the message or the story this message is replying to; may be null if none.
  MessageReplyTo? reply_to;

  /// If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs.
  late int message_thread_id;

  /// The message's self-destruct type; may be null if none.
  MessageSelfDestructType? self_destruct_type;

  /// Time left before the message self-destruct timer expires, in seconds; 0 if self-desctruction isn't scheduled yet.
  late double self_destruct_in;

  /// Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never.
  late double auto_delete_in;

  /// If non-zero, the user identifier of the bot through which this message was sent.
  late int via_bot_user_id;

  /// For channel posts and anonymous group messages, optional author signature.
  late String author_signature;

  /// Unique identifier of an album this message belongs to. Only audios, documents, photos and videos can be grouped together in albums.
  /// ; string representation of int, use `int.parse`
  late int64 media_album_id;

  /// If non-empty, contains a human-readable description of the reason why access to this message must be restricted.
  late String restriction_reason;

  /// Content of the message.
  late MessageContent content;

  /// Reply markup for the message; may be null if none.
  ReplyMarkup? reply_markup;

  /// Describes a message
  Message(
      {required this.id,
      required this.sender_id,
      required this.chat_id,
      this.sending_state,
      this.scheduling_state,
      required this.is_outgoing,
      required this.is_pinned,
      required this.can_be_edited,
      required this.can_be_forwarded,
      required this.can_be_saved,
      required this.can_be_deleted_only_for_self,
      required this.can_be_deleted_for_all_users,
      required this.can_get_added_reactions,
      required this.can_get_statistics,
      required this.can_get_message_thread,
      required this.can_get_viewers,
      required this.can_get_media_timestamp_links,
      required this.can_report_reactions,
      required this.has_timestamped_media,
      required this.is_channel_post,
      required this.is_topic_message,
      required this.contains_unread_mention,
      required this.date,
      required this.edit_date,
      this.forward_info,
      this.interaction_info,
      required this.unread_reactions,
      this.reply_to,
      required this.message_thread_id,
      this.self_destruct_type,
      required this.self_destruct_in,
      required this.auto_delete_in,
      required this.via_bot_user_id,
      required this.author_signature,
      required this.media_album_id,
      required this.restriction_reason,
      required this.content,
      this.reply_markup,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'message',
      if (extra != null) '@extra': extra,
      'id': id,
      'sender_id': sender_id,
      'chat_id': chat_id,
      'sending_state': sending_state,
      'scheduling_state': scheduling_state,
      'is_outgoing': is_outgoing,
      'is_pinned': is_pinned,
      'can_be_edited': can_be_edited,
      'can_be_forwarded': can_be_forwarded,
      'can_be_saved': can_be_saved,
      'can_be_deleted_only_for_self': can_be_deleted_only_for_self,
      'can_be_deleted_for_all_users': can_be_deleted_for_all_users,
      'can_get_added_reactions': can_get_added_reactions,
      'can_get_statistics': can_get_statistics,
      'can_get_message_thread': can_get_message_thread,
      'can_get_viewers': can_get_viewers,
      'can_get_media_timestamp_links': can_get_media_timestamp_links,
      'can_report_reactions': can_report_reactions,
      'has_timestamped_media': has_timestamped_media,
      'is_channel_post': is_channel_post,
      'is_topic_message': is_topic_message,
      'contains_unread_mention': contains_unread_mention,
      'date': date,
      'edit_date': edit_date,
      'forward_info': forward_info,
      'interaction_info': interaction_info,
      'unread_reactions': unread_reactions,
      'reply_to': reply_to,
      'message_thread_id': message_thread_id,
      'self_destruct_type': self_destruct_type,
      'self_destruct_in': self_destruct_in,
      'auto_delete_in': auto_delete_in,
      'via_bot_user_id': via_bot_user_id,
      'author_signature': author_signature,
      'media_album_id': media_album_id,
      'restriction_reason': restriction_reason,
      'content': content,
      'reply_markup': reply_markup
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Message? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var sender_id = MessageSender.fromMap(_map['sender_id'])!;
    var chat_id = _map['chat_id']! as int;
    var sending_state = MessageSendingState.fromMap(_map['sending_state']);
    var scheduling_state =
        MessageSchedulingState.fromMap(_map['scheduling_state']);
    var is_outgoing = _map['is_outgoing']! as bool;
    var is_pinned = _map['is_pinned']! as bool;
    var can_be_edited = _map['can_be_edited']! as bool;
    var can_be_forwarded = _map['can_be_forwarded']! as bool;
    var can_be_saved = _map['can_be_saved']! as bool;
    var can_be_deleted_only_for_self =
        _map['can_be_deleted_only_for_self']! as bool;
    var can_be_deleted_for_all_users =
        _map['can_be_deleted_for_all_users']! as bool;
    var can_get_added_reactions = _map['can_get_added_reactions']! as bool;
    var can_get_statistics = _map['can_get_statistics']! as bool;
    var can_get_message_thread = _map['can_get_message_thread']! as bool;
    var can_get_viewers = _map['can_get_viewers']! as bool;
    var can_get_media_timestamp_links =
        _map['can_get_media_timestamp_links']! as bool;
    var can_report_reactions = _map['can_report_reactions']! as bool;
    var has_timestamped_media = _map['has_timestamped_media']! as bool;
    var is_channel_post = _map['is_channel_post']! as bool;
    var is_topic_message = _map['is_topic_message']! as bool;
    var contains_unread_mention = _map['contains_unread_mention']! as bool;
    var date = _map['date']! as int;
    var edit_date = _map['edit_date']! as int;
    var forward_info = MessageForwardInfo.fromMap(_map['forward_info']);
    var interaction_info =
        MessageInteractionInfo.fromMap(_map['interaction_info']);
    var unread_reactions = List<UnreadReaction>.from(
      (_map["unread_reactions"] ?? []).map(
        (e) => UnreadReaction.fromMap(e),
      ),
    );
    var reply_to = MessageReplyTo.fromMap(_map['reply_to']);
    var message_thread_id = _map['message_thread_id']! as int;
    var self_destruct_type =
        MessageSelfDestructType.fromMap(_map['self_destruct_type']);
    var self_destruct_in = _map['self_destruct_in']! as double;
    var auto_delete_in = _map['auto_delete_in']! as double;
    var via_bot_user_id = _map['via_bot_user_id']! as int;
    var author_signature = _map['author_signature']! as String;
    var media_album_id = _map['media_album_id']! as int64;
    var restriction_reason = _map['restriction_reason']! as String;
    var content = MessageContent.fromMap(_map['content'])!;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    return Message(
      extra: extra,
      clientId: clientId,
      id: id,
      sender_id: sender_id,
      chat_id: chat_id,
      sending_state: sending_state,
      scheduling_state: scheduling_state,
      is_outgoing: is_outgoing,
      is_pinned: is_pinned,
      can_be_edited: can_be_edited,
      can_be_forwarded: can_be_forwarded,
      can_be_saved: can_be_saved,
      can_be_deleted_only_for_self: can_be_deleted_only_for_self,
      can_be_deleted_for_all_users: can_be_deleted_for_all_users,
      can_get_added_reactions: can_get_added_reactions,
      can_get_statistics: can_get_statistics,
      can_get_message_thread: can_get_message_thread,
      can_get_viewers: can_get_viewers,
      can_get_media_timestamp_links: can_get_media_timestamp_links,
      can_report_reactions: can_report_reactions,
      has_timestamped_media: has_timestamped_media,
      is_channel_post: is_channel_post,
      is_topic_message: is_topic_message,
      contains_unread_mention: contains_unread_mention,
      date: date,
      edit_date: edit_date,
      forward_info: forward_info,
      interaction_info: interaction_info,
      unread_reactions: unread_reactions,
      reply_to: reply_to,
      message_thread_id: message_thread_id,
      self_destruct_type: self_destruct_type,
      self_destruct_in: self_destruct_in,
      auto_delete_in: auto_delete_in,
      via_bot_user_id: via_bot_user_id,
      author_signature: author_signature,
      media_album_id: media_album_id,
      restriction_reason: restriction_reason,
      content: content,
      reply_markup: reply_markup,
    );
  }
}

/// Contains a list of messages.
///
class Messages extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messages";

  /// Approximate total number of messages found.
  late int total_count;

  /// List of messages; messages may be null.
  List<Message>? messages;

  /// Contains a list of messages
  Messages(
      {required this.total_count, this.messages, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messages',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'messages': messages
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Messages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var messages = _map["{name}"] == null
        ? null
        : List<Message>.from(
            (_map["messages"] ?? []).map(
              (e) => Message.fromMap(e),
            ),
          );
    return Messages(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      messages: messages,
    );
  }
}

/// Contains a list of messages found by a search.
///
class FoundMessages extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "foundMessages";

  /// Approximate total number of messages found; -1 if unknown.
  late int total_count;

  /// List of messages.
  late List<Message> messages;

  /// The offset for the next request. If empty, there are no more results.
  String? next_offset;

  /// Contains a list of messages found by a search
  FoundMessages(
      {required this.total_count,
      required this.messages,
      this.next_offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'foundMessages',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'messages': messages,
      'next_offset': next_offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FoundMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var messages = List<Message>.from(
      (_map["messages"] ?? []).map(
        (e) => Message.fromMap(e),
      ),
    );
    var next_offset = _map['next_offset'] as String?;
    return FoundMessages(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      messages: messages,
      next_offset: next_offset,
    );
  }
}

/// Contains a list of messages found by a search in a given chat.
///
class FoundChatMessages extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "foundChatMessages";

  /// Approximate total number of messages found; -1 if unknown.
  late int total_count;

  /// List of messages.
  late List<Message> messages;

  /// The offset for the next request. If 0, there are no more results.
  late int next_from_message_id;

  /// Contains a list of messages found by a search in a given chat
  FoundChatMessages(
      {required this.total_count,
      required this.messages,
      required this.next_from_message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'foundChatMessages',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'messages': messages,
      'next_from_message_id': next_from_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FoundChatMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var messages = List<Message>.from(
      (_map["messages"] ?? []).map(
        (e) => Message.fromMap(e),
      ),
    );
    var next_from_message_id = _map['next_from_message_id']! as int;
    return FoundChatMessages(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      messages: messages,
      next_from_message_id: next_from_message_id,
    );
  }
}

/// Contains information about a message in a specific position.
///
class MessagePosition extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messagePosition";

  /// 0-based message position in the full list of suitable messages.
  late int position;

  /// Message identifier.
  late int message_id;

  /// Point in time (Unix timestamp) when the message was sent.
  late int date;

  /// Contains information about a message in a specific position
  MessagePosition(
      {required this.position,
      required this.message_id,
      required this.date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messagePosition',
      if (extra != null) '@extra': extra,
      'position': position,
      'message_id': message_id,
      'date': date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessagePosition? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var position = _map['position']! as int;
    var message_id = _map['message_id']! as int;
    var date = _map['date']! as int;
    return MessagePosition(
      extra: extra,
      clientId: clientId,
      position: position,
      message_id: message_id,
      date: date,
    );
  }
}

/// Contains a list of message positions.
///
class MessagePositions extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messagePositions";

  /// Total number of messages found.
  late int total_count;

  /// List of message positions.
  late List<MessagePosition> positions;

  /// Contains a list of message positions
  MessagePositions(
      {required this.total_count,
      required this.positions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messagePositions',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'positions': positions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessagePositions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var positions = List<MessagePosition>.from(
      (_map["positions"] ?? []).map(
        (e) => MessagePosition.fromMap(e),
      ),
    );
    return MessagePositions(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      positions: positions,
    );
  }
}

/// Contains information about found messages sent on a specific day.
///
class MessageCalendarDay extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageCalendarDay";

  /// Total number of found messages sent on the day.
  late int total_count;

  /// First message sent on the day.
  late Message message;

  /// Contains information about found messages sent on a specific day
  MessageCalendarDay(
      {required this.total_count,
      required this.message,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageCalendarDay',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'message': message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageCalendarDay? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var message = Message.fromMap(_map['message'])!;
    return MessageCalendarDay(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      message: message,
    );
  }
}

/// Contains information about found messages, split by days according to the option "utc_time_offset".
///
class MessageCalendar extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageCalendar";

  /// Total number of found messages.
  late int total_count;

  /// Information about messages sent.
  late List<MessageCalendarDay> days;

  /// Contains information about found messages, split by days according to the option "utc_time_offset"
  MessageCalendar(
      {required this.total_count,
      required this.days,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageCalendar',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'days': days
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageCalendar? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var days = List<MessageCalendarDay>.from(
      (_map["days"] ?? []).map(
        (e) => MessageCalendarDay.fromMap(e),
      ),
    );
    return MessageCalendar(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      days: days,
    );
  }
}

/// The message is from a chat history.
///
class MessageSourceChatHistory extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceChatHistory";

  /// The message is from a chat history
  MessageSourceChatHistory({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSourceChatHistory',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceChatHistory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceChatHistory(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message is from a message thread history.
///
class MessageSourceMessageThreadHistory extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceMessageThreadHistory";

  /// The message is from a message thread history
  MessageSourceMessageThreadHistory({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSourceMessageThreadHistory',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceMessageThreadHistory? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceMessageThreadHistory(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message is from a forum topic history.
///
class MessageSourceForumTopicHistory extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceForumTopicHistory";

  /// The message is from a forum topic history
  MessageSourceForumTopicHistory({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSourceForumTopicHistory',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceForumTopicHistory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceForumTopicHistory(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message is from chat, message thread or forum topic history preview.
///
class MessageSourceHistoryPreview extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceHistoryPreview";

  /// The message is from chat, message thread or forum topic history preview
  MessageSourceHistoryPreview({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSourceHistoryPreview',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceHistoryPreview? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceHistoryPreview(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message is from a chat list or a forum topic list.
///
class MessageSourceChatList extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceChatList";

  /// The message is from a chat list or a forum topic list
  MessageSourceChatList({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSourceChatList',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceChatList? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceChatList(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message is from search results, including file downloads, local file list, outgoing document messages, calendar.
///
class MessageSourceSearch extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceSearch";

  /// The message is from search results, including file downloads, local file list, outgoing document messages, calendar
  MessageSourceSearch({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'messageSourceSearch', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceSearch? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceSearch(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message is from a chat event log.
///
class MessageSourceChatEventLog extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceChatEventLog";

  /// The message is from a chat event log
  MessageSourceChatEventLog({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSourceChatEventLog',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceChatEventLog? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceChatEventLog(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message is from a notification.
///
class MessageSourceNotification extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceNotification";

  /// The message is from a notification
  MessageSourceNotification({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSourceNotification',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceNotification? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceNotification(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message was screenshotted; the source must be used only if the message content was visible during the screenshot.
///
class MessageSourceScreenshot extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceScreenshot";

  /// The message was screenshotted; the source must be used only if the message content was visible during the screenshot
  MessageSourceScreenshot({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSourceScreenshot',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceScreenshot? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceScreenshot(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message is from some other source.
///
class MessageSourceOther extends MessageSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSourceOther";

  /// The message is from some other source
  MessageSourceOther({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'messageSourceOther', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSourceOther? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSourceOther(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The sponsor is a bot.
///
class MessageSponsorTypeBot extends MessageSponsorType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSponsorTypeBot";

  /// User identifier of the bot.
  late int bot_user_id;

  /// An internal link to be opened when the sponsored message is clicked.
  late InternalLinkType link;

  /// The sponsor is a bot
  MessageSponsorTypeBot(
      {required this.bot_user_id,
      required this.link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSponsorTypeBot',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'link': link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSponsorTypeBot? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var link = InternalLinkType.fromMap(_map['link'])!;
    return MessageSponsorTypeBot(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      link: link,
    );
  }
}

/// The sponsor is a public channel chat.
///
class MessageSponsorTypePublicChannel extends MessageSponsorType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSponsorTypePublicChannel";

  /// Sponsor chat identifier.
  late int chat_id;

  /// An internal link to be opened when the sponsored message is clicked; may be null if the sponsor chat needs to be opened instead.
  InternalLinkType? link;

  /// The sponsor is a public channel chat
  MessageSponsorTypePublicChannel(
      {required this.chat_id, this.link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSponsorTypePublicChannel',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'link': link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSponsorTypePublicChannel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var link = InternalLinkType.fromMap(_map['link']);
    return MessageSponsorTypePublicChannel(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      link: link,
    );
  }
}

/// The sponsor is a private channel chat.
///
class MessageSponsorTypePrivateChannel extends MessageSponsorType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSponsorTypePrivateChannel";

  /// Title of the chat.
  late String title;

  /// Invite link for the channel.
  late String invite_link;

  /// The sponsor is a private channel chat
  MessageSponsorTypePrivateChannel(
      {required this.title,
      required this.invite_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSponsorTypePrivateChannel',
      if (extra != null) '@extra': extra,
      'title': title,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSponsorTypePrivateChannel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var invite_link = _map['invite_link']! as String;
    return MessageSponsorTypePrivateChannel(
      extra: extra,
      clientId: clientId,
      title: title,
      invite_link: invite_link,
    );
  }
}

/// The sponsor is a website.
///
class MessageSponsorTypeWebsite extends MessageSponsorType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSponsorTypeWebsite";

  /// URL of the website.
  late String url;

  /// Name of the website.
  late String name;

  /// The sponsor is a website
  MessageSponsorTypeWebsite(
      {required this.url, required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSponsorTypeWebsite',
      if (extra != null) '@extra': extra,
      'url': url,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSponsorTypeWebsite? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var name = _map['name']! as String;
    return MessageSponsorTypeWebsite(
      extra: extra,
      clientId: clientId,
      url: url,
      name: name,
    );
  }
}

/// Information about the sponsor of a message.
///
class MessageSponsor extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSponsor";

  /// Type of the sponsor.
  late MessageSponsorType type;

  /// Photo of the sponsor; may be null if must not be shown.
  ChatPhotoInfo? photo;

  /// Additional optional information about the sponsor to be shown along with the message.
  late String info;

  /// Information about the sponsor of a message
  MessageSponsor(
      {required this.type,
      this.photo,
      required this.info,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSponsor',
      if (extra != null) '@extra': extra,
      'type': type,
      'photo': photo,
      'info': info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSponsor? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = MessageSponsorType.fromMap(_map['type'])!;
    var photo = ChatPhotoInfo.fromMap(_map['photo']);
    var info = _map['info']! as String;
    return MessageSponsor(
      extra: extra,
      clientId: clientId,
      type: type,
      photo: photo,
      info: info,
    );
  }
}

/// Describes a sponsored message.
///
class SponsoredMessage extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sponsoredMessage";

  /// Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages.
  late int message_id;

  /// True, if the message needs to be labeled as "recommended" instead of "sponsored".
  late bool is_recommended;

  /// Content of the message. Currently, can be only of the type messageText.
  late MessageContent content;

  /// Information about the sponsor of the message.
  late MessageSponsor sponsor;

  /// If non-empty, additional information about the sponsored message to be shown along with the message.
  late String additional_info;

  /// Describes a sponsored message
  SponsoredMessage(
      {required this.message_id,
      required this.is_recommended,
      required this.content,
      required this.sponsor,
      required this.additional_info,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sponsoredMessage',
      if (extra != null) '@extra': extra,
      'message_id': message_id,
      'is_recommended': is_recommended,
      'content': content,
      'sponsor': sponsor,
      'additional_info': additional_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SponsoredMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_id = _map['message_id']! as int;
    var is_recommended = _map['is_recommended']! as bool;
    var content = MessageContent.fromMap(_map['content'])!;
    var sponsor = MessageSponsor.fromMap(_map['sponsor'])!;
    var additional_info = _map['additional_info']! as String;
    return SponsoredMessage(
      extra: extra,
      clientId: clientId,
      message_id: message_id,
      is_recommended: is_recommended,
      content: content,
      sponsor: sponsor,
      additional_info: additional_info,
    );
  }
}

/// Contains a list of sponsored messages.
///
class SponsoredMessages extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sponsoredMessages";

  /// List of sponsored messages.
  late List<SponsoredMessage> messages;

  /// The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages.
  late int messages_between;

  /// Contains a list of sponsored messages
  SponsoredMessages(
      {required this.messages,
      required this.messages_between,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sponsoredMessages',
      if (extra != null) '@extra': extra,
      'messages': messages,
      'messages_between': messages_between
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SponsoredMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var messages = List<SponsoredMessage>.from(
      (_map["messages"] ?? []).map(
        (e) => SponsoredMessage.fromMap(e),
      ),
    );
    var messages_between = _map['messages_between']! as int;
    return SponsoredMessages(
      extra: extra,
      clientId: clientId,
      messages: messages,
      messages_between: messages_between,
    );
  }
}

/// Describes a file added to file download list.
///
class FileDownload extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileDownload";

  /// File identifier.
  late int file_id;

  /// The message with the file.
  late Message message;

  /// Point in time (Unix timestamp) when the file was added to the download list.
  late int add_date;

  /// Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed.
  late int complete_date;

  /// True, if downloading of the file is paused.
  late bool is_paused;

  /// Describes a file added to file download list
  FileDownload(
      {required this.file_id,
      required this.message,
      required this.add_date,
      required this.complete_date,
      required this.is_paused,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'fileDownload',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'message': message,
      'add_date': add_date,
      'complete_date': complete_date,
      'is_paused': is_paused
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileDownload? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var message = Message.fromMap(_map['message'])!;
    var add_date = _map['add_date']! as int;
    var complete_date = _map['complete_date']! as int;
    var is_paused = _map['is_paused']! as bool;
    return FileDownload(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      message: message,
      add_date: add_date,
      complete_date: complete_date,
      is_paused: is_paused,
    );
  }
}

/// Contains number of being downloaded and recently downloaded files found.
///
class DownloadedFileCounts extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "downloadedFileCounts";

  /// Number of active file downloads found, including paused.
  late int active_count;

  /// Number of paused file downloads found.
  late int paused_count;

  /// Number of completed file downloads found.
  late int completed_count;

  /// Contains number of being downloaded and recently downloaded files found
  DownloadedFileCounts(
      {required this.active_count,
      required this.paused_count,
      required this.completed_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'downloadedFileCounts',
      if (extra != null) '@extra': extra,
      'active_count': active_count,
      'paused_count': paused_count,
      'completed_count': completed_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DownloadedFileCounts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var active_count = _map['active_count']! as int;
    var paused_count = _map['paused_count']! as int;
    var completed_count = _map['completed_count']! as int;
    return DownloadedFileCounts(
      extra: extra,
      clientId: clientId,
      active_count: active_count,
      paused_count: paused_count,
      completed_count: completed_count,
    );
  }
}

/// Contains a list of downloaded files, found by a search.
///
class FoundFileDownloads extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "foundFileDownloads";

  /// Total number of suitable files, ignoring offset.
  late DownloadedFileCounts total_counts;

  /// The list of files.
  late List<FileDownload> files;

  /// The offset for the next request. If empty, there are no more results.
  String? next_offset;

  /// Contains a list of downloaded files, found by a search
  FoundFileDownloads(
      {required this.total_counts,
      required this.files,
      this.next_offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'foundFileDownloads',
      if (extra != null) '@extra': extra,
      'total_counts': total_counts,
      'files': files,
      'next_offset': next_offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FoundFileDownloads? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_counts = DownloadedFileCounts.fromMap(_map['total_counts'])!;
    var files = List<FileDownload>.from(
      (_map["files"] ?? []).map(
        (e) => FileDownload.fromMap(e),
      ),
    );
    var next_offset = _map['next_offset'] as String?;
    return FoundFileDownloads(
      extra: extra,
      clientId: clientId,
      total_counts: total_counts,
      files: files,
      next_offset: next_offset,
    );
  }
}

/// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value.
///
class NotificationSettingsScopePrivateChats extends NotificationSettingsScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationSettingsScopePrivateChats";

  /// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
  NotificationSettingsScopePrivateChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationSettingsScopePrivateChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationSettingsScopePrivateChats? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NotificationSettingsScopePrivateChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value.
///
class NotificationSettingsScopeGroupChats extends NotificationSettingsScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationSettingsScopeGroupChats";

  /// Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value
  NotificationSettingsScopeGroupChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationSettingsScopeGroupChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationSettingsScopeGroupChats? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NotificationSettingsScopeGroupChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Notification settings applied to all channel chats when the corresponding chat setting has a default value.
///
class NotificationSettingsScopeChannelChats extends NotificationSettingsScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationSettingsScopeChannelChats";

  /// Notification settings applied to all channel chats when the corresponding chat setting has a default value
  NotificationSettingsScopeChannelChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationSettingsScopeChannelChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationSettingsScopeChannelChats? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NotificationSettingsScopeChannelChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains information about notification settings for a chat or a forum topic.
///
class ChatNotificationSettings extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatNotificationSettings";

  /// If true, mute_for is ignored and the value for the relevant type of chat or the forum chat is used instead.
  late bool use_default_mute_for;

  /// Time left before notifications will be unmuted, in seconds.
  late int mute_for;

  /// If true, the value for the relevant type of chat or the forum chat is used instead of sound_id.
  late bool use_default_sound;

  /// Identifier of the notification sound to be played for messages; 0 if sound is disabled.
  /// ; string representation of int, use `int.parse`
  late int64 sound_id;

  /// If true, show_preview is ignored and the value for the relevant type of chat or the forum chat is used instead.
  late bool use_default_show_preview;

  /// True, if message content must be displayed in notifications.
  late bool show_preview;

  /// If true, mute_stories is ignored and the value for the relevant type of chat is used instead.
  late bool use_default_mute_stories;

  /// True, if story notifications are disabled for the chat.
  late bool mute_stories;

  /// If true, the value for the relevant type of chat is used instead of story_sound_id.
  late bool use_default_story_sound;

  /// Identifier of the notification sound to be played for stories; 0 if sound is disabled.
  /// ; string representation of int, use `int.parse`
  late int64 story_sound_id;

  /// If true, show_story_sender is ignored and the value for the relevant type of chat is used instead.
  late bool use_default_show_story_sender;

  /// True, if the sender of stories must be displayed in notifications.
  late bool show_story_sender;

  /// If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat or the forum chat is used instead.
  late bool use_default_disable_pinned_message_notifications;

  /// If true, notifications for incoming pinned messages will be created as for an ordinary unread message.
  late bool disable_pinned_message_notifications;

  /// If true, disable_mention_notifications is ignored and the value for the relevant type of chat or the forum chat is used instead.
  late bool use_default_disable_mention_notifications;

  /// If true, notifications for messages with mentions will be created as for an ordinary unread message.
  late bool disable_mention_notifications;

  /// Contains information about notification settings for a chat or a forum topic
  ChatNotificationSettings(
      {required this.use_default_mute_for,
      required this.mute_for,
      required this.use_default_sound,
      required this.sound_id,
      required this.use_default_show_preview,
      required this.show_preview,
      required this.use_default_mute_stories,
      required this.mute_stories,
      required this.use_default_story_sound,
      required this.story_sound_id,
      required this.use_default_show_story_sender,
      required this.show_story_sender,
      required this.use_default_disable_pinned_message_notifications,
      required this.disable_pinned_message_notifications,
      required this.use_default_disable_mention_notifications,
      required this.disable_mention_notifications,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatNotificationSettings',
      if (extra != null) '@extra': extra,
      'use_default_mute_for': use_default_mute_for,
      'mute_for': mute_for,
      'use_default_sound': use_default_sound,
      'sound_id': sound_id,
      'use_default_show_preview': use_default_show_preview,
      'show_preview': show_preview,
      'use_default_mute_stories': use_default_mute_stories,
      'mute_stories': mute_stories,
      'use_default_story_sound': use_default_story_sound,
      'story_sound_id': story_sound_id,
      'use_default_show_story_sender': use_default_show_story_sender,
      'show_story_sender': show_story_sender,
      'use_default_disable_pinned_message_notifications':
          use_default_disable_pinned_message_notifications,
      'disable_pinned_message_notifications':
          disable_pinned_message_notifications,
      'use_default_disable_mention_notifications':
          use_default_disable_mention_notifications,
      'disable_mention_notifications': disable_mention_notifications
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatNotificationSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var use_default_mute_for = _map['use_default_mute_for']! as bool;
    var mute_for = _map['mute_for']! as int;
    var use_default_sound = _map['use_default_sound']! as bool;
    var sound_id = _map['sound_id']! as int64;
    var use_default_show_preview = _map['use_default_show_preview']! as bool;
    var show_preview = _map['show_preview']! as bool;
    var use_default_mute_stories = _map['use_default_mute_stories']! as bool;
    var mute_stories = _map['mute_stories']! as bool;
    var use_default_story_sound = _map['use_default_story_sound']! as bool;
    var story_sound_id = _map['story_sound_id']! as int64;
    var use_default_show_story_sender =
        _map['use_default_show_story_sender']! as bool;
    var show_story_sender = _map['show_story_sender']! as bool;
    var use_default_disable_pinned_message_notifications =
        _map['use_default_disable_pinned_message_notifications']! as bool;
    var disable_pinned_message_notifications =
        _map['disable_pinned_message_notifications']! as bool;
    var use_default_disable_mention_notifications =
        _map['use_default_disable_mention_notifications']! as bool;
    var disable_mention_notifications =
        _map['disable_mention_notifications']! as bool;
    return ChatNotificationSettings(
      extra: extra,
      clientId: clientId,
      use_default_mute_for: use_default_mute_for,
      mute_for: mute_for,
      use_default_sound: use_default_sound,
      sound_id: sound_id,
      use_default_show_preview: use_default_show_preview,
      show_preview: show_preview,
      use_default_mute_stories: use_default_mute_stories,
      mute_stories: mute_stories,
      use_default_story_sound: use_default_story_sound,
      story_sound_id: story_sound_id,
      use_default_show_story_sender: use_default_show_story_sender,
      show_story_sender: show_story_sender,
      use_default_disable_pinned_message_notifications:
          use_default_disable_pinned_message_notifications,
      disable_pinned_message_notifications:
          disable_pinned_message_notifications,
      use_default_disable_mention_notifications:
          use_default_disable_mention_notifications,
      disable_mention_notifications: disable_mention_notifications,
    );
  }
}

/// Contains information about notification settings for several chats.
///
class ScopeNotificationSettings extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "scopeNotificationSettings";

  /// Time left before notifications will be unmuted, in seconds.
  late int mute_for;

  /// Identifier of the notification sound to be played; 0 if sound is disabled.
  /// ; string representation of int, use `int.parse`
  late int64 sound_id;

  /// True, if message content must be displayed in notifications.
  late bool show_preview;

  /// If true, mute_stories is ignored and story notifications are received only for the first 5 chats from topChatCategoryUsers.
  late bool use_default_mute_stories;

  /// True, if story notifications are disabled for the chat.
  late bool mute_stories;

  /// Identifier of the notification sound to be played for stories; 0 if sound is disabled.
  /// ; string representation of int, use `int.parse`
  late int64 story_sound_id;

  /// True, if the sender of stories must be displayed in notifications.
  late bool show_story_sender;

  /// True, if notifications for incoming pinned messages will be created as for an ordinary unread message.
  late bool disable_pinned_message_notifications;

  /// True, if notifications for messages with mentions will be created as for an ordinary unread message.
  late bool disable_mention_notifications;

  /// Contains information about notification settings for several chats
  ScopeNotificationSettings(
      {required this.mute_for,
      required this.sound_id,
      required this.show_preview,
      required this.use_default_mute_stories,
      required this.mute_stories,
      required this.story_sound_id,
      required this.show_story_sender,
      required this.disable_pinned_message_notifications,
      required this.disable_mention_notifications,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'scopeNotificationSettings',
      if (extra != null) '@extra': extra,
      'mute_for': mute_for,
      'sound_id': sound_id,
      'show_preview': show_preview,
      'use_default_mute_stories': use_default_mute_stories,
      'mute_stories': mute_stories,
      'story_sound_id': story_sound_id,
      'show_story_sender': show_story_sender,
      'disable_pinned_message_notifications':
          disable_pinned_message_notifications,
      'disable_mention_notifications': disable_mention_notifications
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ScopeNotificationSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var mute_for = _map['mute_for']! as int;
    var sound_id = _map['sound_id']! as int64;
    var show_preview = _map['show_preview']! as bool;
    var use_default_mute_stories = _map['use_default_mute_stories']! as bool;
    var mute_stories = _map['mute_stories']! as bool;
    var story_sound_id = _map['story_sound_id']! as int64;
    var show_story_sender = _map['show_story_sender']! as bool;
    var disable_pinned_message_notifications =
        _map['disable_pinned_message_notifications']! as bool;
    var disable_mention_notifications =
        _map['disable_mention_notifications']! as bool;
    return ScopeNotificationSettings(
      extra: extra,
      clientId: clientId,
      mute_for: mute_for,
      sound_id: sound_id,
      show_preview: show_preview,
      use_default_mute_stories: use_default_mute_stories,
      mute_stories: mute_stories,
      story_sound_id: story_sound_id,
      show_story_sender: show_story_sender,
      disable_pinned_message_notifications:
          disable_pinned_message_notifications,
      disable_mention_notifications: disable_mention_notifications,
    );
  }
}

/// Contains information about a message draft.
///
class DraftMessage extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "draftMessage";

  /// Identifier of the replied message; 0 if none.
  late int reply_to_message_id;

  /// Point in time (Unix timestamp) when the draft was created.
  late int date;

  /// Content of the message draft; must be of the type inputMessageText.
  late InputMessageContent input_message_text;

  /// Contains information about a message draft
  DraftMessage(
      {required this.reply_to_message_id,
      required this.date,
      required this.input_message_text,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'draftMessage',
      if (extra != null) '@extra': extra,
      'reply_to_message_id': reply_to_message_id,
      'date': date,
      'input_message_text': input_message_text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DraftMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reply_to_message_id = _map['reply_to_message_id']! as int;
    var date = _map['date']! as int;
    var input_message_text =
        InputMessageContent.fromMap(_map['input_message_text'])!;
    return DraftMessage(
      extra: extra,
      clientId: clientId,
      reply_to_message_id: reply_to_message_id,
      date: date,
      input_message_text: input_message_text,
    );
  }
}

/// An ordinary chat with a user.
///
class ChatTypePrivate extends ChatType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatTypePrivate";

  /// User identifier.
  late int user_id;

  /// An ordinary chat with a user
  ChatTypePrivate({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatTypePrivate',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatTypePrivate? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return ChatTypePrivate(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// A basic group (a chat with 0-200 other users).
///
class ChatTypeBasicGroup extends ChatType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatTypeBasicGroup";

  /// Basic group identifier.
  late int basic_group_id;

  /// A basic group (a chat with 0-200 other users)
  ChatTypeBasicGroup({required this.basic_group_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatTypeBasicGroup',
      if (extra != null) '@extra': extra,
      'basic_group_id': basic_group_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatTypeBasicGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var basic_group_id = _map['basic_group_id']! as int;
    return ChatTypeBasicGroup(
      extra: extra,
      clientId: clientId,
      basic_group_id: basic_group_id,
    );
  }
}

/// A supergroup or channel (with unlimited members).
///
class ChatTypeSupergroup extends ChatType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatTypeSupergroup";

  /// Supergroup or channel identifier.
  late int supergroup_id;

  /// True, if the supergroup is a channel.
  late bool is_channel;

  /// A supergroup or channel (with unlimited members)
  ChatTypeSupergroup(
      {required this.supergroup_id,
      required this.is_channel,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatTypeSupergroup',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'is_channel': is_channel
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatTypeSupergroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var is_channel = _map['is_channel']! as bool;
    return ChatTypeSupergroup(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      is_channel: is_channel,
    );
  }
}

/// A secret chat with a user.
///
class ChatTypeSecret extends ChatType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatTypeSecret";

  /// Secret chat identifier.
  late int secret_chat_id;

  /// User identifier of the secret chat peer.
  late int user_id;

  /// A secret chat with a user
  ChatTypeSecret(
      {required this.secret_chat_id,
      required this.user_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatTypeSecret',
      if (extra != null) '@extra': extra,
      'secret_chat_id': secret_chat_id,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatTypeSecret? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var secret_chat_id = _map['secret_chat_id']! as int;
    var user_id = _map['user_id']! as int;
    return ChatTypeSecret(
      extra: extra,
      clientId: clientId,
      secret_chat_id: secret_chat_id,
      user_id: user_id,
    );
  }
}

/// Represents an icon for a chat folder.
///
class ChatFolderIcon extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatFolderIcon";

  /// The chosen icon name for short folder representation; one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown",.
  late String name;

  /// Represents an icon for a chat folder
  ChatFolderIcon({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatFolderIcon',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatFolderIcon? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return ChatFolderIcon(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// Represents a folder for user chats.
///
class ChatFolder extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatFolder";

  /// The title of the folder; 1-12 characters without line feeds.
  late String title;

  /// The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName to get default icon name for the folder.
  ChatFolderIcon? icon;

  /// True, if at least one link has been created for the folder.
  late bool is_shareable;

  /// The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium.
  late List<int> pinned_chat_ids;

  /// The chat identifiers of always included chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium.
  late List<int> included_chat_ids;

  /// The chat identifiers of always excluded chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium.
  late List<int> excluded_chat_ids;

  /// True, if muted chats need to be excluded.
  late bool exclude_muted;

  /// True, if read chats need to be excluded.
  late bool exclude_read;

  /// True, if archived chats need to be excluded.
  late bool exclude_archived;

  /// True, if contacts need to be included.
  late bool include_contacts;

  /// True, if non-contact users need to be included.
  late bool include_non_contacts;

  /// True, if bots need to be included.
  late bool include_bots;

  /// True, if basic groups and supergroups need to be included.
  late bool include_groups;

  /// True, if channels need to be included.
  late bool include_channels;

  /// Represents a folder for user chats
  ChatFolder(
      {required this.title,
      this.icon,
      required this.is_shareable,
      required this.pinned_chat_ids,
      required this.included_chat_ids,
      required this.excluded_chat_ids,
      required this.exclude_muted,
      required this.exclude_read,
      required this.exclude_archived,
      required this.include_contacts,
      required this.include_non_contacts,
      required this.include_bots,
      required this.include_groups,
      required this.include_channels,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatFolder',
      if (extra != null) '@extra': extra,
      'title': title,
      'icon': icon,
      'is_shareable': is_shareable,
      'pinned_chat_ids': pinned_chat_ids,
      'included_chat_ids': included_chat_ids,
      'excluded_chat_ids': excluded_chat_ids,
      'exclude_muted': exclude_muted,
      'exclude_read': exclude_read,
      'exclude_archived': exclude_archived,
      'include_contacts': include_contacts,
      'include_non_contacts': include_non_contacts,
      'include_bots': include_bots,
      'include_groups': include_groups,
      'include_channels': include_channels
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatFolder? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var icon = ChatFolderIcon.fromMap(_map['icon']);
    var is_shareable = _map['is_shareable']! as bool;
    var pinned_chat_ids = List<int>.from(
      (_map["pinned_chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var included_chat_ids = List<int>.from(
      (_map["included_chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var excluded_chat_ids = List<int>.from(
      (_map["excluded_chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var exclude_muted = _map['exclude_muted']! as bool;
    var exclude_read = _map['exclude_read']! as bool;
    var exclude_archived = _map['exclude_archived']! as bool;
    var include_contacts = _map['include_contacts']! as bool;
    var include_non_contacts = _map['include_non_contacts']! as bool;
    var include_bots = _map['include_bots']! as bool;
    var include_groups = _map['include_groups']! as bool;
    var include_channels = _map['include_channels']! as bool;
    return ChatFolder(
      extra: extra,
      clientId: clientId,
      title: title,
      icon: icon,
      is_shareable: is_shareable,
      pinned_chat_ids: pinned_chat_ids,
      included_chat_ids: included_chat_ids,
      excluded_chat_ids: excluded_chat_ids,
      exclude_muted: exclude_muted,
      exclude_read: exclude_read,
      exclude_archived: exclude_archived,
      include_contacts: include_contacts,
      include_non_contacts: include_non_contacts,
      include_bots: include_bots,
      include_groups: include_groups,
      include_channels: include_channels,
    );
  }
}

/// Contains basic information about a chat folder.
///
class ChatFolderInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatFolderInfo";

  /// Unique chat folder identifier.
  late int id;

  /// The title of the folder; 1-12 characters without line feeds.
  late String title;

  /// The chosen or default icon for the chat folder.
  late ChatFolderIcon icon;

  /// True, if at least one link has been created for the folder.
  late bool is_shareable;

  /// True, if the chat folder has invite links created by the current user.
  late bool has_my_invite_links;

  /// Contains basic information about a chat folder
  ChatFolderInfo(
      {required this.id,
      required this.title,
      required this.icon,
      required this.is_shareable,
      required this.has_my_invite_links,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatFolderInfo',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'icon': icon,
      'is_shareable': is_shareable,
      'has_my_invite_links': has_my_invite_links
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatFolderInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var title = _map['title']! as String;
    var icon = ChatFolderIcon.fromMap(_map['icon'])!;
    var is_shareable = _map['is_shareable']! as bool;
    var has_my_invite_links = _map['has_my_invite_links']! as bool;
    return ChatFolderInfo(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      icon: icon,
      is_shareable: is_shareable,
      has_my_invite_links: has_my_invite_links,
    );
  }
}

/// Contains a chat folder invite link.
///
class ChatFolderInviteLink extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatFolderInviteLink";

  /// The chat folder invite link.
  late String invite_link;

  /// Name of the link.
  late String name;

  /// Identifiers of chats, included in the link.
  late List<int> chat_ids;

  /// Contains a chat folder invite link
  ChatFolderInviteLink(
      {required this.invite_link,
      required this.name,
      required this.chat_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatFolderInviteLink',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link,
      'name': name,
      'chat_ids': chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatFolderInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = _map['invite_link']! as String;
    var name = _map['name']! as String;
    var chat_ids = List<int>.from(
      (_map["chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return ChatFolderInviteLink(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
      name: name,
      chat_ids: chat_ids,
    );
  }
}

/// Represents a list of chat folder invite links.
///
class ChatFolderInviteLinks extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatFolderInviteLinks";

  /// List of the invite links.
  late List<ChatFolderInviteLink> invite_links;

  /// Represents a list of chat folder invite links
  ChatFolderInviteLinks(
      {required this.invite_links, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatFolderInviteLinks',
      if (extra != null) '@extra': extra,
      'invite_links': invite_links
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatFolderInviteLinks? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_links = List<ChatFolderInviteLink>.from(
      (_map["invite_links"] ?? []).map(
        (e) => ChatFolderInviteLink.fromMap(e),
      ),
    );
    return ChatFolderInviteLinks(
      extra: extra,
      clientId: clientId,
      invite_links: invite_links,
    );
  }
}

/// Contains information about an invite link to a chat folder.
///
class ChatFolderInviteLinkInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatFolderInviteLinkInfo";

  /// Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet.
  late ChatFolderInfo chat_folder_info;

  /// Identifiers of the chats from the link, which aren't added to the folder yet.
  late List<int> missing_chat_ids;

  /// Identifiers of the chats from the link, which are added to the folder already.
  late List<int> added_chat_ids;

  /// Contains information about an invite link to a chat folder
  ChatFolderInviteLinkInfo(
      {required this.chat_folder_info,
      required this.missing_chat_ids,
      required this.added_chat_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatFolderInviteLinkInfo',
      if (extra != null) '@extra': extra,
      'chat_folder_info': chat_folder_info,
      'missing_chat_ids': missing_chat_ids,
      'added_chat_ids': added_chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatFolderInviteLinkInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_info = ChatFolderInfo.fromMap(_map['chat_folder_info'])!;
    var missing_chat_ids = List<int>.from(
      (_map["missing_chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var added_chat_ids = List<int>.from(
      (_map["added_chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return ChatFolderInviteLinkInfo(
      extra: extra,
      clientId: clientId,
      chat_folder_info: chat_folder_info,
      missing_chat_ids: missing_chat_ids,
      added_chat_ids: added_chat_ids,
    );
  }
}

/// Describes a recommended chat folder.
///
class RecommendedChatFolder extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "recommendedChatFolder";

  /// The chat folder.
  late ChatFolder folder;

  /// Chat folder description.
  late String description;

  /// Describes a recommended chat folder
  RecommendedChatFolder(
      {required this.folder,
      required this.description,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'recommendedChatFolder',
      if (extra != null) '@extra': extra,
      'folder': folder,
      'description': description
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RecommendedChatFolder? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var folder = ChatFolder.fromMap(_map['folder'])!;
    var description = _map['description']! as String;
    return RecommendedChatFolder(
      extra: extra,
      clientId: clientId,
      folder: folder,
      description: description,
    );
  }
}

/// Contains a list of recommended chat folders.
///
class RecommendedChatFolders extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "recommendedChatFolders";

  /// List of recommended chat folders.
  late List<RecommendedChatFolder> chat_folders;

  /// Contains a list of recommended chat folders
  RecommendedChatFolders(
      {required this.chat_folders, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'recommendedChatFolders',
      if (extra != null) '@extra': extra,
      'chat_folders': chat_folders
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RecommendedChatFolders? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folders = List<RecommendedChatFolder>.from(
      (_map["chat_folders"] ?? []).map(
        (e) => RecommendedChatFolder.fromMap(e),
      ),
    );
    return RecommendedChatFolders(
      extra: extra,
      clientId: clientId,
      chat_folders: chat_folders,
    );
  }
}

/// Contains settings for automatic moving of chats to and from the Archive chat lists.
///
class ArchiveChatListSettings extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "archiveChatListSettings";

  /// True, if new chats from non-contacts will be automatically archived and muted. Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users" is true.
  late bool archive_and_mute_new_chats_from_unknown_users;

  /// True, if unmuted chats will be kept in the Archive chat list when they get a new message.
  late bool keep_unmuted_chats_archived;

  /// True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived == true.
  late bool keep_chats_from_folders_archived;

  /// Contains settings for automatic moving of chats to and from the Archive chat lists
  ArchiveChatListSettings(
      {required this.archive_and_mute_new_chats_from_unknown_users,
      required this.keep_unmuted_chats_archived,
      required this.keep_chats_from_folders_archived,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'archiveChatListSettings',
      if (extra != null) '@extra': extra,
      'archive_and_mute_new_chats_from_unknown_users':
          archive_and_mute_new_chats_from_unknown_users,
      'keep_unmuted_chats_archived': keep_unmuted_chats_archived,
      'keep_chats_from_folders_archived': keep_chats_from_folders_archived
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ArchiveChatListSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var archive_and_mute_new_chats_from_unknown_users =
        _map['archive_and_mute_new_chats_from_unknown_users']! as bool;
    var keep_unmuted_chats_archived =
        _map['keep_unmuted_chats_archived']! as bool;
    var keep_chats_from_folders_archived =
        _map['keep_chats_from_folders_archived']! as bool;
    return ArchiveChatListSettings(
      extra: extra,
      clientId: clientId,
      archive_and_mute_new_chats_from_unknown_users:
          archive_and_mute_new_chats_from_unknown_users,
      keep_unmuted_chats_archived: keep_unmuted_chats_archived,
      keep_chats_from_folders_archived: keep_chats_from_folders_archived,
    );
  }
}

/// A main list of chats.
///
class ChatListMain extends ChatList {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatListMain";

  /// A main list of chats
  ChatListMain({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'chatListMain', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatListMain? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatListMain(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives.
///
class ChatListArchive extends ChatList {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatListArchive";

  /// A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
  ChatListArchive({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'chatListArchive', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatListArchive? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatListArchive(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A list of chats added to a chat folder.
///
class ChatListFolder extends ChatList {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatListFolder";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// A list of chats added to a chat folder
  ChatListFolder({required this.chat_folder_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatListFolder',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatListFolder? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    return ChatListFolder(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
    );
  }
}

/// Contains a list of chat lists.
///
class ChatLists extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatLists";

  /// List of chat lists.
  late List<ChatList> chat_lists;

  /// Contains a list of chat lists
  ChatLists({required this.chat_lists, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatLists',
      if (extra != null) '@extra': extra,
      'chat_lists': chat_lists
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatLists? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_lists = List<ChatList>.from(
      (_map["chat_lists"] ?? []).map(
        (e) => ChatList.fromMap(e),
      ),
    );
    return ChatLists(
      extra: extra,
      clientId: clientId,
      chat_lists: chat_lists,
    );
  }
}

/// The chat is sponsored by the user's MTProxy server.
///
class ChatSourceMtprotoProxy extends ChatSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatSourceMtprotoProxy";

  /// The chat is sponsored by the user's MTProxy server
  ChatSourceMtprotoProxy({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatSourceMtprotoProxy',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatSourceMtprotoProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatSourceMtprotoProxy(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat contains a public service announcement.
///
class ChatSourcePublicServiceAnnouncement extends ChatSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatSourcePublicServiceAnnouncement";

  /// The type of the announcement.
  late String type;

  /// The text of the announcement.
  late String text;

  /// The chat contains a public service announcement
  ChatSourcePublicServiceAnnouncement(
      {required this.type, required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatSourcePublicServiceAnnouncement',
      if (extra != null) '@extra': extra,
      'type': type,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatSourcePublicServiceAnnouncement? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = _map['type']! as String;
    var text = _map['text']! as String;
    return ChatSourcePublicServiceAnnouncement(
      extra: extra,
      clientId: clientId,
      type: type,
      text: text,
    );
  }
}

/// Describes a position of a chat in a chat list.
///
class ChatPosition extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatPosition";

  /// The chat list.
  late ChatList list;

  /// A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order.
  /// ; string representation of int, use `int.parse`
  late int64 order;

  /// True, if the chat is pinned in the chat list.
  late bool is_pinned;

  /// Source of the chat in the chat list; may be null.
  ChatSource? source;

  /// Describes a position of a chat in a chat list
  ChatPosition(
      {required this.list,
      required this.order,
      required this.is_pinned,
      this.source,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatPosition',
      if (extra != null) '@extra': extra,
      'list': list,
      'order': order,
      'is_pinned': is_pinned,
      'source': source
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatPosition? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var list = ChatList.fromMap(_map['list'])!;
    var order = _map['order']! as int64;
    var is_pinned = _map['is_pinned']! as bool;
    var source = ChatSource.fromMap(_map['source']);
    return ChatPosition(
      extra: extra,
      clientId: clientId,
      list: list,
      order: order,
      is_pinned: is_pinned,
      source: source,
    );
  }
}

/// All reactions are available in the chat.
///
class ChatAvailableReactionsAll extends ChatAvailableReactions {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatAvailableReactionsAll";

  /// All reactions are available in the chat
  ChatAvailableReactionsAll({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatAvailableReactionsAll',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatAvailableReactionsAll? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatAvailableReactionsAll(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Only specific reactions are available in the chat.
///
class ChatAvailableReactionsSome extends ChatAvailableReactions {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatAvailableReactionsSome";

  /// The list of reactions.
  late List<ReactionType> reactions;

  /// Only specific reactions are available in the chat
  ChatAvailableReactionsSome(
      {required this.reactions, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatAvailableReactionsSome',
      if (extra != null) '@extra': extra,
      'reactions': reactions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatAvailableReactionsSome? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reactions = List<ReactionType>.from(
      (_map["reactions"] ?? []).map(
        (e) => ReactionType.fromMap(e),
      ),
    );
    return ChatAvailableReactionsSome(
      extra: extra,
      clientId: clientId,
      reactions: reactions,
    );
  }
}

/// Describes a video chat.
///
class VideoChat extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "videoChat";

  /// Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall.
  late int group_call_id;

  /// True, if the video chat has participants.
  late bool has_participants;

  /// Default group call participant identifier to join the video chat; may be null.
  MessageSender? default_participant_id;

  /// Describes a video chat
  VideoChat(
      {required this.group_call_id,
      required this.has_participants,
      this.default_participant_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'videoChat',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'has_participants': has_participants,
      'default_participant_id': default_participant_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static VideoChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var has_participants = _map['has_participants']! as bool;
    var default_participant_id =
        MessageSender.fromMap(_map['default_participant_id']);
    return VideoChat(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      has_participants: has_participants,
      default_participant_id: default_participant_id,
    );
  }
}

/// A chat. (Can be a private chat, basic group, supergroup, or secret chat).
///
class Chat extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chat";

  /// Chat unique identifier.
  late int id;

  /// Type of the chat.
  late ChatType type;

  /// Chat title.
  late String title;

  /// Chat photo; may be null.
  ChatPhotoInfo? photo;

  /// Actions that non-administrator chat members are allowed to take in the chat.
  late ChatPermissions permissions;

  /// Last message in the chat; may be null if none or unknown.
  Message? last_message;

  /// Positions of the chat in chat lists.
  late List<ChatPosition> positions;

  /// Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender.
  MessageSender? message_sender_id;

  /// Block list to which the chat is added; may be null if none.
  BlockList? block_list;

  /// True, if chat content can't be saved locally, forwarded, or copied.
  late bool has_protected_content;

  /// True, if translation of all messages in the chat must be suggested to the user.
  late bool is_translatable;

  /// True, if the chat is marked as unread.
  late bool is_marked_as_unread;

  /// True, if the chat has scheduled messages.
  late bool has_scheduled_messages;

  /// True, if the chat messages can be deleted only for the current user while other users will continue to see the messages.
  late bool can_be_deleted_only_for_self;

  /// True, if the chat messages can be deleted for all users.
  late bool can_be_deleted_for_all_users;

  /// True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto.
  late bool can_be_reported;

  /// Default value of the disable_notification parameter, used when a message is sent to the chat.
  late bool default_disable_notification;

  /// Number of unread messages in the chat.
  late int unread_count;

  /// Identifier of the last read incoming message.
  late int last_read_inbox_message_id;

  /// Identifier of the last read outgoing message.
  late int last_read_outbox_message_id;

  /// Number of unread messages with a mention/reply in the chat.
  late int unread_mention_count;

  /// Number of messages with unread reactions in the chat.
  late int unread_reaction_count;

  /// Notification settings for the chat.
  late ChatNotificationSettings notification_settings;

  /// Types of reaction, available in the chat.
  late ChatAvailableReactions available_reactions;

  /// Current message auto-delete or self-destruct timer setting for the chat, in seconds; 0 if disabled. Self-destruct timer in secret chats starts after the message or its content is viewed. Auto-delete timer in other chats starts from the send date.
  late int message_auto_delete_time;

  /// Background set for the chat; may be null if none.
  ChatBackground? background;

  /// If non-empty, name of a theme, set for the chat.
  late String theme_name;

  /// Information about actions which must be possible to do through the chat action bar; may be null if none.
  ChatActionBar? action_bar;

  /// Information about video chat of the chat.
  late VideoChat video_chat;

  /// Information about pending join requests; may be null if none.
  ChatJoinRequestsInfo? pending_join_requests;

  /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat.
  late int reply_markup_message_id;

  /// A draft of a message in the chat; may be null if none.
  DraftMessage? draft_message;

  /// Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used.
  late String client_data;

  /// A chat. (Can be a private chat, basic group, supergroup, or secret chat)
  Chat(
      {required this.id,
      required this.type,
      required this.title,
      this.photo,
      required this.permissions,
      this.last_message,
      required this.positions,
      this.message_sender_id,
      this.block_list,
      required this.has_protected_content,
      required this.is_translatable,
      required this.is_marked_as_unread,
      required this.has_scheduled_messages,
      required this.can_be_deleted_only_for_self,
      required this.can_be_deleted_for_all_users,
      required this.can_be_reported,
      required this.default_disable_notification,
      required this.unread_count,
      required this.last_read_inbox_message_id,
      required this.last_read_outbox_message_id,
      required this.unread_mention_count,
      required this.unread_reaction_count,
      required this.notification_settings,
      required this.available_reactions,
      required this.message_auto_delete_time,
      this.background,
      required this.theme_name,
      this.action_bar,
      required this.video_chat,
      this.pending_join_requests,
      required this.reply_markup_message_id,
      this.draft_message,
      required this.client_data,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chat',
      if (extra != null) '@extra': extra,
      'id': id,
      'type': type,
      'title': title,
      'photo': photo,
      'permissions': permissions,
      'last_message': last_message,
      'positions': positions,
      'message_sender_id': message_sender_id,
      'block_list': block_list,
      'has_protected_content': has_protected_content,
      'is_translatable': is_translatable,
      'is_marked_as_unread': is_marked_as_unread,
      'has_scheduled_messages': has_scheduled_messages,
      'can_be_deleted_only_for_self': can_be_deleted_only_for_self,
      'can_be_deleted_for_all_users': can_be_deleted_for_all_users,
      'can_be_reported': can_be_reported,
      'default_disable_notification': default_disable_notification,
      'unread_count': unread_count,
      'last_read_inbox_message_id': last_read_inbox_message_id,
      'last_read_outbox_message_id': last_read_outbox_message_id,
      'unread_mention_count': unread_mention_count,
      'unread_reaction_count': unread_reaction_count,
      'notification_settings': notification_settings,
      'available_reactions': available_reactions,
      'message_auto_delete_time': message_auto_delete_time,
      'background': background,
      'theme_name': theme_name,
      'action_bar': action_bar,
      'video_chat': video_chat,
      'pending_join_requests': pending_join_requests,
      'reply_markup_message_id': reply_markup_message_id,
      'draft_message': draft_message,
      'client_data': client_data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Chat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var type = ChatType.fromMap(_map['type'])!;
    var title = _map['title']! as String;
    var photo = ChatPhotoInfo.fromMap(_map['photo']);
    var permissions = ChatPermissions.fromMap(_map['permissions'])!;
    var last_message = Message.fromMap(_map['last_message']);
    var positions = List<ChatPosition>.from(
      (_map["positions"] ?? []).map(
        (e) => ChatPosition.fromMap(e),
      ),
    );
    var message_sender_id = MessageSender.fromMap(_map['message_sender_id']);
    var block_list = BlockList.fromMap(_map['block_list']);
    var has_protected_content = _map['has_protected_content']! as bool;
    var is_translatable = _map['is_translatable']! as bool;
    var is_marked_as_unread = _map['is_marked_as_unread']! as bool;
    var has_scheduled_messages = _map['has_scheduled_messages']! as bool;
    var can_be_deleted_only_for_self =
        _map['can_be_deleted_only_for_self']! as bool;
    var can_be_deleted_for_all_users =
        _map['can_be_deleted_for_all_users']! as bool;
    var can_be_reported = _map['can_be_reported']! as bool;
    var default_disable_notification =
        _map['default_disable_notification']! as bool;
    var unread_count = _map['unread_count']! as int;
    var last_read_inbox_message_id = _map['last_read_inbox_message_id']! as int;
    var last_read_outbox_message_id =
        _map['last_read_outbox_message_id']! as int;
    var unread_mention_count = _map['unread_mention_count']! as int;
    var unread_reaction_count = _map['unread_reaction_count']! as int;
    var notification_settings =
        ChatNotificationSettings.fromMap(_map['notification_settings'])!;
    var available_reactions =
        ChatAvailableReactions.fromMap(_map['available_reactions'])!;
    var message_auto_delete_time = _map['message_auto_delete_time']! as int;
    var background = ChatBackground.fromMap(_map['background']);
    var theme_name = _map['theme_name']! as String;
    var action_bar = ChatActionBar.fromMap(_map['action_bar']);
    var video_chat = VideoChat.fromMap(_map['video_chat'])!;
    var pending_join_requests =
        ChatJoinRequestsInfo.fromMap(_map['pending_join_requests']);
    var reply_markup_message_id = _map['reply_markup_message_id']! as int;
    var draft_message = DraftMessage.fromMap(_map['draft_message']);
    var client_data = _map['client_data']! as String;
    return Chat(
      extra: extra,
      clientId: clientId,
      id: id,
      type: type,
      title: title,
      photo: photo,
      permissions: permissions,
      last_message: last_message,
      positions: positions,
      message_sender_id: message_sender_id,
      block_list: block_list,
      has_protected_content: has_protected_content,
      is_translatable: is_translatable,
      is_marked_as_unread: is_marked_as_unread,
      has_scheduled_messages: has_scheduled_messages,
      can_be_deleted_only_for_self: can_be_deleted_only_for_self,
      can_be_deleted_for_all_users: can_be_deleted_for_all_users,
      can_be_reported: can_be_reported,
      default_disable_notification: default_disable_notification,
      unread_count: unread_count,
      last_read_inbox_message_id: last_read_inbox_message_id,
      last_read_outbox_message_id: last_read_outbox_message_id,
      unread_mention_count: unread_mention_count,
      unread_reaction_count: unread_reaction_count,
      notification_settings: notification_settings,
      available_reactions: available_reactions,
      message_auto_delete_time: message_auto_delete_time,
      background: background,
      theme_name: theme_name,
      action_bar: action_bar,
      video_chat: video_chat,
      pending_join_requests: pending_join_requests,
      reply_markup_message_id: reply_markup_message_id,
      draft_message: draft_message,
      client_data: client_data,
    );
  }
}

/// Represents a list of chats.
///
class Chats extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chats";

  /// Approximate total number of chats found.
  late int total_count;

  /// List of chat identifiers.
  late List<int> chat_ids;

  /// Represents a list of chats
  Chats(
      {required this.total_count,
      required this.chat_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chats',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'chat_ids': chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Chats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var chat_ids = List<int>.from(
      (_map["chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return Chats(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      chat_ids: chat_ids,
    );
  }
}

/// Describes a chat located nearby.
///
class ChatNearby extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatNearby";

  /// Chat identifier.
  late int chat_id;

  /// Distance to the chat location, in meters.
  late int distance;

  /// Describes a chat located nearby
  ChatNearby(
      {required this.chat_id,
      required this.distance,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatNearby',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'distance': distance
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatNearby? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var distance = _map['distance']! as int;
    return ChatNearby(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      distance: distance,
    );
  }
}

/// Represents a list of chats located nearby.
///
class ChatsNearby extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatsNearby";

  /// List of users nearby.
  late List<ChatNearby> users_nearby;

  /// List of location-based supergroups nearby.
  late List<ChatNearby> supergroups_nearby;

  /// Represents a list of chats located nearby
  ChatsNearby(
      {required this.users_nearby,
      required this.supergroups_nearby,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatsNearby',
      if (extra != null) '@extra': extra,
      'users_nearby': users_nearby,
      'supergroups_nearby': supergroups_nearby
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatsNearby? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var users_nearby = List<ChatNearby>.from(
      (_map["users_nearby"] ?? []).map(
        (e) => ChatNearby.fromMap(e),
      ),
    );
    var supergroups_nearby = List<ChatNearby>.from(
      (_map["supergroups_nearby"] ?? []).map(
        (e) => ChatNearby.fromMap(e),
      ),
    );
    return ChatsNearby(
      extra: extra,
      clientId: clientId,
      users_nearby: users_nearby,
      supergroups_nearby: supergroups_nearby,
    );
  }
}

/// The chat is public, because it has an active username.
///
class PublicChatTypeHasUsername extends PublicChatType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "publicChatTypeHasUsername";

  /// The chat is public, because it has an active username
  PublicChatTypeHasUsername({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'publicChatTypeHasUsername',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PublicChatTypeHasUsername? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PublicChatTypeHasUsername(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat is public, because it is a location-based supergroup.
///
class PublicChatTypeIsLocationBased extends PublicChatType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "publicChatTypeIsLocationBased";

  /// The chat is public, because it is a location-based supergroup
  PublicChatTypeIsLocationBased({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'publicChatTypeIsLocationBased',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PublicChatTypeIsLocationBased? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PublicChatTypeIsLocationBased(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat can be reported as spam using the method reportChat with the reason reportReasonSpam. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown.
///
class ChatActionBarReportSpam extends ChatActionBar {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionBarReportSpam";

  /// If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings.
  late bool can_unarchive;

  /// The chat can be reported as spam using the method reportChat with the reason reportReasonSpam. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
  ChatActionBarReportSpam(
      {required this.can_unarchive, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionBarReportSpam',
      if (extra != null) '@extra': extra,
      'can_unarchive': can_unarchive
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionBarReportSpam? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var can_unarchive = _map['can_unarchive']! as bool;
    return ChatActionBarReportSpam(
      extra: extra,
      clientId: clientId,
      can_unarchive: can_unarchive,
    );
  }
}

/// The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason reportReasonUnrelatedLocation.
///
class ChatActionBarReportUnrelatedLocation extends ChatActionBar {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionBarReportUnrelatedLocation";

  /// The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason reportReasonUnrelatedLocation
  ChatActionBarReportUnrelatedLocation({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionBarReportUnrelatedLocation',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionBarReportUnrelatedLocation? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionBarReportUnrelatedLocation(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat is a recently created group chat to which new members can be invited.
///
class ChatActionBarInviteMembers extends ChatActionBar {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionBarInviteMembers";

  /// The chat is a recently created group chat to which new members can be invited
  ChatActionBarInviteMembers({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionBarInviteMembers',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionBarInviteMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionBarInviteMembers(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method setMessageSenderBlockList,.
///
class ChatActionBarReportAddBlock extends ChatActionBar {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionBarReportAddBlock";

  /// If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings.
  late bool can_unarchive;

  /// If non-negative, the current user was found by the peer through searchChatsNearby and this is the distance between the users.
  late int distance;

  /// The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method setMessageSenderBlockList,
  ChatActionBarReportAddBlock(
      {required this.can_unarchive,
      required this.distance,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionBarReportAddBlock',
      if (extra != null) '@extra': extra,
      'can_unarchive': can_unarchive,
      'distance': distance
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionBarReportAddBlock? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var can_unarchive = _map['can_unarchive']! as bool;
    var distance = _map['distance']! as int;
    return ChatActionBarReportAddBlock(
      extra: extra,
      clientId: clientId,
      can_unarchive: can_unarchive,
      distance: distance,
    );
  }
}

/// The chat is a private or secret chat and the other user can be added to the contact list using the method addContact.
///
class ChatActionBarAddContact extends ChatActionBar {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionBarAddContact";

  /// The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
  ChatActionBarAddContact({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionBarAddContact',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionBarAddContact? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionBarAddContact(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber.
///
class ChatActionBarSharePhoneNumber extends ChatActionBar {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionBarSharePhoneNumber";

  /// The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
  ChatActionBarSharePhoneNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionBarSharePhoneNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionBarSharePhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionBarSharePhoneNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat is a private chat with an administrator of a chat to which the user sent join request.
///
class ChatActionBarJoinRequest extends ChatActionBar {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionBarJoinRequest";

  /// Title of the chat to which the join request was sent.
  late String title;

  /// True, if the join request was sent to a channel chat.
  late bool is_channel;

  /// Point in time (Unix timestamp) when the join request was sent.
  late int request_date;

  /// The chat is a private chat with an administrator of a chat to which the user sent join request
  ChatActionBarJoinRequest(
      {required this.title,
      required this.is_channel,
      required this.request_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionBarJoinRequest',
      if (extra != null) '@extra': extra,
      'title': title,
      'is_channel': is_channel,
      'request_date': request_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionBarJoinRequest? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var is_channel = _map['is_channel']! as bool;
    var request_date = _map['request_date']! as int;
    return ChatActionBarJoinRequest(
      extra: extra,
      clientId: clientId,
      title: title,
      is_channel: is_channel,
      request_date: request_date,
    );
  }
}

/// A simple button, with text that must be sent when the button is pressed.
///
class KeyboardButtonTypeText extends KeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "keyboardButtonTypeText";

  /// A simple button, with text that must be sent when the button is pressed
  KeyboardButtonTypeText({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'keyboardButtonTypeText',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static KeyboardButtonTypeText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return KeyboardButtonTypeText(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A button that sends the user's phone number when pressed; available only in private chats.
///
class KeyboardButtonTypeRequestPhoneNumber extends KeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "keyboardButtonTypeRequestPhoneNumber";

  /// A button that sends the user's phone number when pressed; available only in private chats
  KeyboardButtonTypeRequestPhoneNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'keyboardButtonTypeRequestPhoneNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static KeyboardButtonTypeRequestPhoneNumber? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return KeyboardButtonTypeRequestPhoneNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A button that sends the user's location when pressed; available only in private chats.
///
class KeyboardButtonTypeRequestLocation extends KeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "keyboardButtonTypeRequestLocation";

  /// A button that sends the user's location when pressed; available only in private chats
  KeyboardButtonTypeRequestLocation({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'keyboardButtonTypeRequestLocation',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static KeyboardButtonTypeRequestLocation? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return KeyboardButtonTypeRequestLocation(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A button that allows the user to create and send a poll when pressed; available only in private chats.
///
class KeyboardButtonTypeRequestPoll extends KeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "keyboardButtonTypeRequestPoll";

  /// If true, only regular polls must be allowed to create.
  late bool force_regular;

  /// If true, only polls in quiz mode must be allowed to create.
  late bool force_quiz;

  /// A button that allows the user to create and send a poll when pressed; available only in private chats
  KeyboardButtonTypeRequestPoll(
      {required this.force_regular,
      required this.force_quiz,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'keyboardButtonTypeRequestPoll',
      if (extra != null) '@extra': extra,
      'force_regular': force_regular,
      'force_quiz': force_quiz
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static KeyboardButtonTypeRequestPoll? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var force_regular = _map['force_regular']! as bool;
    var force_quiz = _map['force_quiz']! as bool;
    return KeyboardButtonTypeRequestPoll(
      extra: extra,
      clientId: clientId,
      force_regular: force_regular,
      force_quiz: force_quiz,
    );
  }
}

/// A button that requests a user to be shared by the current user; available only in private chats. Use the method shareUserWithBot to complete the request.
///
class KeyboardButtonTypeRequestUser extends KeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "keyboardButtonTypeRequestUser";

  /// Unique button identifier.
  late int id;

  /// True, if the shared user must or must not be a bot.
  late bool restrict_user_is_bot;

  /// True, if the shared user must be a bot; otherwise, the shared user must no be a bot. Ignored if restrict_user_is_bot is false.
  late bool user_is_bot;

  /// True, if the shared user must or must not be a Telegram Premium user.
  late bool restrict_user_is_premium;

  /// True, if the shared user must be a Telegram Premium user; otherwise, the shared user must no be a Telegram Premium user. Ignored if restrict_user_is_premium is false.
  late bool user_is_premium;

  /// A button that requests a user to be shared by the current user; available only in private chats. Use the method shareUserWithBot to complete the request
  KeyboardButtonTypeRequestUser(
      {required this.id,
      required this.restrict_user_is_bot,
      required this.user_is_bot,
      required this.restrict_user_is_premium,
      required this.user_is_premium,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'keyboardButtonTypeRequestUser',
      if (extra != null) '@extra': extra,
      'id': id,
      'restrict_user_is_bot': restrict_user_is_bot,
      'user_is_bot': user_is_bot,
      'restrict_user_is_premium': restrict_user_is_premium,
      'user_is_premium': user_is_premium
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static KeyboardButtonTypeRequestUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var restrict_user_is_bot = _map['restrict_user_is_bot']! as bool;
    var user_is_bot = _map['user_is_bot']! as bool;
    var restrict_user_is_premium = _map['restrict_user_is_premium']! as bool;
    var user_is_premium = _map['user_is_premium']! as bool;
    return KeyboardButtonTypeRequestUser(
      extra: extra,
      clientId: clientId,
      id: id,
      restrict_user_is_bot: restrict_user_is_bot,
      user_is_bot: user_is_bot,
      restrict_user_is_premium: restrict_user_is_premium,
      user_is_premium: user_is_premium,
    );
  }
}

/// A button that requests a chat to be shared by the current user; available only in private chats. Use the method shareChatWithBot to complete the request.
///
class KeyboardButtonTypeRequestChat extends KeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "keyboardButtonTypeRequestChat";

  /// Unique button identifier.
  late int id;

  /// True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared.
  late bool chat_is_channel;

  /// True, if the chat must or must not be a forum supergroup.
  late bool restrict_chat_is_forum;

  /// True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup. Ignored if restrict_chat_is_forum is false.
  late bool chat_is_forum;

  /// True, if the chat must or must not have a username.
  late bool restrict_chat_has_username;

  /// True, if the chat must have a username; otherwise, the chat must not have a username. Ignored if restrict_chat_has_username is false.
  late bool chat_has_username;

  /// True, if the chat must be created by the current user.
  late bool chat_is_created;

  /// Expected user administrator rights in the chat; may be null if they aren't restricted.
  ChatAdministratorRights? user_administrator_rights;

  /// Expected bot administrator rights in the chat; may be null if they aren't restricted.
  ChatAdministratorRights? bot_administrator_rights;

  /// True, if the bot must be a member of the chat; for basic group and supergroup chats only.
  late bool bot_is_member;

  /// A button that requests a chat to be shared by the current user; available only in private chats. Use the method shareChatWithBot to complete the request
  KeyboardButtonTypeRequestChat(
      {required this.id,
      required this.chat_is_channel,
      required this.restrict_chat_is_forum,
      required this.chat_is_forum,
      required this.restrict_chat_has_username,
      required this.chat_has_username,
      required this.chat_is_created,
      this.user_administrator_rights,
      this.bot_administrator_rights,
      required this.bot_is_member,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'keyboardButtonTypeRequestChat',
      if (extra != null) '@extra': extra,
      'id': id,
      'chat_is_channel': chat_is_channel,
      'restrict_chat_is_forum': restrict_chat_is_forum,
      'chat_is_forum': chat_is_forum,
      'restrict_chat_has_username': restrict_chat_has_username,
      'chat_has_username': chat_has_username,
      'chat_is_created': chat_is_created,
      'user_administrator_rights': user_administrator_rights,
      'bot_administrator_rights': bot_administrator_rights,
      'bot_is_member': bot_is_member
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static KeyboardButtonTypeRequestChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var chat_is_channel = _map['chat_is_channel']! as bool;
    var restrict_chat_is_forum = _map['restrict_chat_is_forum']! as bool;
    var chat_is_forum = _map['chat_is_forum']! as bool;
    var restrict_chat_has_username =
        _map['restrict_chat_has_username']! as bool;
    var chat_has_username = _map['chat_has_username']! as bool;
    var chat_is_created = _map['chat_is_created']! as bool;
    var user_administrator_rights =
        ChatAdministratorRights.fromMap(_map['user_administrator_rights']);
    var bot_administrator_rights =
        ChatAdministratorRights.fromMap(_map['bot_administrator_rights']);
    var bot_is_member = _map['bot_is_member']! as bool;
    return KeyboardButtonTypeRequestChat(
      extra: extra,
      clientId: clientId,
      id: id,
      chat_is_channel: chat_is_channel,
      restrict_chat_is_forum: restrict_chat_is_forum,
      chat_is_forum: chat_is_forum,
      restrict_chat_has_username: restrict_chat_has_username,
      chat_has_username: chat_has_username,
      chat_is_created: chat_is_created,
      user_administrator_rights: user_administrator_rights,
      bot_administrator_rights: bot_administrator_rights,
      bot_is_member: bot_is_member,
    );
  }
}

/// A button that opens a Web App by calling getWebAppUrl.
///
class KeyboardButtonTypeWebApp extends KeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "keyboardButtonTypeWebApp";

  /// An HTTP URL to pass to getWebAppUrl.
  late String url;

  /// A button that opens a Web App by calling getWebAppUrl
  KeyboardButtonTypeWebApp({required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'keyboardButtonTypeWebApp',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static KeyboardButtonTypeWebApp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return KeyboardButtonTypeWebApp(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// Represents a single button in a bot keyboard.
///
class KeyboardButton extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "keyboardButton";

  /// Text of the button.
  late String text;

  /// Type of the button.
  late KeyboardButtonType type;

  /// Represents a single button in a bot keyboard
  KeyboardButton(
      {required this.text, required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'keyboardButton',
      if (extra != null) '@extra': extra,
      'text': text,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static KeyboardButton? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var type = KeyboardButtonType.fromMap(_map['type'])!;
    return KeyboardButton(
      extra: extra,
      clientId: clientId,
      text: text,
      type: type,
    );
  }
}

/// A button that opens a specified URL.
///
class InlineKeyboardButtonTypeUrl extends InlineKeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineKeyboardButtonTypeUrl";

  /// HTTP or tg:// URL to open.
  late String url;

  /// A button that opens a specified URL
  InlineKeyboardButtonTypeUrl({required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButtonTypeUrl',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButtonTypeUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return InlineKeyboardButtonTypeUrl(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo.
///
class InlineKeyboardButtonTypeLoginUrl extends InlineKeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineKeyboardButtonTypeLoginUrl";

  /// An HTTP URL to pass to getLoginUrlInfo.
  late String url;

  /// Unique button identifier.
  late int id;

  /// If non-empty, new text of the button in forwarded messages.
  late String forward_text;

  /// A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo
  InlineKeyboardButtonTypeLoginUrl(
      {required this.url,
      required this.id,
      required this.forward_text,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButtonTypeLoginUrl',
      if (extra != null) '@extra': extra,
      'url': url,
      'id': id,
      'forward_text': forward_text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButtonTypeLoginUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var id = _map['id']! as int;
    var forward_text = _map['forward_text']! as String;
    return InlineKeyboardButtonTypeLoginUrl(
      extra: extra,
      clientId: clientId,
      url: url,
      id: id,
      forward_text: forward_text,
    );
  }
}

/// A button that opens a Web App by calling openWebApp.
///
class InlineKeyboardButtonTypeWebApp extends InlineKeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineKeyboardButtonTypeWebApp";

  /// An HTTP URL to pass to openWebApp.
  late String url;

  /// A button that opens a Web App by calling openWebApp
  InlineKeyboardButtonTypeWebApp(
      {required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButtonTypeWebApp',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButtonTypeWebApp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return InlineKeyboardButtonTypeWebApp(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// A button that sends a callback query to a bot.
///
class InlineKeyboardButtonTypeCallback extends InlineKeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineKeyboardButtonTypeCallback";

  /// Data to be sent to the bot via a callback query.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// A button that sends a callback query to a bot
  InlineKeyboardButtonTypeCallback(
      {required this.data, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButtonTypeCallback',
      if (extra != null) '@extra': extra,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButtonTypeCallback? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var data = _map['data']! as bytes;
    return InlineKeyboardButtonTypeCallback(
      extra: extra,
      clientId: clientId,
      data: data,
    );
  }
}

/// A button that asks for the 2-step verification password of the current user and then sends a callback query to a bot.
///
class InlineKeyboardButtonTypeCallbackWithPassword
    extends InlineKeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "inlineKeyboardButtonTypeCallbackWithPassword";

  /// Data to be sent to the bot via a callback query.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// A button that asks for the 2-step verification password of the current user and then sends a callback query to a bot
  InlineKeyboardButtonTypeCallbackWithPassword(
      {required this.data, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButtonTypeCallbackWithPassword',
      if (extra != null) '@extra': extra,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButtonTypeCallbackWithPassword? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var data = _map['data']! as bytes;
    return InlineKeyboardButtonTypeCallbackWithPassword(
      extra: extra,
      clientId: clientId,
      data: data,
    );
  }
}

/// A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame.
///
class InlineKeyboardButtonTypeCallbackGame extends InlineKeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineKeyboardButtonTypeCallbackGame";

  /// A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
  InlineKeyboardButtonTypeCallbackGame({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButtonTypeCallbackGame',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButtonTypeCallbackGame? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InlineKeyboardButtonTypeCallbackGame(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A button that forces an inline query to the bot to be inserted in the input field.
///
class InlineKeyboardButtonTypeSwitchInline extends InlineKeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineKeyboardButtonTypeSwitchInline";

  /// Inline query to be sent to the bot.
  late String query;

  /// Target chat from which to send the inline query.
  late TargetChat target_chat;

  /// A button that forces an inline query to the bot to be inserted in the input field
  InlineKeyboardButtonTypeSwitchInline(
      {required this.query,
      required this.target_chat,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButtonTypeSwitchInline',
      if (extra != null) '@extra': extra,
      'query': query,
      'target_chat': target_chat
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButtonTypeSwitchInline? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    var target_chat = TargetChat.fromMap(_map['target_chat'])!;
    return InlineKeyboardButtonTypeSwitchInline(
      extra: extra,
      clientId: clientId,
      query: query,
      target_chat: target_chat,
    );
  }
}

/// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice.
///
class InlineKeyboardButtonTypeBuy extends InlineKeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineKeyboardButtonTypeBuy";

  /// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
  InlineKeyboardButtonTypeBuy({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButtonTypeBuy',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButtonTypeBuy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InlineKeyboardButtonTypeBuy(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A button with a user reference to be handled in the same way as textEntityTypeMentionName entities.
///
class InlineKeyboardButtonTypeUser extends InlineKeyboardButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineKeyboardButtonTypeUser";

  /// User identifier.
  late int user_id;

  /// A button with a user reference to be handled in the same way as textEntityTypeMentionName entities
  InlineKeyboardButtonTypeUser(
      {required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButtonTypeUser',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButtonTypeUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return InlineKeyboardButtonTypeUser(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// Represents a single button in an inline keyboard.
///
class InlineKeyboardButton extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineKeyboardButton";

  /// Text of the button.
  late String text;

  /// Type of the button.
  late InlineKeyboardButtonType type;

  /// Represents a single button in an inline keyboard
  InlineKeyboardButton(
      {required this.text, required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineKeyboardButton',
      if (extra != null) '@extra': extra,
      'text': text,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineKeyboardButton? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var type = InlineKeyboardButtonType.fromMap(_map['type'])!;
    return InlineKeyboardButton(
      extra: extra,
      clientId: clientId,
      text: text,
      type: type,
    );
  }
}

/// Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup with message_id == 0 will be sent.
///
class ReplyMarkupRemoveKeyboard extends ReplyMarkup {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "replyMarkupRemoveKeyboard";

  /// True, if the keyboard is removed only for the mentioned users or the target user of a reply.
  late bool is_personal;

  /// Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup with message_id == 0 will be sent
  ReplyMarkupRemoveKeyboard(
      {required this.is_personal, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'replyMarkupRemoveKeyboard',
      if (extra != null) '@extra': extra,
      'is_personal': is_personal
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReplyMarkupRemoveKeyboard? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_personal = _map['is_personal']! as bool;
    return ReplyMarkupRemoveKeyboard(
      extra: extra,
      clientId: clientId,
      is_personal: is_personal,
    );
  }
}

/// Instructs application to force a reply to this message.
///
class ReplyMarkupForceReply extends ReplyMarkup {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "replyMarkupForceReply";

  /// True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply.
  late bool is_personal;

  /// If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters.
  late String input_field_placeholder;

  /// Instructs application to force a reply to this message
  ReplyMarkupForceReply(
      {required this.is_personal,
      required this.input_field_placeholder,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'replyMarkupForceReply',
      if (extra != null) '@extra': extra,
      'is_personal': is_personal,
      'input_field_placeholder': input_field_placeholder
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReplyMarkupForceReply? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_personal = _map['is_personal']! as bool;
    var input_field_placeholder = _map['input_field_placeholder']! as String;
    return ReplyMarkupForceReply(
      extra: extra,
      clientId: clientId,
      is_personal: is_personal,
      input_field_placeholder: input_field_placeholder,
    );
  }
}

/// Contains a custom keyboard layout to quickly reply to bots.
///
class ReplyMarkupShowKeyboard extends ReplyMarkup {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "replyMarkupShowKeyboard";

  /// A list of rows of bot keyboard buttons.
  late List<List<KeyboardButton>> rows;

  /// True, if the keyboard is supposed to always be shown when the ordinary keyboard is hidden.
  late bool is_persistent;

  /// True, if the application needs to resize the keyboard vertically.
  late bool resize_keyboard;

  /// True, if the application needs to hide the keyboard after use.
  late bool one_time;

  /// True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply.
  late bool is_personal;

  /// If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters.
  late String input_field_placeholder;

  /// Contains a custom keyboard layout to quickly reply to bots
  ReplyMarkupShowKeyboard(
      {required this.rows,
      required this.is_persistent,
      required this.resize_keyboard,
      required this.one_time,
      required this.is_personal,
      required this.input_field_placeholder,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'replyMarkupShowKeyboard',
      if (extra != null) '@extra': extra,
      'rows': rows,
      'is_persistent': is_persistent,
      'resize_keyboard': resize_keyboard,
      'one_time': one_time,
      'is_personal': is_personal,
      'input_field_placeholder': input_field_placeholder
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReplyMarkupShowKeyboard? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var rows = List<List<KeyboardButton>>.from(
      (_map["rows"] ?? []).map(
        (e) => List<KeyboardButton>.from(
          (e ?? []).map(
            (e) => KeyboardButton.fromMap(e),
          ),
        ),
      ),
    );
    var is_persistent = _map['is_persistent']! as bool;
    var resize_keyboard = _map['resize_keyboard']! as bool;
    var one_time = _map['one_time']! as bool;
    var is_personal = _map['is_personal']! as bool;
    var input_field_placeholder = _map['input_field_placeholder']! as String;
    return ReplyMarkupShowKeyboard(
      extra: extra,
      clientId: clientId,
      rows: rows,
      is_persistent: is_persistent,
      resize_keyboard: resize_keyboard,
      one_time: one_time,
      is_personal: is_personal,
      input_field_placeholder: input_field_placeholder,
    );
  }
}

/// Contains an inline keyboard layout.
///
class ReplyMarkupInlineKeyboard extends ReplyMarkup {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "replyMarkupInlineKeyboard";

  /// A list of rows of inline keyboard buttons.
  late List<List<InlineKeyboardButton>> rows;

  /// Contains an inline keyboard layout
  ReplyMarkupInlineKeyboard({required this.rows, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'replyMarkupInlineKeyboard',
      if (extra != null) '@extra': extra,
      'rows': rows
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReplyMarkupInlineKeyboard? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var rows = List<List<InlineKeyboardButton>>.from(
      (_map["rows"] ?? []).map(
        (e) => List<InlineKeyboardButton>.from(
          (e ?? []).map(
            (e) => InlineKeyboardButton.fromMap(e),
          ),
        ),
      ),
    );
    return ReplyMarkupInlineKeyboard(
      extra: extra,
      clientId: clientId,
      rows: rows,
    );
  }
}

/// An HTTP URL needs to be open.
///
class LoginUrlInfoOpen extends LoginUrlInfo {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "loginUrlInfoOpen";

  /// The URL to open.
  late String url;

  /// True, if there is no need to show an ordinary open URL confirmation.
  late bool skip_confirmation;

  /// An HTTP URL needs to be open
  LoginUrlInfoOpen(
      {required this.url,
      required this.skip_confirmation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'loginUrlInfoOpen',
      if (extra != null) '@extra': extra,
      'url': url,
      'skip_confirmation': skip_confirmation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LoginUrlInfoOpen? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var skip_confirmation = _map['skip_confirmation']! as bool;
    return LoginUrlInfoOpen(
      extra: extra,
      clientId: clientId,
      url: url,
      skip_confirmation: skip_confirmation,
    );
  }
}

/// An authorization confirmation dialog needs to be shown to the user.
///
class LoginUrlInfoRequestConfirmation extends LoginUrlInfo {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "loginUrlInfoRequestConfirmation";

  /// An HTTP URL to be opened.
  late String url;

  /// A domain of the URL.
  late String domain;

  /// User identifier of a bot linked with the website.
  late int bot_user_id;

  /// True, if the user must be asked for the permission to the bot to send them messages.
  late bool request_write_access;

  /// An authorization confirmation dialog needs to be shown to the user
  LoginUrlInfoRequestConfirmation(
      {required this.url,
      required this.domain,
      required this.bot_user_id,
      required this.request_write_access,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'loginUrlInfoRequestConfirmation',
      if (extra != null) '@extra': extra,
      'url': url,
      'domain': domain,
      'bot_user_id': bot_user_id,
      'request_write_access': request_write_access
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LoginUrlInfoRequestConfirmation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var domain = _map['domain']! as String;
    var bot_user_id = _map['bot_user_id']! as int;
    var request_write_access = _map['request_write_access']! as bool;
    return LoginUrlInfoRequestConfirmation(
      extra: extra,
      clientId: clientId,
      url: url,
      domain: domain,
      bot_user_id: bot_user_id,
      request_write_access: request_write_access,
    );
  }
}

/// Contains information about a Web App found by its short name.
///
class FoundWebApp extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "foundWebApp";

  /// The Web App.
  late WebApp web_app;

  /// True, if the app supports "settings_button_pressed" event.
  late bool supports_settings;

  /// True, if the user must be asked for the permission to the bot to send them messages.
  late bool request_write_access;

  /// True, if there is no need to show an ordinary open URL confirmation before opening the Web App. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden.
  late bool skip_confirmation;

  /// Contains information about a Web App found by its short name
  FoundWebApp(
      {required this.web_app,
      required this.supports_settings,
      required this.request_write_access,
      required this.skip_confirmation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'foundWebApp',
      if (extra != null) '@extra': extra,
      'web_app': web_app,
      'supports_settings': supports_settings,
      'request_write_access': request_write_access,
      'skip_confirmation': skip_confirmation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FoundWebApp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var web_app = WebApp.fromMap(_map['web_app'])!;
    var supports_settings = _map['supports_settings']! as bool;
    var request_write_access = _map['request_write_access']! as bool;
    var skip_confirmation = _map['skip_confirmation']! as bool;
    return FoundWebApp(
      extra: extra,
      clientId: clientId,
      web_app: web_app,
      supports_settings: supports_settings,
      request_write_access: request_write_access,
      skip_confirmation: skip_confirmation,
    );
  }
}

/// Contains information about a Web App.
///
class WebAppInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "webAppInfo";

  /// Unique identifier for the Web App launch.
  /// ; string representation of int, use `int.parse`
  late int64 launch_id;

  /// A Web App URL to open in a web view.
  late String url;

  /// Contains information about a Web App
  WebAppInfo(
      {required this.launch_id, required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'webAppInfo',
      if (extra != null) '@extra': extra,
      'launch_id': launch_id,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static WebAppInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var launch_id = _map['launch_id']! as int64;
    var url = _map['url']! as String;
    return WebAppInfo(
      extra: extra,
      clientId: clientId,
      launch_id: launch_id,
      url: url,
    );
  }
}

/// Contains information about a message thread.
///
class MessageThreadInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageThreadInfo";

  /// Identifier of the chat to which the message thread belongs.
  late int chat_id;

  /// Message thread identifier, unique within the chat.
  late int message_thread_id;

  /// Information about the message thread; may be null for forum topic threads.
  MessageReplyInfo? reply_info;

  /// Approximate number of unread messages in the message thread.
  late int unread_message_count;

  /// The messages from which the thread starts. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id).
  late List<Message> messages;

  /// A draft of a message in the message thread; may be null if none.
  DraftMessage? draft_message;

  /// Contains information about a message thread
  MessageThreadInfo(
      {required this.chat_id,
      required this.message_thread_id,
      this.reply_info,
      required this.unread_message_count,
      required this.messages,
      this.draft_message,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageThreadInfo',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'reply_info': reply_info,
      'unread_message_count': unread_message_count,
      'messages': messages,
      'draft_message': draft_message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageThreadInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var reply_info = MessageReplyInfo.fromMap(_map['reply_info']);
    var unread_message_count = _map['unread_message_count']! as int;
    var messages = List<Message>.from(
      (_map["messages"] ?? []).map(
        (e) => Message.fromMap(e),
      ),
    );
    var draft_message = DraftMessage.fromMap(_map['draft_message']);
    return MessageThreadInfo(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      reply_info: reply_info,
      unread_message_count: unread_message_count,
      messages: messages,
      draft_message: draft_message,
    );
  }
}

/// Describes a forum topic icon.
///
class ForumTopicIcon extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "forumTopicIcon";

  /// Color of the topic icon in RGB format.
  late int color;

  /// Unique identifier of the custom emoji shown on the topic icon; 0 if none.
  /// ; string representation of int, use `int.parse`
  late int64 custom_emoji_id;

  /// Describes a forum topic icon
  ForumTopicIcon(
      {required this.color,
      required this.custom_emoji_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'forumTopicIcon',
      if (extra != null) '@extra': extra,
      'color': color,
      'custom_emoji_id': custom_emoji_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ForumTopicIcon? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var color = _map['color']! as int;
    var custom_emoji_id = _map['custom_emoji_id']! as int64;
    return ForumTopicIcon(
      extra: extra,
      clientId: clientId,
      color: color,
      custom_emoji_id: custom_emoji_id,
    );
  }
}

/// Contains basic information about a forum topic.
///
class ForumTopicInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "forumTopicInfo";

  /// Message thread identifier of the topic.
  late int message_thread_id;

  /// Name of the topic.
  late String name;

  /// Icon of the topic.
  late ForumTopicIcon icon;

  /// Point in time (Unix timestamp) when the topic was created.
  late int creation_date;

  /// Identifier of the creator of the topic.
  late MessageSender creator_id;

  /// True, if the topic is the General topic list.
  late bool is_general;

  /// True, if the topic was created by the current user.
  late bool is_outgoing;

  /// True, if the topic is closed.
  late bool is_closed;

  /// True, if the topic is hidden above the topic list and closed; for General topic only.
  late bool is_hidden;

  /// Contains basic information about a forum topic
  ForumTopicInfo(
      {required this.message_thread_id,
      required this.name,
      required this.icon,
      required this.creation_date,
      required this.creator_id,
      required this.is_general,
      required this.is_outgoing,
      required this.is_closed,
      required this.is_hidden,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'forumTopicInfo',
      if (extra != null) '@extra': extra,
      'message_thread_id': message_thread_id,
      'name': name,
      'icon': icon,
      'creation_date': creation_date,
      'creator_id': creator_id,
      'is_general': is_general,
      'is_outgoing': is_outgoing,
      'is_closed': is_closed,
      'is_hidden': is_hidden
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ForumTopicInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_thread_id = _map['message_thread_id']! as int;
    var name = _map['name']! as String;
    var icon = ForumTopicIcon.fromMap(_map['icon'])!;
    var creation_date = _map['creation_date']! as int;
    var creator_id = MessageSender.fromMap(_map['creator_id'])!;
    var is_general = _map['is_general']! as bool;
    var is_outgoing = _map['is_outgoing']! as bool;
    var is_closed = _map['is_closed']! as bool;
    var is_hidden = _map['is_hidden']! as bool;
    return ForumTopicInfo(
      extra: extra,
      clientId: clientId,
      message_thread_id: message_thread_id,
      name: name,
      icon: icon,
      creation_date: creation_date,
      creator_id: creator_id,
      is_general: is_general,
      is_outgoing: is_outgoing,
      is_closed: is_closed,
      is_hidden: is_hidden,
    );
  }
}

/// Describes a forum topic.
///
class ForumTopic extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "forumTopic";

  /// Basic information about the topic.
  late ForumTopicInfo info;

  /// Last message in the topic; may be null if unknown.
  Message? last_message;

  /// True, if the topic is pinned in the topic list.
  late bool is_pinned;

  /// Number of unread messages in the topic.
  late int unread_count;

  /// Identifier of the last read incoming message.
  late int last_read_inbox_message_id;

  /// Identifier of the last read outgoing message.
  late int last_read_outbox_message_id;

  /// Number of unread messages with a mention/reply in the topic.
  late int unread_mention_count;

  /// Number of messages with unread reactions in the topic.
  late int unread_reaction_count;

  /// Notification settings for the topic.
  late ChatNotificationSettings notification_settings;

  /// A draft of a message in the topic; may be null if none.
  DraftMessage? draft_message;

  /// Describes a forum topic
  ForumTopic(
      {required this.info,
      this.last_message,
      required this.is_pinned,
      required this.unread_count,
      required this.last_read_inbox_message_id,
      required this.last_read_outbox_message_id,
      required this.unread_mention_count,
      required this.unread_reaction_count,
      required this.notification_settings,
      this.draft_message,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'forumTopic',
      if (extra != null) '@extra': extra,
      'info': info,
      'last_message': last_message,
      'is_pinned': is_pinned,
      'unread_count': unread_count,
      'last_read_inbox_message_id': last_read_inbox_message_id,
      'last_read_outbox_message_id': last_read_outbox_message_id,
      'unread_mention_count': unread_mention_count,
      'unread_reaction_count': unread_reaction_count,
      'notification_settings': notification_settings,
      'draft_message': draft_message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ForumTopic? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var info = ForumTopicInfo.fromMap(_map['info'])!;
    var last_message = Message.fromMap(_map['last_message']);
    var is_pinned = _map['is_pinned']! as bool;
    var unread_count = _map['unread_count']! as int;
    var last_read_inbox_message_id = _map['last_read_inbox_message_id']! as int;
    var last_read_outbox_message_id =
        _map['last_read_outbox_message_id']! as int;
    var unread_mention_count = _map['unread_mention_count']! as int;
    var unread_reaction_count = _map['unread_reaction_count']! as int;
    var notification_settings =
        ChatNotificationSettings.fromMap(_map['notification_settings'])!;
    var draft_message = DraftMessage.fromMap(_map['draft_message']);
    return ForumTopic(
      extra: extra,
      clientId: clientId,
      info: info,
      last_message: last_message,
      is_pinned: is_pinned,
      unread_count: unread_count,
      last_read_inbox_message_id: last_read_inbox_message_id,
      last_read_outbox_message_id: last_read_outbox_message_id,
      unread_mention_count: unread_mention_count,
      unread_reaction_count: unread_reaction_count,
      notification_settings: notification_settings,
      draft_message: draft_message,
    );
  }
}

/// Describes a list of forum topics.
///
class ForumTopics extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "forumTopics";

  /// Approximate total number of forum topics found.
  late int total_count;

  /// List of forum topics.
  late List<ForumTopic> topics;

  /// Offset date for the next getForumTopics request.
  late int next_offset_date;

  /// Offset message identifier for the next getForumTopics request.
  late int next_offset_message_id;

  /// Offset message thread identifier for the next getForumTopics request.
  late int next_offset_message_thread_id;

  /// Describes a list of forum topics
  ForumTopics(
      {required this.total_count,
      required this.topics,
      required this.next_offset_date,
      required this.next_offset_message_id,
      required this.next_offset_message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'forumTopics',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'topics': topics,
      'next_offset_date': next_offset_date,
      'next_offset_message_id': next_offset_message_id,
      'next_offset_message_thread_id': next_offset_message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ForumTopics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var topics = List<ForumTopic>.from(
      (_map["topics"] ?? []).map(
        (e) => ForumTopic.fromMap(e),
      ),
    );
    var next_offset_date = _map['next_offset_date']! as int;
    var next_offset_message_id = _map['next_offset_message_id']! as int;
    var next_offset_message_thread_id =
        _map['next_offset_message_thread_id']! as int;
    return ForumTopics(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      topics: topics,
      next_offset_date: next_offset_date,
      next_offset_message_id: next_offset_message_id,
      next_offset_message_thread_id: next_offset_message_thread_id,
    );
  }
}

/// A plain text.
///
class RichTextPlain extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextPlain";

  /// Text.
  late String text;

  /// A plain text
  RichTextPlain({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextPlain',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextPlain? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    return RichTextPlain(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// A bold rich text.
///
class RichTextBold extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextBold";

  /// Text.
  late RichText text;

  /// A bold rich text
  RichTextBold({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextBold',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextBold? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    return RichTextBold(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// An italicized rich text.
///
class RichTextItalic extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextItalic";

  /// Text.
  late RichText text;

  /// An italicized rich text
  RichTextItalic({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextItalic',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextItalic? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    return RichTextItalic(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// An underlined rich text.
///
class RichTextUnderline extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextUnderline";

  /// Text.
  late RichText text;

  /// An underlined rich text
  RichTextUnderline({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextUnderline',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextUnderline? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    return RichTextUnderline(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// A strikethrough rich text.
///
class RichTextStrikethrough extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextStrikethrough";

  /// Text.
  late RichText text;

  /// A strikethrough rich text
  RichTextStrikethrough({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextStrikethrough',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextStrikethrough? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    return RichTextStrikethrough(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// A fixed-width rich text.
///
class RichTextFixed extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextFixed";

  /// Text.
  late RichText text;

  /// A fixed-width rich text
  RichTextFixed({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextFixed',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextFixed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    return RichTextFixed(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// A rich text URL link.
///
class RichTextUrl extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextUrl";

  /// Text.
  late RichText text;

  /// URL.
  late String url;

  /// True, if the URL has cached instant view server-side.
  late bool is_cached;

  /// A rich text URL link
  RichTextUrl(
      {required this.text,
      required this.url,
      required this.is_cached,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextUrl',
      if (extra != null) '@extra': extra,
      'text': text,
      'url': url,
      'is_cached': is_cached
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    var url = _map['url']! as String;
    var is_cached = _map['is_cached']! as bool;
    return RichTextUrl(
      extra: extra,
      clientId: clientId,
      text: text,
      url: url,
      is_cached: is_cached,
    );
  }
}

/// A rich text email link.
///
class RichTextEmailAddress extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextEmailAddress";

  /// Text.
  late RichText text;

  /// Email address.
  late String email_address;

  /// A rich text email link
  RichTextEmailAddress(
      {required this.text,
      required this.email_address,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextEmailAddress',
      if (extra != null) '@extra': extra,
      'text': text,
      'email_address': email_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    var email_address = _map['email_address']! as String;
    return RichTextEmailAddress(
      extra: extra,
      clientId: clientId,
      text: text,
      email_address: email_address,
    );
  }
}

/// A subscript rich text.
///
class RichTextSubscript extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextSubscript";

  /// Text.
  late RichText text;

  /// A subscript rich text
  RichTextSubscript({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextSubscript',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextSubscript? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    return RichTextSubscript(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// A superscript rich text.
///
class RichTextSuperscript extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextSuperscript";

  /// Text.
  late RichText text;

  /// A superscript rich text
  RichTextSuperscript({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextSuperscript',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextSuperscript? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    return RichTextSuperscript(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// A marked rich text.
///
class RichTextMarked extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextMarked";

  /// Text.
  late RichText text;

  /// A marked rich text
  RichTextMarked({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextMarked',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextMarked? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    return RichTextMarked(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// A rich text phone number.
///
class RichTextPhoneNumber extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextPhoneNumber";

  /// Text.
  late RichText text;

  /// Phone number.
  late String phone_number;

  /// A rich text phone number
  RichTextPhoneNumber(
      {required this.text,
      required this.phone_number,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextPhoneNumber',
      if (extra != null) '@extra': extra,
      'text': text,
      'phone_number': phone_number
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextPhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    var phone_number = _map['phone_number']! as String;
    return RichTextPhoneNumber(
      extra: extra,
      clientId: clientId,
      text: text,
      phone_number: phone_number,
    );
  }
}

/// A small image inside the text.
///
class RichTextIcon extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextIcon";

  /// The image represented as a document. The image can be in GIF, JPEG or PNG format.
  late Document document;

  /// Width of a bounding box in which the image must be shown; 0 if unknown.
  late int width;

  /// Height of a bounding box in which the image must be shown; 0 if unknown.
  late int height;

  /// A small image inside the text
  RichTextIcon(
      {required this.document,
      required this.width,
      required this.height,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextIcon',
      if (extra != null) '@extra': extra,
      'document': document,
      'width': width,
      'height': height
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextIcon? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var document = Document.fromMap(_map['document'])!;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    return RichTextIcon(
      extra: extra,
      clientId: clientId,
      document: document,
      width: width,
      height: height,
    );
  }
}

/// A reference to a richTexts object on the same web page.
///
class RichTextReference extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextReference";

  /// The text.
  late RichText text;

  /// The name of a richTextAnchor object, which is the first element of the target richTexts object.
  late String anchor_name;

  /// An HTTP URL, opening the reference.
  late String url;

  /// A reference to a richTexts object on the same web page
  RichTextReference(
      {required this.text,
      required this.anchor_name,
      required this.url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextReference',
      if (extra != null) '@extra': extra,
      'text': text,
      'anchor_name': anchor_name,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextReference? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    var anchor_name = _map['anchor_name']! as String;
    var url = _map['url']! as String;
    return RichTextReference(
      extra: extra,
      clientId: clientId,
      text: text,
      anchor_name: anchor_name,
      url: url,
    );
  }
}

/// An anchor.
///
class RichTextAnchor extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextAnchor";

  /// Anchor name.
  late String name;

  /// An anchor
  RichTextAnchor({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextAnchor',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextAnchor? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return RichTextAnchor(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// A link to an anchor on the same web page.
///
class RichTextAnchorLink extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTextAnchorLink";

  /// The link text.
  late RichText text;

  /// The anchor name. If the name is empty, the link must bring back to top.
  late String anchor_name;

  /// An HTTP URL, opening the anchor.
  late String url;

  /// A link to an anchor on the same web page
  RichTextAnchorLink(
      {required this.text,
      required this.anchor_name,
      required this.url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTextAnchorLink',
      if (extra != null) '@extra': extra,
      'text': text,
      'anchor_name': anchor_name,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTextAnchorLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    var anchor_name = _map['anchor_name']! as String;
    var url = _map['url']! as String;
    return RichTextAnchorLink(
      extra: extra,
      clientId: clientId,
      text: text,
      anchor_name: anchor_name,
      url: url,
    );
  }
}

/// A concatenation of rich texts.
///
class RichTexts extends RichText {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "richTexts";

  /// Texts.
  late List<RichText> texts;

  /// A concatenation of rich texts
  RichTexts({required this.texts, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'richTexts',
      if (extra != null) '@extra': extra,
      'texts': texts
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RichTexts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var texts = List<RichText>.from(
      (_map["texts"] ?? []).map(
        (e) => RichText.fromMap(e),
      ),
    );
    return RichTexts(
      extra: extra,
      clientId: clientId,
      texts: texts,
    );
  }
}

/// Contains a caption of an instant view web page block, consisting of a text and a trailing credit.
///
class PageBlockCaption extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockCaption";

  /// Content of the caption.
  late RichText text;

  /// Block credit (like HTML tag <cite>).
  late RichText credit;

  /// Contains a caption of an instant view web page block, consisting of a text and a trailing credit
  PageBlockCaption(
      {required this.text, required this.credit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockCaption',
      if (extra != null) '@extra': extra,
      'text': text,
      'credit': credit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockCaption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    var credit = RichText.fromMap(_map['credit'])!;
    return PageBlockCaption(
      extra: extra,
      clientId: clientId,
      text: text,
      credit: credit,
    );
  }
}

/// Describes an item of a list page block.
///
class PageBlockListItem extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockListItem";

  /// Item label.
  late String label;

  /// Item blocks.
  late List<PageBlock> page_blocks;

  /// Describes an item of a list page block
  PageBlockListItem(
      {required this.label,
      required this.page_blocks,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockListItem',
      if (extra != null) '@extra': extra,
      'label': label,
      'page_blocks': page_blocks
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockListItem? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var label = _map['label']! as String;
    var page_blocks = List<PageBlock>.from(
      (_map["page_blocks"] ?? []).map(
        (e) => PageBlock.fromMap(e),
      ),
    );
    return PageBlockListItem(
      extra: extra,
      clientId: clientId,
      label: label,
      page_blocks: page_blocks,
    );
  }
}

/// The content must be left-aligned.
///
class PageBlockHorizontalAlignmentLeft extends PageBlockHorizontalAlignment {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockHorizontalAlignmentLeft";

  /// The content must be left-aligned
  PageBlockHorizontalAlignmentLeft({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockHorizontalAlignmentLeft',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockHorizontalAlignmentLeft? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PageBlockHorizontalAlignmentLeft(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The content must be center-aligned.
///
class PageBlockHorizontalAlignmentCenter extends PageBlockHorizontalAlignment {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockHorizontalAlignmentCenter";

  /// The content must be center-aligned
  PageBlockHorizontalAlignmentCenter({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockHorizontalAlignmentCenter',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockHorizontalAlignmentCenter? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PageBlockHorizontalAlignmentCenter(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The content must be right-aligned.
///
class PageBlockHorizontalAlignmentRight extends PageBlockHorizontalAlignment {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockHorizontalAlignmentRight";

  /// The content must be right-aligned
  PageBlockHorizontalAlignmentRight({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockHorizontalAlignmentRight',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockHorizontalAlignmentRight? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PageBlockHorizontalAlignmentRight(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The content must be top-aligned.
///
class PageBlockVerticalAlignmentTop extends PageBlockVerticalAlignment {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockVerticalAlignmentTop";

  /// The content must be top-aligned
  PageBlockVerticalAlignmentTop({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockVerticalAlignmentTop',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockVerticalAlignmentTop? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PageBlockVerticalAlignmentTop(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The content must be middle-aligned.
///
class PageBlockVerticalAlignmentMiddle extends PageBlockVerticalAlignment {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockVerticalAlignmentMiddle";

  /// The content must be middle-aligned
  PageBlockVerticalAlignmentMiddle({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockVerticalAlignmentMiddle',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockVerticalAlignmentMiddle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PageBlockVerticalAlignmentMiddle(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The content must be bottom-aligned.
///
class PageBlockVerticalAlignmentBottom extends PageBlockVerticalAlignment {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockVerticalAlignmentBottom";

  /// The content must be bottom-aligned
  PageBlockVerticalAlignmentBottom({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockVerticalAlignmentBottom',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockVerticalAlignmentBottom? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PageBlockVerticalAlignmentBottom(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents a cell of a table.
///
class PageBlockTableCell extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockTableCell";

  /// Cell text; may be null. If the text is null, then the cell must be invisible.
  RichText? text;

  /// True, if it is a header cell.
  late bool is_header;

  /// The number of columns the cell spans.
  late int colspan;

  /// The number of rows the cell spans.
  late int rowspan;

  /// Horizontal cell content alignment.
  late PageBlockHorizontalAlignment align;

  /// Vertical cell content alignment.
  late PageBlockVerticalAlignment valign;

  /// Represents a cell of a table
  PageBlockTableCell(
      {this.text,
      required this.is_header,
      required this.colspan,
      required this.rowspan,
      required this.align,
      required this.valign,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockTableCell',
      if (extra != null) '@extra': extra,
      'text': text,
      'is_header': is_header,
      'colspan': colspan,
      'rowspan': rowspan,
      'align': align,
      'valign': valign
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockTableCell? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text']);
    var is_header = _map['is_header']! as bool;
    var colspan = _map['colspan']! as int;
    var rowspan = _map['rowspan']! as int;
    var align = PageBlockHorizontalAlignment.fromMap(_map['align'])!;
    var valign = PageBlockVerticalAlignment.fromMap(_map['valign'])!;
    return PageBlockTableCell(
      extra: extra,
      clientId: clientId,
      text: text,
      is_header: is_header,
      colspan: colspan,
      rowspan: rowspan,
      align: align,
      valign: valign,
    );
  }
}

/// Contains information about a related article.
///
class PageBlockRelatedArticle extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockRelatedArticle";

  /// Related article URL.
  late String url;

  /// Article title; may be empty.
  late String title;

  /// Article description; may be empty.
  late String description;

  /// Article photo; may be null.
  Photo? photo;

  /// Article author; may be empty.
  late String author;

  /// Point in time (Unix timestamp) when the article was published; 0 if unknown.
  late int publish_date;

  /// Contains information about a related article
  PageBlockRelatedArticle(
      {required this.url,
      required this.title,
      required this.description,
      this.photo,
      required this.author,
      required this.publish_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockRelatedArticle',
      if (extra != null) '@extra': extra,
      'url': url,
      'title': title,
      'description': description,
      'photo': photo,
      'author': author,
      'publish_date': publish_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockRelatedArticle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    var photo = Photo.fromMap(_map['photo']);
    var author = _map['author']! as String;
    var publish_date = _map['publish_date']! as int;
    return PageBlockRelatedArticle(
      extra: extra,
      clientId: clientId,
      url: url,
      title: title,
      description: description,
      photo: photo,
      author: author,
      publish_date: publish_date,
    );
  }
}

/// The title of a page.
///
class PageBlockTitle extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockTitle";

  /// Title.
  late RichText title;

  /// The title of a page
  PageBlockTitle({required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockTitle',
      if (extra != null) '@extra': extra,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockTitle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = RichText.fromMap(_map['title'])!;
    return PageBlockTitle(
      extra: extra,
      clientId: clientId,
      title: title,
    );
  }
}

/// The subtitle of a page.
///
class PageBlockSubtitle extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockSubtitle";

  /// Subtitle.
  late RichText subtitle;

  /// The subtitle of a page
  PageBlockSubtitle({required this.subtitle, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockSubtitle',
      if (extra != null) '@extra': extra,
      'subtitle': subtitle
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockSubtitle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var subtitle = RichText.fromMap(_map['subtitle'])!;
    return PageBlockSubtitle(
      extra: extra,
      clientId: clientId,
      subtitle: subtitle,
    );
  }
}

/// The author and publishing date of a page.
///
class PageBlockAuthorDate extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockAuthorDate";

  /// Author.
  late RichText author;

  /// Point in time (Unix timestamp) when the article was published; 0 if unknown.
  late int publish_date;

  /// The author and publishing date of a page
  PageBlockAuthorDate(
      {required this.author,
      required this.publish_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockAuthorDate',
      if (extra != null) '@extra': extra,
      'author': author,
      'publish_date': publish_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockAuthorDate? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var author = RichText.fromMap(_map['author'])!;
    var publish_date = _map['publish_date']! as int;
    return PageBlockAuthorDate(
      extra: extra,
      clientId: clientId,
      author: author,
      publish_date: publish_date,
    );
  }
}

/// A header.
///
class PageBlockHeader extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockHeader";

  /// Header.
  late RichText header;

  /// A header
  PageBlockHeader({required this.header, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockHeader',
      if (extra != null) '@extra': extra,
      'header': header
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockHeader? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var header = RichText.fromMap(_map['header'])!;
    return PageBlockHeader(
      extra: extra,
      clientId: clientId,
      header: header,
    );
  }
}

/// A subheader.
///
class PageBlockSubheader extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockSubheader";

  /// Subheader.
  late RichText subheader;

  /// A subheader
  PageBlockSubheader({required this.subheader, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockSubheader',
      if (extra != null) '@extra': extra,
      'subheader': subheader
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockSubheader? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var subheader = RichText.fromMap(_map['subheader'])!;
    return PageBlockSubheader(
      extra: extra,
      clientId: clientId,
      subheader: subheader,
    );
  }
}

/// A kicker.
///
class PageBlockKicker extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockKicker";

  /// Kicker.
  late RichText kicker;

  /// A kicker
  PageBlockKicker({required this.kicker, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockKicker',
      if (extra != null) '@extra': extra,
      'kicker': kicker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockKicker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var kicker = RichText.fromMap(_map['kicker'])!;
    return PageBlockKicker(
      extra: extra,
      clientId: clientId,
      kicker: kicker,
    );
  }
}

/// A text paragraph.
///
class PageBlockParagraph extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockParagraph";

  /// Paragraph text.
  late RichText text;

  /// A text paragraph
  PageBlockParagraph({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockParagraph',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockParagraph? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    return PageBlockParagraph(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// A preformatted text paragraph.
///
class PageBlockPreformatted extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockPreformatted";

  /// Paragraph text.
  late RichText text;

  /// Programming language for which the text needs to be formatted.
  late String language;

  /// A preformatted text paragraph
  PageBlockPreformatted(
      {required this.text, required this.language, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockPreformatted',
      if (extra != null) '@extra': extra,
      'text': text,
      'language': language
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockPreformatted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    var language = _map['language']! as String;
    return PageBlockPreformatted(
      extra: extra,
      clientId: clientId,
      text: text,
      language: language,
    );
  }
}

/// The footer of a page.
///
class PageBlockFooter extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockFooter";

  /// Footer.
  late RichText footer;

  /// The footer of a page
  PageBlockFooter({required this.footer, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockFooter',
      if (extra != null) '@extra': extra,
      'footer': footer
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockFooter? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var footer = RichText.fromMap(_map['footer'])!;
    return PageBlockFooter(
      extra: extra,
      clientId: clientId,
      footer: footer,
    );
  }
}

/// An empty block separating a page.
///
class PageBlockDivider extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockDivider";

  /// An empty block separating a page
  PageBlockDivider({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'pageBlockDivider', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockDivider? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PageBlockDivider(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor.
///
class PageBlockAnchor extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockAnchor";

  /// Name of the anchor.
  late String name;

  /// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
  PageBlockAnchor({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockAnchor',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockAnchor? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return PageBlockAnchor(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// A list of data blocks.
///
class PageBlockList extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockList";

  /// The items of the list.
  late List<PageBlockListItem> items;

  /// A list of data blocks
  PageBlockList({required this.items, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockList',
      if (extra != null) '@extra': extra,
      'items': items
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockList? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var items = List<PageBlockListItem>.from(
      (_map["items"] ?? []).map(
        (e) => PageBlockListItem.fromMap(e),
      ),
    );
    return PageBlockList(
      extra: extra,
      clientId: clientId,
      items: items,
    );
  }
}

/// A block quote.
///
class PageBlockBlockQuote extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockBlockQuote";

  /// Quote text.
  late RichText text;

  /// Quote credit.
  late RichText credit;

  /// A block quote
  PageBlockBlockQuote(
      {required this.text, required this.credit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockBlockQuote',
      if (extra != null) '@extra': extra,
      'text': text,
      'credit': credit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockBlockQuote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    var credit = RichText.fromMap(_map['credit'])!;
    return PageBlockBlockQuote(
      extra: extra,
      clientId: clientId,
      text: text,
      credit: credit,
    );
  }
}

/// A pull quote.
///
class PageBlockPullQuote extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockPullQuote";

  /// Quote text.
  late RichText text;

  /// Quote credit.
  late RichText credit;

  /// A pull quote
  PageBlockPullQuote(
      {required this.text, required this.credit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockPullQuote',
      if (extra != null) '@extra': extra,
      'text': text,
      'credit': credit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockPullQuote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = RichText.fromMap(_map['text'])!;
    var credit = RichText.fromMap(_map['credit'])!;
    return PageBlockPullQuote(
      extra: extra,
      clientId: clientId,
      text: text,
      credit: credit,
    );
  }
}

/// An animation.
///
class PageBlockAnimation extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockAnimation";

  /// Animation file; may be null.
  Animation? animation;

  /// Animation caption.
  late PageBlockCaption caption;

  /// True, if the animation must be played automatically.
  late bool need_autoplay;

  /// An animation
  PageBlockAnimation(
      {this.animation,
      required this.caption,
      required this.need_autoplay,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockAnimation',
      if (extra != null) '@extra': extra,
      'animation': animation,
      'caption': caption,
      'need_autoplay': need_autoplay
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animation = Animation.fromMap(_map['animation']);
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    var need_autoplay = _map['need_autoplay']! as bool;
    return PageBlockAnimation(
      extra: extra,
      clientId: clientId,
      animation: animation,
      caption: caption,
      need_autoplay: need_autoplay,
    );
  }
}

/// An audio file.
///
class PageBlockAudio extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockAudio";

  /// Audio file; may be null.
  Audio? audio;

  /// Audio file caption.
  late PageBlockCaption caption;

  /// An audio file
  PageBlockAudio(
      {this.audio, required this.caption, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockAudio',
      if (extra != null) '@extra': extra,
      'audio': audio,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockAudio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var audio = Audio.fromMap(_map['audio']);
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    return PageBlockAudio(
      extra: extra,
      clientId: clientId,
      audio: audio,
      caption: caption,
    );
  }
}

/// A photo.
///
class PageBlockPhoto extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockPhoto";

  /// Photo file; may be null.
  Photo? photo;

  /// Photo caption.
  late PageBlockCaption caption;

  /// URL that needs to be opened when the photo is clicked.
  late String url;

  /// A photo
  PageBlockPhoto(
      {this.photo,
      required this.caption,
      required this.url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockPhoto',
      if (extra != null) '@extra': extra,
      'photo': photo,
      'caption': caption,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = Photo.fromMap(_map['photo']);
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    var url = _map['url']! as String;
    return PageBlockPhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
      caption: caption,
      url: url,
    );
  }
}

/// A video.
///
class PageBlockVideo extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockVideo";

  /// Video file; may be null.
  Video? video;

  /// Video caption.
  late PageBlockCaption caption;

  /// True, if the video must be played automatically.
  late bool need_autoplay;

  /// True, if the video must be looped.
  late bool is_looped;

  /// A video
  PageBlockVideo(
      {this.video,
      required this.caption,
      required this.need_autoplay,
      required this.is_looped,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockVideo',
      if (extra != null) '@extra': extra,
      'video': video,
      'caption': caption,
      'need_autoplay': need_autoplay,
      'is_looped': is_looped
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video = Video.fromMap(_map['video']);
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    var need_autoplay = _map['need_autoplay']! as bool;
    var is_looped = _map['is_looped']! as bool;
    return PageBlockVideo(
      extra: extra,
      clientId: clientId,
      video: video,
      caption: caption,
      need_autoplay: need_autoplay,
      is_looped: is_looped,
    );
  }
}

/// A voice note.
///
class PageBlockVoiceNote extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockVoiceNote";

  /// Voice note; may be null.
  VoiceNote? voice_note;

  /// Voice note caption.
  late PageBlockCaption caption;

  /// A voice note
  PageBlockVoiceNote(
      {this.voice_note, required this.caption, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockVoiceNote',
      if (extra != null) '@extra': extra,
      'voice_note': voice_note,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var voice_note = VoiceNote.fromMap(_map['voice_note']);
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    return PageBlockVoiceNote(
      extra: extra,
      clientId: clientId,
      voice_note: voice_note,
      caption: caption,
    );
  }
}

/// A page cover.
///
class PageBlockCover extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockCover";

  /// Cover.
  late PageBlock cover;

  /// A page cover
  PageBlockCover({required this.cover, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockCover',
      if (extra != null) '@extra': extra,
      'cover': cover
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockCover? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var cover = PageBlock.fromMap(_map['cover'])!;
    return PageBlockCover(
      extra: extra,
      clientId: clientId,
      cover: cover,
    );
  }
}

/// An embedded web page.
///
class PageBlockEmbedded extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockEmbedded";

  /// Web page URL, if available.
  late String url;

  /// HTML-markup of the embedded page.
  late String html;

  /// Poster photo, if available; may be null.
  Photo? poster_photo;

  /// Block width; 0 if unknown.
  late int width;

  /// Block height; 0 if unknown.
  late int height;

  /// Block caption.
  late PageBlockCaption caption;

  /// True, if the block must be full width.
  late bool is_full_width;

  /// True, if scrolling needs to be allowed.
  late bool allow_scrolling;

  /// An embedded web page
  PageBlockEmbedded(
      {required this.url,
      required this.html,
      this.poster_photo,
      required this.width,
      required this.height,
      required this.caption,
      required this.is_full_width,
      required this.allow_scrolling,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockEmbedded',
      if (extra != null) '@extra': extra,
      'url': url,
      'html': html,
      'poster_photo': poster_photo,
      'width': width,
      'height': height,
      'caption': caption,
      'is_full_width': is_full_width,
      'allow_scrolling': allow_scrolling
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockEmbedded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var html = _map['html']! as String;
    var poster_photo = Photo.fromMap(_map['poster_photo']);
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    var is_full_width = _map['is_full_width']! as bool;
    var allow_scrolling = _map['allow_scrolling']! as bool;
    return PageBlockEmbedded(
      extra: extra,
      clientId: clientId,
      url: url,
      html: html,
      poster_photo: poster_photo,
      width: width,
      height: height,
      caption: caption,
      is_full_width: is_full_width,
      allow_scrolling: allow_scrolling,
    );
  }
}

/// An embedded post.
///
class PageBlockEmbeddedPost extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockEmbeddedPost";

  /// Web page URL.
  late String url;

  /// Post author.
  late String author;

  /// Post author photo; may be null.
  Photo? author_photo;

  /// Point in time (Unix timestamp) when the post was created; 0 if unknown.
  late int date;

  /// Post content.
  late List<PageBlock> page_blocks;

  /// Post caption.
  late PageBlockCaption caption;

  /// An embedded post
  PageBlockEmbeddedPost(
      {required this.url,
      required this.author,
      this.author_photo,
      required this.date,
      required this.page_blocks,
      required this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockEmbeddedPost',
      if (extra != null) '@extra': extra,
      'url': url,
      'author': author,
      'author_photo': author_photo,
      'date': date,
      'page_blocks': page_blocks,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockEmbeddedPost? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var author = _map['author']! as String;
    var author_photo = Photo.fromMap(_map['author_photo']);
    var date = _map['date']! as int;
    var page_blocks = List<PageBlock>.from(
      (_map["page_blocks"] ?? []).map(
        (e) => PageBlock.fromMap(e),
      ),
    );
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    return PageBlockEmbeddedPost(
      extra: extra,
      clientId: clientId,
      url: url,
      author: author,
      author_photo: author_photo,
      date: date,
      page_blocks: page_blocks,
      caption: caption,
    );
  }
}

/// A collage.
///
class PageBlockCollage extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockCollage";

  /// Collage item contents.
  late List<PageBlock> page_blocks;

  /// Block caption.
  late PageBlockCaption caption;

  /// A collage
  PageBlockCollage(
      {required this.page_blocks,
      required this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockCollage',
      if (extra != null) '@extra': extra,
      'page_blocks': page_blocks,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockCollage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var page_blocks = List<PageBlock>.from(
      (_map["page_blocks"] ?? []).map(
        (e) => PageBlock.fromMap(e),
      ),
    );
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    return PageBlockCollage(
      extra: extra,
      clientId: clientId,
      page_blocks: page_blocks,
      caption: caption,
    );
  }
}

/// A slideshow.
///
class PageBlockSlideshow extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockSlideshow";

  /// Slideshow item contents.
  late List<PageBlock> page_blocks;

  /// Block caption.
  late PageBlockCaption caption;

  /// A slideshow
  PageBlockSlideshow(
      {required this.page_blocks,
      required this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockSlideshow',
      if (extra != null) '@extra': extra,
      'page_blocks': page_blocks,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockSlideshow? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var page_blocks = List<PageBlock>.from(
      (_map["page_blocks"] ?? []).map(
        (e) => PageBlock.fromMap(e),
      ),
    );
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    return PageBlockSlideshow(
      extra: extra,
      clientId: clientId,
      page_blocks: page_blocks,
      caption: caption,
    );
  }
}

/// A link to a chat.
///
class PageBlockChatLink extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockChatLink";

  /// Chat title.
  late String title;

  /// Chat photo; may be null.
  ChatPhotoInfo? photo;

  /// Chat username by which all other information about the chat can be resolved.
  late String username;

  /// A link to a chat
  PageBlockChatLink(
      {required this.title,
      this.photo,
      required this.username,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockChatLink',
      if (extra != null) '@extra': extra,
      'title': title,
      'photo': photo,
      'username': username
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockChatLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var photo = ChatPhotoInfo.fromMap(_map['photo']);
    var username = _map['username']! as String;
    return PageBlockChatLink(
      extra: extra,
      clientId: clientId,
      title: title,
      photo: photo,
      username: username,
    );
  }
}

/// A table.
///
class PageBlockTable extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockTable";

  /// Table caption.
  late RichText caption;

  /// Table cells.
  late List<List<PageBlockTableCell>> cells;

  /// True, if the table is bordered.
  late bool is_bordered;

  /// True, if the table is striped.
  late bool is_striped;

  /// A table
  PageBlockTable(
      {required this.caption,
      required this.cells,
      required this.is_bordered,
      required this.is_striped,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockTable',
      if (extra != null) '@extra': extra,
      'caption': caption,
      'cells': cells,
      'is_bordered': is_bordered,
      'is_striped': is_striped
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockTable? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var caption = RichText.fromMap(_map['caption'])!;
    var cells = List<List<PageBlockTableCell>>.from(
      (_map["cells"] ?? []).map(
        (e) => List<PageBlockTableCell>.from(
          (e ?? []).map(
            (e) => PageBlockTableCell.fromMap(e),
          ),
        ),
      ),
    );
    var is_bordered = _map['is_bordered']! as bool;
    var is_striped = _map['is_striped']! as bool;
    return PageBlockTable(
      extra: extra,
      clientId: clientId,
      caption: caption,
      cells: cells,
      is_bordered: is_bordered,
      is_striped: is_striped,
    );
  }
}

/// A collapsible block.
///
class PageBlockDetails extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockDetails";

  /// Always visible heading for the block.
  late RichText header;

  /// Block contents.
  late List<PageBlock> page_blocks;

  /// True, if the block is open by default.
  late bool is_open;

  /// A collapsible block
  PageBlockDetails(
      {required this.header,
      required this.page_blocks,
      required this.is_open,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockDetails',
      if (extra != null) '@extra': extra,
      'header': header,
      'page_blocks': page_blocks,
      'is_open': is_open
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockDetails? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var header = RichText.fromMap(_map['header'])!;
    var page_blocks = List<PageBlock>.from(
      (_map["page_blocks"] ?? []).map(
        (e) => PageBlock.fromMap(e),
      ),
    );
    var is_open = _map['is_open']! as bool;
    return PageBlockDetails(
      extra: extra,
      clientId: clientId,
      header: header,
      page_blocks: page_blocks,
      is_open: is_open,
    );
  }
}

/// Related articles.
///
class PageBlockRelatedArticles extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockRelatedArticles";

  /// Block header.
  late RichText header;

  /// List of related articles.
  late List<PageBlockRelatedArticle> articles;

  /// Related articles
  PageBlockRelatedArticles(
      {required this.header,
      required this.articles,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockRelatedArticles',
      if (extra != null) '@extra': extra,
      'header': header,
      'articles': articles
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockRelatedArticles? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var header = RichText.fromMap(_map['header'])!;
    var articles = List<PageBlockRelatedArticle>.from(
      (_map["articles"] ?? []).map(
        (e) => PageBlockRelatedArticle.fromMap(e),
      ),
    );
    return PageBlockRelatedArticles(
      extra: extra,
      clientId: clientId,
      header: header,
      articles: articles,
    );
  }
}

/// A map.
///
class PageBlockMap extends PageBlock {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pageBlockMap";

  /// Location of the map center.
  late Location location;

  /// Map zoom level.
  late int zoom;

  /// Map width.
  late int width;

  /// Map height.
  late int height;

  /// Block caption.
  late PageBlockCaption caption;

  /// A map
  PageBlockMap(
      {required this.location,
      required this.zoom,
      required this.width,
      required this.height,
      required this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pageBlockMap',
      if (extra != null) '@extra': extra,
      'location': location,
      'zoom': zoom,
      'width': width,
      'height': height,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PageBlockMap? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    var zoom = _map['zoom']! as int;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var caption = PageBlockCaption.fromMap(_map['caption'])!;
    return PageBlockMap(
      extra: extra,
      clientId: clientId,
      location: location,
      zoom: zoom,
      width: width,
      height: height,
      caption: caption,
    );
  }
}

/// Describes an instant view page for a web page.
///
class WebPageInstantView extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "webPageInstantView";

  /// Content of the web page.
  late List<PageBlock> page_blocks;

  /// Number of the instant view views; 0 if unknown.
  late int view_count;

  /// Version of the instant view; currently, can be 1 or 2.
  late int version;

  /// True, if the instant view must be shown from right to left.
  late bool is_rtl;

  /// True, if the instant view contains the full page. A network request might be needed to get the full web page instant view.
  late bool is_full;

  /// An internal link to be opened to leave feedback about the instant view.
  late InternalLinkType feedback_link;

  /// Describes an instant view page for a web page
  WebPageInstantView(
      {required this.page_blocks,
      required this.view_count,
      required this.version,
      required this.is_rtl,
      required this.is_full,
      required this.feedback_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'webPageInstantView',
      if (extra != null) '@extra': extra,
      'page_blocks': page_blocks,
      'view_count': view_count,
      'version': version,
      'is_rtl': is_rtl,
      'is_full': is_full,
      'feedback_link': feedback_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static WebPageInstantView? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var page_blocks = List<PageBlock>.from(
      (_map["page_blocks"] ?? []).map(
        (e) => PageBlock.fromMap(e),
      ),
    );
    var view_count = _map['view_count']! as int;
    var version = _map['version']! as int;
    var is_rtl = _map['is_rtl']! as bool;
    var is_full = _map['is_full']! as bool;
    var feedback_link = InternalLinkType.fromMap(_map['feedback_link'])!;
    return WebPageInstantView(
      extra: extra,
      clientId: clientId,
      page_blocks: page_blocks,
      view_count: view_count,
      version: version,
      is_rtl: is_rtl,
      is_full: is_full,
      feedback_link: feedback_link,
    );
  }
}

/// Describes a web page preview.
///
class WebPage extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "webPage";

  /// Original URL of the link.
  late String url;

  /// URL to display.
  late String display_url;

  /// Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else.
  late String type;

  /// Short name of the site (e.g., Google Docs, App Store).
  late String site_name;

  /// Title of the content.
  late String title;

  /// Description of the content.
  late FormattedText description;

  /// Image representing the content; may be null.
  Photo? photo;

  /// URL to show in the embedded preview.
  late String embed_url;

  /// MIME type of the embedded preview, (e.g., text/html or video/mp4).
  late String embed_type;

  /// Width of the embedded preview.
  late int embed_width;

  /// Height of the embedded preview.
  late int embed_height;

  /// Duration of the content, in seconds.
  late int duration;

  /// Author of the content.
  late String author;

  /// Preview of the content as an animation, if available; may be null.
  Animation? animation;

  /// Preview of the content as an audio file, if available; may be null.
  Audio? audio;

  /// Preview of the content as a document, if available; may be null.
  Document? document;

  /// Preview of the content as a sticker for small WEBP files, if available; may be null.
  Sticker? sticker;

  /// Preview of the content as a video, if available; may be null.
  Video? video;

  /// Preview of the content as a video note, if available; may be null.
  VideoNote? video_note;

  /// Preview of the content as a voice note, if available; may be null.
  VoiceNote? voice_note;

  /// The identifier of the sender of the previewed story; 0 if none.
  late int story_sender_chat_id;

  /// The identifier of the previewed story; 0 if none.
  late int story_id;

  /// Version of web page instant view (currently, can be 1 or 2); 0 if none.
  late int instant_view_version;

  /// Describes a web page preview
  WebPage(
      {required this.url,
      required this.display_url,
      required this.type,
      required this.site_name,
      required this.title,
      required this.description,
      this.photo,
      required this.embed_url,
      required this.embed_type,
      required this.embed_width,
      required this.embed_height,
      required this.duration,
      required this.author,
      this.animation,
      this.audio,
      this.document,
      this.sticker,
      this.video,
      this.video_note,
      this.voice_note,
      required this.story_sender_chat_id,
      required this.story_id,
      required this.instant_view_version,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'webPage',
      if (extra != null) '@extra': extra,
      'url': url,
      'display_url': display_url,
      'type': type,
      'site_name': site_name,
      'title': title,
      'description': description,
      'photo': photo,
      'embed_url': embed_url,
      'embed_type': embed_type,
      'embed_width': embed_width,
      'embed_height': embed_height,
      'duration': duration,
      'author': author,
      'animation': animation,
      'audio': audio,
      'document': document,
      'sticker': sticker,
      'video': video,
      'video_note': video_note,
      'voice_note': voice_note,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id,
      'instant_view_version': instant_view_version
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static WebPage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var display_url = _map['display_url']! as String;
    var type = _map['type']! as String;
    var site_name = _map['site_name']! as String;
    var title = _map['title']! as String;
    var description = FormattedText.fromMap(_map['description'])!;
    var photo = Photo.fromMap(_map['photo']);
    var embed_url = _map['embed_url']! as String;
    var embed_type = _map['embed_type']! as String;
    var embed_width = _map['embed_width']! as int;
    var embed_height = _map['embed_height']! as int;
    var duration = _map['duration']! as int;
    var author = _map['author']! as String;
    var animation = Animation.fromMap(_map['animation']);
    var audio = Audio.fromMap(_map['audio']);
    var document = Document.fromMap(_map['document']);
    var sticker = Sticker.fromMap(_map['sticker']);
    var video = Video.fromMap(_map['video']);
    var video_note = VideoNote.fromMap(_map['video_note']);
    var voice_note = VoiceNote.fromMap(_map['voice_note']);
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    var instant_view_version = _map['instant_view_version']! as int;
    return WebPage(
      extra: extra,
      clientId: clientId,
      url: url,
      display_url: display_url,
      type: type,
      site_name: site_name,
      title: title,
      description: description,
      photo: photo,
      embed_url: embed_url,
      embed_type: embed_type,
      embed_width: embed_width,
      embed_height: embed_height,
      duration: duration,
      author: author,
      animation: animation,
      audio: audio,
      document: document,
      sticker: sticker,
      video: video,
      video_note: video_note,
      voice_note: voice_note,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
      instant_view_version: instant_view_version,
    );
  }
}

/// Contains information about a country.
///
class CountryInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "countryInfo";

  /// A two-letter ISO 3166-1 alpha-2 country code.
  late String country_code;

  /// Native name of the country.
  late String name;

  /// English name of the country.
  late String english_name;

  /// True, if the country must be hidden from the list of all countries.
  late bool is_hidden;

  /// List of country calling codes.
  late List<String> calling_codes;

  /// Contains information about a country
  CountryInfo(
      {required this.country_code,
      required this.name,
      required this.english_name,
      required this.is_hidden,
      required this.calling_codes,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'countryInfo',
      if (extra != null) '@extra': extra,
      'country_code': country_code,
      'name': name,
      'english_name': english_name,
      'is_hidden': is_hidden,
      'calling_codes': calling_codes
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CountryInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var country_code = _map['country_code']! as String;
    var name = _map['name']! as String;
    var english_name = _map['english_name']! as String;
    var is_hidden = _map['is_hidden']! as bool;
    var calling_codes = List<String>.from(
      (_map["calling_codes"] ?? []).map(
        (e) => e as String,
      ),
    );
    return CountryInfo(
      extra: extra,
      clientId: clientId,
      country_code: country_code,
      name: name,
      english_name: english_name,
      is_hidden: is_hidden,
      calling_codes: calling_codes,
    );
  }
}

/// Contains information about countries.
///
class Countries extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "countries";

  /// The list of countries.
  late List<CountryInfo> countries;

  /// Contains information about countries
  Countries({required this.countries, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'countries',
      if (extra != null) '@extra': extra,
      'countries': countries
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Countries? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var countries = List<CountryInfo>.from(
      (_map["countries"] ?? []).map(
        (e) => CountryInfo.fromMap(e),
      ),
    );
    return Countries(
      extra: extra,
      clientId: clientId,
      countries: countries,
    );
  }
}

/// Contains information about a phone number.
///
class PhoneNumberInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "phoneNumberInfo";

  /// Information about the country to which the phone number belongs; may be null.
  CountryInfo? country;

  /// The part of the phone number denoting country calling code or its part.
  late String country_calling_code;

  /// The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user.
  late String formatted_phone_number;

  /// True, if the phone number was bought on Fragment and isn't tied to a SIM card.
  late bool is_anonymous;

  /// Contains information about a phone number
  PhoneNumberInfo(
      {this.country,
      required this.country_calling_code,
      required this.formatted_phone_number,
      required this.is_anonymous,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'phoneNumberInfo',
      if (extra != null) '@extra': extra,
      'country': country,
      'country_calling_code': country_calling_code,
      'formatted_phone_number': formatted_phone_number,
      'is_anonymous': is_anonymous
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PhoneNumberInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var country = CountryInfo.fromMap(_map['country']);
    var country_calling_code = _map['country_calling_code']! as String;
    var formatted_phone_number = _map['formatted_phone_number']! as String;
    var is_anonymous = _map['is_anonymous']! as bool;
    return PhoneNumberInfo(
      extra: extra,
      clientId: clientId,
      country: country,
      country_calling_code: country_calling_code,
      formatted_phone_number: formatted_phone_number,
      is_anonymous: is_anonymous,
    );
  }
}

/// Describes an action associated with a bank card number.
///
class BankCardActionOpenUrl extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "bankCardActionOpenUrl";

  /// Action text.
  late String text;

  /// The URL to be opened.
  late String url;

  /// Describes an action associated with a bank card number
  BankCardActionOpenUrl(
      {required this.text, required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'bankCardActionOpenUrl',
      if (extra != null) '@extra': extra,
      'text': text,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BankCardActionOpenUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var url = _map['url']! as String;
    return BankCardActionOpenUrl(
      extra: extra,
      clientId: clientId,
      text: text,
      url: url,
    );
  }
}

/// Information about a bank card.
///
class BankCardInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "bankCardInfo";

  /// Title of the bank card description.
  late String title;

  /// Actions that can be done with the bank card number.
  late List<BankCardActionOpenUrl> actions;

  /// Information about a bank card
  BankCardInfo(
      {required this.title, required this.actions, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'bankCardInfo',
      if (extra != null) '@extra': extra,
      'title': title,
      'actions': actions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BankCardInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var actions = List<BankCardActionOpenUrl>.from(
      (_map["actions"] ?? []).map(
        (e) => BankCardActionOpenUrl.fromMap(e),
      ),
    );
    return BankCardInfo(
      extra: extra,
      clientId: clientId,
      title: title,
      actions: actions,
    );
  }
}

/// Describes an address.
///
class Address extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "address";

  /// A two-letter ISO 3166-1 alpha-2 country code.
  late String country_code;

  /// State, if applicable.
  late String state;

  /// City.
  late String city;

  /// First line of the address.
  late String street_line1;

  /// Second line of the address.
  late String street_line2;

  /// Address postal code.
  late String postal_code;

  /// Describes an address
  Address(
      {required this.country_code,
      required this.state,
      required this.city,
      required this.street_line1,
      required this.street_line2,
      required this.postal_code,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'address',
      if (extra != null) '@extra': extra,
      'country_code': country_code,
      'state': state,
      'city': city,
      'street_line1': street_line1,
      'street_line2': street_line2,
      'postal_code': postal_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Address? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var country_code = _map['country_code']! as String;
    var state = _map['state']! as String;
    var city = _map['city']! as String;
    var street_line1 = _map['street_line1']! as String;
    var street_line2 = _map['street_line2']! as String;
    var postal_code = _map['postal_code']! as String;
    return Address(
      extra: extra,
      clientId: clientId,
      country_code: country_code,
      state: state,
      city: city,
      street_line1: street_line1,
      street_line2: street_line2,
      postal_code: postal_code,
    );
  }
}

/// Contains parameters of the application theme.
///
class ThemeParameters extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "themeParameters";

  /// A color of the background in the RGB24 format.
  late int background_color;

  /// A secondary color for the background in the RGB24 format.
  late int secondary_background_color;

  /// A color of text in the RGB24 format.
  late int text_color;

  /// A color of hints in the RGB24 format.
  late int hint_color;

  /// A color of links in the RGB24 format.
  late int link_color;

  /// A color of the buttons in the RGB24 format.
  late int button_color;

  /// A color of text on the buttons in the RGB24 format.
  late int button_text_color;

  /// Contains parameters of the application theme
  ThemeParameters(
      {required this.background_color,
      required this.secondary_background_color,
      required this.text_color,
      required this.hint_color,
      required this.link_color,
      required this.button_color,
      required this.button_text_color,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'themeParameters',
      if (extra != null) '@extra': extra,
      'background_color': background_color,
      'secondary_background_color': secondary_background_color,
      'text_color': text_color,
      'hint_color': hint_color,
      'link_color': link_color,
      'button_color': button_color,
      'button_text_color': button_text_color
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ThemeParameters? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var background_color = _map['background_color']! as int;
    var secondary_background_color = _map['secondary_background_color']! as int;
    var text_color = _map['text_color']! as int;
    var hint_color = _map['hint_color']! as int;
    var link_color = _map['link_color']! as int;
    var button_color = _map['button_color']! as int;
    var button_text_color = _map['button_text_color']! as int;
    return ThemeParameters(
      extra: extra,
      clientId: clientId,
      background_color: background_color,
      secondary_background_color: secondary_background_color,
      text_color: text_color,
      hint_color: hint_color,
      link_color: link_color,
      button_color: button_color,
      button_text_color: button_text_color,
    );
  }
}

/// Portion of the price of a product (e.g., "delivery cost", "tax amount").
///
class LabeledPricePart extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "labeledPricePart";

  /// Label for this portion of the product price.
  late String label;

  /// Currency amount in the smallest units of the currency.
  late int amount;

  /// Portion of the price of a product (e.g., "delivery cost", "tax amount")
  LabeledPricePart(
      {required this.label, required this.amount, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'labeledPricePart',
      if (extra != null) '@extra': extra,
      'label': label,
      'amount': amount
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LabeledPricePart? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var label = _map['label']! as String;
    var amount = _map['amount']! as int;
    return LabeledPricePart(
      extra: extra,
      clientId: clientId,
      label: label,
      amount: amount,
    );
  }
}

/// Product invoice.
///
class Invoice extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "invoice";

  /// ISO 4217 currency code.
  late String currency;

  /// A list of objects used to calculate the total price of the product.
  late List<LabeledPricePart> price_parts;

  /// The maximum allowed amount of tip in the smallest units of the currency.
  late int max_tip_amount;

  /// Suggested amounts of tip in the smallest units of the currency.
  late List<int> suggested_tip_amounts;

  /// An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay.
  late String recurring_payment_terms_of_service_url;

  /// An HTTP URL with terms of service for non-recurring payments. If non-empty, then the user must accept the terms of service before allowed to pay.
  late String terms_of_service_url;

  /// True, if the payment is a test payment.
  late bool is_test;

  /// True, if the user's name is needed for payment.
  late bool need_name;

  /// True, if the user's phone number is needed for payment.
  late bool need_phone_number;

  /// True, if the user's email address is needed for payment.
  late bool need_email_address;

  /// True, if the user's shipping address is needed for payment.
  late bool need_shipping_address;

  /// True, if the user's phone number will be sent to the provider.
  late bool send_phone_number_to_provider;

  /// True, if the user's email address will be sent to the provider.
  late bool send_email_address_to_provider;

  /// True, if the total price depends on the shipping method.
  late bool is_flexible;

  /// Product invoice
  Invoice(
      {required this.currency,
      required this.price_parts,
      required this.max_tip_amount,
      required this.suggested_tip_amounts,
      required this.recurring_payment_terms_of_service_url,
      required this.terms_of_service_url,
      required this.is_test,
      required this.need_name,
      required this.need_phone_number,
      required this.need_email_address,
      required this.need_shipping_address,
      required this.send_phone_number_to_provider,
      required this.send_email_address_to_provider,
      required this.is_flexible,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'invoice',
      if (extra != null) '@extra': extra,
      'currency': currency,
      'price_parts': price_parts,
      'max_tip_amount': max_tip_amount,
      'suggested_tip_amounts': suggested_tip_amounts,
      'recurring_payment_terms_of_service_url':
          recurring_payment_terms_of_service_url,
      'terms_of_service_url': terms_of_service_url,
      'is_test': is_test,
      'need_name': need_name,
      'need_phone_number': need_phone_number,
      'need_email_address': need_email_address,
      'need_shipping_address': need_shipping_address,
      'send_phone_number_to_provider': send_phone_number_to_provider,
      'send_email_address_to_provider': send_email_address_to_provider,
      'is_flexible': is_flexible
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Invoice? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var currency = _map['currency']! as String;
    var price_parts = List<LabeledPricePart>.from(
      (_map["price_parts"] ?? []).map(
        (e) => LabeledPricePart.fromMap(e),
      ),
    );
    var max_tip_amount = _map['max_tip_amount']! as int;
    var suggested_tip_amounts = List<int>.from(
      (_map["suggested_tip_amounts"] ?? []).map(
        (e) => e as int,
      ),
    );
    var recurring_payment_terms_of_service_url =
        _map['recurring_payment_terms_of_service_url']! as String;
    var terms_of_service_url = _map['terms_of_service_url']! as String;
    var is_test = _map['is_test']! as bool;
    var need_name = _map['need_name']! as bool;
    var need_phone_number = _map['need_phone_number']! as bool;
    var need_email_address = _map['need_email_address']! as bool;
    var need_shipping_address = _map['need_shipping_address']! as bool;
    var send_phone_number_to_provider =
        _map['send_phone_number_to_provider']! as bool;
    var send_email_address_to_provider =
        _map['send_email_address_to_provider']! as bool;
    var is_flexible = _map['is_flexible']! as bool;
    return Invoice(
      extra: extra,
      clientId: clientId,
      currency: currency,
      price_parts: price_parts,
      max_tip_amount: max_tip_amount,
      suggested_tip_amounts: suggested_tip_amounts,
      recurring_payment_terms_of_service_url:
          recurring_payment_terms_of_service_url,
      terms_of_service_url: terms_of_service_url,
      is_test: is_test,
      need_name: need_name,
      need_phone_number: need_phone_number,
      need_email_address: need_email_address,
      need_shipping_address: need_shipping_address,
      send_phone_number_to_provider: send_phone_number_to_provider,
      send_email_address_to_provider: send_email_address_to_provider,
      is_flexible: is_flexible,
    );
  }
}

/// Order information.
///
class OrderInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "orderInfo";

  /// Name of the user.
  late String name;

  /// Phone number of the user.
  late String phone_number;

  /// Email address of the user.
  late String email_address;

  /// Shipping address for this order; may be null.
  Address? shipping_address;

  /// Order information
  OrderInfo(
      {required this.name,
      required this.phone_number,
      required this.email_address,
      this.shipping_address,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'orderInfo',
      if (extra != null) '@extra': extra,
      'name': name,
      'phone_number': phone_number,
      'email_address': email_address,
      'shipping_address': shipping_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OrderInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var phone_number = _map['phone_number']! as String;
    var email_address = _map['email_address']! as String;
    var shipping_address = Address.fromMap(_map['shipping_address']);
    return OrderInfo(
      extra: extra,
      clientId: clientId,
      name: name,
      phone_number: phone_number,
      email_address: email_address,
      shipping_address: shipping_address,
    );
  }
}

/// One shipping option.
///
class ShippingOption extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "shippingOption";

  /// Shipping option identifier.
  late String id;

  /// Option title.
  late String title;

  /// A list of objects used to calculate the total shipping costs.
  late List<LabeledPricePart> price_parts;

  /// One shipping option
  ShippingOption(
      {required this.id,
      required this.title,
      required this.price_parts,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'shippingOption',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'price_parts': price_parts
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ShippingOption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var title = _map['title']! as String;
    var price_parts = List<LabeledPricePart>.from(
      (_map["price_parts"] ?? []).map(
        (e) => LabeledPricePart.fromMap(e),
      ),
    );
    return ShippingOption(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      price_parts: price_parts,
    );
  }
}

/// Contains information about saved payment credentials.
///
class SavedCredentials extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "savedCredentials";

  /// Unique identifier of the saved credentials.
  late String id;

  /// Title of the saved credentials.
  late String title;

  /// Contains information about saved payment credentials
  SavedCredentials(
      {required this.id, required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'savedCredentials',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SavedCredentials? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var title = _map['title']! as String;
    return SavedCredentials(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
    );
  }
}

/// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password.
///
class InputCredentialsSaved extends InputCredentials {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputCredentialsSaved";

  /// Identifier of the saved credentials.
  late String saved_credentials_id;

  /// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
  InputCredentialsSaved(
      {required this.saved_credentials_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputCredentialsSaved',
      if (extra != null) '@extra': extra,
      'saved_credentials_id': saved_credentials_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputCredentialsSaved? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var saved_credentials_id = _map['saved_credentials_id']! as String;
    return InputCredentialsSaved(
      extra: extra,
      clientId: clientId,
      saved_credentials_id: saved_credentials_id,
    );
  }
}

/// Applies if a user enters new credentials on a payment provider website.
///
class InputCredentialsNew extends InputCredentials {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputCredentialsNew";

  /// JSON-encoded data with the credential identifier from the payment provider.
  late String data;

  /// True, if the credential identifier can be saved on the server side.
  late bool allow_save;

  /// Applies if a user enters new credentials on a payment provider website
  InputCredentialsNew(
      {required this.data,
      required this.allow_save,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputCredentialsNew',
      if (extra != null) '@extra': extra,
      'data': data,
      'allow_save': allow_save
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputCredentialsNew? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var data = _map['data']! as String;
    var allow_save = _map['allow_save']! as bool;
    return InputCredentialsNew(
      extra: extra,
      clientId: clientId,
      data: data,
      allow_save: allow_save,
    );
  }
}

/// Applies if a user enters new credentials using Apple Pay.
///
class InputCredentialsApplePay extends InputCredentials {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputCredentialsApplePay";

  /// JSON-encoded data with the credential identifier.
  late String data;

  /// Applies if a user enters new credentials using Apple Pay
  InputCredentialsApplePay({required this.data, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputCredentialsApplePay',
      if (extra != null) '@extra': extra,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputCredentialsApplePay? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var data = _map['data']! as String;
    return InputCredentialsApplePay(
      extra: extra,
      clientId: clientId,
      data: data,
    );
  }
}

/// Applies if a user enters new credentials using Google Pay.
///
class InputCredentialsGooglePay extends InputCredentials {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputCredentialsGooglePay";

  /// JSON-encoded data with the credential identifier.
  late String data;

  /// Applies if a user enters new credentials using Google Pay
  InputCredentialsGooglePay({required this.data, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputCredentialsGooglePay',
      if (extra != null) '@extra': extra,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputCredentialsGooglePay? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var data = _map['data']! as String;
    return InputCredentialsGooglePay(
      extra: extra,
      clientId: clientId,
      data: data,
    );
  }
}

/// Smart Glocal payment provider.
///
class PaymentProviderSmartGlocal extends PaymentProvider {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "paymentProviderSmartGlocal";

  /// Public payment token.
  late String public_token;

  /// Smart Glocal payment provider
  PaymentProviderSmartGlocal(
      {required this.public_token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'paymentProviderSmartGlocal',
      if (extra != null) '@extra': extra,
      'public_token': public_token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PaymentProviderSmartGlocal? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var public_token = _map['public_token']! as String;
    return PaymentProviderSmartGlocal(
      extra: extra,
      clientId: clientId,
      public_token: public_token,
    );
  }
}

/// Stripe payment provider.
///
class PaymentProviderStripe extends PaymentProvider {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "paymentProviderStripe";

  /// Stripe API publishable key.
  late String publishable_key;

  /// True, if the user country must be provided.
  late bool need_country;

  /// True, if the user ZIP/postal code must be provided.
  late bool need_postal_code;

  /// True, if the cardholder name must be provided.
  late bool need_cardholder_name;

  /// Stripe payment provider
  PaymentProviderStripe(
      {required this.publishable_key,
      required this.need_country,
      required this.need_postal_code,
      required this.need_cardholder_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'paymentProviderStripe',
      if (extra != null) '@extra': extra,
      'publishable_key': publishable_key,
      'need_country': need_country,
      'need_postal_code': need_postal_code,
      'need_cardholder_name': need_cardholder_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PaymentProviderStripe? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var publishable_key = _map['publishable_key']! as String;
    var need_country = _map['need_country']! as bool;
    var need_postal_code = _map['need_postal_code']! as bool;
    var need_cardholder_name = _map['need_cardholder_name']! as bool;
    return PaymentProviderStripe(
      extra: extra,
      clientId: clientId,
      publishable_key: publishable_key,
      need_country: need_country,
      need_postal_code: need_postal_code,
      need_cardholder_name: need_cardholder_name,
    );
  }
}

/// Some other payment provider, for which a web payment form must be shown.
///
class PaymentProviderOther extends PaymentProvider {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "paymentProviderOther";

  /// Payment form URL.
  late String url;

  /// Some other payment provider, for which a web payment form must be shown
  PaymentProviderOther({required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'paymentProviderOther',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PaymentProviderOther? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return PaymentProviderOther(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// Describes an additional payment option.
///
class PaymentOption extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "paymentOption";

  /// Title for the payment option.
  late String title;

  /// Payment form URL to be opened in a web view.
  late String url;

  /// Describes an additional payment option
  PaymentOption(
      {required this.title, required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'paymentOption',
      if (extra != null) '@extra': extra,
      'title': title,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PaymentOption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var url = _map['url']! as String;
    return PaymentOption(
      extra: extra,
      clientId: clientId,
      title: title,
      url: url,
    );
  }
}

/// Contains information about an invoice payment form.
///
class PaymentForm extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "paymentForm";

  /// The payment form identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Full information about the invoice.
  late Invoice invoice;

  /// User identifier of the seller bot.
  late int seller_bot_user_id;

  /// User identifier of the payment provider bot.
  late int payment_provider_user_id;

  /// Information about the payment provider.
  late PaymentProvider payment_provider;

  /// The list of additional payment options.
  late List<PaymentOption> additional_payment_options;

  /// Saved server-side order information; may be null.
  OrderInfo? saved_order_info;

  /// The list of saved payment credentials.
  late List<SavedCredentials> saved_credentials;

  /// True, if the user can choose to save credentials.
  late bool can_save_credentials;

  /// True, if the user will be able to save credentials, if sets up a 2-step verification password.
  late bool need_password;

  /// Product title.
  late String product_title;

  /// Product description.
  late FormattedText product_description;

  /// Product photo; may be null.
  Photo? product_photo;

  /// Contains information about an invoice payment form
  PaymentForm(
      {required this.id,
      required this.invoice,
      required this.seller_bot_user_id,
      required this.payment_provider_user_id,
      required this.payment_provider,
      required this.additional_payment_options,
      this.saved_order_info,
      required this.saved_credentials,
      required this.can_save_credentials,
      required this.need_password,
      required this.product_title,
      required this.product_description,
      this.product_photo,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'paymentForm',
      if (extra != null) '@extra': extra,
      'id': id,
      'invoice': invoice,
      'seller_bot_user_id': seller_bot_user_id,
      'payment_provider_user_id': payment_provider_user_id,
      'payment_provider': payment_provider,
      'additional_payment_options': additional_payment_options,
      'saved_order_info': saved_order_info,
      'saved_credentials': saved_credentials,
      'can_save_credentials': can_save_credentials,
      'need_password': need_password,
      'product_title': product_title,
      'product_description': product_description,
      'product_photo': product_photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PaymentForm? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var invoice = Invoice.fromMap(_map['invoice'])!;
    var seller_bot_user_id = _map['seller_bot_user_id']! as int;
    var payment_provider_user_id = _map['payment_provider_user_id']! as int;
    var payment_provider = PaymentProvider.fromMap(_map['payment_provider'])!;
    var additional_payment_options = List<PaymentOption>.from(
      (_map["additional_payment_options"] ?? []).map(
        (e) => PaymentOption.fromMap(e),
      ),
    );
    var saved_order_info = OrderInfo.fromMap(_map['saved_order_info']);
    var saved_credentials = List<SavedCredentials>.from(
      (_map["saved_credentials"] ?? []).map(
        (e) => SavedCredentials.fromMap(e),
      ),
    );
    var can_save_credentials = _map['can_save_credentials']! as bool;
    var need_password = _map['need_password']! as bool;
    var product_title = _map['product_title']! as String;
    var product_description =
        FormattedText.fromMap(_map['product_description'])!;
    var product_photo = Photo.fromMap(_map['product_photo']);
    return PaymentForm(
      extra: extra,
      clientId: clientId,
      id: id,
      invoice: invoice,
      seller_bot_user_id: seller_bot_user_id,
      payment_provider_user_id: payment_provider_user_id,
      payment_provider: payment_provider,
      additional_payment_options: additional_payment_options,
      saved_order_info: saved_order_info,
      saved_credentials: saved_credentials,
      can_save_credentials: can_save_credentials,
      need_password: need_password,
      product_title: product_title,
      product_description: product_description,
      product_photo: product_photo,
    );
  }
}

/// Contains a temporary identifier of validated order information, which is stored for one hour, and the available shipping options.
///
class ValidatedOrderInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "validatedOrderInfo";

  /// Temporary identifier of the order information.
  late String order_info_id;

  /// Available shipping options.
  late List<ShippingOption> shipping_options;

  /// Contains a temporary identifier of validated order information, which is stored for one hour, and the available shipping options
  ValidatedOrderInfo(
      {required this.order_info_id,
      required this.shipping_options,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'validatedOrderInfo',
      if (extra != null) '@extra': extra,
      'order_info_id': order_info_id,
      'shipping_options': shipping_options
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ValidatedOrderInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var order_info_id = _map['order_info_id']! as String;
    var shipping_options = List<ShippingOption>.from(
      (_map["shipping_options"] ?? []).map(
        (e) => ShippingOption.fromMap(e),
      ),
    );
    return ValidatedOrderInfo(
      extra: extra,
      clientId: clientId,
      order_info_id: order_info_id,
      shipping_options: shipping_options,
    );
  }
}

/// Contains the result of a payment request.
///
class PaymentResult extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "paymentResult";

  /// True, if the payment request was successful; otherwise, the verification_url will be non-empty.
  late bool success;

  /// URL for additional payment credentials verification.
  late String verification_url;

  /// Contains the result of a payment request
  PaymentResult(
      {required this.success,
      required this.verification_url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'paymentResult',
      if (extra != null) '@extra': extra,
      'success': success,
      'verification_url': verification_url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PaymentResult? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var success = _map['success']! as bool;
    var verification_url = _map['verification_url']! as String;
    return PaymentResult(
      extra: extra,
      clientId: clientId,
      success: success,
      verification_url: verification_url,
    );
  }
}

/// Contains information about a successful payment.
///
class PaymentReceipt extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "paymentReceipt";

  /// Product title.
  late String title;

  /// Product description.
  late FormattedText description;

  /// Product photo; may be null.
  Photo? photo;

  /// Point in time (Unix timestamp) when the payment was made.
  late int date;

  /// User identifier of the seller bot.
  late int seller_bot_user_id;

  /// User identifier of the payment provider bot.
  late int payment_provider_user_id;

  /// Information about the invoice.
  late Invoice invoice;

  /// Order information; may be null.
  OrderInfo? order_info;

  /// Chosen shipping option; may be null.
  ShippingOption? shipping_option;

  /// Title of the saved credentials chosen by the buyer.
  late String credentials_title;

  /// The amount of tip chosen by the buyer in the smallest units of the currency.
  late int tip_amount;

  /// Contains information about a successful payment
  PaymentReceipt(
      {required this.title,
      required this.description,
      this.photo,
      required this.date,
      required this.seller_bot_user_id,
      required this.payment_provider_user_id,
      required this.invoice,
      this.order_info,
      this.shipping_option,
      required this.credentials_title,
      required this.tip_amount,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'paymentReceipt',
      if (extra != null) '@extra': extra,
      'title': title,
      'description': description,
      'photo': photo,
      'date': date,
      'seller_bot_user_id': seller_bot_user_id,
      'payment_provider_user_id': payment_provider_user_id,
      'invoice': invoice,
      'order_info': order_info,
      'shipping_option': shipping_option,
      'credentials_title': credentials_title,
      'tip_amount': tip_amount
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PaymentReceipt? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var description = FormattedText.fromMap(_map['description'])!;
    var photo = Photo.fromMap(_map['photo']);
    var date = _map['date']! as int;
    var seller_bot_user_id = _map['seller_bot_user_id']! as int;
    var payment_provider_user_id = _map['payment_provider_user_id']! as int;
    var invoice = Invoice.fromMap(_map['invoice'])!;
    var order_info = OrderInfo.fromMap(_map['order_info']);
    var shipping_option = ShippingOption.fromMap(_map['shipping_option']);
    var credentials_title = _map['credentials_title']! as String;
    var tip_amount = _map['tip_amount']! as int;
    return PaymentReceipt(
      extra: extra,
      clientId: clientId,
      title: title,
      description: description,
      photo: photo,
      date: date,
      seller_bot_user_id: seller_bot_user_id,
      payment_provider_user_id: payment_provider_user_id,
      invoice: invoice,
      order_info: order_info,
      shipping_option: shipping_option,
      credentials_title: credentials_title,
      tip_amount: tip_amount,
    );
  }
}

/// An invoice from a message of the type messageInvoice.
///
class InputInvoiceMessage extends InputInvoice {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInvoiceMessage";

  /// Chat identifier of the message.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// An invoice from a message of the type messageInvoice
  InputInvoiceMessage(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInvoiceMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInvoiceMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return InputInvoiceMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// An invoice from a link of the type internalLinkTypeInvoice.
///
class InputInvoiceName extends InputInvoice {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInvoiceName";

  /// Name of the invoice.
  late String name;

  /// An invoice from a link of the type internalLinkTypeInvoice
  InputInvoiceName({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInvoiceName',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInvoiceName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return InputInvoiceName(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// The media is hidden until the invoice is paid.
///
class MessageExtendedMediaPreview extends MessageExtendedMedia {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageExtendedMediaPreview";

  /// Media width; 0 if unknown.
  late int width;

  /// Media height; 0 if unknown.
  late int height;

  /// Media duration; 0 if unknown.
  late int duration;

  /// Media minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// Media caption.
  late FormattedText caption;

  /// The media is hidden until the invoice is paid
  MessageExtendedMediaPreview(
      {required this.width,
      required this.height,
      required this.duration,
      this.minithumbnail,
      required this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageExtendedMediaPreview',
      if (extra != null) '@extra': extra,
      'width': width,
      'height': height,
      'duration': duration,
      'minithumbnail': minithumbnail,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageExtendedMediaPreview? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var duration = _map['duration']! as int;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var caption = FormattedText.fromMap(_map['caption'])!;
    return MessageExtendedMediaPreview(
      extra: extra,
      clientId: clientId,
      width: width,
      height: height,
      duration: duration,
      minithumbnail: minithumbnail,
      caption: caption,
    );
  }
}

/// The media is a photo.
///
class MessageExtendedMediaPhoto extends MessageExtendedMedia {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageExtendedMediaPhoto";

  /// The photo.
  late Photo photo;

  /// Photo caption.
  late FormattedText caption;

  /// The media is a photo
  MessageExtendedMediaPhoto(
      {required this.photo, required this.caption, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageExtendedMediaPhoto',
      if (extra != null) '@extra': extra,
      'photo': photo,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageExtendedMediaPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = Photo.fromMap(_map['photo'])!;
    var caption = FormattedText.fromMap(_map['caption'])!;
    return MessageExtendedMediaPhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
      caption: caption,
    );
  }
}

/// The media is a video.
///
class MessageExtendedMediaVideo extends MessageExtendedMedia {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageExtendedMediaVideo";

  /// The video.
  late Video video;

  /// Photo caption.
  late FormattedText caption;

  /// The media is a video
  MessageExtendedMediaVideo(
      {required this.video, required this.caption, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageExtendedMediaVideo',
      if (extra != null) '@extra': extra,
      'video': video,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageExtendedMediaVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video = Video.fromMap(_map['video'])!;
    var caption = FormattedText.fromMap(_map['caption'])!;
    return MessageExtendedMediaVideo(
      extra: extra,
      clientId: clientId,
      video: video,
      caption: caption,
    );
  }
}

/// The media is unsupported.
///
class MessageExtendedMediaUnsupported extends MessageExtendedMedia {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageExtendedMediaUnsupported";

  /// Media caption.
  late FormattedText caption;

  /// The media is unsupported
  MessageExtendedMediaUnsupported(
      {required this.caption, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageExtendedMediaUnsupported',
      if (extra != null) '@extra': extra,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageExtendedMediaUnsupported? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var caption = FormattedText.fromMap(_map['caption'])!;
    return MessageExtendedMediaUnsupported(
      extra: extra,
      clientId: clientId,
      caption: caption,
    );
  }
}

/// File with the date it was uploaded.
///
class DatedFile extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "datedFile";

  /// The file.
  late File file;

  /// Point in time (Unix timestamp) when the file was uploaded.
  late int date;

  /// File with the date it was uploaded
  DatedFile(
      {required this.file, required this.date, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'datedFile',
      if (extra != null) '@extra': extra,
      'file': file,
      'date': date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DatedFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file = File.fromMap(_map['file'])!;
    var date = _map['date']! as int;
    return DatedFile(
      extra: extra,
      clientId: clientId,
      file: file,
      date: date,
    );
  }
}

/// A Telegram Passport element containing the user's personal details.
///
class PassportElementTypePersonalDetails extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypePersonalDetails";

  /// A Telegram Passport element containing the user's personal details
  PassportElementTypePersonalDetails({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypePersonalDetails',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypePersonalDetails? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypePersonalDetails(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's passport.
///
class PassportElementTypePassport extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypePassport";

  /// A Telegram Passport element containing the user's passport
  PassportElementTypePassport({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypePassport',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypePassport? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypePassport(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's driver license.
///
class PassportElementTypeDriverLicense extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypeDriverLicense";

  /// A Telegram Passport element containing the user's driver license
  PassportElementTypeDriverLicense({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypeDriverLicense',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypeDriverLicense? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypeDriverLicense(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's identity card.
///
class PassportElementTypeIdentityCard extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypeIdentityCard";

  /// A Telegram Passport element containing the user's identity card
  PassportElementTypeIdentityCard({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypeIdentityCard',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypeIdentityCard? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypeIdentityCard(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's internal passport.
///
class PassportElementTypeInternalPassport extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypeInternalPassport";

  /// A Telegram Passport element containing the user's internal passport
  PassportElementTypeInternalPassport({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypeInternalPassport',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypeInternalPassport? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypeInternalPassport(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's address.
///
class PassportElementTypeAddress extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypeAddress";

  /// A Telegram Passport element containing the user's address
  PassportElementTypeAddress({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypeAddress',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypeAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypeAddress(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's utility bill.
///
class PassportElementTypeUtilityBill extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypeUtilityBill";

  /// A Telegram Passport element containing the user's utility bill
  PassportElementTypeUtilityBill({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypeUtilityBill',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypeUtilityBill? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypeUtilityBill(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's bank statement.
///
class PassportElementTypeBankStatement extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypeBankStatement";

  /// A Telegram Passport element containing the user's bank statement
  PassportElementTypeBankStatement({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypeBankStatement',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypeBankStatement? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypeBankStatement(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's rental agreement.
///
class PassportElementTypeRentalAgreement extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypeRentalAgreement";

  /// A Telegram Passport element containing the user's rental agreement
  PassportElementTypeRentalAgreement({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypeRentalAgreement',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypeRentalAgreement? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypeRentalAgreement(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the registration page of the user's passport.
///
class PassportElementTypePassportRegistration extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypePassportRegistration";

  /// A Telegram Passport element containing the registration page of the user's passport
  PassportElementTypePassportRegistration({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypePassportRegistration',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypePassportRegistration? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypePassportRegistration(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's temporary registration.
///
class PassportElementTypeTemporaryRegistration extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypeTemporaryRegistration";

  /// A Telegram Passport element containing the user's temporary registration
  PassportElementTypeTemporaryRegistration({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypeTemporaryRegistration',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypeTemporaryRegistration? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypeTemporaryRegistration(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's phone number.
///
class PassportElementTypePhoneNumber extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypePhoneNumber";

  /// A Telegram Passport element containing the user's phone number
  PassportElementTypePhoneNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypePhoneNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypePhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypePhoneNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Telegram Passport element containing the user's email address.
///
class PassportElementTypeEmailAddress extends PassportElementType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTypeEmailAddress";

  /// A Telegram Passport element containing the user's email address
  PassportElementTypeEmailAddress({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTypeEmailAddress',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTypeEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementTypeEmailAddress(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents a date according to the Gregorian calendar.
///
class Date extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "date";

  /// Day of the month; 1-31.
  late int day;

  /// Month; 1-12.
  late int month;

  /// Year; 1-9999.
  late int year;

  /// Represents a date according to the Gregorian calendar
  Date(
      {required this.day,
      required this.month,
      required this.year,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'date',
      if (extra != null) '@extra': extra,
      'day': day,
      'month': month,
      'year': year
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Date? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var day = _map['day']! as int;
    var month = _map['month']! as int;
    var year = _map['year']! as int;
    return Date(
      extra: extra,
      clientId: clientId,
      day: day,
      month: month,
      year: year,
    );
  }
}

/// Contains the user's personal details.
///
class PersonalDetails extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "personalDetails";

  /// First name of the user written in English; 1-255 characters.
  late String first_name;

  /// Middle name of the user written in English; 0-255 characters.
  late String middle_name;

  /// Last name of the user written in English; 1-255 characters.
  late String last_name;

  /// Native first name of the user; 1-255 characters.
  late String native_first_name;

  /// Native middle name of the user; 0-255 characters.
  late String native_middle_name;

  /// Native last name of the user; 1-255 characters.
  late String native_last_name;

  /// Birthdate of the user.
  late Date birthdate;

  /// Gender of the user, "male" or "female".
  late String gender;

  /// A two-letter ISO 3166-1 alpha-2 country code of the user's country.
  late String country_code;

  /// A two-letter ISO 3166-1 alpha-2 country code of the user's residence country.
  late String residence_country_code;

  /// Contains the user's personal details
  PersonalDetails(
      {required this.first_name,
      required this.middle_name,
      required this.last_name,
      required this.native_first_name,
      required this.native_middle_name,
      required this.native_last_name,
      required this.birthdate,
      required this.gender,
      required this.country_code,
      required this.residence_country_code,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'personalDetails',
      if (extra != null) '@extra': extra,
      'first_name': first_name,
      'middle_name': middle_name,
      'last_name': last_name,
      'native_first_name': native_first_name,
      'native_middle_name': native_middle_name,
      'native_last_name': native_last_name,
      'birthdate': birthdate,
      'gender': gender,
      'country_code': country_code,
      'residence_country_code': residence_country_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PersonalDetails? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var first_name = _map['first_name']! as String;
    var middle_name = _map['middle_name']! as String;
    var last_name = _map['last_name']! as String;
    var native_first_name = _map['native_first_name']! as String;
    var native_middle_name = _map['native_middle_name']! as String;
    var native_last_name = _map['native_last_name']! as String;
    var birthdate = Date.fromMap(_map['birthdate'])!;
    var gender = _map['gender']! as String;
    var country_code = _map['country_code']! as String;
    var residence_country_code = _map['residence_country_code']! as String;
    return PersonalDetails(
      extra: extra,
      clientId: clientId,
      first_name: first_name,
      middle_name: middle_name,
      last_name: last_name,
      native_first_name: native_first_name,
      native_middle_name: native_middle_name,
      native_last_name: native_last_name,
      birthdate: birthdate,
      gender: gender,
      country_code: country_code,
      residence_country_code: residence_country_code,
    );
  }
}

/// An identity document.
///
class IdentityDocument extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "identityDocument";

  /// Document number; 1-24 characters.
  late String number;

  /// Document expiration date; may be null if not applicable.
  Date? expiration_date;

  /// Front side of the document.
  late DatedFile front_side;

  /// Reverse side of the document; only for driver license and identity card; may be null.
  DatedFile? reverse_side;

  /// Selfie with the document; may be null.
  DatedFile? selfie;

  /// List of files containing a certified English translation of the document.
  late List<DatedFile> translation;

  /// An identity document
  IdentityDocument(
      {required this.number,
      this.expiration_date,
      required this.front_side,
      this.reverse_side,
      this.selfie,
      required this.translation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'identityDocument',
      if (extra != null) '@extra': extra,
      'number': number,
      'expiration_date': expiration_date,
      'front_side': front_side,
      'reverse_side': reverse_side,
      'selfie': selfie,
      'translation': translation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static IdentityDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var number = _map['number']! as String;
    var expiration_date = Date.fromMap(_map['expiration_date']);
    var front_side = DatedFile.fromMap(_map['front_side'])!;
    var reverse_side = DatedFile.fromMap(_map['reverse_side']);
    var selfie = DatedFile.fromMap(_map['selfie']);
    var translation = List<DatedFile>.from(
      (_map["translation"] ?? []).map(
        (e) => DatedFile.fromMap(e),
      ),
    );
    return IdentityDocument(
      extra: extra,
      clientId: clientId,
      number: number,
      expiration_date: expiration_date,
      front_side: front_side,
      reverse_side: reverse_side,
      selfie: selfie,
      translation: translation,
    );
  }
}

/// An identity document to be saved to Telegram Passport.
///
class InputIdentityDocument extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputIdentityDocument";

  /// Document number; 1-24 characters.
  late String number;

  /// Document expiration date; pass null if not applicable.
  Date? expiration_date;

  /// Front side of the document.
  late InputFile front_side;

  /// Reverse side of the document; only for driver license and identity card; pass null otherwise.
  InputFile? reverse_side;

  /// Selfie with the document; pass null if unavailable.
  InputFile? selfie;

  /// List of files containing a certified English translation of the document.
  late List<InputFile> translation;

  /// An identity document to be saved to Telegram Passport
  InputIdentityDocument(
      {required this.number,
      this.expiration_date,
      required this.front_side,
      this.reverse_side,
      this.selfie,
      required this.translation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputIdentityDocument',
      if (extra != null) '@extra': extra,
      'number': number,
      'expiration_date': expiration_date,
      'front_side': front_side,
      'reverse_side': reverse_side,
      'selfie': selfie,
      'translation': translation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputIdentityDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var number = _map['number']! as String;
    var expiration_date = Date.fromMap(_map['expiration_date']);
    var front_side = InputFile.fromMap(_map['front_side'])!;
    var reverse_side = InputFile.fromMap(_map['reverse_side']);
    var selfie = InputFile.fromMap(_map['selfie']);
    var translation = List<InputFile>.from(
      (_map["translation"] ?? []).map(
        (e) => InputFile.fromMap(e),
      ),
    );
    return InputIdentityDocument(
      extra: extra,
      clientId: clientId,
      number: number,
      expiration_date: expiration_date,
      front_side: front_side,
      reverse_side: reverse_side,
      selfie: selfie,
      translation: translation,
    );
  }
}

/// A personal document, containing some information about a user.
///
class PersonalDocument extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "personalDocument";

  /// List of files containing the pages of the document.
  late List<DatedFile> files;

  /// List of files containing a certified English translation of the document.
  late List<DatedFile> translation;

  /// A personal document, containing some information about a user
  PersonalDocument(
      {required this.files,
      required this.translation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'personalDocument',
      if (extra != null) '@extra': extra,
      'files': files,
      'translation': translation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PersonalDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var files = List<DatedFile>.from(
      (_map["files"] ?? []).map(
        (e) => DatedFile.fromMap(e),
      ),
    );
    var translation = List<DatedFile>.from(
      (_map["translation"] ?? []).map(
        (e) => DatedFile.fromMap(e),
      ),
    );
    return PersonalDocument(
      extra: extra,
      clientId: clientId,
      files: files,
      translation: translation,
    );
  }
}

/// A personal document to be saved to Telegram Passport.
///
class InputPersonalDocument extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPersonalDocument";

  /// List of files containing the pages of the document.
  late List<InputFile> files;

  /// List of files containing a certified English translation of the document.
  late List<InputFile> translation;

  /// A personal document to be saved to Telegram Passport
  InputPersonalDocument(
      {required this.files,
      required this.translation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPersonalDocument',
      if (extra != null) '@extra': extra,
      'files': files,
      'translation': translation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPersonalDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var files = List<InputFile>.from(
      (_map["files"] ?? []).map(
        (e) => InputFile.fromMap(e),
      ),
    );
    var translation = List<InputFile>.from(
      (_map["translation"] ?? []).map(
        (e) => InputFile.fromMap(e),
      ),
    );
    return InputPersonalDocument(
      extra: extra,
      clientId: clientId,
      files: files,
      translation: translation,
    );
  }
}

/// A Telegram Passport element containing the user's personal details.
///
class PassportElementPersonalDetails extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementPersonalDetails";

  /// Personal details of the user.
  late PersonalDetails personal_details;

  /// A Telegram Passport element containing the user's personal details
  PassportElementPersonalDetails(
      {required this.personal_details, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementPersonalDetails',
      if (extra != null) '@extra': extra,
      'personal_details': personal_details
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementPersonalDetails? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var personal_details = PersonalDetails.fromMap(_map['personal_details'])!;
    return PassportElementPersonalDetails(
      extra: extra,
      clientId: clientId,
      personal_details: personal_details,
    );
  }
}

/// A Telegram Passport element containing the user's passport.
///
class PassportElementPassport extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementPassport";

  /// Passport.
  late IdentityDocument passport;

  /// A Telegram Passport element containing the user's passport
  PassportElementPassport({required this.passport, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementPassport',
      if (extra != null) '@extra': extra,
      'passport': passport
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementPassport? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var passport = IdentityDocument.fromMap(_map['passport'])!;
    return PassportElementPassport(
      extra: extra,
      clientId: clientId,
      passport: passport,
    );
  }
}

/// A Telegram Passport element containing the user's driver license.
///
class PassportElementDriverLicense extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementDriverLicense";

  /// Driver license.
  late IdentityDocument driver_license;

  /// A Telegram Passport element containing the user's driver license
  PassportElementDriverLicense(
      {required this.driver_license, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementDriverLicense',
      if (extra != null) '@extra': extra,
      'driver_license': driver_license
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementDriverLicense? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var driver_license = IdentityDocument.fromMap(_map['driver_license'])!;
    return PassportElementDriverLicense(
      extra: extra,
      clientId: clientId,
      driver_license: driver_license,
    );
  }
}

/// A Telegram Passport element containing the user's identity card.
///
class PassportElementIdentityCard extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementIdentityCard";

  /// Identity card.
  late IdentityDocument identity_card;

  /// A Telegram Passport element containing the user's identity card
  PassportElementIdentityCard(
      {required this.identity_card, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementIdentityCard',
      if (extra != null) '@extra': extra,
      'identity_card': identity_card
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementIdentityCard? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var identity_card = IdentityDocument.fromMap(_map['identity_card'])!;
    return PassportElementIdentityCard(
      extra: extra,
      clientId: clientId,
      identity_card: identity_card,
    );
  }
}

/// A Telegram Passport element containing the user's internal passport.
///
class PassportElementInternalPassport extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementInternalPassport";

  /// Internal passport.
  late IdentityDocument internal_passport;

  /// A Telegram Passport element containing the user's internal passport
  PassportElementInternalPassport(
      {required this.internal_passport, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementInternalPassport',
      if (extra != null) '@extra': extra,
      'internal_passport': internal_passport
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementInternalPassport? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var internal_passport =
        IdentityDocument.fromMap(_map['internal_passport'])!;
    return PassportElementInternalPassport(
      extra: extra,
      clientId: clientId,
      internal_passport: internal_passport,
    );
  }
}

/// A Telegram Passport element containing the user's address.
///
class PassportElementAddress extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementAddress";

  /// Address.
  late Address address;

  /// A Telegram Passport element containing the user's address
  PassportElementAddress({required this.address, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementAddress',
      if (extra != null) '@extra': extra,
      'address': address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var address = Address.fromMap(_map['address'])!;
    return PassportElementAddress(
      extra: extra,
      clientId: clientId,
      address: address,
    );
  }
}

/// A Telegram Passport element containing the user's utility bill.
///
class PassportElementUtilityBill extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementUtilityBill";

  /// Utility bill.
  late PersonalDocument utility_bill;

  /// A Telegram Passport element containing the user's utility bill
  PassportElementUtilityBill(
      {required this.utility_bill, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementUtilityBill',
      if (extra != null) '@extra': extra,
      'utility_bill': utility_bill
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementUtilityBill? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var utility_bill = PersonalDocument.fromMap(_map['utility_bill'])!;
    return PassportElementUtilityBill(
      extra: extra,
      clientId: clientId,
      utility_bill: utility_bill,
    );
  }
}

/// A Telegram Passport element containing the user's bank statement.
///
class PassportElementBankStatement extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementBankStatement";

  /// Bank statement.
  late PersonalDocument bank_statement;

  /// A Telegram Passport element containing the user's bank statement
  PassportElementBankStatement(
      {required this.bank_statement, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementBankStatement',
      if (extra != null) '@extra': extra,
      'bank_statement': bank_statement
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementBankStatement? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bank_statement = PersonalDocument.fromMap(_map['bank_statement'])!;
    return PassportElementBankStatement(
      extra: extra,
      clientId: clientId,
      bank_statement: bank_statement,
    );
  }
}

/// A Telegram Passport element containing the user's rental agreement.
///
class PassportElementRentalAgreement extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementRentalAgreement";

  /// Rental agreement.
  late PersonalDocument rental_agreement;

  /// A Telegram Passport element containing the user's rental agreement
  PassportElementRentalAgreement(
      {required this.rental_agreement, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementRentalAgreement',
      if (extra != null) '@extra': extra,
      'rental_agreement': rental_agreement
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementRentalAgreement? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var rental_agreement = PersonalDocument.fromMap(_map['rental_agreement'])!;
    return PassportElementRentalAgreement(
      extra: extra,
      clientId: clientId,
      rental_agreement: rental_agreement,
    );
  }
}

/// A Telegram Passport element containing the user's passport registration pages.
///
class PassportElementPassportRegistration extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementPassportRegistration";

  /// Passport registration pages.
  late PersonalDocument passport_registration;

  /// A Telegram Passport element containing the user's passport registration pages
  PassportElementPassportRegistration(
      {required this.passport_registration, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementPassportRegistration',
      if (extra != null) '@extra': extra,
      'passport_registration': passport_registration
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementPassportRegistration? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var passport_registration =
        PersonalDocument.fromMap(_map['passport_registration'])!;
    return PassportElementPassportRegistration(
      extra: extra,
      clientId: clientId,
      passport_registration: passport_registration,
    );
  }
}

/// A Telegram Passport element containing the user's temporary registration.
///
class PassportElementTemporaryRegistration extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementTemporaryRegistration";

  /// Temporary registration.
  late PersonalDocument temporary_registration;

  /// A Telegram Passport element containing the user's temporary registration
  PassportElementTemporaryRegistration(
      {required this.temporary_registration, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementTemporaryRegistration',
      if (extra != null) '@extra': extra,
      'temporary_registration': temporary_registration
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementTemporaryRegistration? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var temporary_registration =
        PersonalDocument.fromMap(_map['temporary_registration'])!;
    return PassportElementTemporaryRegistration(
      extra: extra,
      clientId: clientId,
      temporary_registration: temporary_registration,
    );
  }
}

/// A Telegram Passport element containing the user's phone number.
///
class PassportElementPhoneNumber extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementPhoneNumber";

  /// Phone number.
  late String phone_number;

  /// A Telegram Passport element containing the user's phone number
  PassportElementPhoneNumber(
      {required this.phone_number, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementPhoneNumber',
      if (extra != null) '@extra': extra,
      'phone_number': phone_number
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementPhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number = _map['phone_number']! as String;
    return PassportElementPhoneNumber(
      extra: extra,
      clientId: clientId,
      phone_number: phone_number,
    );
  }
}

/// A Telegram Passport element containing the user's email address.
///
class PassportElementEmailAddress extends PassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementEmailAddress";

  /// Email address.
  late String email_address;

  /// A Telegram Passport element containing the user's email address
  PassportElementEmailAddress(
      {required this.email_address, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementEmailAddress',
      if (extra != null) '@extra': extra,
      'email_address': email_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var email_address = _map['email_address']! as String;
    return PassportElementEmailAddress(
      extra: extra,
      clientId: clientId,
      email_address: email_address,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's personal details.
///
class InputPassportElementPersonalDetails extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementPersonalDetails";

  /// Personal details of the user.
  late PersonalDetails personal_details;

  /// A Telegram Passport element to be saved containing the user's personal details
  InputPassportElementPersonalDetails(
      {required this.personal_details, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementPersonalDetails',
      if (extra != null) '@extra': extra,
      'personal_details': personal_details
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementPersonalDetails? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var personal_details = PersonalDetails.fromMap(_map['personal_details'])!;
    return InputPassportElementPersonalDetails(
      extra: extra,
      clientId: clientId,
      personal_details: personal_details,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's passport.
///
class InputPassportElementPassport extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementPassport";

  /// The passport to be saved.
  late InputIdentityDocument passport;

  /// A Telegram Passport element to be saved containing the user's passport
  InputPassportElementPassport(
      {required this.passport, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementPassport',
      if (extra != null) '@extra': extra,
      'passport': passport
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementPassport? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var passport = InputIdentityDocument.fromMap(_map['passport'])!;
    return InputPassportElementPassport(
      extra: extra,
      clientId: clientId,
      passport: passport,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's driver license.
///
class InputPassportElementDriverLicense extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementDriverLicense";

  /// The driver license to be saved.
  late InputIdentityDocument driver_license;

  /// A Telegram Passport element to be saved containing the user's driver license
  InputPassportElementDriverLicense(
      {required this.driver_license, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementDriverLicense',
      if (extra != null) '@extra': extra,
      'driver_license': driver_license
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementDriverLicense? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var driver_license = InputIdentityDocument.fromMap(_map['driver_license'])!;
    return InputPassportElementDriverLicense(
      extra: extra,
      clientId: clientId,
      driver_license: driver_license,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's identity card.
///
class InputPassportElementIdentityCard extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementIdentityCard";

  /// The identity card to be saved.
  late InputIdentityDocument identity_card;

  /// A Telegram Passport element to be saved containing the user's identity card
  InputPassportElementIdentityCard(
      {required this.identity_card, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementIdentityCard',
      if (extra != null) '@extra': extra,
      'identity_card': identity_card
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementIdentityCard? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var identity_card = InputIdentityDocument.fromMap(_map['identity_card'])!;
    return InputPassportElementIdentityCard(
      extra: extra,
      clientId: clientId,
      identity_card: identity_card,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's internal passport.
///
class InputPassportElementInternalPassport extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementInternalPassport";

  /// The internal passport to be saved.
  late InputIdentityDocument internal_passport;

  /// A Telegram Passport element to be saved containing the user's internal passport
  InputPassportElementInternalPassport(
      {required this.internal_passport, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementInternalPassport',
      if (extra != null) '@extra': extra,
      'internal_passport': internal_passport
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementInternalPassport? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var internal_passport =
        InputIdentityDocument.fromMap(_map['internal_passport'])!;
    return InputPassportElementInternalPassport(
      extra: extra,
      clientId: clientId,
      internal_passport: internal_passport,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's address.
///
class InputPassportElementAddress extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementAddress";

  /// The address to be saved.
  late Address address;

  /// A Telegram Passport element to be saved containing the user's address
  InputPassportElementAddress(
      {required this.address, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementAddress',
      if (extra != null) '@extra': extra,
      'address': address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var address = Address.fromMap(_map['address'])!;
    return InputPassportElementAddress(
      extra: extra,
      clientId: clientId,
      address: address,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's utility bill.
///
class InputPassportElementUtilityBill extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementUtilityBill";

  /// The utility bill to be saved.
  late InputPersonalDocument utility_bill;

  /// A Telegram Passport element to be saved containing the user's utility bill
  InputPassportElementUtilityBill(
      {required this.utility_bill, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementUtilityBill',
      if (extra != null) '@extra': extra,
      'utility_bill': utility_bill
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementUtilityBill? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var utility_bill = InputPersonalDocument.fromMap(_map['utility_bill'])!;
    return InputPassportElementUtilityBill(
      extra: extra,
      clientId: clientId,
      utility_bill: utility_bill,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's bank statement.
///
class InputPassportElementBankStatement extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementBankStatement";

  /// The bank statement to be saved.
  late InputPersonalDocument bank_statement;

  /// A Telegram Passport element to be saved containing the user's bank statement
  InputPassportElementBankStatement(
      {required this.bank_statement, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementBankStatement',
      if (extra != null) '@extra': extra,
      'bank_statement': bank_statement
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementBankStatement? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bank_statement = InputPersonalDocument.fromMap(_map['bank_statement'])!;
    return InputPassportElementBankStatement(
      extra: extra,
      clientId: clientId,
      bank_statement: bank_statement,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's rental agreement.
///
class InputPassportElementRentalAgreement extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementRentalAgreement";

  /// The rental agreement to be saved.
  late InputPersonalDocument rental_agreement;

  /// A Telegram Passport element to be saved containing the user's rental agreement
  InputPassportElementRentalAgreement(
      {required this.rental_agreement, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementRentalAgreement',
      if (extra != null) '@extra': extra,
      'rental_agreement': rental_agreement
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementRentalAgreement? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var rental_agreement =
        InputPersonalDocument.fromMap(_map['rental_agreement'])!;
    return InputPassportElementRentalAgreement(
      extra: extra,
      clientId: clientId,
      rental_agreement: rental_agreement,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's passport registration.
///
class InputPassportElementPassportRegistration extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementPassportRegistration";

  /// The passport registration page to be saved.
  late InputPersonalDocument passport_registration;

  /// A Telegram Passport element to be saved containing the user's passport registration
  InputPassportElementPassportRegistration(
      {required this.passport_registration, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementPassportRegistration',
      if (extra != null) '@extra': extra,
      'passport_registration': passport_registration
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementPassportRegistration? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var passport_registration =
        InputPersonalDocument.fromMap(_map['passport_registration'])!;
    return InputPassportElementPassportRegistration(
      extra: extra,
      clientId: clientId,
      passport_registration: passport_registration,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's temporary registration.
///
class InputPassportElementTemporaryRegistration extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementTemporaryRegistration";

  /// The temporary registration document to be saved.
  late InputPersonalDocument temporary_registration;

  /// A Telegram Passport element to be saved containing the user's temporary registration
  InputPassportElementTemporaryRegistration(
      {required this.temporary_registration, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementTemporaryRegistration',
      if (extra != null) '@extra': extra,
      'temporary_registration': temporary_registration
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementTemporaryRegistration? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var temporary_registration =
        InputPersonalDocument.fromMap(_map['temporary_registration'])!;
    return InputPassportElementTemporaryRegistration(
      extra: extra,
      clientId: clientId,
      temporary_registration: temporary_registration,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's phone number.
///
class InputPassportElementPhoneNumber extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementPhoneNumber";

  /// The phone number to be saved.
  late String phone_number;

  /// A Telegram Passport element to be saved containing the user's phone number
  InputPassportElementPhoneNumber(
      {required this.phone_number, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementPhoneNumber',
      if (extra != null) '@extra': extra,
      'phone_number': phone_number
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementPhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number = _map['phone_number']! as String;
    return InputPassportElementPhoneNumber(
      extra: extra,
      clientId: clientId,
      phone_number: phone_number,
    );
  }
}

/// A Telegram Passport element to be saved containing the user's email address.
///
class InputPassportElementEmailAddress extends InputPassportElement {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementEmailAddress";

  /// The email address to be saved.
  late String email_address;

  /// A Telegram Passport element to be saved containing the user's email address
  InputPassportElementEmailAddress(
      {required this.email_address, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementEmailAddress',
      if (extra != null) '@extra': extra,
      'email_address': email_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var email_address = _map['email_address']! as String;
    return InputPassportElementEmailAddress(
      extra: extra,
      clientId: clientId,
      email_address: email_address,
    );
  }
}

/// Contains information about saved Telegram Passport elements.
///
class PassportElements extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElements";

  /// Telegram Passport elements.
  late List<PassportElement> elements;

  /// Contains information about saved Telegram Passport elements
  PassportElements({required this.elements, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElements',
      if (extra != null) '@extra': extra,
      'elements': elements
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElements? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var elements = List<PassportElement>.from(
      (_map["elements"] ?? []).map(
        (e) => PassportElement.fromMap(e),
      ),
    );
    return PassportElements(
      extra: extra,
      clientId: clientId,
      elements: elements,
    );
  }
}

/// The element contains an error in an unspecified place. The error will be considered resolved when new data is added.
///
class PassportElementErrorSourceUnspecified extends PassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementErrorSourceUnspecified";

  /// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
  PassportElementErrorSourceUnspecified({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementErrorSourceUnspecified',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementErrorSourceUnspecified? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementErrorSourceUnspecified(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// One of the data fields contains an error. The error will be considered resolved when the value of the field changes.
///
class PassportElementErrorSourceDataField extends PassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementErrorSourceDataField";

  /// Field name.
  late String field_name;

  /// One of the data fields contains an error. The error will be considered resolved when the value of the field changes
  PassportElementErrorSourceDataField(
      {required this.field_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementErrorSourceDataField',
      if (extra != null) '@extra': extra,
      'field_name': field_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementErrorSourceDataField? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var field_name = _map['field_name']! as String;
    return PassportElementErrorSourceDataField(
      extra: extra,
      clientId: clientId,
      field_name: field_name,
    );
  }
}

/// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes.
///
class PassportElementErrorSourceFrontSide extends PassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementErrorSourceFrontSide";

  /// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
  PassportElementErrorSourceFrontSide({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementErrorSourceFrontSide',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementErrorSourceFrontSide? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementErrorSourceFrontSide(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes.
///
class PassportElementErrorSourceReverseSide extends PassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementErrorSourceReverseSide";

  /// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
  PassportElementErrorSourceReverseSide({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementErrorSourceReverseSide',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementErrorSourceReverseSide? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementErrorSourceReverseSide(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes.
///
class PassportElementErrorSourceSelfie extends PassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementErrorSourceSelfie";

  /// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
  PassportElementErrorSourceSelfie({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementErrorSourceSelfie',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementErrorSourceSelfie? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementErrorSourceSelfie(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes.
///
class PassportElementErrorSourceTranslationFile
    extends PassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementErrorSourceTranslationFile";

  /// Index of a file with the error.
  late int file_index;

  /// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
  PassportElementErrorSourceTranslationFile(
      {required this.file_index, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementErrorSourceTranslationFile',
      if (extra != null) '@extra': extra,
      'file_index': file_index
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementErrorSourceTranslationFile? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_index = _map['file_index']! as int;
    return PassportElementErrorSourceTranslationFile(
      extra: extra,
      clientId: clientId,
      file_index: file_index,
    );
  }
}

/// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes.
///
class PassportElementErrorSourceTranslationFiles
    extends PassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "passportElementErrorSourceTranslationFiles";

  /// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
  PassportElementErrorSourceTranslationFiles({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementErrorSourceTranslationFiles',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementErrorSourceTranslationFiles? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementErrorSourceTranslationFiles(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file contains an error. The error will be considered resolved when the file changes.
///
class PassportElementErrorSourceFile extends PassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementErrorSourceFile";

  /// Index of a file with the error.
  late int file_index;

  /// The file contains an error. The error will be considered resolved when the file changes
  PassportElementErrorSourceFile(
      {required this.file_index, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementErrorSourceFile',
      if (extra != null) '@extra': extra,
      'file_index': file_index
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementErrorSourceFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_index = _map['file_index']! as int;
    return PassportElementErrorSourceFile(
      extra: extra,
      clientId: clientId,
      file_index: file_index,
    );
  }
}

/// The list of attached files contains an error. The error will be considered resolved when the list of files changes.
///
class PassportElementErrorSourceFiles extends PassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementErrorSourceFiles";

  /// The list of attached files contains an error. The error will be considered resolved when the list of files changes
  PassportElementErrorSourceFiles({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementErrorSourceFiles',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementErrorSourceFiles? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PassportElementErrorSourceFiles(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains the description of an error in a Telegram Passport element.
///
class PassportElementError extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementError";

  /// Type of the Telegram Passport element which has the error.
  late PassportElementType type;

  /// Error message.
  late String message;

  /// Error source.
  late PassportElementErrorSource source;

  /// Contains the description of an error in a Telegram Passport element
  PassportElementError(
      {required this.type,
      required this.message,
      required this.source,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementError',
      if (extra != null) '@extra': extra,
      'type': type,
      'message': message,
      'source': source
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementError? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = PassportElementType.fromMap(_map['type'])!;
    var message = _map['message']! as String;
    var source = PassportElementErrorSource.fromMap(_map['source'])!;
    return PassportElementError(
      extra: extra,
      clientId: clientId,
      type: type,
      message: message,
      source: source,
    );
  }
}

/// Contains information about a Telegram Passport element that was requested by a service.
///
class PassportSuitableElement extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportSuitableElement";

  /// Type of the element.
  late PassportElementType type;

  /// True, if a selfie is required with the identity document.
  late bool is_selfie_required;

  /// True, if a certified English translation is required with the document.
  late bool is_translation_required;

  /// True, if personal details must include the user's name in the language of their country of residence.
  late bool is_native_name_required;

  /// Contains information about a Telegram Passport element that was requested by a service
  PassportSuitableElement(
      {required this.type,
      required this.is_selfie_required,
      required this.is_translation_required,
      required this.is_native_name_required,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportSuitableElement',
      if (extra != null) '@extra': extra,
      'type': type,
      'is_selfie_required': is_selfie_required,
      'is_translation_required': is_translation_required,
      'is_native_name_required': is_native_name_required
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportSuitableElement? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = PassportElementType.fromMap(_map['type'])!;
    var is_selfie_required = _map['is_selfie_required']! as bool;
    var is_translation_required = _map['is_translation_required']! as bool;
    var is_native_name_required = _map['is_native_name_required']! as bool;
    return PassportSuitableElement(
      extra: extra,
      clientId: clientId,
      type: type,
      is_selfie_required: is_selfie_required,
      is_translation_required: is_translation_required,
      is_native_name_required: is_native_name_required,
    );
  }
}

/// Contains a description of the required Telegram Passport element that was requested by a service.
///
class PassportRequiredElement extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportRequiredElement";

  /// List of Telegram Passport elements any of which is enough to provide.
  late List<PassportSuitableElement> suitable_elements;

  /// Contains a description of the required Telegram Passport element that was requested by a service
  PassportRequiredElement(
      {required this.suitable_elements, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportRequiredElement',
      if (extra != null) '@extra': extra,
      'suitable_elements': suitable_elements
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportRequiredElement? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var suitable_elements = List<PassportSuitableElement>.from(
      (_map["suitable_elements"] ?? []).map(
        (e) => PassportSuitableElement.fromMap(e),
      ),
    );
    return PassportRequiredElement(
      extra: extra,
      clientId: clientId,
      suitable_elements: suitable_elements,
    );
  }
}

/// Contains information about a Telegram Passport authorization form that was requested.
///
class PassportAuthorizationForm extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportAuthorizationForm";

  /// Unique identifier of the authorization form.
  late int id;

  /// Telegram Passport elements that must be provided to complete the form.
  late List<PassportRequiredElement> required_elements;

  /// URL for the privacy policy of the service; may be empty.
  late String privacy_policy_url;

  /// Contains information about a Telegram Passport authorization form that was requested
  PassportAuthorizationForm(
      {required this.id,
      required this.required_elements,
      required this.privacy_policy_url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportAuthorizationForm',
      if (extra != null) '@extra': extra,
      'id': id,
      'required_elements': required_elements,
      'privacy_policy_url': privacy_policy_url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportAuthorizationForm? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var required_elements = List<PassportRequiredElement>.from(
      (_map["required_elements"] ?? []).map(
        (e) => PassportRequiredElement.fromMap(e),
      ),
    );
    var privacy_policy_url = _map['privacy_policy_url']! as String;
    return PassportAuthorizationForm(
      extra: extra,
      clientId: clientId,
      id: id,
      required_elements: required_elements,
      privacy_policy_url: privacy_policy_url,
    );
  }
}

/// Contains information about a Telegram Passport elements and corresponding errors.
///
class PassportElementsWithErrors extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "passportElementsWithErrors";

  /// Telegram Passport elements.
  late List<PassportElement> elements;

  /// Errors in the elements that are already available.
  late List<PassportElementError> errors;

  /// Contains information about a Telegram Passport elements and corresponding errors
  PassportElementsWithErrors(
      {required this.elements,
      required this.errors,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'passportElementsWithErrors',
      if (extra != null) '@extra': extra,
      'elements': elements,
      'errors': errors
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PassportElementsWithErrors? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var elements = List<PassportElement>.from(
      (_map["elements"] ?? []).map(
        (e) => PassportElement.fromMap(e),
      ),
    );
    var errors = List<PassportElementError>.from(
      (_map["errors"] ?? []).map(
        (e) => PassportElementError.fromMap(e),
      ),
    );
    return PassportElementsWithErrors(
      extra: extra,
      clientId: clientId,
      elements: elements,
      errors: errors,
    );
  }
}

/// Contains encrypted Telegram Passport data credentials.
///
class EncryptedCredentials extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "encryptedCredentials";

  /// The encrypted credentials.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// The decrypted data hash.
  /// ; base64-encoded bytes `List<int>`
  late bytes hash;

  /// Secret for data decryption, encrypted with the service's public key.
  /// ; base64-encoded bytes `List<int>`
  late bytes secret;

  /// Contains encrypted Telegram Passport data credentials
  EncryptedCredentials(
      {required this.data,
      required this.hash,
      required this.secret,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'encryptedCredentials',
      if (extra != null) '@extra': extra,
      'data': data,
      'hash': hash,
      'secret': secret
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EncryptedCredentials? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var data = _map['data']! as bytes;
    var hash = _map['hash']! as bytes;
    var secret = _map['secret']! as bytes;
    return EncryptedCredentials(
      extra: extra,
      clientId: clientId,
      data: data,
      hash: hash,
      secret: secret,
    );
  }
}

/// Contains information about an encrypted Telegram Passport element; for bots only.
///
class EncryptedPassportElement extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "encryptedPassportElement";

  /// Type of Telegram Passport element.
  late PassportElementType type;

  /// Encrypted JSON-encoded data about the user.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// The front side of an identity document.
  late DatedFile front_side;

  /// The reverse side of an identity document; may be null.
  DatedFile? reverse_side;

  /// Selfie with the document; may be null.
  DatedFile? selfie;

  /// List of files containing a certified English translation of the document.
  late List<DatedFile> translation;

  /// List of attached files.
  late List<DatedFile> files;

  /// Unencrypted data, phone number or email address.
  late String value;

  /// Hash of the entire element.
  late String hash;

  /// Contains information about an encrypted Telegram Passport element; for bots only
  EncryptedPassportElement(
      {required this.type,
      required this.data,
      required this.front_side,
      this.reverse_side,
      this.selfie,
      required this.translation,
      required this.files,
      required this.value,
      required this.hash,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'encryptedPassportElement',
      if (extra != null) '@extra': extra,
      'type': type,
      'data': data,
      'front_side': front_side,
      'reverse_side': reverse_side,
      'selfie': selfie,
      'translation': translation,
      'files': files,
      'value': value,
      'hash': hash
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EncryptedPassportElement? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = PassportElementType.fromMap(_map['type'])!;
    var data = _map['data']! as bytes;
    var front_side = DatedFile.fromMap(_map['front_side'])!;
    var reverse_side = DatedFile.fromMap(_map['reverse_side']);
    var selfie = DatedFile.fromMap(_map['selfie']);
    var translation = List<DatedFile>.from(
      (_map["translation"] ?? []).map(
        (e) => DatedFile.fromMap(e),
      ),
    );
    var files = List<DatedFile>.from(
      (_map["files"] ?? []).map(
        (e) => DatedFile.fromMap(e),
      ),
    );
    var value = _map['value']! as String;
    var hash = _map['hash']! as String;
    return EncryptedPassportElement(
      extra: extra,
      clientId: clientId,
      type: type,
      data: data,
      front_side: front_side,
      reverse_side: reverse_side,
      selfie: selfie,
      translation: translation,
      files: files,
      value: value,
      hash: hash,
    );
  }
}

/// The element contains an error in an unspecified place. The error will be considered resolved when new data is added.
///
class InputPassportElementErrorSourceUnspecified
    extends InputPassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "inputPassportElementErrorSourceUnspecified";

  /// Current hash of the entire element.
  /// ; base64-encoded bytes `List<int>`
  late bytes element_hash;

  /// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
  InputPassportElementErrorSourceUnspecified(
      {required this.element_hash, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementErrorSourceUnspecified',
      if (extra != null) '@extra': extra,
      'element_hash': element_hash
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementErrorSourceUnspecified? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var element_hash = _map['element_hash']! as bytes;
    return InputPassportElementErrorSourceUnspecified(
      extra: extra,
      clientId: clientId,
      element_hash: element_hash,
    );
  }
}

/// A data field contains an error. The error is considered resolved when the field's value changes.
///
class InputPassportElementErrorSourceDataField
    extends InputPassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementErrorSourceDataField";

  /// Field name.
  late String field_name;

  /// Current data hash.
  /// ; base64-encoded bytes `List<int>`
  late bytes data_hash;

  /// A data field contains an error. The error is considered resolved when the field's value changes
  InputPassportElementErrorSourceDataField(
      {required this.field_name,
      required this.data_hash,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementErrorSourceDataField',
      if (extra != null) '@extra': extra,
      'field_name': field_name,
      'data_hash': data_hash
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementErrorSourceDataField? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var field_name = _map['field_name']! as String;
    var data_hash = _map['data_hash']! as bytes;
    return InputPassportElementErrorSourceDataField(
      extra: extra,
      clientId: clientId,
      field_name: field_name,
      data_hash: data_hash,
    );
  }
}

/// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes.
///
class InputPassportElementErrorSourceFrontSide
    extends InputPassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementErrorSourceFrontSide";

  /// Current hash of the file containing the front side.
  /// ; base64-encoded bytes `List<int>`
  late bytes file_hash;

  /// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
  InputPassportElementErrorSourceFrontSide(
      {required this.file_hash, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementErrorSourceFrontSide',
      if (extra != null) '@extra': extra,
      'file_hash': file_hash
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementErrorSourceFrontSide? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_hash = _map['file_hash']! as bytes;
    return InputPassportElementErrorSourceFrontSide(
      extra: extra,
      clientId: clientId,
      file_hash: file_hash,
    );
  }
}

/// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes.
///
class InputPassportElementErrorSourceReverseSide
    extends InputPassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "inputPassportElementErrorSourceReverseSide";

  /// Current hash of the file containing the reverse side.
  /// ; base64-encoded bytes `List<int>`
  late bytes file_hash;

  /// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
  InputPassportElementErrorSourceReverseSide(
      {required this.file_hash, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementErrorSourceReverseSide',
      if (extra != null) '@extra': extra,
      'file_hash': file_hash
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementErrorSourceReverseSide? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_hash = _map['file_hash']! as bytes;
    return InputPassportElementErrorSourceReverseSide(
      extra: extra,
      clientId: clientId,
      file_hash: file_hash,
    );
  }
}

/// The selfie contains an error. The error is considered resolved when the file with the selfie changes.
///
class InputPassportElementErrorSourceSelfie
    extends InputPassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementErrorSourceSelfie";

  /// Current hash of the file containing the selfie.
  /// ; base64-encoded bytes `List<int>`
  late bytes file_hash;

  /// The selfie contains an error. The error is considered resolved when the file with the selfie changes
  InputPassportElementErrorSourceSelfie(
      {required this.file_hash, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementErrorSourceSelfie',
      if (extra != null) '@extra': extra,
      'file_hash': file_hash
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementErrorSourceSelfie? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_hash = _map['file_hash']! as bytes;
    return InputPassportElementErrorSourceSelfie(
      extra: extra,
      clientId: clientId,
      file_hash: file_hash,
    );
  }
}

/// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes.
///
class InputPassportElementErrorSourceTranslationFile
    extends InputPassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "inputPassportElementErrorSourceTranslationFile";

  /// Current hash of the file containing the translation.
  /// ; base64-encoded bytes `List<int>`
  late bytes file_hash;

  /// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
  InputPassportElementErrorSourceTranslationFile(
      {required this.file_hash, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementErrorSourceTranslationFile',
      if (extra != null) '@extra': extra,
      'file_hash': file_hash
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementErrorSourceTranslationFile? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_hash = _map['file_hash']! as bytes;
    return InputPassportElementErrorSourceTranslationFile(
      extra: extra,
      clientId: clientId,
      file_hash: file_hash,
    );
  }
}

/// The translation of the document contains an error. The error is considered resolved when the list of files changes.
///
class InputPassportElementErrorSourceTranslationFiles
    extends InputPassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "inputPassportElementErrorSourceTranslationFiles";

  /// Current hashes of all files with the translation.
  late List<bytes> file_hashes;

  /// The translation of the document contains an error. The error is considered resolved when the list of files changes
  InputPassportElementErrorSourceTranslationFiles(
      {required this.file_hashes, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementErrorSourceTranslationFiles',
      if (extra != null) '@extra': extra,
      'file_hashes': file_hashes
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementErrorSourceTranslationFiles? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_hashes = List<bytes>.from(
      (_map["file_hashes"] ?? []).map(
        (e) => e as bytes,
      ),
    );
    return InputPassportElementErrorSourceTranslationFiles(
      extra: extra,
      clientId: clientId,
      file_hashes: file_hashes,
    );
  }
}

/// The file contains an error. The error is considered resolved when the file changes.
///
class InputPassportElementErrorSourceFile
    extends InputPassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementErrorSourceFile";

  /// Current hash of the file which has the error.
  /// ; base64-encoded bytes `List<int>`
  late bytes file_hash;

  /// The file contains an error. The error is considered resolved when the file changes
  InputPassportElementErrorSourceFile(
      {required this.file_hash, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementErrorSourceFile',
      if (extra != null) '@extra': extra,
      'file_hash': file_hash
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementErrorSourceFile? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_hash = _map['file_hash']! as bytes;
    return InputPassportElementErrorSourceFile(
      extra: extra,
      clientId: clientId,
      file_hash: file_hash,
    );
  }
}

/// The list of attached files contains an error. The error is considered resolved when the file list changes.
///
class InputPassportElementErrorSourceFiles
    extends InputPassportElementErrorSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementErrorSourceFiles";

  /// Current hashes of all attached files.
  late List<bytes> file_hashes;

  /// The list of attached files contains an error. The error is considered resolved when the file list changes
  InputPassportElementErrorSourceFiles(
      {required this.file_hashes, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementErrorSourceFiles',
      if (extra != null) '@extra': extra,
      'file_hashes': file_hashes
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementErrorSourceFiles? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_hashes = List<bytes>.from(
      (_map["file_hashes"] ?? []).map(
        (e) => e as bytes,
      ),
    );
    return InputPassportElementErrorSourceFiles(
      extra: extra,
      clientId: clientId,
      file_hashes: file_hashes,
    );
  }
}

/// Contains the description of an error in a Telegram Passport element; for bots only.
///
class InputPassportElementError extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputPassportElementError";

  /// Type of Telegram Passport element that has the error.
  late PassportElementType type;

  /// Error message.
  late String message;

  /// Error source.
  late InputPassportElementErrorSource source;

  /// Contains the description of an error in a Telegram Passport element; for bots only
  InputPassportElementError(
      {required this.type,
      required this.message,
      required this.source,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputPassportElementError',
      if (extra != null) '@extra': extra,
      'type': type,
      'message': message,
      'source': source
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputPassportElementError? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = PassportElementType.fromMap(_map['type'])!;
    var message = _map['message']! as String;
    var source = InputPassportElementErrorSource.fromMap(_map['source'])!;
    return InputPassportElementError(
      extra: extra,
      clientId: clientId,
      type: type,
      message: message,
      source: source,
    );
  }
}

/// A text message.
///
class MessageText extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageText";

  /// Text of the message.
  late FormattedText text;

  /// A preview of the web page that's mentioned in the text; may be null.
  WebPage? web_page;

  /// A text message
  MessageText({required this.text, this.web_page, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageText',
      if (extra != null) '@extra': extra,
      'text': text,
      'web_page': web_page
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = FormattedText.fromMap(_map['text'])!;
    var web_page = WebPage.fromMap(_map['web_page']);
    return MessageText(
      extra: extra,
      clientId: clientId,
      text: text,
      web_page: web_page,
    );
  }
}

/// An animation message (GIF-style)..
///
class MessageAnimation extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageAnimation";

  /// The animation description.
  late Animation animation;

  /// Animation caption.
  late FormattedText caption;

  /// True, if the animation preview must be covered by a spoiler animation.
  late bool has_spoiler;

  /// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped.
  late bool is_secret;

  /// An animation message (GIF-style).
  MessageAnimation(
      {required this.animation,
      required this.caption,
      required this.has_spoiler,
      required this.is_secret,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageAnimation',
      if (extra != null) '@extra': extra,
      'animation': animation,
      'caption': caption,
      'has_spoiler': has_spoiler,
      'is_secret': is_secret
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animation = Animation.fromMap(_map['animation'])!;
    var caption = FormattedText.fromMap(_map['caption'])!;
    var has_spoiler = _map['has_spoiler']! as bool;
    var is_secret = _map['is_secret']! as bool;
    return MessageAnimation(
      extra: extra,
      clientId: clientId,
      animation: animation,
      caption: caption,
      has_spoiler: has_spoiler,
      is_secret: is_secret,
    );
  }
}

/// An audio message.
///
class MessageAudio extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageAudio";

  /// The audio description.
  late Audio audio;

  /// Audio caption.
  late FormattedText caption;

  /// An audio message
  MessageAudio(
      {required this.audio, required this.caption, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageAudio',
      if (extra != null) '@extra': extra,
      'audio': audio,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageAudio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var audio = Audio.fromMap(_map['audio'])!;
    var caption = FormattedText.fromMap(_map['caption'])!;
    return MessageAudio(
      extra: extra,
      clientId: clientId,
      audio: audio,
      caption: caption,
    );
  }
}

/// A document message (general file).
///
class MessageDocument extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageDocument";

  /// The document description.
  late Document document;

  /// Document caption.
  late FormattedText caption;

  /// A document message (general file)
  MessageDocument(
      {required this.document,
      required this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageDocument',
      if (extra != null) '@extra': extra,
      'document': document,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var document = Document.fromMap(_map['document'])!;
    var caption = FormattedText.fromMap(_map['caption'])!;
    return MessageDocument(
      extra: extra,
      clientId: clientId,
      document: document,
      caption: caption,
    );
  }
}

/// A photo message.
///
class MessagePhoto extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messagePhoto";

  /// The photo.
  late Photo photo;

  /// Photo caption.
  late FormattedText caption;

  /// True, if the photo preview must be covered by a spoiler animation.
  late bool has_spoiler;

  /// True, if the photo must be blurred and must be shown only while tapped.
  late bool is_secret;

  /// A photo message
  MessagePhoto(
      {required this.photo,
      required this.caption,
      required this.has_spoiler,
      required this.is_secret,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messagePhoto',
      if (extra != null) '@extra': extra,
      'photo': photo,
      'caption': caption,
      'has_spoiler': has_spoiler,
      'is_secret': is_secret
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessagePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = Photo.fromMap(_map['photo'])!;
    var caption = FormattedText.fromMap(_map['caption'])!;
    var has_spoiler = _map['has_spoiler']! as bool;
    var is_secret = _map['is_secret']! as bool;
    return MessagePhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
      caption: caption,
      has_spoiler: has_spoiler,
      is_secret: is_secret,
    );
  }
}

/// A self-destructed photo message.
///
class MessageExpiredPhoto extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageExpiredPhoto";

  /// A self-destructed photo message
  MessageExpiredPhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'messageExpiredPhoto', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageExpiredPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageExpiredPhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A sticker message.
///
class MessageSticker extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSticker";

  /// The sticker description.
  late Sticker sticker;

  /// True, if premium animation of the sticker must be played.
  late bool is_premium;

  /// A sticker message
  MessageSticker(
      {required this.sticker,
      required this.is_premium,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSticker',
      if (extra != null) '@extra': extra,
      'sticker': sticker,
      'is_premium': is_premium
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = Sticker.fromMap(_map['sticker'])!;
    var is_premium = _map['is_premium']! as bool;
    return MessageSticker(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
      is_premium: is_premium,
    );
  }
}

/// A video message.
///
class MessageVideo extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageVideo";

  /// The video description.
  late Video video;

  /// Video caption.
  late FormattedText caption;

  /// True, if the video preview must be covered by a spoiler animation.
  late bool has_spoiler;

  /// True, if the video thumbnail must be blurred and the video must be shown only while tapped.
  late bool is_secret;

  /// A video message
  MessageVideo(
      {required this.video,
      required this.caption,
      required this.has_spoiler,
      required this.is_secret,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageVideo',
      if (extra != null) '@extra': extra,
      'video': video,
      'caption': caption,
      'has_spoiler': has_spoiler,
      'is_secret': is_secret
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video = Video.fromMap(_map['video'])!;
    var caption = FormattedText.fromMap(_map['caption'])!;
    var has_spoiler = _map['has_spoiler']! as bool;
    var is_secret = _map['is_secret']! as bool;
    return MessageVideo(
      extra: extra,
      clientId: clientId,
      video: video,
      caption: caption,
      has_spoiler: has_spoiler,
      is_secret: is_secret,
    );
  }
}

/// A self-destructed video message.
///
class MessageExpiredVideo extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageExpiredVideo";

  /// A self-destructed video message
  MessageExpiredVideo({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'messageExpiredVideo', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageExpiredVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageExpiredVideo(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A video note message.
///
class MessageVideoNote extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageVideoNote";

  /// The video note description.
  late VideoNote video_note;

  /// True, if at least one of the recipients has viewed the video note.
  late bool is_viewed;

  /// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped.
  late bool is_secret;

  /// A video note message
  MessageVideoNote(
      {required this.video_note,
      required this.is_viewed,
      required this.is_secret,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageVideoNote',
      if (extra != null) '@extra': extra,
      'video_note': video_note,
      'is_viewed': is_viewed,
      'is_secret': is_secret
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageVideoNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video_note = VideoNote.fromMap(_map['video_note'])!;
    var is_viewed = _map['is_viewed']! as bool;
    var is_secret = _map['is_secret']! as bool;
    return MessageVideoNote(
      extra: extra,
      clientId: clientId,
      video_note: video_note,
      is_viewed: is_viewed,
      is_secret: is_secret,
    );
  }
}

/// A voice note message.
///
class MessageVoiceNote extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageVoiceNote";

  /// The voice note description.
  late VoiceNote voice_note;

  /// Voice note caption.
  late FormattedText caption;

  /// True, if at least one of the recipients has listened to the voice note.
  late bool is_listened;

  /// A voice note message
  MessageVoiceNote(
      {required this.voice_note,
      required this.caption,
      required this.is_listened,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageVoiceNote',
      if (extra != null) '@extra': extra,
      'voice_note': voice_note,
      'caption': caption,
      'is_listened': is_listened
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var voice_note = VoiceNote.fromMap(_map['voice_note'])!;
    var caption = FormattedText.fromMap(_map['caption'])!;
    var is_listened = _map['is_listened']! as bool;
    return MessageVoiceNote(
      extra: extra,
      clientId: clientId,
      voice_note: voice_note,
      caption: caption,
      is_listened: is_listened,
    );
  }
}

/// A message with a location.
///
class MessageLocation extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageLocation";

  /// The location description.
  late Location location;

  /// Time relative to the message send date, for which the location can be updated, in seconds.
  late int live_period;

  /// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes.
  late int expires_in;

  /// For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown.
  late int heading;

  /// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender.
  late int proximity_alert_radius;

  /// A message with a location
  MessageLocation(
      {required this.location,
      required this.live_period,
      required this.expires_in,
      required this.heading,
      required this.proximity_alert_radius,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageLocation',
      if (extra != null) '@extra': extra,
      'location': location,
      'live_period': live_period,
      'expires_in': expires_in,
      'heading': heading,
      'proximity_alert_radius': proximity_alert_radius
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    var live_period = _map['live_period']! as int;
    var expires_in = _map['expires_in']! as int;
    var heading = _map['heading']! as int;
    var proximity_alert_radius = _map['proximity_alert_radius']! as int;
    return MessageLocation(
      extra: extra,
      clientId: clientId,
      location: location,
      live_period: live_period,
      expires_in: expires_in,
      heading: heading,
      proximity_alert_radius: proximity_alert_radius,
    );
  }
}

/// A message with information about a venue.
///
class MessageVenue extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageVenue";

  /// The venue description.
  late Venue venue;

  /// A message with information about a venue
  MessageVenue({required this.venue, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageVenue',
      if (extra != null) '@extra': extra,
      'venue': venue
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageVenue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var venue = Venue.fromMap(_map['venue'])!;
    return MessageVenue(
      extra: extra,
      clientId: clientId,
      venue: venue,
    );
  }
}

/// A message with a user contact.
///
class MessageContact extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageContact";

  /// The contact description.
  late Contact contact;

  /// A message with a user contact
  MessageContact({required this.contact, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageContact',
      if (extra != null) '@extra': extra,
      'contact': contact
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageContact? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var contact = Contact.fromMap(_map['contact'])!;
    return MessageContact(
      extra: extra,
      clientId: clientId,
      contact: contact,
    );
  }
}

/// A message with an animated emoji.
///
class MessageAnimatedEmoji extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageAnimatedEmoji";

  /// The animated emoji.
  late AnimatedEmoji animated_emoji;

  /// The corresponding emoji.
  late String emoji;

  /// A message with an animated emoji
  MessageAnimatedEmoji(
      {required this.animated_emoji,
      required this.emoji,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageAnimatedEmoji',
      if (extra != null) '@extra': extra,
      'animated_emoji': animated_emoji,
      'emoji': emoji
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageAnimatedEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animated_emoji = AnimatedEmoji.fromMap(_map['animated_emoji'])!;
    var emoji = _map['emoji']! as String;
    return MessageAnimatedEmoji(
      extra: extra,
      clientId: clientId,
      animated_emoji: animated_emoji,
      emoji: emoji,
    );
  }
}

/// A dice message. The dice value is randomly generated by the server.
///
class MessageDice extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageDice";

  /// The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known.
  DiceStickers? initial_state;

  /// The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known.
  DiceStickers? final_state;

  /// Emoji on which the dice throw animation is based.
  late String emoji;

  /// The dice value. If the value is 0, the dice don't have final state yet.
  late int value;

  /// Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded.
  late int success_animation_frame_number;

  /// A dice message. The dice value is randomly generated by the server
  MessageDice(
      {this.initial_state,
      this.final_state,
      required this.emoji,
      required this.value,
      required this.success_animation_frame_number,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageDice',
      if (extra != null) '@extra': extra,
      'initial_state': initial_state,
      'final_state': final_state,
      'emoji': emoji,
      'value': value,
      'success_animation_frame_number': success_animation_frame_number
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageDice? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var initial_state = DiceStickers.fromMap(_map['initial_state']);
    var final_state = DiceStickers.fromMap(_map['final_state']);
    var emoji = _map['emoji']! as String;
    var value = _map['value']! as int;
    var success_animation_frame_number =
        _map['success_animation_frame_number']! as int;
    return MessageDice(
      extra: extra,
      clientId: clientId,
      initial_state: initial_state,
      final_state: final_state,
      emoji: emoji,
      value: value,
      success_animation_frame_number: success_animation_frame_number,
    );
  }
}

/// A message with a game.
///
class MessageGame extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageGame";

  /// The game description.
  late Game game;

  /// A message with a game
  MessageGame({required this.game, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageGame',
      if (extra != null) '@extra': extra,
      'game': game
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageGame? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var game = Game.fromMap(_map['game'])!;
    return MessageGame(
      extra: extra,
      clientId: clientId,
      game: game,
    );
  }
}

/// A message with a poll.
///
class MessagePoll extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messagePoll";

  /// The poll description.
  late Poll poll;

  /// A message with a poll
  MessagePoll({required this.poll, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messagePoll',
      if (extra != null) '@extra': extra,
      'poll': poll
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessagePoll? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var poll = Poll.fromMap(_map['poll'])!;
    return MessagePoll(
      extra: extra,
      clientId: clientId,
      poll: poll,
    );
  }
}

/// A message with a forwarded story.
///
class MessageStory extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageStory";

  /// Identifier of the chat that posted the story.
  late int story_sender_chat_id;

  /// Story identifier.
  late int story_id;

  /// True, if the story was automatically forwarded because of a mention of the user.
  late bool via_mention;

  /// A message with a forwarded story
  MessageStory(
      {required this.story_sender_chat_id,
      required this.story_id,
      required this.via_mention,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageStory',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id,
      'via_mention': via_mention
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    var via_mention = _map['via_mention']! as bool;
    return MessageStory(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
      via_mention: via_mention,
    );
  }
}

/// A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice.
///
class MessageInvoice extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageInvoice";

  /// Product title.
  late String title;

  /// Product description.
  late FormattedText description;

  /// Product photo; may be null.
  Photo? photo;

  /// Currency for the product price.
  late String currency;

  /// Product total price in the smallest units of the currency.
  late int total_amount;

  /// Unique invoice bot start_parameter to be passed to getInternalLink.
  late String start_parameter;

  /// True, if the invoice is a test invoice.
  late bool is_test;

  /// True, if the shipping address must be specified.
  late bool need_shipping_address;

  /// The identifier of the message with the receipt, after the product has been purchased.
  late int receipt_message_id;

  /// Extended media attached to the invoice; may be null.
  MessageExtendedMedia? extended_media;

  /// A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
  MessageInvoice(
      {required this.title,
      required this.description,
      this.photo,
      required this.currency,
      required this.total_amount,
      required this.start_parameter,
      required this.is_test,
      required this.need_shipping_address,
      required this.receipt_message_id,
      this.extended_media,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageInvoice',
      if (extra != null) '@extra': extra,
      'title': title,
      'description': description,
      'photo': photo,
      'currency': currency,
      'total_amount': total_amount,
      'start_parameter': start_parameter,
      'is_test': is_test,
      'need_shipping_address': need_shipping_address,
      'receipt_message_id': receipt_message_id,
      'extended_media': extended_media
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageInvoice? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var description = FormattedText.fromMap(_map['description'])!;
    var photo = Photo.fromMap(_map['photo']);
    var currency = _map['currency']! as String;
    var total_amount = _map['total_amount']! as int;
    var start_parameter = _map['start_parameter']! as String;
    var is_test = _map['is_test']! as bool;
    var need_shipping_address = _map['need_shipping_address']! as bool;
    var receipt_message_id = _map['receipt_message_id']! as int;
    var extended_media = MessageExtendedMedia.fromMap(_map['extended_media']);
    return MessageInvoice(
      extra: extra,
      clientId: clientId,
      title: title,
      description: description,
      photo: photo,
      currency: currency,
      total_amount: total_amount,
      start_parameter: start_parameter,
      is_test: is_test,
      need_shipping_address: need_shipping_address,
      receipt_message_id: receipt_message_id,
      extended_media: extended_media,
    );
  }
}

/// A message with information about an ended call.
///
class MessageCall extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageCall";

  /// True, if the call was a video call.
  late bool is_video;

  /// Reason why the call was discarded.
  late CallDiscardReason discard_reason;

  /// Call duration, in seconds.
  late int duration;

  /// A message with information about an ended call
  MessageCall(
      {required this.is_video,
      required this.discard_reason,
      required this.duration,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageCall',
      if (extra != null) '@extra': extra,
      'is_video': is_video,
      'discard_reason': discard_reason,
      'duration': duration
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_video = _map['is_video']! as bool;
    var discard_reason = CallDiscardReason.fromMap(_map['discard_reason'])!;
    var duration = _map['duration']! as int;
    return MessageCall(
      extra: extra,
      clientId: clientId,
      is_video: is_video,
      discard_reason: discard_reason,
      duration: duration,
    );
  }
}

/// A new video chat was scheduled.
///
class MessageVideoChatScheduled extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageVideoChatScheduled";

  /// Identifier of the video chat. The video chat can be received through the method getGroupCall.
  late int group_call_id;

  /// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator.
  late int start_date;

  /// A new video chat was scheduled
  MessageVideoChatScheduled(
      {required this.group_call_id,
      required this.start_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageVideoChatScheduled',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'start_date': start_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageVideoChatScheduled? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var start_date = _map['start_date']! as int;
    return MessageVideoChatScheduled(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      start_date: start_date,
    );
  }
}

/// A newly created video chat.
///
class MessageVideoChatStarted extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageVideoChatStarted";

  /// Identifier of the video chat. The video chat can be received through the method getGroupCall.
  late int group_call_id;

  /// A newly created video chat
  MessageVideoChatStarted(
      {required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageVideoChatStarted',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageVideoChatStarted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return MessageVideoChatStarted(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// A message with information about an ended video chat.
///
class MessageVideoChatEnded extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageVideoChatEnded";

  /// Call duration, in seconds.
  late int duration;

  /// A message with information about an ended video chat
  MessageVideoChatEnded({required this.duration, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageVideoChatEnded',
      if (extra != null) '@extra': extra,
      'duration': duration
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageVideoChatEnded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var duration = _map['duration']! as int;
    return MessageVideoChatEnded(
      extra: extra,
      clientId: clientId,
      duration: duration,
    );
  }
}

/// A message with information about an invite to a video chat.
///
class MessageInviteVideoChatParticipants extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageInviteVideoChatParticipants";

  /// Identifier of the video chat. The video chat can be received through the method getGroupCall.
  late int group_call_id;

  /// Invited user identifiers.
  late List<int> user_ids;

  /// A message with information about an invite to a video chat
  MessageInviteVideoChatParticipants(
      {required this.group_call_id,
      required this.user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageInviteVideoChatParticipants',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageInviteVideoChatParticipants? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return MessageInviteVideoChatParticipants(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      user_ids: user_ids,
    );
  }
}

/// A newly created basic group.
///
class MessageBasicGroupChatCreate extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageBasicGroupChatCreate";

  /// Title of the basic group.
  late String title;

  /// User identifiers of members in the basic group.
  late List<int> member_user_ids;

  /// A newly created basic group
  MessageBasicGroupChatCreate(
      {required this.title,
      required this.member_user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageBasicGroupChatCreate',
      if (extra != null) '@extra': extra,
      'title': title,
      'member_user_ids': member_user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageBasicGroupChatCreate? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var member_user_ids = List<int>.from(
      (_map["member_user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return MessageBasicGroupChatCreate(
      extra: extra,
      clientId: clientId,
      title: title,
      member_user_ids: member_user_ids,
    );
  }
}

/// A newly created supergroup or channel.
///
class MessageSupergroupChatCreate extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSupergroupChatCreate";

  /// Title of the supergroup or channel.
  late String title;

  /// A newly created supergroup or channel
  MessageSupergroupChatCreate({required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSupergroupChatCreate',
      if (extra != null) '@extra': extra,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSupergroupChatCreate? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    return MessageSupergroupChatCreate(
      extra: extra,
      clientId: clientId,
      title: title,
    );
  }
}

/// An updated chat title.
///
class MessageChatChangeTitle extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatChangeTitle";

  /// New chat title.
  late String title;

  /// An updated chat title
  MessageChatChangeTitle({required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatChangeTitle',
      if (extra != null) '@extra': extra,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatChangeTitle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    return MessageChatChangeTitle(
      extra: extra,
      clientId: clientId,
      title: title,
    );
  }
}

/// An updated chat photo.
///
class MessageChatChangePhoto extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatChangePhoto";

  /// New chat photo.
  late ChatPhoto photo;

  /// An updated chat photo
  MessageChatChangePhoto({required this.photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatChangePhoto',
      if (extra != null) '@extra': extra,
      'photo': photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatChangePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = ChatPhoto.fromMap(_map['photo'])!;
    return MessageChatChangePhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
    );
  }
}

/// A deleted chat photo.
///
class MessageChatDeletePhoto extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatDeletePhoto";

  /// A deleted chat photo
  MessageChatDeletePhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatDeletePhoto',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatDeletePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageChatDeletePhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// New chat members were added.
///
class MessageChatAddMembers extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatAddMembers";

  /// User identifiers of the new members.
  late List<int> member_user_ids;

  /// New chat members were added
  MessageChatAddMembers(
      {required this.member_user_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatAddMembers',
      if (extra != null) '@extra': extra,
      'member_user_ids': member_user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatAddMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var member_user_ids = List<int>.from(
      (_map["member_user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return MessageChatAddMembers(
      extra: extra,
      clientId: clientId,
      member_user_ids: member_user_ids,
    );
  }
}

/// A new member joined the chat via an invite link.
///
class MessageChatJoinByLink extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatJoinByLink";

  /// A new member joined the chat via an invite link
  MessageChatJoinByLink({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatJoinByLink',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatJoinByLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageChatJoinByLink(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A new member was accepted to the chat by an administrator.
///
class MessageChatJoinByRequest extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatJoinByRequest";

  /// A new member was accepted to the chat by an administrator
  MessageChatJoinByRequest({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatJoinByRequest',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatJoinByRequest? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageChatJoinByRequest(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A chat member was deleted.
///
class MessageChatDeleteMember extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatDeleteMember";

  /// User identifier of the deleted chat member.
  late int user_id;

  /// A chat member was deleted
  MessageChatDeleteMember({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatDeleteMember',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatDeleteMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return MessageChatDeleteMember(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// A basic group was upgraded to a supergroup and was deactivated as the result.
///
class MessageChatUpgradeTo extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatUpgradeTo";

  /// Identifier of the supergroup to which the basic group was upgraded.
  late int supergroup_id;

  /// A basic group was upgraded to a supergroup and was deactivated as the result
  MessageChatUpgradeTo(
      {required this.supergroup_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatUpgradeTo',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatUpgradeTo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    return MessageChatUpgradeTo(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
    );
  }
}

/// A supergroup has been created from a basic group.
///
class MessageChatUpgradeFrom extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatUpgradeFrom";

  /// Title of the newly created supergroup.
  late String title;

  /// The identifier of the original basic group.
  late int basic_group_id;

  /// A supergroup has been created from a basic group
  MessageChatUpgradeFrom(
      {required this.title,
      required this.basic_group_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatUpgradeFrom',
      if (extra != null) '@extra': extra,
      'title': title,
      'basic_group_id': basic_group_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatUpgradeFrom? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var basic_group_id = _map['basic_group_id']! as int;
    return MessageChatUpgradeFrom(
      extra: extra,
      clientId: clientId,
      title: title,
      basic_group_id: basic_group_id,
    );
  }
}

/// A message has been pinned.
///
class MessagePinMessage extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messagePinMessage";

  /// Identifier of the pinned message, can be an identifier of a deleted message or 0.
  late int message_id;

  /// A message has been pinned
  MessagePinMessage({required this.message_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messagePinMessage',
      if (extra != null) '@extra': extra,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessagePinMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_id = _map['message_id']! as int;
    return MessagePinMessage(
      extra: extra,
      clientId: clientId,
      message_id: message_id,
    );
  }
}

/// A screenshot of a message in the chat has been taken.
///
class MessageScreenshotTaken extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageScreenshotTaken";

  /// A screenshot of a message in the chat has been taken
  MessageScreenshotTaken({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageScreenshotTaken',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageScreenshotTaken? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageScreenshotTaken(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A new background was set in the chat.
///
class MessageChatSetBackground extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatSetBackground";

  /// Identifier of the message with a previously set same background; 0 if none. Can be an identifier of a deleted message.
  late int old_background_message_id;

  /// The new background.
  late ChatBackground background;

  /// A new background was set in the chat
  MessageChatSetBackground(
      {required this.old_background_message_id,
      required this.background,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatSetBackground',
      if (extra != null) '@extra': extra,
      'old_background_message_id': old_background_message_id,
      'background': background
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatSetBackground? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_background_message_id = _map['old_background_message_id']! as int;
    var background = ChatBackground.fromMap(_map['background'])!;
    return MessageChatSetBackground(
      extra: extra,
      clientId: clientId,
      old_background_message_id: old_background_message_id,
      background: background,
    );
  }
}

/// A theme in the chat has been changed.
///
class MessageChatSetTheme extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatSetTheme";

  /// If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one.
  late String theme_name;

  /// A theme in the chat has been changed
  MessageChatSetTheme({required this.theme_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatSetTheme',
      if (extra != null) '@extra': extra,
      'theme_name': theme_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatSetTheme? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var theme_name = _map['theme_name']! as String;
    return MessageChatSetTheme(
      extra: extra,
      clientId: clientId,
      theme_name: theme_name,
    );
  }
}

/// The auto-delete or self-destruct timer for messages in the chat has been changed.
///
class MessageChatSetMessageAutoDeleteTime extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatSetMessageAutoDeleteTime";

  /// New value auto-delete or self-destruct time, in seconds; 0 if disabled.
  late int message_auto_delete_time;

  /// If not 0, a user identifier, which default setting was automatically applied.
  late int from_user_id;

  /// The auto-delete or self-destruct timer for messages in the chat has been changed
  MessageChatSetMessageAutoDeleteTime(
      {required this.message_auto_delete_time,
      required this.from_user_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatSetMessageAutoDeleteTime',
      if (extra != null) '@extra': extra,
      'message_auto_delete_time': message_auto_delete_time,
      'from_user_id': from_user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatSetMessageAutoDeleteTime? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_auto_delete_time = _map['message_auto_delete_time']! as int;
    var from_user_id = _map['from_user_id']! as int;
    return MessageChatSetMessageAutoDeleteTime(
      extra: extra,
      clientId: clientId,
      message_auto_delete_time: message_auto_delete_time,
      from_user_id: from_user_id,
    );
  }
}

/// A forum topic has been created.
///
class MessageForumTopicCreated extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForumTopicCreated";

  /// Name of the topic.
  late String name;

  /// Icon of the topic.
  late ForumTopicIcon icon;

  /// A forum topic has been created
  MessageForumTopicCreated(
      {required this.name, required this.icon, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForumTopicCreated',
      if (extra != null) '@extra': extra,
      'name': name,
      'icon': icon
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForumTopicCreated? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var icon = ForumTopicIcon.fromMap(_map['icon'])!;
    return MessageForumTopicCreated(
      extra: extra,
      clientId: clientId,
      name: name,
      icon: icon,
    );
  }
}

/// A forum topic has been edited.
///
class MessageForumTopicEdited extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForumTopicEdited";

  /// If non-empty, the new name of the topic.
  late String name;

  /// True, if icon's custom_emoji_id is changed.
  late bool edit_icon_custom_emoji_id;

  /// New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false.
  /// ; string representation of int, use `int.parse`
  late int64 icon_custom_emoji_id;

  /// A forum topic has been edited
  MessageForumTopicEdited(
      {required this.name,
      required this.edit_icon_custom_emoji_id,
      required this.icon_custom_emoji_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForumTopicEdited',
      if (extra != null) '@extra': extra,
      'name': name,
      'edit_icon_custom_emoji_id': edit_icon_custom_emoji_id,
      'icon_custom_emoji_id': icon_custom_emoji_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForumTopicEdited? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var edit_icon_custom_emoji_id = _map['edit_icon_custom_emoji_id']! as bool;
    var icon_custom_emoji_id = _map['icon_custom_emoji_id']! as int64;
    return MessageForumTopicEdited(
      extra: extra,
      clientId: clientId,
      name: name,
      edit_icon_custom_emoji_id: edit_icon_custom_emoji_id,
      icon_custom_emoji_id: icon_custom_emoji_id,
    );
  }
}

/// A forum topic has been closed or opened.
///
class MessageForumTopicIsClosedToggled extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForumTopicIsClosedToggled";

  /// True, if the topic was closed; otherwise, the topic was reopened.
  late bool is_closed;

  /// A forum topic has been closed or opened
  MessageForumTopicIsClosedToggled(
      {required this.is_closed, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForumTopicIsClosedToggled',
      if (extra != null) '@extra': extra,
      'is_closed': is_closed
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForumTopicIsClosedToggled? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_closed = _map['is_closed']! as bool;
    return MessageForumTopicIsClosedToggled(
      extra: extra,
      clientId: clientId,
      is_closed: is_closed,
    );
  }
}

/// A General forum topic has been hidden or unhidden.
///
class MessageForumTopicIsHiddenToggled extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageForumTopicIsHiddenToggled";

  /// True, if the topic was hidden; otherwise, the topic was unhidden.
  late bool is_hidden;

  /// A General forum topic has been hidden or unhidden
  MessageForumTopicIsHiddenToggled(
      {required this.is_hidden, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageForumTopicIsHiddenToggled',
      if (extra != null) '@extra': extra,
      'is_hidden': is_hidden
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageForumTopicIsHiddenToggled? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_hidden = _map['is_hidden']! as bool;
    return MessageForumTopicIsHiddenToggled(
      extra: extra,
      clientId: clientId,
      is_hidden: is_hidden,
    );
  }
}

/// A profile photo was suggested to a user in a private chat.
///
class MessageSuggestProfilePhoto extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSuggestProfilePhoto";

  /// The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo.
  late ChatPhoto photo;

  /// A profile photo was suggested to a user in a private chat
  MessageSuggestProfilePhoto({required this.photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSuggestProfilePhoto',
      if (extra != null) '@extra': extra,
      'photo': photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSuggestProfilePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = ChatPhoto.fromMap(_map['photo'])!;
    return MessageSuggestProfilePhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
    );
  }
}

/// A non-standard action has happened in the chat.
///
class MessageCustomServiceAction extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageCustomServiceAction";

  /// Message text to be shown in the chat.
  late String text;

  /// A non-standard action has happened in the chat
  MessageCustomServiceAction({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageCustomServiceAction',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageCustomServiceAction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    return MessageCustomServiceAction(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// A new high score was achieved in a game.
///
class MessageGameScore extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageGameScore";

  /// Identifier of the message with the game, can be an identifier of a deleted message.
  late int game_message_id;

  /// Identifier of the game; may be different from the games presented in the message with the game.
  /// ; string representation of int, use `int.parse`
  late int64 game_id;

  /// New score.
  late int score;

  /// A new high score was achieved in a game
  MessageGameScore(
      {required this.game_message_id,
      required this.game_id,
      required this.score,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageGameScore',
      if (extra != null) '@extra': extra,
      'game_message_id': game_message_id,
      'game_id': game_id,
      'score': score
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageGameScore? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var game_message_id = _map['game_message_id']! as int;
    var game_id = _map['game_id']! as int64;
    var score = _map['score']! as int;
    return MessageGameScore(
      extra: extra,
      clientId: clientId,
      game_message_id: game_message_id,
      game_id: game_id,
      score: score,
    );
  }
}

/// A payment has been completed.
///
class MessagePaymentSuccessful extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messagePaymentSuccessful";

  /// Identifier of the chat, containing the corresponding invoice message.
  late int invoice_chat_id;

  /// Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message.
  late int invoice_message_id;

  /// Currency for the price of the product.
  late String currency;

  /// Total price for the product, in the smallest units of the currency.
  late int total_amount;

  /// True, if this is a recurring payment.
  late bool is_recurring;

  /// True, if this is the first recurring payment.
  late bool is_first_recurring;

  /// Name of the invoice; may be empty if unknown.
  late String invoice_name;

  /// A payment has been completed
  MessagePaymentSuccessful(
      {required this.invoice_chat_id,
      required this.invoice_message_id,
      required this.currency,
      required this.total_amount,
      required this.is_recurring,
      required this.is_first_recurring,
      required this.invoice_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messagePaymentSuccessful',
      if (extra != null) '@extra': extra,
      'invoice_chat_id': invoice_chat_id,
      'invoice_message_id': invoice_message_id,
      'currency': currency,
      'total_amount': total_amount,
      'is_recurring': is_recurring,
      'is_first_recurring': is_first_recurring,
      'invoice_name': invoice_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessagePaymentSuccessful? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invoice_chat_id = _map['invoice_chat_id']! as int;
    var invoice_message_id = _map['invoice_message_id']! as int;
    var currency = _map['currency']! as String;
    var total_amount = _map['total_amount']! as int;
    var is_recurring = _map['is_recurring']! as bool;
    var is_first_recurring = _map['is_first_recurring']! as bool;
    var invoice_name = _map['invoice_name']! as String;
    return MessagePaymentSuccessful(
      extra: extra,
      clientId: clientId,
      invoice_chat_id: invoice_chat_id,
      invoice_message_id: invoice_message_id,
      currency: currency,
      total_amount: total_amount,
      is_recurring: is_recurring,
      is_first_recurring: is_first_recurring,
      invoice_name: invoice_name,
    );
  }
}

/// A payment has been completed; for bots only.
///
class MessagePaymentSuccessfulBot extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messagePaymentSuccessfulBot";

  /// Currency for price of the product.
  late String currency;

  /// Total price for the product, in the smallest units of the currency.
  late int total_amount;

  /// True, if this is a recurring payment.
  late bool is_recurring;

  /// True, if this is the first recurring payment.
  late bool is_first_recurring;

  /// Invoice payload.
  /// ; base64-encoded bytes `List<int>`
  late bytes invoice_payload;

  /// Identifier of the shipping option chosen by the user; may be empty if not applicable.
  late String shipping_option_id;

  /// Information about the order; may be null.
  OrderInfo? order_info;

  /// Telegram payment identifier.
  late String telegram_payment_charge_id;

  /// Provider payment identifier.
  late String provider_payment_charge_id;

  /// A payment has been completed; for bots only
  MessagePaymentSuccessfulBot(
      {required this.currency,
      required this.total_amount,
      required this.is_recurring,
      required this.is_first_recurring,
      required this.invoice_payload,
      required this.shipping_option_id,
      this.order_info,
      required this.telegram_payment_charge_id,
      required this.provider_payment_charge_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messagePaymentSuccessfulBot',
      if (extra != null) '@extra': extra,
      'currency': currency,
      'total_amount': total_amount,
      'is_recurring': is_recurring,
      'is_first_recurring': is_first_recurring,
      'invoice_payload': invoice_payload,
      'shipping_option_id': shipping_option_id,
      'order_info': order_info,
      'telegram_payment_charge_id': telegram_payment_charge_id,
      'provider_payment_charge_id': provider_payment_charge_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessagePaymentSuccessfulBot? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var currency = _map['currency']! as String;
    var total_amount = _map['total_amount']! as int;
    var is_recurring = _map['is_recurring']! as bool;
    var is_first_recurring = _map['is_first_recurring']! as bool;
    var invoice_payload = _map['invoice_payload']! as bytes;
    var shipping_option_id = _map['shipping_option_id']! as String;
    var order_info = OrderInfo.fromMap(_map['order_info']);
    var telegram_payment_charge_id =
        _map['telegram_payment_charge_id']! as String;
    var provider_payment_charge_id =
        _map['provider_payment_charge_id']! as String;
    return MessagePaymentSuccessfulBot(
      extra: extra,
      clientId: clientId,
      currency: currency,
      total_amount: total_amount,
      is_recurring: is_recurring,
      is_first_recurring: is_first_recurring,
      invoice_payload: invoice_payload,
      shipping_option_id: shipping_option_id,
      order_info: order_info,
      telegram_payment_charge_id: telegram_payment_charge_id,
      provider_payment_charge_id: provider_payment_charge_id,
    );
  }
}

/// Telegram Premium was gifted to the user.
///
class MessageGiftedPremium extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageGiftedPremium";

  /// The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous.
  late int gifter_user_id;

  /// Currency for the paid amount.
  late String currency;

  /// The paid amount, in the smallest units of the currency.
  late int amount;

  /// Cryptocurrency used to pay for the gift; may be empty if none.
  late String cryptocurrency;

  /// The paid amount, in the smallest units of the cryptocurrency.
  /// ; string representation of int, use `int.parse`
  late int64 cryptocurrency_amount;

  /// Number of month the Telegram Premium subscription will be active.
  late int month_count;

  /// A sticker to be shown in the message; may be null if unknown.
  Sticker? sticker;

  /// Telegram Premium was gifted to the user
  MessageGiftedPremium(
      {required this.gifter_user_id,
      required this.currency,
      required this.amount,
      required this.cryptocurrency,
      required this.cryptocurrency_amount,
      required this.month_count,
      this.sticker,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageGiftedPremium',
      if (extra != null) '@extra': extra,
      'gifter_user_id': gifter_user_id,
      'currency': currency,
      'amount': amount,
      'cryptocurrency': cryptocurrency,
      'cryptocurrency_amount': cryptocurrency_amount,
      'month_count': month_count,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageGiftedPremium? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var gifter_user_id = _map['gifter_user_id']! as int;
    var currency = _map['currency']! as String;
    var amount = _map['amount']! as int;
    var cryptocurrency = _map['cryptocurrency']! as String;
    var cryptocurrency_amount = _map['cryptocurrency_amount']! as int64;
    var month_count = _map['month_count']! as int;
    var sticker = Sticker.fromMap(_map['sticker']);
    return MessageGiftedPremium(
      extra: extra,
      clientId: clientId,
      gifter_user_id: gifter_user_id,
      currency: currency,
      amount: amount,
      cryptocurrency: cryptocurrency,
      cryptocurrency_amount: cryptocurrency_amount,
      month_count: month_count,
      sticker: sticker,
    );
  }
}

/// A contact has registered with Telegram.
///
class MessageContactRegistered extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageContactRegistered";

  /// A contact has registered with Telegram
  MessageContactRegistered({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageContactRegistered',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageContactRegistered? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageContactRegistered(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The current user shared a user, which was requested by the bot.
///
class MessageUserShared extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageUserShared";

  /// Identifier of the shared user.
  late int user_id;

  /// Identifier of the keyboard button with the request.
  late int button_id;

  /// The current user shared a user, which was requested by the bot
  MessageUserShared(
      {required this.user_id,
      required this.button_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageUserShared',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'button_id': button_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageUserShared? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var button_id = _map['button_id']! as int;
    return MessageUserShared(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      button_id: button_id,
    );
  }
}

/// The current user shared a chat, which was requested by the bot.
///
class MessageChatShared extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageChatShared";

  /// Identifier of the shared chat.
  late int chat_id;

  /// Identifier of the keyboard button with the request.
  late int button_id;

  /// The current user shared a chat, which was requested by the bot
  MessageChatShared(
      {required this.chat_id,
      required this.button_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageChatShared',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'button_id': button_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageChatShared? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var button_id = _map['button_id']! as int;
    return MessageChatShared(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      button_id: button_id,
    );
  }
}

/// The current user has connected a website by logging in using Telegram Login Widget on it.
///
class MessageWebsiteConnected extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageWebsiteConnected";

  /// Domain name of the connected website.
  late String domain_name;

  /// The current user has connected a website by logging in using Telegram Login Widget on it
  MessageWebsiteConnected(
      {required this.domain_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageWebsiteConnected',
      if (extra != null) '@extra': extra,
      'domain_name': domain_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageWebsiteConnected? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var domain_name = _map['domain_name']! as String;
    return MessageWebsiteConnected(
      extra: extra,
      clientId: clientId,
      domain_name: domain_name,
    );
  }
}

/// The user allowed the bot to send messages.
///
class MessageBotWriteAccessAllowed extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageBotWriteAccessAllowed";

  /// Information about the Web App, which requested the access; may be null if none or the Web App was opened from the attachment menu.
  WebApp? web_app;

  /// True, if user allowed the bot to send messages by an explicit call to allowBotToSendMessages.
  late bool by_request;

  /// The user allowed the bot to send messages
  MessageBotWriteAccessAllowed(
      {this.web_app, required this.by_request, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageBotWriteAccessAllowed',
      if (extra != null) '@extra': extra,
      'web_app': web_app,
      'by_request': by_request
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageBotWriteAccessAllowed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var web_app = WebApp.fromMap(_map['web_app']);
    var by_request = _map['by_request']! as bool;
    return MessageBotWriteAccessAllowed(
      extra: extra,
      clientId: clientId,
      web_app: web_app,
      by_request: by_request,
    );
  }
}

/// Data from a Web App has been sent to a bot.
///
class MessageWebAppDataSent extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageWebAppDataSent";

  /// Text of the keyboardButtonTypeWebApp button, which opened the Web App.
  late String button_text;

  /// Data from a Web App has been sent to a bot
  MessageWebAppDataSent({required this.button_text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageWebAppDataSent',
      if (extra != null) '@extra': extra,
      'button_text': button_text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageWebAppDataSent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var button_text = _map['button_text']! as String;
    return MessageWebAppDataSent(
      extra: extra,
      clientId: clientId,
      button_text: button_text,
    );
  }
}

/// Data from a Web App has been received; for bots only.
///
class MessageWebAppDataReceived extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageWebAppDataReceived";

  /// Text of the keyboardButtonTypeWebApp button, which opened the Web App.
  late String button_text;

  /// The data.
  late String data;

  /// Data from a Web App has been received; for bots only
  MessageWebAppDataReceived(
      {required this.button_text,
      required this.data,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageWebAppDataReceived',
      if (extra != null) '@extra': extra,
      'button_text': button_text,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageWebAppDataReceived? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var button_text = _map['button_text']! as String;
    var data = _map['data']! as String;
    return MessageWebAppDataReceived(
      extra: extra,
      clientId: clientId,
      button_text: button_text,
      data: data,
    );
  }
}

/// Telegram Passport data has been sent to a bot.
///
class MessagePassportDataSent extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messagePassportDataSent";

  /// List of Telegram Passport element types sent.
  late List<PassportElementType> types;

  /// Telegram Passport data has been sent to a bot
  MessagePassportDataSent({required this.types, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messagePassportDataSent',
      if (extra != null) '@extra': extra,
      'types': types
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessagePassportDataSent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var types = List<PassportElementType>.from(
      (_map["types"] ?? []).map(
        (e) => PassportElementType.fromMap(e),
      ),
    );
    return MessagePassportDataSent(
      extra: extra,
      clientId: clientId,
      types: types,
    );
  }
}

/// Telegram Passport data has been received; for bots only.
///
class MessagePassportDataReceived extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messagePassportDataReceived";

  /// List of received Telegram Passport elements.
  late List<EncryptedPassportElement> elements;

  /// Encrypted data credentials.
  late EncryptedCredentials credentials;

  /// Telegram Passport data has been received; for bots only
  MessagePassportDataReceived(
      {required this.elements,
      required this.credentials,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messagePassportDataReceived',
      if (extra != null) '@extra': extra,
      'elements': elements,
      'credentials': credentials
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessagePassportDataReceived? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var elements = List<EncryptedPassportElement>.from(
      (_map["elements"] ?? []).map(
        (e) => EncryptedPassportElement.fromMap(e),
      ),
    );
    var credentials = EncryptedCredentials.fromMap(_map['credentials'])!;
    return MessagePassportDataReceived(
      extra: extra,
      clientId: clientId,
      elements: elements,
      credentials: credentials,
    );
  }
}

/// A user in the chat came within proximity alert range.
///
class MessageProximityAlertTriggered extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageProximityAlertTriggered";

  /// The identifier of a user or chat that triggered the proximity alert.
  late MessageSender traveler_id;

  /// The identifier of a user or chat that subscribed for the proximity alert.
  late MessageSender watcher_id;

  /// The distance between the users.
  late int distance;

  /// A user in the chat came within proximity alert range
  MessageProximityAlertTriggered(
      {required this.traveler_id,
      required this.watcher_id,
      required this.distance,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageProximityAlertTriggered',
      if (extra != null) '@extra': extra,
      'traveler_id': traveler_id,
      'watcher_id': watcher_id,
      'distance': distance
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageProximityAlertTriggered? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var traveler_id = MessageSender.fromMap(_map['traveler_id'])!;
    var watcher_id = MessageSender.fromMap(_map['watcher_id'])!;
    var distance = _map['distance']! as int;
    return MessageProximityAlertTriggered(
      extra: extra,
      clientId: clientId,
      traveler_id: traveler_id,
      watcher_id: watcher_id,
      distance: distance,
    );
  }
}

/// A message content that is not supported in the current TDLib version.
///
class MessageUnsupported extends MessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageUnsupported";

  /// A message content that is not supported in the current TDLib version
  MessageUnsupported({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'messageUnsupported', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageUnsupported? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageUnsupported(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A mention of a user, a supergroup, or a channel by their username.
///
class TextEntityTypeMention extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeMention";

  /// A mention of a user, a supergroup, or a channel by their username
  TextEntityTypeMention({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeMention',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeMention? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeMention(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A hashtag text, beginning with "#".
///
class TextEntityTypeHashtag extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeHashtag";

  /// A hashtag text, beginning with "#"
  TextEntityTypeHashtag({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeHashtag',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeHashtag? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeHashtag(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A cashtag text, beginning with "$" and consisting of capital English letters (e.g., "$USD").
///
class TextEntityTypeCashtag extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeCashtag";

  /// A cashtag text, beginning with "$" and consisting of capital English letters (e.g., "$USD")
  TextEntityTypeCashtag({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeCashtag',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeCashtag? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeCashtag(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A bot command, beginning with "/".
///
class TextEntityTypeBotCommand extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeBotCommand";

  /// A bot command, beginning with "/"
  TextEntityTypeBotCommand({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeBotCommand',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeBotCommand? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeBotCommand(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// An HTTP URL.
///
class TextEntityTypeUrl extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeUrl";

  /// An HTTP URL
  TextEntityTypeUrl({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'textEntityTypeUrl', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeUrl(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// An email address.
///
class TextEntityTypeEmailAddress extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeEmailAddress";

  /// An email address
  TextEntityTypeEmailAddress({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeEmailAddress',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeEmailAddress(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A phone number.
///
class TextEntityTypePhoneNumber extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypePhoneNumber";

  /// A phone number
  TextEntityTypePhoneNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypePhoneNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypePhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypePhoneNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A bank card number. The getBankCardInfo method can be used to get information about the bank card.
///
class TextEntityTypeBankCardNumber extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeBankCardNumber";

  /// A bank card number. The getBankCardInfo method can be used to get information about the bank card
  TextEntityTypeBankCardNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeBankCardNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeBankCardNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeBankCardNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A bold text.
///
class TextEntityTypeBold extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeBold";

  /// A bold text
  TextEntityTypeBold({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'textEntityTypeBold', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeBold? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeBold(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// An italic text.
///
class TextEntityTypeItalic extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeItalic";

  /// An italic text
  TextEntityTypeItalic({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeItalic',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeItalic? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeItalic(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// An underlined text.
///
class TextEntityTypeUnderline extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeUnderline";

  /// An underlined text
  TextEntityTypeUnderline({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeUnderline',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeUnderline? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeUnderline(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A strikethrough text.
///
class TextEntityTypeStrikethrough extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeStrikethrough";

  /// A strikethrough text
  TextEntityTypeStrikethrough({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeStrikethrough',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeStrikethrough? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeStrikethrough(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A spoiler text.
///
class TextEntityTypeSpoiler extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeSpoiler";

  /// A spoiler text
  TextEntityTypeSpoiler({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeSpoiler',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeSpoiler? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeSpoiler(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Text that must be formatted as if inside a code HTML tag.
///
class TextEntityTypeCode extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeCode";

  /// Text that must be formatted as if inside a code HTML tag
  TextEntityTypeCode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'textEntityTypeCode', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypeCode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Text that must be formatted as if inside a pre HTML tag.
///
class TextEntityTypePre extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypePre";

  /// Text that must be formatted as if inside a pre HTML tag
  TextEntityTypePre({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'textEntityTypePre', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypePre? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextEntityTypePre(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Text that must be formatted as if inside pre, and code HTML tags.
///
class TextEntityTypePreCode extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypePreCode";

  /// Programming language of the code; as defined by the sender.
  late String language;

  /// Text that must be formatted as if inside pre, and code HTML tags
  TextEntityTypePreCode({required this.language, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypePreCode',
      if (extra != null) '@extra': extra,
      'language': language
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypePreCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language = _map['language']! as String;
    return TextEntityTypePreCode(
      extra: extra,
      clientId: clientId,
      language: language,
    );
  }
}

/// A text description shown instead of a raw URL.
///
class TextEntityTypeTextUrl extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeTextUrl";

  /// HTTP or tg:// URL to be opened when the link is clicked.
  late String url;

  /// A text description shown instead of a raw URL
  TextEntityTypeTextUrl({required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeTextUrl',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeTextUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return TextEntityTypeTextUrl(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// A text shows instead of a raw mention of the user (e.g., when the user has no username).
///
class TextEntityTypeMentionName extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeMentionName";

  /// Identifier of the mentioned user.
  late int user_id;

  /// A text shows instead of a raw mention of the user (e.g., when the user has no username)
  TextEntityTypeMentionName({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeMentionName',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeMentionName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return TextEntityTypeMentionName(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// A custom emoji. The text behind a custom emoji must be an emoji. Only premium users can use premium custom emoji.
///
class TextEntityTypeCustomEmoji extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeCustomEmoji";

  /// Unique identifier of the custom emoji.
  /// ; string representation of int, use `int.parse`
  late int64 custom_emoji_id;

  /// A custom emoji. The text behind a custom emoji must be an emoji. Only premium users can use premium custom emoji
  TextEntityTypeCustomEmoji(
      {required this.custom_emoji_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeCustomEmoji',
      if (extra != null) '@extra': extra,
      'custom_emoji_id': custom_emoji_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeCustomEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_emoji_id = _map['custom_emoji_id']! as int64;
    return TextEntityTypeCustomEmoji(
      extra: extra,
      clientId: clientId,
      custom_emoji_id: custom_emoji_id,
    );
  }
}

/// A media timestamp.
///
class TextEntityTypeMediaTimestamp extends TextEntityType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textEntityTypeMediaTimestamp";

  /// Timestamp from which a video/audio/video note/voice note playing must start, in seconds. The media can be in the content or the web page preview of the current message, or in the same places in the replied message.
  late int media_timestamp;

  /// A media timestamp
  TextEntityTypeMediaTimestamp(
      {required this.media_timestamp, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textEntityTypeMediaTimestamp',
      if (extra != null) '@extra': extra,
      'media_timestamp': media_timestamp
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextEntityTypeMediaTimestamp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var media_timestamp = _map['media_timestamp']! as int;
    return TextEntityTypeMediaTimestamp(
      extra: extra,
      clientId: clientId,
      media_timestamp: media_timestamp,
    );
  }
}

/// A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size.
///
class InputThumbnail extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputThumbnail";

  /// Thumbnail file to send. Sending thumbnails by file_id is currently not supported.
  late InputFile thumbnail;

  /// Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown.
  late int width;

  /// Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown.
  late int height;

  /// A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size
  InputThumbnail(
      {required this.thumbnail,
      required this.width,
      required this.height,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputThumbnail',
      if (extra != null) '@extra': extra,
      'thumbnail': thumbnail,
      'width': width,
      'height': height
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputThumbnail? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var thumbnail = InputFile.fromMap(_map['thumbnail'])!;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    return InputThumbnail(
      extra: extra,
      clientId: clientId,
      thumbnail: thumbnail,
      width: width,
      height: height,
    );
  }
}

/// The message will be sent at the specified date.
///
class MessageSchedulingStateSendAtDate extends MessageSchedulingState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSchedulingStateSendAtDate";

  /// Point in time (Unix timestamp) when the message will be sent. The date must be within 367 days in the future.
  late int send_date;

  /// The message will be sent at the specified date
  MessageSchedulingStateSendAtDate(
      {required this.send_date, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSchedulingStateSendAtDate',
      if (extra != null) '@extra': extra,
      'send_date': send_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSchedulingStateSendAtDate? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var send_date = _map['send_date']! as int;
    return MessageSchedulingStateSendAtDate(
      extra: extra,
      clientId: clientId,
      send_date: send_date,
    );
  }
}

/// The message will be sent when the peer will be online. Applicable to private chats only and when the exact online status of the peer is known.
///
class MessageSchedulingStateSendWhenOnline extends MessageSchedulingState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSchedulingStateSendWhenOnline";

  /// The message will be sent when the peer will be online. Applicable to private chats only and when the exact online status of the peer is known
  MessageSchedulingStateSendWhenOnline({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSchedulingStateSendWhenOnline',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSchedulingStateSendWhenOnline? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSchedulingStateSendWhenOnline(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The message will be self-destructed in the specified time after its content was opened.
///
class MessageSelfDestructTypeTimer extends MessageSelfDestructType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSelfDestructTypeTimer";

  /// The message's self-destruct time, in seconds; must be between 0 and 60 in private chats.
  late int self_destruct_time;

  /// The message will be self-destructed in the specified time after its content was opened
  MessageSelfDestructTypeTimer(
      {required this.self_destruct_time, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSelfDestructTypeTimer',
      if (extra != null) '@extra': extra,
      'self_destruct_time': self_destruct_time
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSelfDestructTypeTimer? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var self_destruct_time = _map['self_destruct_time']! as int;
    return MessageSelfDestructTypeTimer(
      extra: extra,
      clientId: clientId,
      self_destruct_time: self_destruct_time,
    );
  }
}

/// The message can be opened only once and will be self-destructed once closed.
///
class MessageSelfDestructTypeImmediately extends MessageSelfDestructType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSelfDestructTypeImmediately";

  /// The message can be opened only once and will be self-destructed once closed
  MessageSelfDestructTypeImmediately({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSelfDestructTypeImmediately',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSelfDestructTypeImmediately? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageSelfDestructTypeImmediately(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Options to be used when a message is sent.
///
class MessageSendOptions extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageSendOptions";

  /// Pass true to disable notification for the message.
  late bool disable_notification;

  /// Pass true if the message is sent from the background.
  late bool from_background;

  /// Pass true if the content of the message must be protected from forwarding and saving; for bots only.
  late bool protect_content;

  /// Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum.
  late bool update_order_of_installed_sticker_sets;

  /// Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled.
  MessageSchedulingState? scheduling_state;

  /// Non-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates.
  late int sending_id;

  /// Options to be used when a message is sent
  MessageSendOptions(
      {required this.disable_notification,
      required this.from_background,
      required this.protect_content,
      required this.update_order_of_installed_sticker_sets,
      this.scheduling_state,
      required this.sending_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageSendOptions',
      if (extra != null) '@extra': extra,
      'disable_notification': disable_notification,
      'from_background': from_background,
      'protect_content': protect_content,
      'update_order_of_installed_sticker_sets':
          update_order_of_installed_sticker_sets,
      'scheduling_state': scheduling_state,
      'sending_id': sending_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageSendOptions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var disable_notification = _map['disable_notification']! as bool;
    var from_background = _map['from_background']! as bool;
    var protect_content = _map['protect_content']! as bool;
    var update_order_of_installed_sticker_sets =
        _map['update_order_of_installed_sticker_sets']! as bool;
    var scheduling_state =
        MessageSchedulingState.fromMap(_map['scheduling_state']);
    var sending_id = _map['sending_id']! as int;
    return MessageSendOptions(
      extra: extra,
      clientId: clientId,
      disable_notification: disable_notification,
      from_background: from_background,
      protect_content: protect_content,
      update_order_of_installed_sticker_sets:
          update_order_of_installed_sticker_sets,
      scheduling_state: scheduling_state,
      sending_id: sending_id,
    );
  }
}

/// Options to be used when a message content is copied without reference to the original sender. Service messages and messageInvoice can't be copied.
///
class MessageCopyOptions extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageCopyOptions";

  /// True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local.
  late bool send_copy;

  /// True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false.
  late bool replace_caption;

  /// New message caption; pass null to copy message without caption. Ignored if replace_caption is false.
  FormattedText? new_caption;

  /// Options to be used when a message content is copied without reference to the original sender. Service messages and messageInvoice can't be copied
  MessageCopyOptions(
      {required this.send_copy,
      required this.replace_caption,
      this.new_caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageCopyOptions',
      if (extra != null) '@extra': extra,
      'send_copy': send_copy,
      'replace_caption': replace_caption,
      'new_caption': new_caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageCopyOptions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var send_copy = _map['send_copy']! as bool;
    var replace_caption = _map['replace_caption']! as bool;
    var new_caption = FormattedText.fromMap(_map['new_caption']);
    return MessageCopyOptions(
      extra: extra,
      clientId: clientId,
      send_copy: send_copy,
      replace_caption: replace_caption,
      new_caption: new_caption,
    );
  }
}

/// A text message.
///
class InputMessageText extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageText";

  /// Formatted text to be sent; 1-getOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually.
  late FormattedText text;

  /// True, if rich web page previews for URLs in the message text must be disabled.
  late bool disable_web_page_preview;

  /// True, if a chat message draft must be deleted.
  late bool clear_draft;

  /// A text message
  InputMessageText(
      {required this.text,
      required this.disable_web_page_preview,
      required this.clear_draft,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageText',
      if (extra != null) '@extra': extra,
      'text': text,
      'disable_web_page_preview': disable_web_page_preview,
      'clear_draft': clear_draft
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = FormattedText.fromMap(_map['text'])!;
    var disable_web_page_preview = _map['disable_web_page_preview']! as bool;
    var clear_draft = _map['clear_draft']! as bool;
    return InputMessageText(
      extra: extra,
      clientId: clientId,
      text: text,
      disable_web_page_preview: disable_web_page_preview,
      clear_draft: clear_draft,
    );
  }
}

/// An animation message (GIF-style)..
///
class InputMessageAnimation extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageAnimation";

  /// Animation file to be sent.
  late InputFile animation;

  /// Animation thumbnail; pass null to skip thumbnail uploading.
  InputThumbnail? thumbnail;

  /// File identifiers of the stickers added to the animation, if applicable.
  late List<int> added_sticker_file_ids;

  /// Duration of the animation, in seconds.
  late int duration;

  /// Width of the animation; may be replaced by the server.
  late int width;

  /// Height of the animation; may be replaced by the server.
  late int height;

  /// Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters.
  FormattedText? caption;

  /// True, if the animation preview must be covered by a spoiler animation; not supported in secret chats.
  late bool has_spoiler;

  /// An animation message (GIF-style).
  InputMessageAnimation(
      {required this.animation,
      this.thumbnail,
      required this.added_sticker_file_ids,
      required this.duration,
      required this.width,
      required this.height,
      this.caption,
      required this.has_spoiler,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageAnimation',
      if (extra != null) '@extra': extra,
      'animation': animation,
      'thumbnail': thumbnail,
      'added_sticker_file_ids': added_sticker_file_ids,
      'duration': duration,
      'width': width,
      'height': height,
      'caption': caption,
      'has_spoiler': has_spoiler
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animation = InputFile.fromMap(_map['animation'])!;
    var thumbnail = InputThumbnail.fromMap(_map['thumbnail']);
    var added_sticker_file_ids = List<int>.from(
      (_map["added_sticker_file_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var duration = _map['duration']! as int;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var caption = FormattedText.fromMap(_map['caption']);
    var has_spoiler = _map['has_spoiler']! as bool;
    return InputMessageAnimation(
      extra: extra,
      clientId: clientId,
      animation: animation,
      thumbnail: thumbnail,
      added_sticker_file_ids: added_sticker_file_ids,
      duration: duration,
      width: width,
      height: height,
      caption: caption,
      has_spoiler: has_spoiler,
    );
  }
}

/// An audio message.
///
class InputMessageAudio extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageAudio";

  /// Audio file to be sent.
  late InputFile audio;

  /// Thumbnail of the cover for the album; pass null to skip thumbnail uploading.
  InputThumbnail? album_cover_thumbnail;

  /// Duration of the audio, in seconds; may be replaced by the server.
  late int duration;

  /// Title of the audio; 0-64 characters; may be replaced by the server.
  late String title;

  /// Performer of the audio; 0-64 characters, may be replaced by the server.
  late String performer;

  /// Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters.
  FormattedText? caption;

  /// An audio message
  InputMessageAudio(
      {required this.audio,
      this.album_cover_thumbnail,
      required this.duration,
      required this.title,
      required this.performer,
      this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageAudio',
      if (extra != null) '@extra': extra,
      'audio': audio,
      'album_cover_thumbnail': album_cover_thumbnail,
      'duration': duration,
      'title': title,
      'performer': performer,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageAudio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var audio = InputFile.fromMap(_map['audio'])!;
    var album_cover_thumbnail =
        InputThumbnail.fromMap(_map['album_cover_thumbnail']);
    var duration = _map['duration']! as int;
    var title = _map['title']! as String;
    var performer = _map['performer']! as String;
    var caption = FormattedText.fromMap(_map['caption']);
    return InputMessageAudio(
      extra: extra,
      clientId: clientId,
      audio: audio,
      album_cover_thumbnail: album_cover_thumbnail,
      duration: duration,
      title: title,
      performer: performer,
      caption: caption,
    );
  }
}

/// A document message (general file).
///
class InputMessageDocument extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageDocument";

  /// Document to be sent.
  late InputFile document;

  /// Document thumbnail; pass null to skip thumbnail uploading.
  InputThumbnail? thumbnail;

  /// If true, automatic file type detection will be disabled and the document will always be sent as file. Always true for files sent to secret chats.
  late bool disable_content_type_detection;

  /// Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters.
  FormattedText? caption;

  /// A document message (general file)
  InputMessageDocument(
      {required this.document,
      this.thumbnail,
      required this.disable_content_type_detection,
      this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageDocument',
      if (extra != null) '@extra': extra,
      'document': document,
      'thumbnail': thumbnail,
      'disable_content_type_detection': disable_content_type_detection,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var document = InputFile.fromMap(_map['document'])!;
    var thumbnail = InputThumbnail.fromMap(_map['thumbnail']);
    var disable_content_type_detection =
        _map['disable_content_type_detection']! as bool;
    var caption = FormattedText.fromMap(_map['caption']);
    return InputMessageDocument(
      extra: extra,
      clientId: clientId,
      document: document,
      thumbnail: thumbnail,
      disable_content_type_detection: disable_content_type_detection,
      caption: caption,
    );
  }
}

/// A photo message.
///
class InputMessagePhoto extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessagePhoto";

  /// Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20.
  late InputFile photo;

  /// Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats.
  InputThumbnail? thumbnail;

  /// File identifiers of the stickers added to the photo, if applicable.
  late List<int> added_sticker_file_ids;

  /// Photo width.
  late int width;

  /// Photo height.
  late int height;

  /// Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters.
  FormattedText? caption;

  /// Photo self-destruct type; pass null if none; private chats only.
  MessageSelfDestructType? self_destruct_type;

  /// True, if the photo preview must be covered by a spoiler animation; not supported in secret chats.
  late bool has_spoiler;

  /// A photo message
  InputMessagePhoto(
      {required this.photo,
      this.thumbnail,
      required this.added_sticker_file_ids,
      required this.width,
      required this.height,
      this.caption,
      this.self_destruct_type,
      required this.has_spoiler,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessagePhoto',
      if (extra != null) '@extra': extra,
      'photo': photo,
      'thumbnail': thumbnail,
      'added_sticker_file_ids': added_sticker_file_ids,
      'width': width,
      'height': height,
      'caption': caption,
      'self_destruct_type': self_destruct_type,
      'has_spoiler': has_spoiler
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessagePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = InputFile.fromMap(_map['photo'])!;
    var thumbnail = InputThumbnail.fromMap(_map['thumbnail']);
    var added_sticker_file_ids = List<int>.from(
      (_map["added_sticker_file_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var caption = FormattedText.fromMap(_map['caption']);
    var self_destruct_type =
        MessageSelfDestructType.fromMap(_map['self_destruct_type']);
    var has_spoiler = _map['has_spoiler']! as bool;
    return InputMessagePhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
      thumbnail: thumbnail,
      added_sticker_file_ids: added_sticker_file_ids,
      width: width,
      height: height,
      caption: caption,
      self_destruct_type: self_destruct_type,
      has_spoiler: has_spoiler,
    );
  }
}

/// A sticker message.
///
class InputMessageSticker extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageSticker";

  /// Sticker to be sent.
  late InputFile sticker;

  /// Sticker thumbnail; pass null to skip thumbnail uploading.
  InputThumbnail? thumbnail;

  /// Sticker width.
  late int width;

  /// Sticker height.
  late int height;

  /// Emoji used to choose the sticker.
  late String emoji;

  /// A sticker message
  InputMessageSticker(
      {required this.sticker,
      this.thumbnail,
      required this.width,
      required this.height,
      required this.emoji,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageSticker',
      if (extra != null) '@extra': extra,
      'sticker': sticker,
      'thumbnail': thumbnail,
      'width': width,
      'height': height,
      'emoji': emoji
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    var thumbnail = InputThumbnail.fromMap(_map['thumbnail']);
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var emoji = _map['emoji']! as String;
    return InputMessageSticker(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
      thumbnail: thumbnail,
      width: width,
      height: height,
      emoji: emoji,
    );
  }
}

/// A video message.
///
class InputMessageVideo extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageVideo";

  /// Video to be sent.
  late InputFile video;

  /// Video thumbnail; pass null to skip thumbnail uploading.
  InputThumbnail? thumbnail;

  /// File identifiers of the stickers added to the video, if applicable.
  late List<int> added_sticker_file_ids;

  /// Duration of the video, in seconds.
  late int duration;

  /// Video width.
  late int width;

  /// Video height.
  late int height;

  /// True, if the video is supposed to be streamed.
  late bool supports_streaming;

  /// Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters.
  FormattedText? caption;

  /// Video self-destruct type; pass null if none; private chats only.
  MessageSelfDestructType? self_destruct_type;

  /// True, if the video preview must be covered by a spoiler animation; not supported in secret chats.
  late bool has_spoiler;

  /// A video message
  InputMessageVideo(
      {required this.video,
      this.thumbnail,
      required this.added_sticker_file_ids,
      required this.duration,
      required this.width,
      required this.height,
      required this.supports_streaming,
      this.caption,
      this.self_destruct_type,
      required this.has_spoiler,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageVideo',
      if (extra != null) '@extra': extra,
      'video': video,
      'thumbnail': thumbnail,
      'added_sticker_file_ids': added_sticker_file_ids,
      'duration': duration,
      'width': width,
      'height': height,
      'supports_streaming': supports_streaming,
      'caption': caption,
      'self_destruct_type': self_destruct_type,
      'has_spoiler': has_spoiler
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video = InputFile.fromMap(_map['video'])!;
    var thumbnail = InputThumbnail.fromMap(_map['thumbnail']);
    var added_sticker_file_ids = List<int>.from(
      (_map["added_sticker_file_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var duration = _map['duration']! as int;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var supports_streaming = _map['supports_streaming']! as bool;
    var caption = FormattedText.fromMap(_map['caption']);
    var self_destruct_type =
        MessageSelfDestructType.fromMap(_map['self_destruct_type']);
    var has_spoiler = _map['has_spoiler']! as bool;
    return InputMessageVideo(
      extra: extra,
      clientId: clientId,
      video: video,
      thumbnail: thumbnail,
      added_sticker_file_ids: added_sticker_file_ids,
      duration: duration,
      width: width,
      height: height,
      supports_streaming: supports_streaming,
      caption: caption,
      self_destruct_type: self_destruct_type,
      has_spoiler: has_spoiler,
    );
  }
}

/// A video note message.
///
class InputMessageVideoNote extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageVideoNote";

  /// Video note to be sent.
  late InputFile video_note;

  /// Video thumbnail; pass null to skip thumbnail uploading.
  InputThumbnail? thumbnail;

  /// Duration of the video, in seconds.
  late int duration;

  /// Video width and height; must be positive and not greater than 640.
  late int length;

  /// A video note message
  InputMessageVideoNote(
      {required this.video_note,
      this.thumbnail,
      required this.duration,
      required this.length,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageVideoNote',
      if (extra != null) '@extra': extra,
      'video_note': video_note,
      'thumbnail': thumbnail,
      'duration': duration,
      'length': length
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageVideoNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video_note = InputFile.fromMap(_map['video_note'])!;
    var thumbnail = InputThumbnail.fromMap(_map['thumbnail']);
    var duration = _map['duration']! as int;
    var length = _map['length']! as int;
    return InputMessageVideoNote(
      extra: extra,
      clientId: clientId,
      video_note: video_note,
      thumbnail: thumbnail,
      duration: duration,
      length: length,
    );
  }
}

/// A voice note message.
///
class InputMessageVoiceNote extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageVoiceNote";

  /// Voice note to be sent.
  late InputFile voice_note;

  /// Duration of the voice note, in seconds.
  late int duration;

  /// Waveform representation of the voice note in 5-bit format.
  /// ; base64-encoded bytes `List<int>`
  late bytes waveform;

  /// Voice note caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters.
  FormattedText? caption;

  /// A voice note message
  InputMessageVoiceNote(
      {required this.voice_note,
      required this.duration,
      required this.waveform,
      this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageVoiceNote',
      if (extra != null) '@extra': extra,
      'voice_note': voice_note,
      'duration': duration,
      'waveform': waveform,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var voice_note = InputFile.fromMap(_map['voice_note'])!;
    var duration = _map['duration']! as int;
    var waveform = _map['waveform']! as bytes;
    var caption = FormattedText.fromMap(_map['caption']);
    return InputMessageVoiceNote(
      extra: extra,
      clientId: clientId,
      voice_note: voice_note,
      duration: duration,
      waveform: waveform,
      caption: caption,
    );
  }
}

/// A message with a location.
///
class InputMessageLocation extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageLocation";

  /// Location to be sent.
  late Location location;

  /// Period for which the location can be updated, in seconds; must be between 60 and 86400 for a live location and 0 otherwise.
  late int live_period;

  /// For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown.
  late int heading;

  /// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages.
  late int proximity_alert_radius;

  /// A message with a location
  InputMessageLocation(
      {required this.location,
      required this.live_period,
      required this.heading,
      required this.proximity_alert_radius,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageLocation',
      if (extra != null) '@extra': extra,
      'location': location,
      'live_period': live_period,
      'heading': heading,
      'proximity_alert_radius': proximity_alert_radius
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    var live_period = _map['live_period']! as int;
    var heading = _map['heading']! as int;
    var proximity_alert_radius = _map['proximity_alert_radius']! as int;
    return InputMessageLocation(
      extra: extra,
      clientId: clientId,
      location: location,
      live_period: live_period,
      heading: heading,
      proximity_alert_radius: proximity_alert_radius,
    );
  }
}

/// A message with information about a venue.
///
class InputMessageVenue extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageVenue";

  /// Venue to send.
  late Venue venue;

  /// A message with information about a venue
  InputMessageVenue({required this.venue, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageVenue',
      if (extra != null) '@extra': extra,
      'venue': venue
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageVenue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var venue = Venue.fromMap(_map['venue'])!;
    return InputMessageVenue(
      extra: extra,
      clientId: clientId,
      venue: venue,
    );
  }
}

/// A message containing a user contact.
///
class InputMessageContact extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageContact";

  /// Contact to send.
  late Contact contact;

  /// A message containing a user contact
  InputMessageContact({required this.contact, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageContact',
      if (extra != null) '@extra': extra,
      'contact': contact
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageContact? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var contact = Contact.fromMap(_map['contact'])!;
    return InputMessageContact(
      extra: extra,
      clientId: clientId,
      contact: contact,
    );
  }
}

/// A dice message.
///
class InputMessageDice extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageDice";

  /// Emoji on which the dice throw animation is based.
  late String emoji;

  /// True, if the chat message draft must be deleted.
  late bool clear_draft;

  /// A dice message
  InputMessageDice(
      {required this.emoji,
      required this.clear_draft,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageDice',
      if (extra != null) '@extra': extra,
      'emoji': emoji,
      'clear_draft': clear_draft
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageDice? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emoji = _map['emoji']! as String;
    var clear_draft = _map['clear_draft']! as bool;
    return InputMessageDice(
      extra: extra,
      clientId: clientId,
      emoji: emoji,
      clear_draft: clear_draft,
    );
  }
}

/// A message with a game; not supported for channels or secret chats.
///
class InputMessageGame extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageGame";

  /// User identifier of the bot that owns the game.
  late int bot_user_id;

  /// Short name of the game.
  late String game_short_name;

  /// A message with a game; not supported for channels or secret chats
  InputMessageGame(
      {required this.bot_user_id,
      required this.game_short_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageGame',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'game_short_name': game_short_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageGame? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var game_short_name = _map['game_short_name']! as String;
    return InputMessageGame(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      game_short_name: game_short_name,
    );
  }
}

/// A message with an invoice; can be used only by bots.
///
class InputMessageInvoice extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageInvoice";

  /// Invoice.
  late Invoice invoice;

  /// Product title; 1-32 characters.
  late String title;

  /// Product description; 0-255 characters.
  late String description;

  /// Product photo URL; optional.
  late String photo_url;

  /// Product photo size.
  late int photo_size;

  /// Product photo width.
  late int photo_width;

  /// Product photo height.
  late int photo_height;

  /// The invoice payload.
  /// ; base64-encoded bytes `List<int>`
  late bytes payload;

  /// Payment provider token.
  late String provider_token;

  /// JSON-encoded data about the invoice, which will be shared with the payment provider.
  late String provider_data;

  /// Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message.
  String? start_parameter;

  /// The content of extended media attached to the invoice. The content of the message to be sent. Must be one of the following types: inputMessagePhoto, inputMessageVideo.
  late InputMessageContent extended_media_content;

  /// A message with an invoice; can be used only by bots
  InputMessageInvoice(
      {required this.invoice,
      required this.title,
      required this.description,
      required this.photo_url,
      required this.photo_size,
      required this.photo_width,
      required this.photo_height,
      required this.payload,
      required this.provider_token,
      required this.provider_data,
      this.start_parameter,
      required this.extended_media_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageInvoice',
      if (extra != null) '@extra': extra,
      'invoice': invoice,
      'title': title,
      'description': description,
      'photo_url': photo_url,
      'photo_size': photo_size,
      'photo_width': photo_width,
      'photo_height': photo_height,
      'payload': payload,
      'provider_token': provider_token,
      'provider_data': provider_data,
      'start_parameter': start_parameter,
      'extended_media_content': extended_media_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageInvoice? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invoice = Invoice.fromMap(_map['invoice'])!;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    var photo_url = _map['photo_url']! as String;
    var photo_size = _map['photo_size']! as int;
    var photo_width = _map['photo_width']! as int;
    var photo_height = _map['photo_height']! as int;
    var payload = _map['payload']! as bytes;
    var provider_token = _map['provider_token']! as String;
    var provider_data = _map['provider_data']! as String;
    var start_parameter = _map['start_parameter'] as String?;
    var extended_media_content =
        InputMessageContent.fromMap(_map['extended_media_content'])!;
    return InputMessageInvoice(
      extra: extra,
      clientId: clientId,
      invoice: invoice,
      title: title,
      description: description,
      photo_url: photo_url,
      photo_size: photo_size,
      photo_width: photo_width,
      photo_height: photo_height,
      payload: payload,
      provider_token: provider_token,
      provider_data: provider_data,
      start_parameter: start_parameter,
      extended_media_content: extended_media_content,
    );
  }
}

/// A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot.
///
class InputMessagePoll extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessagePoll";

  /// Poll question; 1-255 characters (up to 300 characters for bots).
  late String question;

  /// List of poll answer options, 2-10 strings 1-100 characters each.
  late List<String> options;

  /// True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels.
  late bool is_anonymous;

  /// Type of the poll.
  late PollType type;

  /// Amount of time the poll will be active after creation, in seconds; for bots only.
  late int open_period;

  /// Point in time (Unix timestamp) when the poll will automatically be closed; for bots only.
  late int close_date;

  /// True, if the poll needs to be sent already closed; for bots only.
  late bool is_closed;

  /// A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
  InputMessagePoll(
      {required this.question,
      required this.options,
      required this.is_anonymous,
      required this.type,
      required this.open_period,
      required this.close_date,
      required this.is_closed,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessagePoll',
      if (extra != null) '@extra': extra,
      'question': question,
      'options': options,
      'is_anonymous': is_anonymous,
      'type': type,
      'open_period': open_period,
      'close_date': close_date,
      'is_closed': is_closed
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessagePoll? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var question = _map['question']! as String;
    var options = List<String>.from(
      (_map["options"] ?? []).map(
        (e) => e as String,
      ),
    );
    var is_anonymous = _map['is_anonymous']! as bool;
    var type = PollType.fromMap(_map['type'])!;
    var open_period = _map['open_period']! as int;
    var close_date = _map['close_date']! as int;
    var is_closed = _map['is_closed']! as bool;
    return InputMessagePoll(
      extra: extra,
      clientId: clientId,
      question: question,
      options: options,
      is_anonymous: is_anonymous,
      type: type,
      open_period: open_period,
      close_date: close_date,
      is_closed: is_closed,
    );
  }
}

/// A message with a forwarded story. Stories can't be sent to secret chats. A story can be forwarded only if story.can_be_forwarded.
///
class InputMessageStory extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageStory";

  /// Identifier of the chat that posted the story.
  late int story_sender_chat_id;

  /// Story identifier.
  late int story_id;

  /// A message with a forwarded story. Stories can't be sent to secret chats. A story can be forwarded only if story.can_be_forwarded
  InputMessageStory(
      {required this.story_sender_chat_id,
      required this.story_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageStory',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    return InputMessageStory(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
    );
  }
}

/// A forwarded message.
///
class InputMessageForwarded extends InputMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputMessageForwarded";

  /// Identifier for the chat this forwarded message came from.
  late int from_chat_id;

  /// Identifier of the message to forward.
  late int message_id;

  /// True, if a game message is being shared from a launched game; applies only to game messages.
  late bool in_game_share;

  /// Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual.
  MessageCopyOptions? copy_options;

  /// A forwarded message
  InputMessageForwarded(
      {required this.from_chat_id,
      required this.message_id,
      required this.in_game_share,
      this.copy_options,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputMessageForwarded',
      if (extra != null) '@extra': extra,
      'from_chat_id': from_chat_id,
      'message_id': message_id,
      'in_game_share': in_game_share,
      'copy_options': copy_options
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputMessageForwarded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var from_chat_id = _map['from_chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var in_game_share = _map['in_game_share']! as bool;
    var copy_options = MessageCopyOptions.fromMap(_map['copy_options']);
    return InputMessageForwarded(
      extra: extra,
      clientId: clientId,
      from_chat_id: from_chat_id,
      message_id: message_id,
      in_game_share: in_game_share,
      copy_options: copy_options,
    );
  }
}

/// Returns all found messages, no filter is applied.
///
class SearchMessagesFilterEmpty extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterEmpty";

  /// Returns all found messages, no filter is applied
  SearchMessagesFilterEmpty({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterEmpty',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterEmpty? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterEmpty(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only animation messages.
///
class SearchMessagesFilterAnimation extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterAnimation";

  /// Returns only animation messages
  SearchMessagesFilterAnimation({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterAnimation',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterAnimation(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only audio messages.
///
class SearchMessagesFilterAudio extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterAudio";

  /// Returns only audio messages
  SearchMessagesFilterAudio({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterAudio',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterAudio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterAudio(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only document messages.
///
class SearchMessagesFilterDocument extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterDocument";

  /// Returns only document messages
  SearchMessagesFilterDocument({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterDocument',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterDocument(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only photo messages.
///
class SearchMessagesFilterPhoto extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterPhoto";

  /// Returns only photo messages
  SearchMessagesFilterPhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterPhoto',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterPhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only video messages.
///
class SearchMessagesFilterVideo extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterVideo";

  /// Returns only video messages
  SearchMessagesFilterVideo({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterVideo',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterVideo(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only voice note messages.
///
class SearchMessagesFilterVoiceNote extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterVoiceNote";

  /// Returns only voice note messages
  SearchMessagesFilterVoiceNote({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterVoiceNote',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterVoiceNote(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only photo and video messages.
///
class SearchMessagesFilterPhotoAndVideo extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterPhotoAndVideo";

  /// Returns only photo and video messages
  SearchMessagesFilterPhotoAndVideo({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterPhotoAndVideo',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterPhotoAndVideo? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterPhotoAndVideo(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only messages containing URLs.
///
class SearchMessagesFilterUrl extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterUrl";

  /// Returns only messages containing URLs
  SearchMessagesFilterUrl({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterUrl',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterUrl(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only messages containing chat photos.
///
class SearchMessagesFilterChatPhoto extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterChatPhoto";

  /// Returns only messages containing chat photos
  SearchMessagesFilterChatPhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterChatPhoto',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterChatPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterChatPhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only video note messages.
///
class SearchMessagesFilterVideoNote extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterVideoNote";

  /// Returns only video note messages
  SearchMessagesFilterVideoNote({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterVideoNote',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterVideoNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterVideoNote(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only voice and video note messages.
///
class SearchMessagesFilterVoiceAndVideoNote extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterVoiceAndVideoNote";

  /// Returns only voice and video note messages
  SearchMessagesFilterVoiceAndVideoNote({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterVoiceAndVideoNote',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterVoiceAndVideoNote? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterVoiceAndVideoNote(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only messages with mentions of the current user, or messages that are replies to their messages.
///
class SearchMessagesFilterMention extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterMention";

  /// Returns only messages with mentions of the current user, or messages that are replies to their messages
  SearchMessagesFilterMention({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterMention',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterMention? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterMention(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user.
///
class SearchMessagesFilterUnreadMention extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterUnreadMention";

  /// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
  SearchMessagesFilterUnreadMention({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterUnreadMention',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterUnreadMention? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterUnreadMention(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only messages with unread reactions for the current user. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user.
///
class SearchMessagesFilterUnreadReaction extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterUnreadReaction";

  /// Returns only messages with unread reactions for the current user. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
  SearchMessagesFilterUnreadReaction({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterUnreadReaction',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterUnreadReaction? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterUnreadReaction(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only failed to send messages. This filter can be used only if the message database is used.
///
class SearchMessagesFilterFailedToSend extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterFailedToSend";

  /// Returns only failed to send messages. This filter can be used only if the message database is used
  SearchMessagesFilterFailedToSend({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterFailedToSend',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterFailedToSend? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterFailedToSend(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns only pinned messages.
///
class SearchMessagesFilterPinned extends SearchMessagesFilter {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessagesFilterPinned";

  /// Returns only pinned messages
  SearchMessagesFilterPinned({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessagesFilterPinned',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessagesFilterPinned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SearchMessagesFilterPinned(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is typing a message.
///
class ChatActionTyping extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionTyping";

  /// The user is typing a message
  ChatActionTyping({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'chatActionTyping', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionTyping? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionTyping(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is recording a video.
///
class ChatActionRecordingVideo extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionRecordingVideo";

  /// The user is recording a video
  ChatActionRecordingVideo({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionRecordingVideo',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionRecordingVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionRecordingVideo(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is uploading a video.
///
class ChatActionUploadingVideo extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionUploadingVideo";

  /// Upload progress, as a percentage.
  late int progress;

  /// The user is uploading a video
  ChatActionUploadingVideo({required this.progress, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionUploadingVideo',
      if (extra != null) '@extra': extra,
      'progress': progress
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionUploadingVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var progress = _map['progress']! as int;
    return ChatActionUploadingVideo(
      extra: extra,
      clientId: clientId,
      progress: progress,
    );
  }
}

/// The user is recording a voice note.
///
class ChatActionRecordingVoiceNote extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionRecordingVoiceNote";

  /// The user is recording a voice note
  ChatActionRecordingVoiceNote({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionRecordingVoiceNote',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionRecordingVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionRecordingVoiceNote(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is uploading a voice note.
///
class ChatActionUploadingVoiceNote extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionUploadingVoiceNote";

  /// Upload progress, as a percentage.
  late int progress;

  /// The user is uploading a voice note
  ChatActionUploadingVoiceNote(
      {required this.progress, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionUploadingVoiceNote',
      if (extra != null) '@extra': extra,
      'progress': progress
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionUploadingVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var progress = _map['progress']! as int;
    return ChatActionUploadingVoiceNote(
      extra: extra,
      clientId: clientId,
      progress: progress,
    );
  }
}

/// The user is uploading a photo.
///
class ChatActionUploadingPhoto extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionUploadingPhoto";

  /// Upload progress, as a percentage.
  late int progress;

  /// The user is uploading a photo
  ChatActionUploadingPhoto({required this.progress, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionUploadingPhoto',
      if (extra != null) '@extra': extra,
      'progress': progress
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionUploadingPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var progress = _map['progress']! as int;
    return ChatActionUploadingPhoto(
      extra: extra,
      clientId: clientId,
      progress: progress,
    );
  }
}

/// The user is uploading a document.
///
class ChatActionUploadingDocument extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionUploadingDocument";

  /// Upload progress, as a percentage.
  late int progress;

  /// The user is uploading a document
  ChatActionUploadingDocument(
      {required this.progress, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionUploadingDocument',
      if (extra != null) '@extra': extra,
      'progress': progress
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionUploadingDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var progress = _map['progress']! as int;
    return ChatActionUploadingDocument(
      extra: extra,
      clientId: clientId,
      progress: progress,
    );
  }
}

/// The user is picking a sticker to send.
///
class ChatActionChoosingSticker extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionChoosingSticker";

  /// The user is picking a sticker to send
  ChatActionChoosingSticker({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionChoosingSticker',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionChoosingSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionChoosingSticker(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is picking a location or venue to send.
///
class ChatActionChoosingLocation extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionChoosingLocation";

  /// The user is picking a location or venue to send
  ChatActionChoosingLocation({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionChoosingLocation',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionChoosingLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionChoosingLocation(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is picking a contact to send.
///
class ChatActionChoosingContact extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionChoosingContact";

  /// The user is picking a contact to send
  ChatActionChoosingContact({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionChoosingContact',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionChoosingContact? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionChoosingContact(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user has started to play a game.
///
class ChatActionStartPlayingGame extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionStartPlayingGame";

  /// The user has started to play a game
  ChatActionStartPlayingGame({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionStartPlayingGame',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionStartPlayingGame? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionStartPlayingGame(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is recording a video note.
///
class ChatActionRecordingVideoNote extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionRecordingVideoNote";

  /// The user is recording a video note
  ChatActionRecordingVideoNote({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionRecordingVideoNote',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionRecordingVideoNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionRecordingVideoNote(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is uploading a video note.
///
class ChatActionUploadingVideoNote extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionUploadingVideoNote";

  /// Upload progress, as a percentage.
  late int progress;

  /// The user is uploading a video note
  ChatActionUploadingVideoNote(
      {required this.progress, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionUploadingVideoNote',
      if (extra != null) '@extra': extra,
      'progress': progress
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionUploadingVideoNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var progress = _map['progress']! as int;
    return ChatActionUploadingVideoNote(
      extra: extra,
      clientId: clientId,
      progress: progress,
    );
  }
}

/// The user is watching animations sent by the other party by clicking on an animated emoji.
///
class ChatActionWatchingAnimations extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionWatchingAnimations";

  /// The animated emoji.
  late String emoji;

  /// The user is watching animations sent by the other party by clicking on an animated emoji
  ChatActionWatchingAnimations(
      {required this.emoji, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActionWatchingAnimations',
      if (extra != null) '@extra': extra,
      'emoji': emoji
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionWatchingAnimations? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emoji = _map['emoji']! as String;
    return ChatActionWatchingAnimations(
      extra: extra,
      clientId: clientId,
      emoji: emoji,
    );
  }
}

/// The user has canceled the previous action.
///
class ChatActionCancel extends ChatAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActionCancel";

  /// The user has canceled the previous action
  ChatActionCancel({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'chatActionCancel', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActionCancel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatActionCancel(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user status was never changed.
///
class UserStatusEmpty extends UserStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userStatusEmpty";

  /// The user status was never changed
  UserStatusEmpty({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'userStatusEmpty', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserStatusEmpty? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserStatusEmpty(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is online.
///
class UserStatusOnline extends UserStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userStatusOnline";

  /// Point in time (Unix timestamp) when the user's online status will expire.
  late int expires;

  /// The user is online
  UserStatusOnline({required this.expires, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userStatusOnline',
      if (extra != null) '@extra': extra,
      'expires': expires
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserStatusOnline? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var expires = _map['expires']! as int;
    return UserStatusOnline(
      extra: extra,
      clientId: clientId,
      expires: expires,
    );
  }
}

/// The user is offline.
///
class UserStatusOffline extends UserStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userStatusOffline";

  /// Point in time (Unix timestamp) when the user was last online.
  late int was_online;

  /// The user is offline
  UserStatusOffline({required this.was_online, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userStatusOffline',
      if (extra != null) '@extra': extra,
      'was_online': was_online
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserStatusOffline? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var was_online = _map['was_online']! as int;
    return UserStatusOffline(
      extra: extra,
      clientId: clientId,
      was_online: was_online,
    );
  }
}

/// The user was online recently.
///
class UserStatusRecently extends UserStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userStatusRecently";

  /// The user was online recently
  UserStatusRecently({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'userStatusRecently', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserStatusRecently? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserStatusRecently(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is offline, but was online last week.
///
class UserStatusLastWeek extends UserStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userStatusLastWeek";

  /// The user is offline, but was online last week
  UserStatusLastWeek({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'userStatusLastWeek', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserStatusLastWeek? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserStatusLastWeek(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user is offline, but was online last month.
///
class UserStatusLastMonth extends UserStatus {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userStatusLastMonth";

  /// The user is offline, but was online last month
  UserStatusLastMonth({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'userStatusLastMonth', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserStatusLastMonth? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserStatusLastMonth(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents a list of stickers.
///
class Stickers extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickers";

  /// List of stickers.
  late List<Sticker> stickers;

  /// Represents a list of stickers
  Stickers({required this.stickers, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stickers',
      if (extra != null) '@extra': extra,
      'stickers': stickers
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Stickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var stickers = List<Sticker>.from(
      (_map["stickers"] ?? []).map(
        (e) => Sticker.fromMap(e),
      ),
    );
    return Stickers(
      extra: extra,
      clientId: clientId,
      stickers: stickers,
    );
  }
}

/// Represents a list of emoji.
///
class Emojis extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emojis";

  /// List of emojis.
  late List<String> emojis;

  /// Represents a list of emoji
  Emojis({required this.emojis, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emojis',
      if (extra != null) '@extra': extra,
      'emojis': emojis
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Emojis? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emojis = List<String>.from(
      (_map["emojis"] ?? []).map(
        (e) => e as String,
      ),
    );
    return Emojis(
      extra: extra,
      clientId: clientId,
      emojis: emojis,
    );
  }
}

/// Represents a sticker set.
///
class StickerSet extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerSet";

  /// Identifier of the sticker set.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Title of the sticker set.
  late String title;

  /// Name of the sticker set.
  late String name;

  /// Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed.
  Thumbnail? thumbnail;

  /// Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner.
  late List<ClosedVectorPath> thumbnail_outline;

  /// True, if the sticker set has been installed by the current user.
  late bool is_installed;

  /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously.
  late bool is_archived;

  /// True, if the sticker set is official.
  late bool is_official;

  /// Format of the stickers in the set.
  late StickerFormat sticker_format;

  /// Type of the stickers in the set.
  late StickerType sticker_type;

  /// True for already viewed trending sticker sets.
  late bool is_viewed;

  /// List of stickers in this set.
  late List<Sticker> stickers;

  /// A list of emoji corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object.
  late List<List<String>> emojis;

  /// Represents a sticker set
  StickerSet(
      {required this.id,
      required this.title,
      required this.name,
      this.thumbnail,
      required this.thumbnail_outline,
      required this.is_installed,
      required this.is_archived,
      required this.is_official,
      required this.sticker_format,
      required this.sticker_type,
      required this.is_viewed,
      required this.stickers,
      required this.emojis,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stickerSet',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'name': name,
      'thumbnail': thumbnail,
      'thumbnail_outline': thumbnail_outline,
      'is_installed': is_installed,
      'is_archived': is_archived,
      'is_official': is_official,
      'sticker_format': sticker_format,
      'sticker_type': sticker_type,
      'is_viewed': is_viewed,
      'stickers': stickers,
      'emojis': emojis
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var title = _map['title']! as String;
    var name = _map['name']! as String;
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    var thumbnail_outline = List<ClosedVectorPath>.from(
      (_map["thumbnail_outline"] ?? []).map(
        (e) => ClosedVectorPath.fromMap(e),
      ),
    );
    var is_installed = _map['is_installed']! as bool;
    var is_archived = _map['is_archived']! as bool;
    var is_official = _map['is_official']! as bool;
    var sticker_format = StickerFormat.fromMap(_map['sticker_format'])!;
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var is_viewed = _map['is_viewed']! as bool;
    var stickers = List<Sticker>.from(
      (_map["stickers"] ?? []).map(
        (e) => Sticker.fromMap(e),
      ),
    );
    var emojis = List<List<String>>.from(
      (_map["emojis"] ?? []).map(
        (e) => e as List<String>,
      ),
    );
    return StickerSet(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      name: name,
      thumbnail: thumbnail,
      thumbnail_outline: thumbnail_outline,
      is_installed: is_installed,
      is_archived: is_archived,
      is_official: is_official,
      sticker_format: sticker_format,
      sticker_type: sticker_type,
      is_viewed: is_viewed,
      stickers: stickers,
      emojis: emojis,
    );
  }
}

/// Represents short information about a sticker set.
///
class StickerSetInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerSetInfo";

  /// Identifier of the sticker set.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Title of the sticker set.
  late String title;

  /// Name of the sticker set.
  late String name;

  /// Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null.
  Thumbnail? thumbnail;

  /// Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner.
  late List<ClosedVectorPath> thumbnail_outline;

  /// True, if the sticker set has been installed by the current user.
  late bool is_installed;

  /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously.
  late bool is_archived;

  /// True, if the sticker set is official.
  late bool is_official;

  /// Format of the stickers in the set.
  late StickerFormat sticker_format;

  /// Type of the stickers in the set.
  late StickerType sticker_type;

  /// True for already viewed trending sticker sets.
  late bool is_viewed;

  /// Total number of stickers in the set.
  late int size;

  /// Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested.
  late List<Sticker> covers;

  /// Represents short information about a sticker set
  StickerSetInfo(
      {required this.id,
      required this.title,
      required this.name,
      this.thumbnail,
      required this.thumbnail_outline,
      required this.is_installed,
      required this.is_archived,
      required this.is_official,
      required this.sticker_format,
      required this.sticker_type,
      required this.is_viewed,
      required this.size,
      required this.covers,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stickerSetInfo',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'name': name,
      'thumbnail': thumbnail,
      'thumbnail_outline': thumbnail_outline,
      'is_installed': is_installed,
      'is_archived': is_archived,
      'is_official': is_official,
      'sticker_format': sticker_format,
      'sticker_type': sticker_type,
      'is_viewed': is_viewed,
      'size': size,
      'covers': covers
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerSetInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var title = _map['title']! as String;
    var name = _map['name']! as String;
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    var thumbnail_outline = List<ClosedVectorPath>.from(
      (_map["thumbnail_outline"] ?? []).map(
        (e) => ClosedVectorPath.fromMap(e),
      ),
    );
    var is_installed = _map['is_installed']! as bool;
    var is_archived = _map['is_archived']! as bool;
    var is_official = _map['is_official']! as bool;
    var sticker_format = StickerFormat.fromMap(_map['sticker_format'])!;
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var is_viewed = _map['is_viewed']! as bool;
    var size = _map['size']! as int;
    var covers = List<Sticker>.from(
      (_map["covers"] ?? []).map(
        (e) => Sticker.fromMap(e),
      ),
    );
    return StickerSetInfo(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      name: name,
      thumbnail: thumbnail,
      thumbnail_outline: thumbnail_outline,
      is_installed: is_installed,
      is_archived: is_archived,
      is_official: is_official,
      sticker_format: sticker_format,
      sticker_type: sticker_type,
      is_viewed: is_viewed,
      size: size,
      covers: covers,
    );
  }
}

/// Represents a list of sticker sets.
///
class StickerSets extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stickerSets";

  /// Approximate total number of sticker sets found.
  late int total_count;

  /// List of sticker sets.
  late List<StickerSetInfo> sets;

  /// Represents a list of sticker sets
  StickerSets(
      {required this.total_count,
      required this.sets,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stickerSets',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'sets': sets
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var sets = List<StickerSetInfo>.from(
      (_map["sets"] ?? []).map(
        (e) => StickerSetInfo.fromMap(e),
      ),
    );
    return StickerSets(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      sets: sets,
    );
  }
}

/// Represents a list of trending sticker sets.
///
class TrendingStickerSets extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "trendingStickerSets";

  /// Approximate total number of trending sticker sets.
  late int total_count;

  /// List of trending sticker sets.
  late List<StickerSetInfo> sets;

  /// True, if the list contains sticker sets with premium stickers.
  late bool is_premium;

  /// Represents a list of trending sticker sets
  TrendingStickerSets(
      {required this.total_count,
      required this.sets,
      required this.is_premium,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'trendingStickerSets',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'sets': sets,
      'is_premium': is_premium
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TrendingStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var sets = List<StickerSetInfo>.from(
      (_map["sets"] ?? []).map(
        (e) => StickerSetInfo.fromMap(e),
      ),
    );
    var is_premium = _map['is_premium']! as bool;
    return TrendingStickerSets(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      sets: sets,
      is_premium: is_premium,
    );
  }
}

/// Contains a list of similar emoji to search for in getStickers and searchStickers.
///
class EmojiCategory extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emojiCategory";

  /// Name of the category.
  late String name;

  /// Custom emoji sticker, which represents icon of the category.
  late Sticker icon;

  /// List of emojis in the category.
  late List<String> emojis;

  /// Contains a list of similar emoji to search for in getStickers and searchStickers
  EmojiCategory(
      {required this.name,
      required this.icon,
      required this.emojis,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emojiCategory',
      if (extra != null) '@extra': extra,
      'name': name,
      'icon': icon,
      'emojis': emojis
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmojiCategory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var icon = Sticker.fromMap(_map['icon'])!;
    var emojis = List<String>.from(
      (_map["emojis"] ?? []).map(
        (e) => e as String,
      ),
    );
    return EmojiCategory(
      extra: extra,
      clientId: clientId,
      name: name,
      icon: icon,
      emojis: emojis,
    );
  }
}

/// Represents a list of emoji categories.
///
class EmojiCategories extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emojiCategories";

  /// List of categories.
  late List<EmojiCategory> categories;

  /// Represents a list of emoji categories
  EmojiCategories({required this.categories, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emojiCategories',
      if (extra != null) '@extra': extra,
      'categories': categories
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmojiCategories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var categories = List<EmojiCategory>.from(
      (_map["categories"] ?? []).map(
        (e) => EmojiCategory.fromMap(e),
      ),
    );
    return EmojiCategories(
      extra: extra,
      clientId: clientId,
      categories: categories,
    );
  }
}

/// The category must be used by default.
///
class EmojiCategoryTypeDefault extends EmojiCategoryType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emojiCategoryTypeDefault";

  /// The category must be used by default
  EmojiCategoryTypeDefault({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emojiCategoryTypeDefault',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmojiCategoryTypeDefault? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return EmojiCategoryTypeDefault(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The category must be used for emoji status selection.
///
class EmojiCategoryTypeEmojiStatus extends EmojiCategoryType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emojiCategoryTypeEmojiStatus";

  /// The category must be used for emoji status selection
  EmojiCategoryTypeEmojiStatus({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emojiCategoryTypeEmojiStatus',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmojiCategoryTypeEmojiStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return EmojiCategoryTypeEmojiStatus(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The category must be used for chat photo emoji selection.
///
class EmojiCategoryTypeChatPhoto extends EmojiCategoryType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emojiCategoryTypeChatPhoto";

  /// The category must be used for chat photo emoji selection
  EmojiCategoryTypeChatPhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emojiCategoryTypeChatPhoto',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmojiCategoryTypeChatPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return EmojiCategoryTypeChatPhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents a viewer of a story.
///
class StoryViewer extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyViewer";

  /// User identifier of the viewer.
  late int user_id;

  /// Approximate point in time (Unix timestamp) when the story was viewed.
  late int view_date;

  /// Block list to which the user is added; may be null if none.
  BlockList? block_list;

  /// Type of the reaction that was chosen by the user; may be null if none.
  ReactionType? chosen_reaction_type;

  /// Represents a viewer of a story
  StoryViewer(
      {required this.user_id,
      required this.view_date,
      this.block_list,
      this.chosen_reaction_type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyViewer',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'view_date': view_date,
      'block_list': block_list,
      'chosen_reaction_type': chosen_reaction_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryViewer? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var view_date = _map['view_date']! as int;
    var block_list = BlockList.fromMap(_map['block_list']);
    var chosen_reaction_type =
        ReactionType.fromMap(_map['chosen_reaction_type']);
    return StoryViewer(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      view_date: view_date,
      block_list: block_list,
      chosen_reaction_type: chosen_reaction_type,
    );
  }
}

/// Represents a list of story viewers.
///
class StoryViewers extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyViewers";

  /// Approximate total number of story viewers found.
  late int total_count;

  /// Approximate total number of reactions set by found story viewers.
  late int total_reaction_count;

  /// List of story viewers.
  late List<StoryViewer> viewers;

  /// The offset for the next request. If empty, there are no more results.
  String? next_offset;

  /// Represents a list of story viewers
  StoryViewers(
      {required this.total_count,
      required this.total_reaction_count,
      required this.viewers,
      this.next_offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyViewers',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'total_reaction_count': total_reaction_count,
      'viewers': viewers,
      'next_offset': next_offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryViewers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var total_reaction_count = _map['total_reaction_count']! as int;
    var viewers = List<StoryViewer>.from(
      (_map["viewers"] ?? []).map(
        (e) => StoryViewer.fromMap(e),
      ),
    );
    var next_offset = _map['next_offset'] as String?;
    return StoryViewers(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      total_reaction_count: total_reaction_count,
      viewers: viewers,
      next_offset: next_offset,
    );
  }
}

/// Describes position of a clickable rectangle area on a story media.
///
class StoryAreaPosition extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyAreaPosition";

  /// The abscissa of the rectangle's center, as a percentage of the media width.
  late double x_percentage;

  /// The ordinate of the rectangle's center, as a percentage of the media height.
  late double y_percentage;

  /// The width of the rectangle, as a percentage of the media width.
  late double width_percentage;

  /// The ordinate of the rectangle's center, as a percentage of the media height.
  late double height_percentage;

  /// Clockwise rotation angle of the rectangle, in degrees; 0-360.
  late double rotation_angle;

  /// Describes position of a clickable rectangle area on a story media
  StoryAreaPosition(
      {required this.x_percentage,
      required this.y_percentage,
      required this.width_percentage,
      required this.height_percentage,
      required this.rotation_angle,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyAreaPosition',
      if (extra != null) '@extra': extra,
      'x_percentage': x_percentage,
      'y_percentage': y_percentage,
      'width_percentage': width_percentage,
      'height_percentage': height_percentage,
      'rotation_angle': rotation_angle
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryAreaPosition? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var x_percentage = _map['x_percentage']! as double;
    var y_percentage = _map['y_percentage']! as double;
    var width_percentage = _map['width_percentage']! as double;
    var height_percentage = _map['height_percentage']! as double;
    var rotation_angle = _map['rotation_angle']! as double;
    return StoryAreaPosition(
      extra: extra,
      clientId: clientId,
      x_percentage: x_percentage,
      y_percentage: y_percentage,
      width_percentage: width_percentage,
      height_percentage: height_percentage,
      rotation_angle: rotation_angle,
    );
  }
}

/// An area pointing to a location.
///
class StoryAreaTypeLocation extends StoryAreaType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyAreaTypeLocation";

  /// The location.
  late Location location;

  /// An area pointing to a location
  StoryAreaTypeLocation({required this.location, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyAreaTypeLocation',
      if (extra != null) '@extra': extra,
      'location': location
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryAreaTypeLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    return StoryAreaTypeLocation(
      extra: extra,
      clientId: clientId,
      location: location,
    );
  }
}

/// An area pointing to a venue.
///
class StoryAreaTypeVenue extends StoryAreaType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyAreaTypeVenue";

  /// Information about the venue.
  late Venue venue;

  /// An area pointing to a venue
  StoryAreaTypeVenue({required this.venue, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyAreaTypeVenue',
      if (extra != null) '@extra': extra,
      'venue': venue
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryAreaTypeVenue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var venue = Venue.fromMap(_map['venue'])!;
    return StoryAreaTypeVenue(
      extra: extra,
      clientId: clientId,
      venue: venue,
    );
  }
}

/// An area pointing to a suggested reaction. App needs to show a clickable reaction on the area and call setStoryReaction when the are is clicked.
///
class StoryAreaTypeSuggestedReaction extends StoryAreaType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyAreaTypeSuggestedReaction";

  /// Type of the reaction.
  late ReactionType reaction_type;

  /// Number of times the reaction was added.
  late int total_count;

  /// True, if reaction has a dark background.
  late bool is_dark;

  /// True, if reaction corner is flipped.
  late bool is_flipped;

  /// An area pointing to a suggested reaction. App needs to show a clickable reaction on the area and call setStoryReaction when the are is clicked
  StoryAreaTypeSuggestedReaction(
      {required this.reaction_type,
      required this.total_count,
      required this.is_dark,
      required this.is_flipped,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyAreaTypeSuggestedReaction',
      if (extra != null) '@extra': extra,
      'reaction_type': reaction_type,
      'total_count': total_count,
      'is_dark': is_dark,
      'is_flipped': is_flipped
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryAreaTypeSuggestedReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reaction_type = ReactionType.fromMap(_map['reaction_type'])!;
    var total_count = _map['total_count']! as int;
    var is_dark = _map['is_dark']! as bool;
    var is_flipped = _map['is_flipped']! as bool;
    return StoryAreaTypeSuggestedReaction(
      extra: extra,
      clientId: clientId,
      reaction_type: reaction_type,
      total_count: total_count,
      is_dark: is_dark,
      is_flipped: is_flipped,
    );
  }
}

/// Describes a clickable rectangle area on a story media.
///
class StoryArea extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyArea";

  /// Position of the area.
  late StoryAreaPosition position;

  /// Type of the area.
  late StoryAreaType type;

  /// Describes a clickable rectangle area on a story media
  StoryArea(
      {required this.position, required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyArea',
      if (extra != null) '@extra': extra,
      'position': position,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryArea? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var position = StoryAreaPosition.fromMap(_map['position'])!;
    var type = StoryAreaType.fromMap(_map['type'])!;
    return StoryArea(
      extra: extra,
      clientId: clientId,
      position: position,
      type: type,
    );
  }
}

/// An area pointing to a location.
///
class InputStoryAreaTypeLocation extends InputStoryAreaType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputStoryAreaTypeLocation";

  /// The location.
  late Location location;

  /// An area pointing to a location
  InputStoryAreaTypeLocation(
      {required this.location, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputStoryAreaTypeLocation',
      if (extra != null) '@extra': extra,
      'location': location
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputStoryAreaTypeLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    return InputStoryAreaTypeLocation(
      extra: extra,
      clientId: clientId,
      location: location,
    );
  }
}

/// An area pointing to a venue found by the bot getOption("venue_search_bot_username").
///
class InputStoryAreaTypeFoundVenue extends InputStoryAreaType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputStoryAreaTypeFoundVenue";

  /// Identifier of the inline query, used to found the venue.
  /// ; string representation of int, use `int.parse`
  late int64 query_id;

  /// Identifier of the inline query result.
  late String result_id;

  /// An area pointing to a venue found by the bot getOption("venue_search_bot_username")
  InputStoryAreaTypeFoundVenue(
      {required this.query_id,
      required this.result_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputStoryAreaTypeFoundVenue',
      if (extra != null) '@extra': extra,
      'query_id': query_id,
      'result_id': result_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputStoryAreaTypeFoundVenue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query_id = _map['query_id']! as int64;
    var result_id = _map['result_id']! as String;
    return InputStoryAreaTypeFoundVenue(
      extra: extra,
      clientId: clientId,
      query_id: query_id,
      result_id: result_id,
    );
  }
}

/// An area pointing to a venue already added to the story.
///
class InputStoryAreaTypePreviousVenue extends InputStoryAreaType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputStoryAreaTypePreviousVenue";

  /// Provider of the venue.
  late String venue_provider;

  /// Identifier of the venue in the provider database.
  late String venue_id;

  /// An area pointing to a venue already added to the story
  InputStoryAreaTypePreviousVenue(
      {required this.venue_provider,
      required this.venue_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputStoryAreaTypePreviousVenue',
      if (extra != null) '@extra': extra,
      'venue_provider': venue_provider,
      'venue_id': venue_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputStoryAreaTypePreviousVenue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var venue_provider = _map['venue_provider']! as String;
    var venue_id = _map['venue_id']! as String;
    return InputStoryAreaTypePreviousVenue(
      extra: extra,
      clientId: clientId,
      venue_provider: venue_provider,
      venue_id: venue_id,
    );
  }
}

/// An area pointing to a suggested reaction.
///
class InputStoryAreaTypeSuggestedReaction extends InputStoryAreaType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputStoryAreaTypeSuggestedReaction";

  /// Type of the reaction.
  late ReactionType reaction_type;

  /// True, if reaction has a dark background.
  late bool is_dark;

  /// True, if reaction corner is flipped.
  late bool is_flipped;

  /// An area pointing to a suggested reaction
  InputStoryAreaTypeSuggestedReaction(
      {required this.reaction_type,
      required this.is_dark,
      required this.is_flipped,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputStoryAreaTypeSuggestedReaction',
      if (extra != null) '@extra': extra,
      'reaction_type': reaction_type,
      'is_dark': is_dark,
      'is_flipped': is_flipped
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputStoryAreaTypeSuggestedReaction? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reaction_type = ReactionType.fromMap(_map['reaction_type'])!;
    var is_dark = _map['is_dark']! as bool;
    var is_flipped = _map['is_flipped']! as bool;
    return InputStoryAreaTypeSuggestedReaction(
      extra: extra,
      clientId: clientId,
      reaction_type: reaction_type,
      is_dark: is_dark,
      is_flipped: is_flipped,
    );
  }
}

/// Describes a clickable rectangle area on a story media to be added.
///
class InputStoryArea extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputStoryArea";

  /// Position of the area.
  late StoryAreaPosition position;

  /// Type of the area.
  late InputStoryAreaType type;

  /// Describes a clickable rectangle area on a story media to be added
  InputStoryArea(
      {required this.position, required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputStoryArea',
      if (extra != null) '@extra': extra,
      'position': position,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputStoryArea? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var position = StoryAreaPosition.fromMap(_map['position'])!;
    var type = InputStoryAreaType.fromMap(_map['type'])!;
    return InputStoryArea(
      extra: extra,
      clientId: clientId,
      position: position,
      type: type,
    );
  }
}

/// Contains a list of story areas to be added.
///
class InputStoryAreas extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputStoryAreas";

  /// List of 0-10 input story areas.
  late List<InputStoryArea> areas;

  /// Contains a list of story areas to be added
  InputStoryAreas({required this.areas, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputStoryAreas',
      if (extra != null) '@extra': extra,
      'areas': areas
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputStoryAreas? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var areas = List<InputStoryArea>.from(
      (_map["areas"] ?? []).map(
        (e) => InputStoryArea.fromMap(e),
      ),
    );
    return InputStoryAreas(
      extra: extra,
      clientId: clientId,
      areas: areas,
    );
  }
}

/// Describes a video file sent in a story.
///
class StoryVideo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyVideo";

  /// Duration of the video, in seconds.
  late double duration;

  /// Video width.
  late int width;

  /// Video height.
  late int height;

  /// True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets.
  late bool has_stickers;

  /// True, if the video has no sound.
  late bool is_animation;

  /// Video minithumbnail; may be null.
  Minithumbnail? minithumbnail;

  /// Video thumbnail in JPEG or MPEG4 format; may be null.
  Thumbnail? thumbnail;

  /// Size of file prefix, which is supposed to be preloaded, in bytes.
  late int preload_prefix_size;

  /// File containing the video.
  late File video;

  /// Describes a video file sent in a story
  StoryVideo(
      {required this.duration,
      required this.width,
      required this.height,
      required this.has_stickers,
      required this.is_animation,
      this.minithumbnail,
      this.thumbnail,
      required this.preload_prefix_size,
      required this.video,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyVideo',
      if (extra != null) '@extra': extra,
      'duration': duration,
      'width': width,
      'height': height,
      'has_stickers': has_stickers,
      'is_animation': is_animation,
      'minithumbnail': minithumbnail,
      'thumbnail': thumbnail,
      'preload_prefix_size': preload_prefix_size,
      'video': video
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var duration = _map['duration']! as double;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var has_stickers = _map['has_stickers']! as bool;
    var is_animation = _map['is_animation']! as bool;
    var minithumbnail = Minithumbnail.fromMap(_map['minithumbnail']);
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    var preload_prefix_size = _map['preload_prefix_size']! as int;
    var video = File.fromMap(_map['video'])!;
    return StoryVideo(
      extra: extra,
      clientId: clientId,
      duration: duration,
      width: width,
      height: height,
      has_stickers: has_stickers,
      is_animation: is_animation,
      minithumbnail: minithumbnail,
      thumbnail: thumbnail,
      preload_prefix_size: preload_prefix_size,
      video: video,
    );
  }
}

/// A photo story.
///
class StoryContentPhoto extends StoryContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyContentPhoto";

  /// The photo.
  late Photo photo;

  /// A photo story
  StoryContentPhoto({required this.photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyContentPhoto',
      if (extra != null) '@extra': extra,
      'photo': photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryContentPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = Photo.fromMap(_map['photo'])!;
    return StoryContentPhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
    );
  }
}

/// A video story.
///
class StoryContentVideo extends StoryContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyContentVideo";

  /// The video in MPEG4 format.
  late StoryVideo video;

  /// Alternative version of the video in MPEG4 format, encoded by x264 codec; may be null.
  StoryVideo? alternative_video;

  /// A video story
  StoryContentVideo(
      {required this.video, this.alternative_video, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyContentVideo',
      if (extra != null) '@extra': extra,
      'video': video,
      'alternative_video': alternative_video
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryContentVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video = StoryVideo.fromMap(_map['video'])!;
    var alternative_video = StoryVideo.fromMap(_map['alternative_video']);
    return StoryContentVideo(
      extra: extra,
      clientId: clientId,
      video: video,
      alternative_video: alternative_video,
    );
  }
}

/// A story content that is not supported in the current TDLib version.
///
class StoryContentUnsupported extends StoryContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyContentUnsupported";

  /// A story content that is not supported in the current TDLib version
  StoryContentUnsupported({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyContentUnsupported',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryContentUnsupported? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StoryContentUnsupported(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A photo story.
///
class InputStoryContentPhoto extends InputStoryContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputStoryContentPhoto";

  /// Photo to send. The photo must be at most 10 MB in size. The photo size must be 1080x1920.
  late InputFile photo;

  /// File identifiers of the stickers added to the photo, if applicable.
  late List<int> added_sticker_file_ids;

  /// A photo story
  InputStoryContentPhoto(
      {required this.photo,
      required this.added_sticker_file_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputStoryContentPhoto',
      if (extra != null) '@extra': extra,
      'photo': photo,
      'added_sticker_file_ids': added_sticker_file_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputStoryContentPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = InputFile.fromMap(_map['photo'])!;
    var added_sticker_file_ids = List<int>.from(
      (_map["added_sticker_file_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return InputStoryContentPhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
      added_sticker_file_ids: added_sticker_file_ids,
    );
  }
}

/// A video story.
///
class InputStoryContentVideo extends InputStoryContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputStoryContentVideo";

  /// Video to be sent. The video size must be 720x1280. The video must be streamable and stored in MPEG4 format, after encoding with x265 codec and key frames added each second.
  late InputFile video;

  /// File identifiers of the stickers added to the video, if applicable.
  late List<int> added_sticker_file_ids;

  /// Precise duration of the video, in seconds; 0-60.
  late double duration;

  /// True, if the video has no sound.
  late bool is_animation;

  /// A video story
  InputStoryContentVideo(
      {required this.video,
      required this.added_sticker_file_ids,
      required this.duration,
      required this.is_animation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputStoryContentVideo',
      if (extra != null) '@extra': extra,
      'video': video,
      'added_sticker_file_ids': added_sticker_file_ids,
      'duration': duration,
      'is_animation': is_animation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputStoryContentVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video = InputFile.fromMap(_map['video'])!;
    var added_sticker_file_ids = List<int>.from(
      (_map["added_sticker_file_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var duration = _map['duration']! as double;
    var is_animation = _map['is_animation']! as bool;
    return InputStoryContentVideo(
      extra: extra,
      clientId: clientId,
      video: video,
      added_sticker_file_ids: added_sticker_file_ids,
      duration: duration,
      is_animation: is_animation,
    );
  }
}

/// The list of stories, shown in the main chat list and folder chat lists.
///
class StoryListMain extends StoryList {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyListMain";

  /// The list of stories, shown in the main chat list and folder chat lists
  StoryListMain({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'storyListMain', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryListMain? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StoryListMain(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The list of stories, shown in the Arvhive chat list.
///
class StoryListArchive extends StoryList {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyListArchive";

  /// The list of stories, shown in the Arvhive chat list
  StoryListArchive({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'storyListArchive', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryListArchive? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StoryListArchive(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains information about interactions with a story.
///
class StoryInteractionInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyInteractionInfo";

  /// Number of times the story was viewed.
  late int view_count;

  /// Number of times the story was forwarded; 0 if none or unknown.
  late int forward_count;

  /// Number of reactions added to the story; 0 if none or unknown.
  late int reaction_count;

  /// Identifiers of at most 3 recent viewers of the story.
  late List<int> recent_viewer_user_ids;

  /// Contains information about interactions with a story
  StoryInteractionInfo(
      {required this.view_count,
      required this.forward_count,
      required this.reaction_count,
      required this.recent_viewer_user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyInteractionInfo',
      if (extra != null) '@extra': extra,
      'view_count': view_count,
      'forward_count': forward_count,
      'reaction_count': reaction_count,
      'recent_viewer_user_ids': recent_viewer_user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryInteractionInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var view_count = _map['view_count']! as int;
    var forward_count = _map['forward_count']! as int;
    var reaction_count = _map['reaction_count']! as int;
    var recent_viewer_user_ids = List<int>.from(
      (_map["recent_viewer_user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return StoryInteractionInfo(
      extra: extra,
      clientId: clientId,
      view_count: view_count,
      forward_count: forward_count,
      reaction_count: reaction_count,
      recent_viewer_user_ids: recent_viewer_user_ids,
    );
  }
}

/// Represents a story.
///
class Story extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "story";

  /// Unique story identifier among stories of the given sender.
  late int id;

  /// Identifier of the chat that posted the story.
  late int sender_chat_id;

  /// Point in time (Unix timestamp) when the story was published.
  late int date;

  /// True, if the story is being sent by the current user.
  late bool is_being_sent;

  /// True, if the story is being edited by the current user.
  late bool is_being_edited;

  /// True, if the story was edited.
  late bool is_edited;

  /// True, if the story is saved in the sender's profile and will be available there after expiration.
  late bool is_pinned;

  /// True, if the story is visible only for the current user.
  late bool is_visible_only_for_self;

  /// True, if the story can be deleted.
  late bool can_be_deleted;

  /// True, if the story can be edited.
  late bool can_be_edited;

  /// True, if the story can be forwarded as a message. Otherwise, screenshots and saving of the story content must be also forbidden.
  late bool can_be_forwarded;

  /// True, if the story can be replied in the chat with the story sender.
  late bool can_be_replied;

  /// True, if the story's is_pinned value can be changed.
  late bool can_toggle_is_pinned;

  /// True, if users viewed the story can be received through getStoryViewers.
  late bool can_get_viewers;

  /// True, if users viewed the story can't be received, because the story has expired more than getOption("story_viewers_expiration_delay") seconds ago.
  late bool has_expired_viewers;

  /// Information about interactions with the story; may be null if the story isn't owned or there were no interactions.
  StoryInteractionInfo? interaction_info;

  /// Type of the chosen reaction; may be null if none.
  ReactionType? chosen_reaction_type;

  /// Privacy rules affecting story visibility; may be approximate for non-owned stories.
  late StoryPrivacySettings privacy_settings;

  /// Content of the story.
  late StoryContent content;

  /// Clickable areas to be shown on the story content.
  late List<StoryArea> areas;

  /// Caption of the story.
  late FormattedText caption;

  /// Represents a story
  Story(
      {required this.id,
      required this.sender_chat_id,
      required this.date,
      required this.is_being_sent,
      required this.is_being_edited,
      required this.is_edited,
      required this.is_pinned,
      required this.is_visible_only_for_self,
      required this.can_be_deleted,
      required this.can_be_edited,
      required this.can_be_forwarded,
      required this.can_be_replied,
      required this.can_toggle_is_pinned,
      required this.can_get_viewers,
      required this.has_expired_viewers,
      this.interaction_info,
      this.chosen_reaction_type,
      required this.privacy_settings,
      required this.content,
      required this.areas,
      required this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'story',
      if (extra != null) '@extra': extra,
      'id': id,
      'sender_chat_id': sender_chat_id,
      'date': date,
      'is_being_sent': is_being_sent,
      'is_being_edited': is_being_edited,
      'is_edited': is_edited,
      'is_pinned': is_pinned,
      'is_visible_only_for_self': is_visible_only_for_self,
      'can_be_deleted': can_be_deleted,
      'can_be_edited': can_be_edited,
      'can_be_forwarded': can_be_forwarded,
      'can_be_replied': can_be_replied,
      'can_toggle_is_pinned': can_toggle_is_pinned,
      'can_get_viewers': can_get_viewers,
      'has_expired_viewers': has_expired_viewers,
      'interaction_info': interaction_info,
      'chosen_reaction_type': chosen_reaction_type,
      'privacy_settings': privacy_settings,
      'content': content,
      'areas': areas,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Story? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var sender_chat_id = _map['sender_chat_id']! as int;
    var date = _map['date']! as int;
    var is_being_sent = _map['is_being_sent']! as bool;
    var is_being_edited = _map['is_being_edited']! as bool;
    var is_edited = _map['is_edited']! as bool;
    var is_pinned = _map['is_pinned']! as bool;
    var is_visible_only_for_self = _map['is_visible_only_for_self']! as bool;
    var can_be_deleted = _map['can_be_deleted']! as bool;
    var can_be_edited = _map['can_be_edited']! as bool;
    var can_be_forwarded = _map['can_be_forwarded']! as bool;
    var can_be_replied = _map['can_be_replied']! as bool;
    var can_toggle_is_pinned = _map['can_toggle_is_pinned']! as bool;
    var can_get_viewers = _map['can_get_viewers']! as bool;
    var has_expired_viewers = _map['has_expired_viewers']! as bool;
    var interaction_info =
        StoryInteractionInfo.fromMap(_map['interaction_info']);
    var chosen_reaction_type =
        ReactionType.fromMap(_map['chosen_reaction_type']);
    var privacy_settings =
        StoryPrivacySettings.fromMap(_map['privacy_settings'])!;
    var content = StoryContent.fromMap(_map['content'])!;
    var areas = List<StoryArea>.from(
      (_map["areas"] ?? []).map(
        (e) => StoryArea.fromMap(e),
      ),
    );
    var caption = FormattedText.fromMap(_map['caption'])!;
    return Story(
      extra: extra,
      clientId: clientId,
      id: id,
      sender_chat_id: sender_chat_id,
      date: date,
      is_being_sent: is_being_sent,
      is_being_edited: is_being_edited,
      is_edited: is_edited,
      is_pinned: is_pinned,
      is_visible_only_for_self: is_visible_only_for_self,
      can_be_deleted: can_be_deleted,
      can_be_edited: can_be_edited,
      can_be_forwarded: can_be_forwarded,
      can_be_replied: can_be_replied,
      can_toggle_is_pinned: can_toggle_is_pinned,
      can_get_viewers: can_get_viewers,
      has_expired_viewers: has_expired_viewers,
      interaction_info: interaction_info,
      chosen_reaction_type: chosen_reaction_type,
      privacy_settings: privacy_settings,
      content: content,
      areas: areas,
      caption: caption,
    );
  }
}

/// Represents a list of stories.
///
class Stories extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stories";

  /// Approximate total number of stories found.
  late int total_count;

  /// The list of stories.
  late List<Story> stories;

  /// Represents a list of stories
  Stories(
      {required this.total_count,
      required this.stories,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stories',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'stories': stories
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Stories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var stories = List<Story>.from(
      (_map["stories"] ?? []).map(
        (e) => Story.fromMap(e),
      ),
    );
    return Stories(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      stories: stories,
    );
  }
}

/// Contains basic information about a story.
///
class StoryInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyInfo";

  /// Unique story identifier among stories of the given sender.
  late int story_id;

  /// Point in time (Unix timestamp) when the story was published.
  late int date;

  /// True, if the story is available only to close friends.
  late bool is_for_close_friends;

  /// Contains basic information about a story
  StoryInfo(
      {required this.story_id,
      required this.date,
      required this.is_for_close_friends,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyInfo',
      if (extra != null) '@extra': extra,
      'story_id': story_id,
      'date': date,
      'is_for_close_friends': is_for_close_friends
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_id = _map['story_id']! as int;
    var date = _map['date']! as int;
    var is_for_close_friends = _map['is_for_close_friends']! as bool;
    return StoryInfo(
      extra: extra,
      clientId: clientId,
      story_id: story_id,
      date: date,
      is_for_close_friends: is_for_close_friends,
    );
  }
}

/// Describes active stories posted by a chat.
///
class ChatActiveStories extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatActiveStories";

  /// Identifier of the chat that posted the stories.
  late int chat_id;

  /// Identifier of the story list in which the stories are shown; may be null if the stories aren't shown in a story list.
  StoryList? list;

  /// A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list. Stories must be sorted by the pair (order, story_sender_chat_id) in descending order.
  late int order;

  /// Identifier of the last read active story.
  late int max_read_story_id;

  /// Basic information about the stories; use getStory to get full information about the stories. The stories are in a chronological order (i.e., in order of increasing story identifiers).
  late List<StoryInfo> stories;

  /// Describes active stories posted by a chat
  ChatActiveStories(
      {required this.chat_id,
      this.list,
      required this.order,
      required this.max_read_story_id,
      required this.stories,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatActiveStories',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'list': list,
      'order': order,
      'max_read_story_id': max_read_story_id,
      'stories': stories
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatActiveStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var list = StoryList.fromMap(_map['list']);
    var order = _map['order']! as int;
    var max_read_story_id = _map['max_read_story_id']! as int;
    var stories = List<StoryInfo>.from(
      (_map["stories"] ?? []).map(
        (e) => StoryInfo.fromMap(e),
      ),
    );
    return ChatActiveStories(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      list: list,
      order: order,
      max_read_story_id: max_read_story_id,
      stories: stories,
    );
  }
}

/// Describes current boost status of a chat.
///
class ChatBoostStatus extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatBoostStatus";

  /// True, if the current user has already boosted the chat.
  late bool is_boosted;

  /// Current boost level of the chat.
  late int level;

  /// The number of times the chat was boosted.
  late int boost_count;

  /// The number of boosts added to reach the current level.
  late int current_level_boost_count;

  /// The number of boosts needed to reach the next level; 0 if the next level isn't available.
  late int next_level_boost_count;

  /// Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat.
  late int premium_member_count;

  /// A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat.
  late double premium_member_percentage;

  /// Describes current boost status of a chat
  ChatBoostStatus(
      {required this.is_boosted,
      required this.level,
      required this.boost_count,
      required this.current_level_boost_count,
      required this.next_level_boost_count,
      required this.premium_member_count,
      required this.premium_member_percentage,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatBoostStatus',
      if (extra != null) '@extra': extra,
      'is_boosted': is_boosted,
      'level': level,
      'boost_count': boost_count,
      'current_level_boost_count': current_level_boost_count,
      'next_level_boost_count': next_level_boost_count,
      'premium_member_count': premium_member_count,
      'premium_member_percentage': premium_member_percentage
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatBoostStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_boosted = _map['is_boosted']! as bool;
    var level = _map['level']! as int;
    var boost_count = _map['boost_count']! as int;
    var current_level_boost_count = _map['current_level_boost_count']! as int;
    var next_level_boost_count = _map['next_level_boost_count']! as int;
    var premium_member_count = _map['premium_member_count']! as int;
    var premium_member_percentage =
        _map['premium_member_percentage']! as double;
    return ChatBoostStatus(
      extra: extra,
      clientId: clientId,
      is_boosted: is_boosted,
      level: level,
      boost_count: boost_count,
      current_level_boost_count: current_level_boost_count,
      next_level_boost_count: next_level_boost_count,
      premium_member_count: premium_member_count,
      premium_member_percentage: premium_member_percentage,
    );
  }
}

/// Describes a boost of a chat.
///
class ChatBoost extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatBoost";

  /// Identifier of a user that boosted the chat.
  late int user_id;

  /// Point in time (Unix timestamp) when the boost will automatically expire if the user will not prolongate their Telegram Premium subscription.
  late int expiration_date;

  /// Describes a boost of a chat
  ChatBoost(
      {required this.user_id,
      required this.expiration_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatBoost',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'expiration_date': expiration_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatBoost? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var expiration_date = _map['expiration_date']! as int;
    return ChatBoost(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      expiration_date: expiration_date,
    );
  }
}

/// Contains a list of boosts applied to a chat.
///
class FoundChatBoosts extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "foundChatBoosts";

  /// Total number of boosts applied to the chat.
  late int total_count;

  /// List of boosts.
  late List<ChatBoost> boosts;

  /// The offset for the next request. If empty, there are no more results.
  String? next_offset;

  /// Contains a list of boosts applied to a chat
  FoundChatBoosts(
      {required this.total_count,
      required this.boosts,
      this.next_offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'foundChatBoosts',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'boosts': boosts,
      'next_offset': next_offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FoundChatBoosts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var boosts = List<ChatBoost>.from(
      (_map["boosts"] ?? []).map(
        (e) => ChatBoost.fromMap(e),
      ),
    );
    var next_offset = _map['next_offset'] as String?;
    return FoundChatBoosts(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      boosts: boosts,
      next_offset: next_offset,
    );
  }
}

/// The call wasn't discarded, or the reason is unknown.
///
class CallDiscardReasonEmpty extends CallDiscardReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callDiscardReasonEmpty";

  /// The call wasn't discarded, or the reason is unknown
  CallDiscardReasonEmpty({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callDiscardReasonEmpty',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallDiscardReasonEmpty? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallDiscardReasonEmpty(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The call was ended before the conversation started. It was canceled by the caller or missed by the other party.
///
class CallDiscardReasonMissed extends CallDiscardReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callDiscardReasonMissed";

  /// The call was ended before the conversation started. It was canceled by the caller or missed by the other party
  CallDiscardReasonMissed({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callDiscardReasonMissed',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallDiscardReasonMissed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallDiscardReasonMissed(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The call was ended before the conversation started. It was declined by the other party.
///
class CallDiscardReasonDeclined extends CallDiscardReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callDiscardReasonDeclined";

  /// The call was ended before the conversation started. It was declined by the other party
  CallDiscardReasonDeclined({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callDiscardReasonDeclined',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallDiscardReasonDeclined? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallDiscardReasonDeclined(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The call was ended during the conversation because the users were disconnected.
///
class CallDiscardReasonDisconnected extends CallDiscardReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callDiscardReasonDisconnected";

  /// The call was ended during the conversation because the users were disconnected
  CallDiscardReasonDisconnected({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callDiscardReasonDisconnected',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallDiscardReasonDisconnected? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallDiscardReasonDisconnected(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The call was ended because one of the parties hung up.
///
class CallDiscardReasonHungUp extends CallDiscardReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callDiscardReasonHungUp";

  /// The call was ended because one of the parties hung up
  CallDiscardReasonHungUp({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callDiscardReasonHungUp',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallDiscardReasonHungUp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallDiscardReasonHungUp(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Specifies the supported call protocols.
///
class CallProtocol extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProtocol";

  /// True, if UDP peer-to-peer connections are supported.
  late bool udp_p2p;

  /// True, if connection through UDP reflectors is supported.
  late bool udp_reflector;

  /// The minimum supported API layer; use 65.
  late int min_layer;

  /// The maximum supported API layer; use 92.
  late int max_layer;

  /// List of supported tgcalls versions.
  late List<String> library_versions;

  /// Specifies the supported call protocols
  CallProtocol(
      {required this.udp_p2p,
      required this.udp_reflector,
      required this.min_layer,
      required this.max_layer,
      required this.library_versions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callProtocol',
      if (extra != null) '@extra': extra,
      'udp_p2p': udp_p2p,
      'udp_reflector': udp_reflector,
      'min_layer': min_layer,
      'max_layer': max_layer,
      'library_versions': library_versions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProtocol? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var udp_p2p = _map['udp_p2p']! as bool;
    var udp_reflector = _map['udp_reflector']! as bool;
    var min_layer = _map['min_layer']! as int;
    var max_layer = _map['max_layer']! as int;
    var library_versions = List<String>.from(
      (_map["library_versions"] ?? []).map(
        (e) => e as String,
      ),
    );
    return CallProtocol(
      extra: extra,
      clientId: clientId,
      udp_p2p: udp_p2p,
      udp_reflector: udp_reflector,
      min_layer: min_layer,
      max_layer: max_layer,
      library_versions: library_versions,
    );
  }
}

/// A Telegram call reflector.
///
class CallServerTypeTelegramReflector extends CallServerType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callServerTypeTelegramReflector";

  /// A peer tag to be used with the reflector.
  /// ; base64-encoded bytes `List<int>`
  late bytes peer_tag;

  /// True, if the server uses TCP instead of UDP.
  late bool is_tcp;

  /// A Telegram call reflector
  CallServerTypeTelegramReflector(
      {required this.peer_tag,
      required this.is_tcp,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callServerTypeTelegramReflector',
      if (extra != null) '@extra': extra,
      'peer_tag': peer_tag,
      'is_tcp': is_tcp
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallServerTypeTelegramReflector? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var peer_tag = _map['peer_tag']! as bytes;
    var is_tcp = _map['is_tcp']! as bool;
    return CallServerTypeTelegramReflector(
      extra: extra,
      clientId: clientId,
      peer_tag: peer_tag,
      is_tcp: is_tcp,
    );
  }
}

/// A WebRTC server.
///
class CallServerTypeWebrtc extends CallServerType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callServerTypeWebrtc";

  /// Username to be used for authentication.
  late String username;

  /// Authentication password.
  late String password;

  /// True, if the server supports TURN.
  late bool supports_turn;

  /// True, if the server supports STUN.
  late bool supports_stun;

  /// A WebRTC server
  CallServerTypeWebrtc(
      {required this.username,
      required this.password,
      required this.supports_turn,
      required this.supports_stun,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callServerTypeWebrtc',
      if (extra != null) '@extra': extra,
      'username': username,
      'password': password,
      'supports_turn': supports_turn,
      'supports_stun': supports_stun
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallServerTypeWebrtc? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var username = _map['username']! as String;
    var password = _map['password']! as String;
    var supports_turn = _map['supports_turn']! as bool;
    var supports_stun = _map['supports_stun']! as bool;
    return CallServerTypeWebrtc(
      extra: extra,
      clientId: clientId,
      username: username,
      password: password,
      supports_turn: supports_turn,
      supports_stun: supports_stun,
    );
  }
}

/// Describes a server for relaying call data.
///
class CallServer extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callServer";

  /// Server identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Server IPv4 address.
  late String ip_address;

  /// Server IPv6 address.
  late String ipv6_address;

  /// Server port number.
  late int port;

  /// Server type.
  late CallServerType type;

  /// Describes a server for relaying call data
  CallServer(
      {required this.id,
      required this.ip_address,
      required this.ipv6_address,
      required this.port,
      required this.type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callServer',
      if (extra != null) '@extra': extra,
      'id': id,
      'ip_address': ip_address,
      'ipv6_address': ipv6_address,
      'port': port,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallServer? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var ip_address = _map['ip_address']! as String;
    var ipv6_address = _map['ipv6_address']! as String;
    var port = _map['port']! as int;
    var type = CallServerType.fromMap(_map['type'])!;
    return CallServer(
      extra: extra,
      clientId: clientId,
      id: id,
      ip_address: ip_address,
      ipv6_address: ipv6_address,
      port: port,
      type: type,
    );
  }
}

/// Contains the call identifier.
///
class CallId extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callId";

  /// Call identifier.
  late int id;

  /// Contains the call identifier
  CallId({required this.id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'callId', if (extra != null) '@extra': extra, 'id': id};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallId? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    return CallId(
      extra: extra,
      clientId: clientId,
      id: id,
    );
  }
}

/// Contains the group call identifier.
///
class GroupCallId extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallId";

  /// Group call identifier.
  late int id;

  /// Contains the group call identifier
  GroupCallId({required this.id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallId',
      if (extra != null) '@extra': extra,
      'id': id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallId? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    return GroupCallId(
      extra: extra,
      clientId: clientId,
      id: id,
    );
  }
}

/// The call is pending, waiting to be accepted by a user.
///
class CallStatePending extends CallState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callStatePending";

  /// True, if the call has already been created by the server.
  late bool is_created;

  /// True, if the call has already been received by the other party.
  late bool is_received;

  /// The call is pending, waiting to be accepted by a user
  CallStatePending(
      {required this.is_created,
      required this.is_received,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callStatePending',
      if (extra != null) '@extra': extra,
      'is_created': is_created,
      'is_received': is_received
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallStatePending? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_created = _map['is_created']! as bool;
    var is_received = _map['is_received']! as bool;
    return CallStatePending(
      extra: extra,
      clientId: clientId,
      is_created: is_created,
      is_received: is_received,
    );
  }
}

/// The call has been answered and encryption keys are being exchanged.
///
class CallStateExchangingKeys extends CallState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callStateExchangingKeys";

  /// The call has been answered and encryption keys are being exchanged
  CallStateExchangingKeys({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callStateExchangingKeys',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallStateExchangingKeys? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallStateExchangingKeys(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The call is ready to use.
///
class CallStateReady extends CallState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callStateReady";

  /// Call protocols supported by the peer.
  late CallProtocol protocol;

  /// List of available call servers.
  late List<CallServer> servers;

  /// A JSON-encoded call config.
  late String config;

  /// Call encryption key.
  /// ; base64-encoded bytes `List<int>`
  late bytes encryption_key;

  /// Encryption key emojis fingerprint.
  late List<String> emojis;

  /// True, if peer-to-peer connection is allowed by users privacy settings.
  late bool allow_p2p;

  /// The call is ready to use
  CallStateReady(
      {required this.protocol,
      required this.servers,
      required this.config,
      required this.encryption_key,
      required this.emojis,
      required this.allow_p2p,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callStateReady',
      if (extra != null) '@extra': extra,
      'protocol': protocol,
      'servers': servers,
      'config': config,
      'encryption_key': encryption_key,
      'emojis': emojis,
      'allow_p2p': allow_p2p
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallStateReady? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var protocol = CallProtocol.fromMap(_map['protocol'])!;
    var servers = List<CallServer>.from(
      (_map["servers"] ?? []).map(
        (e) => CallServer.fromMap(e),
      ),
    );
    var config = _map['config']! as String;
    var encryption_key = _map['encryption_key']! as bytes;
    var emojis = List<String>.from(
      (_map["emojis"] ?? []).map(
        (e) => e as String,
      ),
    );
    var allow_p2p = _map['allow_p2p']! as bool;
    return CallStateReady(
      extra: extra,
      clientId: clientId,
      protocol: protocol,
      servers: servers,
      config: config,
      encryption_key: encryption_key,
      emojis: emojis,
      allow_p2p: allow_p2p,
    );
  }
}

/// The call is hanging up after discardCall has been called.
///
class CallStateHangingUp extends CallState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callStateHangingUp";

  /// The call is hanging up after discardCall has been called
  CallStateHangingUp({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'callStateHangingUp', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallStateHangingUp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallStateHangingUp(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The call has ended successfully.
///
class CallStateDiscarded extends CallState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callStateDiscarded";

  /// The reason, why the call has ended.
  late CallDiscardReason reason;

  /// True, if the call rating must be sent to the server.
  late bool need_rating;

  /// True, if the call debug information must be sent to the server.
  late bool need_debug_information;

  /// True, if the call log must be sent to the server.
  late bool need_log;

  /// The call has ended successfully
  CallStateDiscarded(
      {required this.reason,
      required this.need_rating,
      required this.need_debug_information,
      required this.need_log,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callStateDiscarded',
      if (extra != null) '@extra': extra,
      'reason': reason,
      'need_rating': need_rating,
      'need_debug_information': need_debug_information,
      'need_log': need_log
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallStateDiscarded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reason = CallDiscardReason.fromMap(_map['reason'])!;
    var need_rating = _map['need_rating']! as bool;
    var need_debug_information = _map['need_debug_information']! as bool;
    var need_log = _map['need_log']! as bool;
    return CallStateDiscarded(
      extra: extra,
      clientId: clientId,
      reason: reason,
      need_rating: need_rating,
      need_debug_information: need_debug_information,
      need_log: need_log,
    );
  }
}

/// The call has ended with an error.
///
class CallStateError extends CallState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callStateError";

  /// Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout.
  late Error error;

  /// The call has ended with an error
  CallStateError({required this.error, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callStateError',
      if (extra != null) '@extra': extra,
      'error': error
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallStateError? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var error = Error.fromMap(_map['error'])!;
    return CallStateError(
      extra: extra,
      clientId: clientId,
      error: error,
    );
  }
}

/// The worst available video quality.
///
class GroupCallVideoQualityThumbnail extends GroupCallVideoQuality {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallVideoQualityThumbnail";

  /// The worst available video quality
  GroupCallVideoQualityThumbnail({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallVideoQualityThumbnail',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallVideoQualityThumbnail? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GroupCallVideoQualityThumbnail(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The medium video quality.
///
class GroupCallVideoQualityMedium extends GroupCallVideoQuality {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallVideoQualityMedium";

  /// The medium video quality
  GroupCallVideoQualityMedium({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallVideoQualityMedium',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallVideoQualityMedium? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GroupCallVideoQualityMedium(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The best available video quality.
///
class GroupCallVideoQualityFull extends GroupCallVideoQuality {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallVideoQualityFull";

  /// The best available video quality
  GroupCallVideoQualityFull({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallVideoQualityFull',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallVideoQualityFull? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GroupCallVideoQualityFull(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Describes an available stream in a group call.
///
class GroupCallStream extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallStream";

  /// Identifier of an audio/video channel.
  late int channel_id;

  /// Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds.
  late int scale;

  /// Point in time when the stream currently ends; Unix timestamp in milliseconds.
  late int time_offset;

  /// Describes an available stream in a group call
  GroupCallStream(
      {required this.channel_id,
      required this.scale,
      required this.time_offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallStream',
      if (extra != null) '@extra': extra,
      'channel_id': channel_id,
      'scale': scale,
      'time_offset': time_offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallStream? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var channel_id = _map['channel_id']! as int;
    var scale = _map['scale']! as int;
    var time_offset = _map['time_offset']! as int;
    return GroupCallStream(
      extra: extra,
      clientId: clientId,
      channel_id: channel_id,
      scale: scale,
      time_offset: time_offset,
    );
  }
}

/// Represents a list of group call streams.
///
class GroupCallStreams extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallStreams";

  /// A list of group call streams.
  late List<GroupCallStream> streams;

  /// Represents a list of group call streams
  GroupCallStreams({required this.streams, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallStreams',
      if (extra != null) '@extra': extra,
      'streams': streams
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallStreams? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var streams = List<GroupCallStream>.from(
      (_map["streams"] ?? []).map(
        (e) => GroupCallStream.fromMap(e),
      ),
    );
    return GroupCallStreams(
      extra: extra,
      clientId: clientId,
      streams: streams,
    );
  }
}

/// Represents an RTMP URL.
///
class RtmpUrl extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "rtmpUrl";

  /// The URL.
  late String url;

  /// Stream key.
  late String stream_key;

  /// Represents an RTMP URL
  RtmpUrl(
      {required this.url, required this.stream_key, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'rtmpUrl',
      if (extra != null) '@extra': extra,
      'url': url,
      'stream_key': stream_key
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RtmpUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var stream_key = _map['stream_key']! as String;
    return RtmpUrl(
      extra: extra,
      clientId: clientId,
      url: url,
      stream_key: stream_key,
    );
  }
}

/// Describes a recently speaking participant in a group call.
///
class GroupCallRecentSpeaker extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallRecentSpeaker";

  /// Group call participant identifier.
  late MessageSender participant_id;

  /// True, is the user has spoken recently.
  late bool is_speaking;

  /// Describes a recently speaking participant in a group call
  GroupCallRecentSpeaker(
      {required this.participant_id,
      required this.is_speaking,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallRecentSpeaker',
      if (extra != null) '@extra': extra,
      'participant_id': participant_id,
      'is_speaking': is_speaking
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallRecentSpeaker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var participant_id = MessageSender.fromMap(_map['participant_id'])!;
    var is_speaking = _map['is_speaking']! as bool;
    return GroupCallRecentSpeaker(
      extra: extra,
      clientId: clientId,
      participant_id: participant_id,
      is_speaking: is_speaking,
    );
  }
}

/// Describes a group call.
///
class GroupCall extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCall";

  /// Group call identifier.
  late int id;

  /// Group call title.
  late String title;

  /// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended.
  late int scheduled_start_date;

  /// True, if the group call is scheduled and the current user will receive a notification when the group call will start.
  late bool enabled_start_notification;

  /// True, if the call is active.
  late bool is_active;

  /// True, if the chat is an RTMP stream instead of an ordinary video chat.
  late bool is_rtmp_stream;

  /// True, if the call is joined.
  late bool is_joined;

  /// True, if user was kicked from the call because of network loss and the call needs to be rejoined.
  late bool need_rejoin;

  /// True, if the current user can manage the group call.
  late bool can_be_managed;

  /// Number of participants in the group call.
  late int participant_count;

  /// True, if group call participants, which are muted, aren't returned in participant list.
  late bool has_hidden_listeners;

  /// True, if all group call participants are loaded.
  late bool loaded_all_participants;

  /// At most 3 recently speaking users in the group call.
  late List<GroupCallRecentSpeaker> recent_speakers;

  /// True, if the current user's video is enabled.
  late bool is_my_video_enabled;

  /// True, if the current user's video is paused.
  late bool is_my_video_paused;

  /// True, if the current user can broadcast video or share screen.
  late bool can_enable_video;

  /// True, if only group call administrators can unmute new participants.
  late bool mute_new_participants;

  /// True, if the current user can enable or disable mute_new_participants setting.
  late bool can_toggle_mute_new_participants;

  /// Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on.
  late int record_duration;

  /// True, if a video file is being recorded for the call.
  late bool is_video_recorded;

  /// Call duration, in seconds; for ended calls only.
  late int duration;

  /// Describes a group call
  GroupCall(
      {required this.id,
      required this.title,
      required this.scheduled_start_date,
      required this.enabled_start_notification,
      required this.is_active,
      required this.is_rtmp_stream,
      required this.is_joined,
      required this.need_rejoin,
      required this.can_be_managed,
      required this.participant_count,
      required this.has_hidden_listeners,
      required this.loaded_all_participants,
      required this.recent_speakers,
      required this.is_my_video_enabled,
      required this.is_my_video_paused,
      required this.can_enable_video,
      required this.mute_new_participants,
      required this.can_toggle_mute_new_participants,
      required this.record_duration,
      required this.is_video_recorded,
      required this.duration,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCall',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'scheduled_start_date': scheduled_start_date,
      'enabled_start_notification': enabled_start_notification,
      'is_active': is_active,
      'is_rtmp_stream': is_rtmp_stream,
      'is_joined': is_joined,
      'need_rejoin': need_rejoin,
      'can_be_managed': can_be_managed,
      'participant_count': participant_count,
      'has_hidden_listeners': has_hidden_listeners,
      'loaded_all_participants': loaded_all_participants,
      'recent_speakers': recent_speakers,
      'is_my_video_enabled': is_my_video_enabled,
      'is_my_video_paused': is_my_video_paused,
      'can_enable_video': can_enable_video,
      'mute_new_participants': mute_new_participants,
      'can_toggle_mute_new_participants': can_toggle_mute_new_participants,
      'record_duration': record_duration,
      'is_video_recorded': is_video_recorded,
      'duration': duration
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var title = _map['title']! as String;
    var scheduled_start_date = _map['scheduled_start_date']! as int;
    var enabled_start_notification =
        _map['enabled_start_notification']! as bool;
    var is_active = _map['is_active']! as bool;
    var is_rtmp_stream = _map['is_rtmp_stream']! as bool;
    var is_joined = _map['is_joined']! as bool;
    var need_rejoin = _map['need_rejoin']! as bool;
    var can_be_managed = _map['can_be_managed']! as bool;
    var participant_count = _map['participant_count']! as int;
    var has_hidden_listeners = _map['has_hidden_listeners']! as bool;
    var loaded_all_participants = _map['loaded_all_participants']! as bool;
    var recent_speakers = List<GroupCallRecentSpeaker>.from(
      (_map["recent_speakers"] ?? []).map(
        (e) => GroupCallRecentSpeaker.fromMap(e),
      ),
    );
    var is_my_video_enabled = _map['is_my_video_enabled']! as bool;
    var is_my_video_paused = _map['is_my_video_paused']! as bool;
    var can_enable_video = _map['can_enable_video']! as bool;
    var mute_new_participants = _map['mute_new_participants']! as bool;
    var can_toggle_mute_new_participants =
        _map['can_toggle_mute_new_participants']! as bool;
    var record_duration = _map['record_duration']! as int;
    var is_video_recorded = _map['is_video_recorded']! as bool;
    var duration = _map['duration']! as int;
    return GroupCall(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      scheduled_start_date: scheduled_start_date,
      enabled_start_notification: enabled_start_notification,
      is_active: is_active,
      is_rtmp_stream: is_rtmp_stream,
      is_joined: is_joined,
      need_rejoin: need_rejoin,
      can_be_managed: can_be_managed,
      participant_count: participant_count,
      has_hidden_listeners: has_hidden_listeners,
      loaded_all_participants: loaded_all_participants,
      recent_speakers: recent_speakers,
      is_my_video_enabled: is_my_video_enabled,
      is_my_video_paused: is_my_video_paused,
      can_enable_video: can_enable_video,
      mute_new_participants: mute_new_participants,
      can_toggle_mute_new_participants: can_toggle_mute_new_participants,
      record_duration: record_duration,
      is_video_recorded: is_video_recorded,
      duration: duration,
    );
  }
}

/// Describes a group of video synchronization source identifiers.
///
class GroupCallVideoSourceGroup extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallVideoSourceGroup";

  /// The semantics of sources, one of "SIM" or "FID".
  late String semantics;

  /// The list of synchronization source identifiers.
  late List<int> source_ids;

  /// Describes a group of video synchronization source identifiers
  GroupCallVideoSourceGroup(
      {required this.semantics,
      required this.source_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallVideoSourceGroup',
      if (extra != null) '@extra': extra,
      'semantics': semantics,
      'source_ids': source_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallVideoSourceGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var semantics = _map['semantics']! as String;
    var source_ids = List<int>.from(
      (_map["source_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return GroupCallVideoSourceGroup(
      extra: extra,
      clientId: clientId,
      semantics: semantics,
      source_ids: source_ids,
    );
  }
}

/// Contains information about a group call participant's video channel.
///
class GroupCallParticipantVideoInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallParticipantVideoInfo";

  /// List of synchronization source groups of the video.
  late List<GroupCallVideoSourceGroup> source_groups;

  /// Video channel endpoint identifier.
  late String endpoint_id;

  /// True, if the video is paused. This flag needs to be ignored, if new video frames are received.
  late bool is_paused;

  /// Contains information about a group call participant's video channel
  GroupCallParticipantVideoInfo(
      {required this.source_groups,
      required this.endpoint_id,
      required this.is_paused,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallParticipantVideoInfo',
      if (extra != null) '@extra': extra,
      'source_groups': source_groups,
      'endpoint_id': endpoint_id,
      'is_paused': is_paused
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallParticipantVideoInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var source_groups = List<GroupCallVideoSourceGroup>.from(
      (_map["source_groups"] ?? []).map(
        (e) => GroupCallVideoSourceGroup.fromMap(e),
      ),
    );
    var endpoint_id = _map['endpoint_id']! as String;
    var is_paused = _map['is_paused']! as bool;
    return GroupCallParticipantVideoInfo(
      extra: extra,
      clientId: clientId,
      source_groups: source_groups,
      endpoint_id: endpoint_id,
      is_paused: is_paused,
    );
  }
}

/// Represents a group call participant.
///
class GroupCallParticipant extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "groupCallParticipant";

  /// Identifier of the group call participant.
  late MessageSender participant_id;

  /// User's audio channel synchronization source identifier.
  late int audio_source_id;

  /// User's screen sharing audio channel synchronization source identifier.
  late int screen_sharing_audio_source_id;

  /// Information about user's video channel; may be null if there is no active video.
  GroupCallParticipantVideoInfo? video_info;

  /// Information about user's screen sharing video channel; may be null if there is no active screen sharing video.
  GroupCallParticipantVideoInfo? screen_sharing_video_info;

  /// The participant user's bio or the participant chat's description.
  late String bio;

  /// True, if the participant is the current user.
  late bool is_current_user;

  /// True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking.
  late bool is_speaking;

  /// True, if the participant hand is raised.
  late bool is_hand_raised;

  /// True, if the current user can mute the participant for all other group call participants.
  late bool can_be_muted_for_all_users;

  /// True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user).
  late bool can_be_unmuted_for_all_users;

  /// True, if the current user can mute the participant only for self.
  late bool can_be_muted_for_current_user;

  /// True, if the current user can unmute the participant for self.
  late bool can_be_unmuted_for_current_user;

  /// True, if the participant is muted for all users.
  late bool is_muted_for_all_users;

  /// True, if the participant is muted for the current user.
  late bool is_muted_for_current_user;

  /// True, if the participant is muted for all users, but can unmute themselves.
  late bool can_unmute_self;

  /// Participant's volume level; 1-20000 in hundreds of percents.
  late int volume_level;

  /// User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list.
  late String order;

  /// Represents a group call participant
  GroupCallParticipant(
      {required this.participant_id,
      required this.audio_source_id,
      required this.screen_sharing_audio_source_id,
      this.video_info,
      this.screen_sharing_video_info,
      required this.bio,
      required this.is_current_user,
      required this.is_speaking,
      required this.is_hand_raised,
      required this.can_be_muted_for_all_users,
      required this.can_be_unmuted_for_all_users,
      required this.can_be_muted_for_current_user,
      required this.can_be_unmuted_for_current_user,
      required this.is_muted_for_all_users,
      required this.is_muted_for_current_user,
      required this.can_unmute_self,
      required this.volume_level,
      required this.order,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'groupCallParticipant',
      if (extra != null) '@extra': extra,
      'participant_id': participant_id,
      'audio_source_id': audio_source_id,
      'screen_sharing_audio_source_id': screen_sharing_audio_source_id,
      'video_info': video_info,
      'screen_sharing_video_info': screen_sharing_video_info,
      'bio': bio,
      'is_current_user': is_current_user,
      'is_speaking': is_speaking,
      'is_hand_raised': is_hand_raised,
      'can_be_muted_for_all_users': can_be_muted_for_all_users,
      'can_be_unmuted_for_all_users': can_be_unmuted_for_all_users,
      'can_be_muted_for_current_user': can_be_muted_for_current_user,
      'can_be_unmuted_for_current_user': can_be_unmuted_for_current_user,
      'is_muted_for_all_users': is_muted_for_all_users,
      'is_muted_for_current_user': is_muted_for_current_user,
      'can_unmute_self': can_unmute_self,
      'volume_level': volume_level,
      'order': order
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GroupCallParticipant? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var participant_id = MessageSender.fromMap(_map['participant_id'])!;
    var audio_source_id = _map['audio_source_id']! as int;
    var screen_sharing_audio_source_id =
        _map['screen_sharing_audio_source_id']! as int;
    var video_info = GroupCallParticipantVideoInfo.fromMap(_map['video_info']);
    var screen_sharing_video_info = GroupCallParticipantVideoInfo.fromMap(
        _map['screen_sharing_video_info']);
    var bio = _map['bio']! as String;
    var is_current_user = _map['is_current_user']! as bool;
    var is_speaking = _map['is_speaking']! as bool;
    var is_hand_raised = _map['is_hand_raised']! as bool;
    var can_be_muted_for_all_users =
        _map['can_be_muted_for_all_users']! as bool;
    var can_be_unmuted_for_all_users =
        _map['can_be_unmuted_for_all_users']! as bool;
    var can_be_muted_for_current_user =
        _map['can_be_muted_for_current_user']! as bool;
    var can_be_unmuted_for_current_user =
        _map['can_be_unmuted_for_current_user']! as bool;
    var is_muted_for_all_users = _map['is_muted_for_all_users']! as bool;
    var is_muted_for_current_user = _map['is_muted_for_current_user']! as bool;
    var can_unmute_self = _map['can_unmute_self']! as bool;
    var volume_level = _map['volume_level']! as int;
    var order = _map['order']! as String;
    return GroupCallParticipant(
      extra: extra,
      clientId: clientId,
      participant_id: participant_id,
      audio_source_id: audio_source_id,
      screen_sharing_audio_source_id: screen_sharing_audio_source_id,
      video_info: video_info,
      screen_sharing_video_info: screen_sharing_video_info,
      bio: bio,
      is_current_user: is_current_user,
      is_speaking: is_speaking,
      is_hand_raised: is_hand_raised,
      can_be_muted_for_all_users: can_be_muted_for_all_users,
      can_be_unmuted_for_all_users: can_be_unmuted_for_all_users,
      can_be_muted_for_current_user: can_be_muted_for_current_user,
      can_be_unmuted_for_current_user: can_be_unmuted_for_current_user,
      is_muted_for_all_users: is_muted_for_all_users,
      is_muted_for_current_user: is_muted_for_current_user,
      can_unmute_self: can_unmute_self,
      volume_level: volume_level,
      order: order,
    );
  }
}

/// The user heard their own voice.
///
class CallProblemEcho extends CallProblem {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProblemEcho";

  /// The user heard their own voice
  CallProblemEcho({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'callProblemEcho', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProblemEcho? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallProblemEcho(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user heard background noise.
///
class CallProblemNoise extends CallProblem {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProblemNoise";

  /// The user heard background noise
  CallProblemNoise({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'callProblemNoise', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProblemNoise? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallProblemNoise(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The other side kept disappearing.
///
class CallProblemInterruptions extends CallProblem {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProblemInterruptions";

  /// The other side kept disappearing
  CallProblemInterruptions({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callProblemInterruptions',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProblemInterruptions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallProblemInterruptions(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The speech was distorted.
///
class CallProblemDistortedSpeech extends CallProblem {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProblemDistortedSpeech";

  /// The speech was distorted
  CallProblemDistortedSpeech({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callProblemDistortedSpeech',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProblemDistortedSpeech? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallProblemDistortedSpeech(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user couldn't hear the other side.
///
class CallProblemSilentLocal extends CallProblem {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProblemSilentLocal";

  /// The user couldn't hear the other side
  CallProblemSilentLocal({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callProblemSilentLocal',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProblemSilentLocal? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallProblemSilentLocal(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The other side couldn't hear the user.
///
class CallProblemSilentRemote extends CallProblem {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProblemSilentRemote";

  /// The other side couldn't hear the user
  CallProblemSilentRemote({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callProblemSilentRemote',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProblemSilentRemote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallProblemSilentRemote(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The call ended unexpectedly.
///
class CallProblemDropped extends CallProblem {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProblemDropped";

  /// The call ended unexpectedly
  CallProblemDropped({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'callProblemDropped', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProblemDropped? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallProblemDropped(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The video was distorted.
///
class CallProblemDistortedVideo extends CallProblem {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProblemDistortedVideo";

  /// The video was distorted
  CallProblemDistortedVideo({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callProblemDistortedVideo',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProblemDistortedVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallProblemDistortedVideo(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The video was pixelated.
///
class CallProblemPixelatedVideo extends CallProblem {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callProblemPixelatedVideo";

  /// The video was pixelated
  CallProblemPixelatedVideo({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callProblemPixelatedVideo',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallProblemPixelatedVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CallProblemPixelatedVideo(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Describes a call.
///
class Call extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "call";

  /// Call identifier, not persistent.
  late int id;

  /// Peer user identifier.
  late int user_id;

  /// True, if the call is outgoing.
  late bool is_outgoing;

  /// True, if the call is a video call.
  late bool is_video;

  /// Call state.
  late CallState state;

  /// Describes a call
  Call(
      {required this.id,
      required this.user_id,
      required this.is_outgoing,
      required this.is_video,
      required this.state,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'call',
      if (extra != null) '@extra': extra,
      'id': id,
      'user_id': user_id,
      'is_outgoing': is_outgoing,
      'is_video': is_video,
      'state': state
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Call? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var user_id = _map['user_id']! as int;
    var is_outgoing = _map['is_outgoing']! as bool;
    var is_video = _map['is_video']! as bool;
    var state = CallState.fromMap(_map['state'])!;
    return Call(
      extra: extra,
      clientId: clientId,
      id: id,
      user_id: user_id,
      is_outgoing: is_outgoing,
      is_video: is_video,
      state: state,
    );
  }
}

/// Settings for Firebase Authentication in the official Android application.
///
class FirebaseAuthenticationSettingsAndroid
    extends FirebaseAuthenticationSettings {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "firebaseAuthenticationSettingsAndroid";

  /// Settings for Firebase Authentication in the official Android application
  FirebaseAuthenticationSettingsAndroid({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'firebaseAuthenticationSettingsAndroid',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FirebaseAuthenticationSettingsAndroid? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FirebaseAuthenticationSettingsAndroid(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Settings for Firebase Authentication in the official iOS application.
///
class FirebaseAuthenticationSettingsIos extends FirebaseAuthenticationSettings {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "firebaseAuthenticationSettingsIos";

  /// Device token from Apple Push Notification service.
  late String device_token;

  /// True, if App Sandbox is enabled.
  late bool is_app_sandbox;

  /// Settings for Firebase Authentication in the official iOS application
  FirebaseAuthenticationSettingsIos(
      {required this.device_token,
      required this.is_app_sandbox,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'firebaseAuthenticationSettingsIos',
      if (extra != null) '@extra': extra,
      'device_token': device_token,
      'is_app_sandbox': is_app_sandbox
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FirebaseAuthenticationSettingsIos? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var device_token = _map['device_token']! as String;
    var is_app_sandbox = _map['is_app_sandbox']! as bool;
    return FirebaseAuthenticationSettingsIos(
      extra: extra,
      clientId: clientId,
      device_token: device_token,
      is_app_sandbox: is_app_sandbox,
    );
  }
}

/// Contains settings for the authentication of the user's phone number.
///
class PhoneNumberAuthenticationSettings extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "phoneNumberAuthenticationSettings";

  /// Pass true if the authentication code may be sent via a flash call to the specified phone number.
  late bool allow_flash_call;

  /// Pass true if the authentication code may be sent via a missed call to the specified phone number.
  late bool allow_missed_call;

  /// Pass true if the authenticated phone number is used on the current device.
  late bool is_current_phone_number;

  /// For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details.
  late bool allow_sms_retriever_api;

  /// For official Android and iOS applications only; pass null otherwise. Settings for Firebase Authentication.
  FirebaseAuthenticationSettings? firebase_authentication_settings;

  /// List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions.
  late List<String> authentication_tokens;

  /// Contains settings for the authentication of the user's phone number
  PhoneNumberAuthenticationSettings(
      {required this.allow_flash_call,
      required this.allow_missed_call,
      required this.is_current_phone_number,
      required this.allow_sms_retriever_api,
      this.firebase_authentication_settings,
      required this.authentication_tokens,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'phoneNumberAuthenticationSettings',
      if (extra != null) '@extra': extra,
      'allow_flash_call': allow_flash_call,
      'allow_missed_call': allow_missed_call,
      'is_current_phone_number': is_current_phone_number,
      'allow_sms_retriever_api': allow_sms_retriever_api,
      'firebase_authentication_settings': firebase_authentication_settings,
      'authentication_tokens': authentication_tokens
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PhoneNumberAuthenticationSettings? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var allow_flash_call = _map['allow_flash_call']! as bool;
    var allow_missed_call = _map['allow_missed_call']! as bool;
    var is_current_phone_number = _map['is_current_phone_number']! as bool;
    var allow_sms_retriever_api = _map['allow_sms_retriever_api']! as bool;
    var firebase_authentication_settings =
        FirebaseAuthenticationSettings.fromMap(
            _map['firebase_authentication_settings']);
    var authentication_tokens = List<String>.from(
      (_map["authentication_tokens"] ?? []).map(
        (e) => e as String,
      ),
    );
    return PhoneNumberAuthenticationSettings(
      extra: extra,
      clientId: clientId,
      allow_flash_call: allow_flash_call,
      allow_missed_call: allow_missed_call,
      is_current_phone_number: is_current_phone_number,
      allow_sms_retriever_api: allow_sms_retriever_api,
      firebase_authentication_settings: firebase_authentication_settings,
      authentication_tokens: authentication_tokens,
    );
  }
}

/// Represents a reaction applied to a message.
///
class AddedReaction extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addedReaction";

  /// Type of the reaction.
  late ReactionType type;

  /// Identifier of the chat member, applied the reaction.
  late MessageSender sender_id;

  /// Point in time (Unix timestamp) when the reaction was added.
  late int date;

  /// Represents a reaction applied to a message
  AddedReaction(
      {required this.type,
      required this.sender_id,
      required this.date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addedReaction',
      if (extra != null) '@extra': extra,
      'type': type,
      'sender_id': sender_id,
      'date': date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddedReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = ReactionType.fromMap(_map['type'])!;
    var sender_id = MessageSender.fromMap(_map['sender_id'])!;
    var date = _map['date']! as int;
    return AddedReaction(
      extra: extra,
      clientId: clientId,
      type: type,
      sender_id: sender_id,
      date: date,
    );
  }
}

/// Represents a list of reactions added to a message.
///
class AddedReactions extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addedReactions";

  /// The total number of found reactions.
  late int total_count;

  /// The list of added reactions.
  late List<AddedReaction> reactions;

  /// The offset for the next request. If empty, there are no more results.
  String? next_offset;

  /// Represents a list of reactions added to a message
  AddedReactions(
      {required this.total_count,
      required this.reactions,
      this.next_offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addedReactions',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'reactions': reactions,
      'next_offset': next_offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddedReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var reactions = List<AddedReaction>.from(
      (_map["reactions"] ?? []).map(
        (e) => AddedReaction.fromMap(e),
      ),
    );
    var next_offset = _map['next_offset'] as String?;
    return AddedReactions(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      reactions: reactions,
      next_offset: next_offset,
    );
  }
}

/// Represents an available reaction.
///
class AvailableReaction extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "availableReaction";

  /// Type of the reaction.
  late ReactionType type;

  /// True, if Telegram Premium is needed to send the reaction.
  late bool needs_premium;

  /// Represents an available reaction
  AvailableReaction(
      {required this.type,
      required this.needs_premium,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'availableReaction',
      if (extra != null) '@extra': extra,
      'type': type,
      'needs_premium': needs_premium
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AvailableReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = ReactionType.fromMap(_map['type'])!;
    var needs_premium = _map['needs_premium']! as bool;
    return AvailableReaction(
      extra: extra,
      clientId: clientId,
      type: type,
      needs_premium: needs_premium,
    );
  }
}

/// Represents a list of reactions that can be added to a message.
///
class AvailableReactions extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "availableReactions";

  /// List of reactions to be shown at the top.
  late List<AvailableReaction> top_reactions;

  /// List of recently used reactions.
  late List<AvailableReaction> recent_reactions;

  /// List of popular reactions.
  late List<AvailableReaction> popular_reactions;

  /// True, if custom emoji reactions could be added by Telegram Premium subscribers.
  late bool allow_custom_emoji;

  /// Represents a list of reactions that can be added to a message
  AvailableReactions(
      {required this.top_reactions,
      required this.recent_reactions,
      required this.popular_reactions,
      required this.allow_custom_emoji,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'availableReactions',
      if (extra != null) '@extra': extra,
      'top_reactions': top_reactions,
      'recent_reactions': recent_reactions,
      'popular_reactions': popular_reactions,
      'allow_custom_emoji': allow_custom_emoji
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AvailableReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var top_reactions = List<AvailableReaction>.from(
      (_map["top_reactions"] ?? []).map(
        (e) => AvailableReaction.fromMap(e),
      ),
    );
    var recent_reactions = List<AvailableReaction>.from(
      (_map["recent_reactions"] ?? []).map(
        (e) => AvailableReaction.fromMap(e),
      ),
    );
    var popular_reactions = List<AvailableReaction>.from(
      (_map["popular_reactions"] ?? []).map(
        (e) => AvailableReaction.fromMap(e),
      ),
    );
    var allow_custom_emoji = _map['allow_custom_emoji']! as bool;
    return AvailableReactions(
      extra: extra,
      clientId: clientId,
      top_reactions: top_reactions,
      recent_reactions: recent_reactions,
      popular_reactions: popular_reactions,
      allow_custom_emoji: allow_custom_emoji,
    );
  }
}

/// Contains information about a emoji reaction.
///
class EmojiReaction extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "emojiReaction";

  /// Text representation of the reaction.
  late String emoji;

  /// Reaction title.
  late String title;

  /// True, if the reaction can be added to new messages and enabled in chats.
  late bool is_active;

  /// Static icon for the reaction.
  late Sticker static_icon;

  /// Appear animation for the reaction.
  late Sticker appear_animation;

  /// Select animation for the reaction.
  late Sticker select_animation;

  /// Activate animation for the reaction.
  late Sticker activate_animation;

  /// Effect animation for the reaction.
  late Sticker effect_animation;

  /// Around animation for the reaction; may be null.
  Sticker? around_animation;

  /// Center animation for the reaction; may be null.
  Sticker? center_animation;

  /// Contains information about a emoji reaction
  EmojiReaction(
      {required this.emoji,
      required this.title,
      required this.is_active,
      required this.static_icon,
      required this.appear_animation,
      required this.select_animation,
      required this.activate_animation,
      required this.effect_animation,
      this.around_animation,
      this.center_animation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'emojiReaction',
      if (extra != null) '@extra': extra,
      'emoji': emoji,
      'title': title,
      'is_active': is_active,
      'static_icon': static_icon,
      'appear_animation': appear_animation,
      'select_animation': select_animation,
      'activate_animation': activate_animation,
      'effect_animation': effect_animation,
      'around_animation': around_animation,
      'center_animation': center_animation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EmojiReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emoji = _map['emoji']! as String;
    var title = _map['title']! as String;
    var is_active = _map['is_active']! as bool;
    var static_icon = Sticker.fromMap(_map['static_icon'])!;
    var appear_animation = Sticker.fromMap(_map['appear_animation'])!;
    var select_animation = Sticker.fromMap(_map['select_animation'])!;
    var activate_animation = Sticker.fromMap(_map['activate_animation'])!;
    var effect_animation = Sticker.fromMap(_map['effect_animation'])!;
    var around_animation = Sticker.fromMap(_map['around_animation']);
    var center_animation = Sticker.fromMap(_map['center_animation']);
    return EmojiReaction(
      extra: extra,
      clientId: clientId,
      emoji: emoji,
      title: title,
      is_active: is_active,
      static_icon: static_icon,
      appear_animation: appear_animation,
      select_animation: select_animation,
      activate_animation: activate_animation,
      effect_animation: effect_animation,
      around_animation: around_animation,
      center_animation: center_animation,
    );
  }
}

/// Represents a list of animations.
///
class Animations extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "animations";

  /// List of animations.
  late List<Animation> animations;

  /// Represents a list of animations
  Animations({required this.animations, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'animations',
      if (extra != null) '@extra': extra,
      'animations': animations
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Animations? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animations = List<Animation>.from(
      (_map["animations"] ?? []).map(
        (e) => Animation.fromMap(e),
      ),
    );
    return Animations(
      extra: extra,
      clientId: clientId,
      animations: animations,
    );
  }
}

/// A regular animated sticker.
///
class DiceStickersRegular extends DiceStickers {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "diceStickersRegular";

  /// The animated sticker with the dice animation.
  late Sticker sticker;

  /// A regular animated sticker
  DiceStickersRegular({required this.sticker, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'diceStickersRegular',
      if (extra != null) '@extra': extra,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DiceStickersRegular? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = Sticker.fromMap(_map['sticker'])!;
    return DiceStickersRegular(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
    );
  }
}

/// Animated stickers to be combined into a slot machine.
///
class DiceStickersSlotMachine extends DiceStickers {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "diceStickersSlotMachine";

  /// The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish.
  late Sticker background;

  /// The animated sticker with the lever animation. The lever animation must play once in the initial dice state.
  late Sticker lever;

  /// The animated sticker with the left reel.
  late Sticker left_reel;

  /// The animated sticker with the center reel.
  late Sticker center_reel;

  /// The animated sticker with the right reel.
  late Sticker right_reel;

  /// Animated stickers to be combined into a slot machine
  DiceStickersSlotMachine(
      {required this.background,
      required this.lever,
      required this.left_reel,
      required this.center_reel,
      required this.right_reel,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'diceStickersSlotMachine',
      if (extra != null) '@extra': extra,
      'background': background,
      'lever': lever,
      'left_reel': left_reel,
      'center_reel': center_reel,
      'right_reel': right_reel
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DiceStickersSlotMachine? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var background = Sticker.fromMap(_map['background'])!;
    var lever = Sticker.fromMap(_map['lever'])!;
    var left_reel = Sticker.fromMap(_map['left_reel'])!;
    var center_reel = Sticker.fromMap(_map['center_reel'])!;
    var right_reel = Sticker.fromMap(_map['right_reel'])!;
    return DiceStickersSlotMachine(
      extra: extra,
      clientId: clientId,
      background: background,
      lever: lever,
      left_reel: left_reel,
      center_reel: center_reel,
      right_reel: right_reel,
    );
  }
}

/// Represents the result of an importContacts request.
///
class ImportedContacts extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "importedContacts";

  /// User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user.
  late List<int> user_ids;

  /// The number of users that imported the corresponding contact; 0 for already registered users or if unavailable.
  late List<int> importer_count;

  /// Represents the result of an importContacts request
  ImportedContacts(
      {required this.user_ids,
      required this.importer_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'importedContacts',
      if (extra != null) '@extra': extra,
      'user_ids': user_ids,
      'importer_count': importer_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ImportedContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var importer_count = List<int>.from(
      (_map["importer_count"] ?? []).map(
        (e) => e as int,
      ),
    );
    return ImportedContacts(
      extra: extra,
      clientId: clientId,
      user_ids: user_ids,
      importer_count: importer_count,
    );
  }
}

/// The speech recognition is ongoing.
///
class SpeechRecognitionResultPending extends SpeechRecognitionResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "speechRecognitionResultPending";

  /// Partially recognized text.
  late String partial_text;

  /// The speech recognition is ongoing
  SpeechRecognitionResultPending(
      {required this.partial_text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'speechRecognitionResultPending',
      if (extra != null) '@extra': extra,
      'partial_text': partial_text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SpeechRecognitionResultPending? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var partial_text = _map['partial_text']! as String;
    return SpeechRecognitionResultPending(
      extra: extra,
      clientId: clientId,
      partial_text: partial_text,
    );
  }
}

/// The speech recognition successfully finished.
///
class SpeechRecognitionResultText extends SpeechRecognitionResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "speechRecognitionResultText";

  /// Recognized text.
  late String text;

  /// The speech recognition successfully finished
  SpeechRecognitionResultText({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'speechRecognitionResultText',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SpeechRecognitionResultText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    return SpeechRecognitionResultText(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// The speech recognition failed.
///
class SpeechRecognitionResultError extends SpeechRecognitionResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "speechRecognitionResultError";

  /// Recognition error.
  late Error error;

  /// The speech recognition failed
  SpeechRecognitionResultError(
      {required this.error, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'speechRecognitionResultError',
      if (extra != null) '@extra': extra,
      'error': error
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SpeechRecognitionResultError? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var error = Error.fromMap(_map['error'])!;
    return SpeechRecognitionResultError(
      extra: extra,
      clientId: clientId,
      error: error,
    );
  }
}

/// Describes a color to highlight a bot added to attachment menu.
///
class AttachmentMenuBotColor extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "attachmentMenuBotColor";

  /// Color in the RGB24 format for light themes.
  late int light_color;

  /// Color in the RGB24 format for dark themes.
  late int dark_color;

  /// Describes a color to highlight a bot added to attachment menu
  AttachmentMenuBotColor(
      {required this.light_color,
      required this.dark_color,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'attachmentMenuBotColor',
      if (extra != null) '@extra': extra,
      'light_color': light_color,
      'dark_color': dark_color
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AttachmentMenuBotColor? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var light_color = _map['light_color']! as int;
    var dark_color = _map['dark_color']! as int;
    return AttachmentMenuBotColor(
      extra: extra,
      clientId: clientId,
      light_color: light_color,
      dark_color: dark_color,
    );
  }
}

/// Represents a bot, which can be added to attachment or side menu.
///
class AttachmentMenuBot extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "attachmentMenuBot";

  /// User identifier of the bot.
  late int bot_user_id;

  /// True, if the bot supports opening from attachment menu in the chat with the bot.
  late bool supports_self_chat;

  /// True, if the bot supports opening from attachment menu in private chats with ordinary users.
  late bool supports_user_chats;

  /// True, if the bot supports opening from attachment menu in private chats with other bots.
  late bool supports_bot_chats;

  /// True, if the bot supports opening from attachment menu in basic group and supergroup chats.
  late bool supports_group_chats;

  /// True, if the bot supports opening from attachment menu in channel chats.
  late bool supports_channel_chats;

  /// True, if the bot supports "settings_button_pressed" event.
  late bool supports_settings;

  /// True, if the user must be asked for the permission to send messages to the bot.
  late bool request_write_access;

  /// True, if the bot was explicitly added by the user. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed.
  late bool is_added;

  /// True, if the bot must be shown in the attachment menu.
  late bool show_in_attachment_menu;

  /// True, if the bot must be shown in the side menu.
  late bool show_in_side_menu;

  /// True, if a disclaimer, why the bot is shown in the side menu, is needed.
  late bool show_disclaimer_in_side_menu;

  /// Name for the bot in attachment menu.
  late String name;

  /// Color to highlight selected name of the bot if appropriate; may be null.
  AttachmentMenuBotColor? name_color;

  /// Default icon for the bot in SVG format; may be null.
  File? default_icon;

  /// Icon for the bot in SVG format for the official iOS app; may be null.
  File? ios_static_icon;

  /// Icon for the bot in TGS format for the official iOS app; may be null.
  File? ios_animated_icon;

  /// Icon for the bot in PNG format for the official iOS app side menu; may be null.
  File? ios_side_menu_icon;

  /// Icon for the bot in TGS format for the official Android app; may be null.
  File? android_icon;

  /// Icon for the bot in SVG format for the official Android app side menu; may be null.
  File? android_side_menu_icon;

  /// Icon for the bot in TGS format for the official native macOS app; may be null.
  File? macos_icon;

  /// Icon for the bot in PNG format for the official macOS app side menu; may be null.
  File? macos_side_menu_icon;

  /// Color to highlight selected icon of the bot if appropriate; may be null.
  AttachmentMenuBotColor? icon_color;

  /// Default placeholder for opened Web Apps in SVG format; may be null.
  File? web_app_placeholder;

  /// Represents a bot, which can be added to attachment or side menu
  AttachmentMenuBot(
      {required this.bot_user_id,
      required this.supports_self_chat,
      required this.supports_user_chats,
      required this.supports_bot_chats,
      required this.supports_group_chats,
      required this.supports_channel_chats,
      required this.supports_settings,
      required this.request_write_access,
      required this.is_added,
      required this.show_in_attachment_menu,
      required this.show_in_side_menu,
      required this.show_disclaimer_in_side_menu,
      required this.name,
      this.name_color,
      this.default_icon,
      this.ios_static_icon,
      this.ios_animated_icon,
      this.ios_side_menu_icon,
      this.android_icon,
      this.android_side_menu_icon,
      this.macos_icon,
      this.macos_side_menu_icon,
      this.icon_color,
      this.web_app_placeholder,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'attachmentMenuBot',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'supports_self_chat': supports_self_chat,
      'supports_user_chats': supports_user_chats,
      'supports_bot_chats': supports_bot_chats,
      'supports_group_chats': supports_group_chats,
      'supports_channel_chats': supports_channel_chats,
      'supports_settings': supports_settings,
      'request_write_access': request_write_access,
      'is_added': is_added,
      'show_in_attachment_menu': show_in_attachment_menu,
      'show_in_side_menu': show_in_side_menu,
      'show_disclaimer_in_side_menu': show_disclaimer_in_side_menu,
      'name': name,
      'name_color': name_color,
      'default_icon': default_icon,
      'ios_static_icon': ios_static_icon,
      'ios_animated_icon': ios_animated_icon,
      'ios_side_menu_icon': ios_side_menu_icon,
      'android_icon': android_icon,
      'android_side_menu_icon': android_side_menu_icon,
      'macos_icon': macos_icon,
      'macos_side_menu_icon': macos_side_menu_icon,
      'icon_color': icon_color,
      'web_app_placeholder': web_app_placeholder
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AttachmentMenuBot? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var supports_self_chat = _map['supports_self_chat']! as bool;
    var supports_user_chats = _map['supports_user_chats']! as bool;
    var supports_bot_chats = _map['supports_bot_chats']! as bool;
    var supports_group_chats = _map['supports_group_chats']! as bool;
    var supports_channel_chats = _map['supports_channel_chats']! as bool;
    var supports_settings = _map['supports_settings']! as bool;
    var request_write_access = _map['request_write_access']! as bool;
    var is_added = _map['is_added']! as bool;
    var show_in_attachment_menu = _map['show_in_attachment_menu']! as bool;
    var show_in_side_menu = _map['show_in_side_menu']! as bool;
    var show_disclaimer_in_side_menu =
        _map['show_disclaimer_in_side_menu']! as bool;
    var name = _map['name']! as String;
    var name_color = AttachmentMenuBotColor.fromMap(_map['name_color']);
    var default_icon = File.fromMap(_map['default_icon']);
    var ios_static_icon = File.fromMap(_map['ios_static_icon']);
    var ios_animated_icon = File.fromMap(_map['ios_animated_icon']);
    var ios_side_menu_icon = File.fromMap(_map['ios_side_menu_icon']);
    var android_icon = File.fromMap(_map['android_icon']);
    var android_side_menu_icon = File.fromMap(_map['android_side_menu_icon']);
    var macos_icon = File.fromMap(_map['macos_icon']);
    var macos_side_menu_icon = File.fromMap(_map['macos_side_menu_icon']);
    var icon_color = AttachmentMenuBotColor.fromMap(_map['icon_color']);
    var web_app_placeholder = File.fromMap(_map['web_app_placeholder']);
    return AttachmentMenuBot(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      supports_self_chat: supports_self_chat,
      supports_user_chats: supports_user_chats,
      supports_bot_chats: supports_bot_chats,
      supports_group_chats: supports_group_chats,
      supports_channel_chats: supports_channel_chats,
      supports_settings: supports_settings,
      request_write_access: request_write_access,
      is_added: is_added,
      show_in_attachment_menu: show_in_attachment_menu,
      show_in_side_menu: show_in_side_menu,
      show_disclaimer_in_side_menu: show_disclaimer_in_side_menu,
      name: name,
      name_color: name_color,
      default_icon: default_icon,
      ios_static_icon: ios_static_icon,
      ios_animated_icon: ios_animated_icon,
      ios_side_menu_icon: ios_side_menu_icon,
      android_icon: android_icon,
      android_side_menu_icon: android_side_menu_icon,
      macos_icon: macos_icon,
      macos_side_menu_icon: macos_side_menu_icon,
      icon_color: icon_color,
      web_app_placeholder: web_app_placeholder,
    );
  }
}

/// Information about the message sent by answerWebAppQuery.
///
class SentWebAppMessage extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sentWebAppMessage";

  /// Identifier of the sent inline message, if known.
  late String inline_message_id;

  /// Information about the message sent by answerWebAppQuery
  SentWebAppMessage(
      {required this.inline_message_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sentWebAppMessage',
      if (extra != null) '@extra': extra,
      'inline_message_id': inline_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SentWebAppMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_message_id = _map['inline_message_id']! as String;
    return SentWebAppMessage(
      extra: extra,
      clientId: clientId,
      inline_message_id: inline_message_id,
    );
  }
}

/// Contains an HTTP URL.
///
class HttpUrl extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "httpUrl";

  /// The URL.
  late String url;

  /// Contains an HTTP URL
  HttpUrl({required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'httpUrl', if (extra != null) '@extra': extra, 'url': url};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static HttpUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return HttpUrl(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// Contains an HTTPS URL, which can be used to get information about a user.
///
class UserLink extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userLink";

  /// The URL.
  late String url;

  /// Left time for which the link is valid, in seconds; 0 if the link is a public username link.
  late int expires_in;

  /// Contains an HTTPS URL, which can be used to get information about a user
  UserLink(
      {required this.url, required this.expires_in, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userLink',
      if (extra != null) '@extra': extra,
      'url': url,
      'expires_in': expires_in
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var expires_in = _map['expires_in']! as int;
    return UserLink(
      extra: extra,
      clientId: clientId,
      url: url,
      expires_in: expires_in,
    );
  }
}

/// Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video.
///
class InputInlineQueryResultAnimation extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultAnimation";

  /// Unique identifier of the query result.
  late String id;

  /// Title of the query result.
  late String title;

  /// URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists.
  late String thumbnail_url;

  /// MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4".
  late String thumbnail_mime_type;

  /// The URL of the video file (file size must not exceed 1MB).
  late String video_url;

  /// MIME type of the video file. Must be one of "image/gif" and "video/mp4".
  late String video_mime_type;

  /// Duration of the video, in seconds.
  late int video_duration;

  /// Width of the video.
  late int video_width;

  /// Height of the video.
  late int video_height;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video
  InputInlineQueryResultAnimation(
      {required this.id,
      required this.title,
      required this.thumbnail_url,
      required this.thumbnail_mime_type,
      required this.video_url,
      required this.video_mime_type,
      required this.video_duration,
      required this.video_width,
      required this.video_height,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultAnimation',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'thumbnail_url': thumbnail_url,
      'thumbnail_mime_type': thumbnail_mime_type,
      'video_url': video_url,
      'video_mime_type': video_mime_type,
      'video_duration': video_duration,
      'video_width': video_width,
      'video_height': video_height,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var title = _map['title']! as String;
    var thumbnail_url = _map['thumbnail_url']! as String;
    var thumbnail_mime_type = _map['thumbnail_mime_type']! as String;
    var video_url = _map['video_url']! as String;
    var video_mime_type = _map['video_mime_type']! as String;
    var video_duration = _map['video_duration']! as int;
    var video_width = _map['video_width']! as int;
    var video_height = _map['video_height']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultAnimation(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      thumbnail_url: thumbnail_url,
      thumbnail_mime_type: thumbnail_mime_type,
      video_url: video_url,
      video_mime_type: video_mime_type,
      video_duration: video_duration,
      video_width: video_width,
      video_height: video_height,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents a link to an article or web page.
///
class InputInlineQueryResultArticle extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultArticle";

  /// Unique identifier of the query result.
  late String id;

  /// URL of the result, if it exists.
  late String url;

  /// True, if the URL must be not shown.
  late bool hide_url;

  /// Title of the result.
  late String title;

  /// A short description of the result.
  late String description;

  /// URL of the result thumbnail, if it exists.
  late String thumbnail_url;

  /// Thumbnail width, if known.
  late int thumbnail_width;

  /// Thumbnail height, if known.
  late int thumbnail_height;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents a link to an article or web page
  InputInlineQueryResultArticle(
      {required this.id,
      required this.url,
      required this.hide_url,
      required this.title,
      required this.description,
      required this.thumbnail_url,
      required this.thumbnail_width,
      required this.thumbnail_height,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultArticle',
      if (extra != null) '@extra': extra,
      'id': id,
      'url': url,
      'hide_url': hide_url,
      'title': title,
      'description': description,
      'thumbnail_url': thumbnail_url,
      'thumbnail_width': thumbnail_width,
      'thumbnail_height': thumbnail_height,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultArticle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var url = _map['url']! as String;
    var hide_url = _map['hide_url']! as bool;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    var thumbnail_url = _map['thumbnail_url']! as String;
    var thumbnail_width = _map['thumbnail_width']! as int;
    var thumbnail_height = _map['thumbnail_height']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultArticle(
      extra: extra,
      clientId: clientId,
      id: id,
      url: url,
      hide_url: hide_url,
      title: title,
      description: description,
      thumbnail_url: thumbnail_url,
      thumbnail_width: thumbnail_width,
      thumbnail_height: thumbnail_height,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents a link to an MP3 audio file.
///
class InputInlineQueryResultAudio extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultAudio";

  /// Unique identifier of the query result.
  late String id;

  /// Title of the audio file.
  late String title;

  /// Performer of the audio file.
  late String performer;

  /// The URL of the audio file.
  late String audio_url;

  /// Audio file duration, in seconds.
  late int audio_duration;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents a link to an MP3 audio file
  InputInlineQueryResultAudio(
      {required this.id,
      required this.title,
      required this.performer,
      required this.audio_url,
      required this.audio_duration,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultAudio',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'performer': performer,
      'audio_url': audio_url,
      'audio_duration': audio_duration,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultAudio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var title = _map['title']! as String;
    var performer = _map['performer']! as String;
    var audio_url = _map['audio_url']! as String;
    var audio_duration = _map['audio_duration']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultAudio(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      performer: performer,
      audio_url: audio_url,
      audio_duration: audio_duration,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents a user contact.
///
class InputInlineQueryResultContact extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultContact";

  /// Unique identifier of the query result.
  late String id;

  /// User contact.
  late Contact contact;

  /// URL of the result thumbnail, if it exists.
  late String thumbnail_url;

  /// Thumbnail width, if known.
  late int thumbnail_width;

  /// Thumbnail height, if known.
  late int thumbnail_height;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents a user contact
  InputInlineQueryResultContact(
      {required this.id,
      required this.contact,
      required this.thumbnail_url,
      required this.thumbnail_width,
      required this.thumbnail_height,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultContact',
      if (extra != null) '@extra': extra,
      'id': id,
      'contact': contact,
      'thumbnail_url': thumbnail_url,
      'thumbnail_width': thumbnail_width,
      'thumbnail_height': thumbnail_height,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultContact? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var contact = Contact.fromMap(_map['contact'])!;
    var thumbnail_url = _map['thumbnail_url']! as String;
    var thumbnail_width = _map['thumbnail_width']! as int;
    var thumbnail_height = _map['thumbnail_height']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultContact(
      extra: extra,
      clientId: clientId,
      id: id,
      contact: contact,
      thumbnail_url: thumbnail_url,
      thumbnail_width: thumbnail_width,
      thumbnail_height: thumbnail_height,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents a link to a file.
///
class InputInlineQueryResultDocument extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultDocument";

  /// Unique identifier of the query result.
  late String id;

  /// Title of the resulting file.
  late String title;

  /// Short description of the result, if known.
  late String description;

  /// URL of the file.
  late String document_url;

  /// MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed.
  late String mime_type;

  /// The URL of the file thumbnail, if it exists.
  late String thumbnail_url;

  /// Width of the thumbnail.
  late int thumbnail_width;

  /// Height of the thumbnail.
  late int thumbnail_height;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents a link to a file
  InputInlineQueryResultDocument(
      {required this.id,
      required this.title,
      required this.description,
      required this.document_url,
      required this.mime_type,
      required this.thumbnail_url,
      required this.thumbnail_width,
      required this.thumbnail_height,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultDocument',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'description': description,
      'document_url': document_url,
      'mime_type': mime_type,
      'thumbnail_url': thumbnail_url,
      'thumbnail_width': thumbnail_width,
      'thumbnail_height': thumbnail_height,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    var document_url = _map['document_url']! as String;
    var mime_type = _map['mime_type']! as String;
    var thumbnail_url = _map['thumbnail_url']! as String;
    var thumbnail_width = _map['thumbnail_width']! as int;
    var thumbnail_height = _map['thumbnail_height']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultDocument(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      description: description,
      document_url: document_url,
      mime_type: mime_type,
      thumbnail_url: thumbnail_url,
      thumbnail_width: thumbnail_width,
      thumbnail_height: thumbnail_height,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents a game.
///
class InputInlineQueryResultGame extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultGame";

  /// Unique identifier of the query result.
  late String id;

  /// Short name of the game.
  late String game_short_name;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// Represents a game
  InputInlineQueryResultGame(
      {required this.id,
      required this.game_short_name,
      this.reply_markup,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultGame',
      if (extra != null) '@extra': extra,
      'id': id,
      'game_short_name': game_short_name,
      'reply_markup': reply_markup
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultGame? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var game_short_name = _map['game_short_name']! as String;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    return InputInlineQueryResultGame(
      extra: extra,
      clientId: clientId,
      id: id,
      game_short_name: game_short_name,
      reply_markup: reply_markup,
    );
  }
}

/// Represents a point on the map.
///
class InputInlineQueryResultLocation extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultLocation";

  /// Unique identifier of the query result.
  late String id;

  /// Location result.
  late Location location;

  /// Amount of time relative to the message sent time until the location can be updated, in seconds.
  late int live_period;

  /// Title of the result.
  late String title;

  /// URL of the result thumbnail, if it exists.
  late String thumbnail_url;

  /// Thumbnail width, if known.
  late int thumbnail_width;

  /// Thumbnail height, if known.
  late int thumbnail_height;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents a point on the map
  InputInlineQueryResultLocation(
      {required this.id,
      required this.location,
      required this.live_period,
      required this.title,
      required this.thumbnail_url,
      required this.thumbnail_width,
      required this.thumbnail_height,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultLocation',
      if (extra != null) '@extra': extra,
      'id': id,
      'location': location,
      'live_period': live_period,
      'title': title,
      'thumbnail_url': thumbnail_url,
      'thumbnail_width': thumbnail_width,
      'thumbnail_height': thumbnail_height,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var location = Location.fromMap(_map['location'])!;
    var live_period = _map['live_period']! as int;
    var title = _map['title']! as String;
    var thumbnail_url = _map['thumbnail_url']! as String;
    var thumbnail_width = _map['thumbnail_width']! as int;
    var thumbnail_height = _map['thumbnail_height']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultLocation(
      extra: extra,
      clientId: clientId,
      id: id,
      location: location,
      live_period: live_period,
      title: title,
      thumbnail_url: thumbnail_url,
      thumbnail_width: thumbnail_width,
      thumbnail_height: thumbnail_height,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents link to a JPEG image.
///
class InputInlineQueryResultPhoto extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultPhoto";

  /// Unique identifier of the query result.
  late String id;

  /// Title of the result, if known.
  late String title;

  /// A short description of the result, if known.
  late String description;

  /// URL of the photo thumbnail, if it exists.
  late String thumbnail_url;

  /// The URL of the JPEG photo (photo size must not exceed 5MB).
  late String photo_url;

  /// Width of the photo.
  late int photo_width;

  /// Height of the photo.
  late int photo_height;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents link to a JPEG image
  InputInlineQueryResultPhoto(
      {required this.id,
      required this.title,
      required this.description,
      required this.thumbnail_url,
      required this.photo_url,
      required this.photo_width,
      required this.photo_height,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultPhoto',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'description': description,
      'thumbnail_url': thumbnail_url,
      'photo_url': photo_url,
      'photo_width': photo_width,
      'photo_height': photo_height,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    var thumbnail_url = _map['thumbnail_url']! as String;
    var photo_url = _map['photo_url']! as String;
    var photo_width = _map['photo_width']! as int;
    var photo_height = _map['photo_height']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultPhoto(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      description: description,
      thumbnail_url: thumbnail_url,
      photo_url: photo_url,
      photo_width: photo_width,
      photo_height: photo_height,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents a link to a WEBP, TGS, or WEBM sticker.
///
class InputInlineQueryResultSticker extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultSticker";

  /// Unique identifier of the query result.
  late String id;

  /// URL of the sticker thumbnail, if it exists.
  late String thumbnail_url;

  /// The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB).
  late String sticker_url;

  /// Width of the sticker.
  late int sticker_width;

  /// Height of the sticker.
  late int sticker_height;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents a link to a WEBP, TGS, or WEBM sticker
  InputInlineQueryResultSticker(
      {required this.id,
      required this.thumbnail_url,
      required this.sticker_url,
      required this.sticker_width,
      required this.sticker_height,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultSticker',
      if (extra != null) '@extra': extra,
      'id': id,
      'thumbnail_url': thumbnail_url,
      'sticker_url': sticker_url,
      'sticker_width': sticker_width,
      'sticker_height': sticker_height,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var thumbnail_url = _map['thumbnail_url']! as String;
    var sticker_url = _map['sticker_url']! as String;
    var sticker_width = _map['sticker_width']! as int;
    var sticker_height = _map['sticker_height']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultSticker(
      extra: extra,
      clientId: clientId,
      id: id,
      thumbnail_url: thumbnail_url,
      sticker_url: sticker_url,
      sticker_width: sticker_width,
      sticker_height: sticker_height,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents information about a venue.
///
class InputInlineQueryResultVenue extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultVenue";

  /// Unique identifier of the query result.
  late String id;

  /// Venue result.
  late Venue venue;

  /// URL of the result thumbnail, if it exists.
  late String thumbnail_url;

  /// Thumbnail width, if known.
  late int thumbnail_width;

  /// Thumbnail height, if known.
  late int thumbnail_height;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents information about a venue
  InputInlineQueryResultVenue(
      {required this.id,
      required this.venue,
      required this.thumbnail_url,
      required this.thumbnail_width,
      required this.thumbnail_height,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultVenue',
      if (extra != null) '@extra': extra,
      'id': id,
      'venue': venue,
      'thumbnail_url': thumbnail_url,
      'thumbnail_width': thumbnail_width,
      'thumbnail_height': thumbnail_height,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultVenue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var venue = Venue.fromMap(_map['venue'])!;
    var thumbnail_url = _map['thumbnail_url']! as String;
    var thumbnail_width = _map['thumbnail_width']! as int;
    var thumbnail_height = _map['thumbnail_height']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultVenue(
      extra: extra,
      clientId: clientId,
      id: id,
      venue: venue,
      thumbnail_url: thumbnail_url,
      thumbnail_width: thumbnail_width,
      thumbnail_height: thumbnail_height,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents a link to a page containing an embedded video player or a video file.
///
class InputInlineQueryResultVideo extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultVideo";

  /// Unique identifier of the query result.
  late String id;

  /// Title of the result.
  late String title;

  /// A short description of the result, if known.
  late String description;

  /// The URL of the video thumbnail (JPEG), if it exists.
  late String thumbnail_url;

  /// URL of the embedded video player or video file.
  late String video_url;

  /// MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported.
  late String mime_type;

  /// Width of the video.
  late int video_width;

  /// Height of the video.
  late int video_height;

  /// Video duration, in seconds.
  late int video_duration;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents a link to a page containing an embedded video player or a video file
  InputInlineQueryResultVideo(
      {required this.id,
      required this.title,
      required this.description,
      required this.thumbnail_url,
      required this.video_url,
      required this.mime_type,
      required this.video_width,
      required this.video_height,
      required this.video_duration,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultVideo',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'description': description,
      'thumbnail_url': thumbnail_url,
      'video_url': video_url,
      'mime_type': mime_type,
      'video_width': video_width,
      'video_height': video_height,
      'video_duration': video_duration,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    var thumbnail_url = _map['thumbnail_url']! as String;
    var video_url = _map['video_url']! as String;
    var mime_type = _map['mime_type']! as String;
    var video_width = _map['video_width']! as int;
    var video_height = _map['video_height']! as int;
    var video_duration = _map['video_duration']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultVideo(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      description: description,
      thumbnail_url: thumbnail_url,
      video_url: video_url,
      mime_type: mime_type,
      video_width: video_width,
      video_height: video_height,
      video_duration: video_duration,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents a link to an opus-encoded audio file within an OGG container, single channel audio.
///
class InputInlineQueryResultVoiceNote extends InputInlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputInlineQueryResultVoiceNote";

  /// Unique identifier of the query result.
  late String id;

  /// Title of the voice note.
  late String title;

  /// The URL of the voice note file.
  late String voice_note_url;

  /// Duration of the voice note, in seconds.
  late int voice_note_duration;

  /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact.
  late InputMessageContent input_message_content;

  /// Represents a link to an opus-encoded audio file within an OGG container, single channel audio
  InputInlineQueryResultVoiceNote(
      {required this.id,
      required this.title,
      required this.voice_note_url,
      required this.voice_note_duration,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputInlineQueryResultVoiceNote',
      if (extra != null) '@extra': extra,
      'id': id,
      'title': title,
      'voice_note_url': voice_note_url,
      'voice_note_duration': voice_note_duration,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputInlineQueryResultVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var title = _map['title']! as String;
    var voice_note_url = _map['voice_note_url']! as String;
    var voice_note_duration = _map['voice_note_duration']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return InputInlineQueryResultVoiceNote(
      extra: extra,
      clientId: clientId,
      id: id,
      title: title,
      voice_note_url: voice_note_url,
      voice_note_duration: voice_note_duration,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Represents a link to an article or web page.
///
class InlineQueryResultArticle extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultArticle";

  /// Unique identifier of the query result.
  late String id;

  /// URL of the result, if it exists.
  late String url;

  /// True, if the URL must be not shown.
  late bool hide_url;

  /// Title of the result.
  late String title;

  /// A short description of the result.
  late String description;

  /// Result thumbnail in JPEG format; may be null.
  Thumbnail? thumbnail;

  /// Represents a link to an article or web page
  InlineQueryResultArticle(
      {required this.id,
      required this.url,
      required this.hide_url,
      required this.title,
      required this.description,
      this.thumbnail,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultArticle',
      if (extra != null) '@extra': extra,
      'id': id,
      'url': url,
      'hide_url': hide_url,
      'title': title,
      'description': description,
      'thumbnail': thumbnail
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultArticle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var url = _map['url']! as String;
    var hide_url = _map['hide_url']! as bool;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    return InlineQueryResultArticle(
      extra: extra,
      clientId: clientId,
      id: id,
      url: url,
      hide_url: hide_url,
      title: title,
      description: description,
      thumbnail: thumbnail,
    );
  }
}

/// Represents a user contact.
///
class InlineQueryResultContact extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultContact";

  /// Unique identifier of the query result.
  late String id;

  /// A user contact.
  late Contact contact;

  /// Result thumbnail in JPEG format; may be null.
  Thumbnail? thumbnail;

  /// Represents a user contact
  InlineQueryResultContact(
      {required this.id,
      required this.contact,
      this.thumbnail,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultContact',
      if (extra != null) '@extra': extra,
      'id': id,
      'contact': contact,
      'thumbnail': thumbnail
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultContact? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var contact = Contact.fromMap(_map['contact'])!;
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    return InlineQueryResultContact(
      extra: extra,
      clientId: clientId,
      id: id,
      contact: contact,
      thumbnail: thumbnail,
    );
  }
}

/// Represents a point on the map.
///
class InlineQueryResultLocation extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultLocation";

  /// Unique identifier of the query result.
  late String id;

  /// Location result.
  late Location location;

  /// Title of the result.
  late String title;

  /// Result thumbnail in JPEG format; may be null.
  Thumbnail? thumbnail;

  /// Represents a point on the map
  InlineQueryResultLocation(
      {required this.id,
      required this.location,
      required this.title,
      this.thumbnail,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultLocation',
      if (extra != null) '@extra': extra,
      'id': id,
      'location': location,
      'title': title,
      'thumbnail': thumbnail
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var location = Location.fromMap(_map['location'])!;
    var title = _map['title']! as String;
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    return InlineQueryResultLocation(
      extra: extra,
      clientId: clientId,
      id: id,
      location: location,
      title: title,
      thumbnail: thumbnail,
    );
  }
}

/// Represents information about a venue.
///
class InlineQueryResultVenue extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultVenue";

  /// Unique identifier of the query result.
  late String id;

  /// Venue result.
  late Venue venue;

  /// Result thumbnail in JPEG format; may be null.
  Thumbnail? thumbnail;

  /// Represents information about a venue
  InlineQueryResultVenue(
      {required this.id,
      required this.venue,
      this.thumbnail,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultVenue',
      if (extra != null) '@extra': extra,
      'id': id,
      'venue': venue,
      'thumbnail': thumbnail
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultVenue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var venue = Venue.fromMap(_map['venue'])!;
    var thumbnail = Thumbnail.fromMap(_map['thumbnail']);
    return InlineQueryResultVenue(
      extra: extra,
      clientId: clientId,
      id: id,
      venue: venue,
      thumbnail: thumbnail,
    );
  }
}

/// Represents information about a game.
///
class InlineQueryResultGame extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultGame";

  /// Unique identifier of the query result.
  late String id;

  /// Game result.
  late Game game;

  /// Represents information about a game
  InlineQueryResultGame(
      {required this.id, required this.game, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultGame',
      if (extra != null) '@extra': extra,
      'id': id,
      'game': game
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultGame? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var game = Game.fromMap(_map['game'])!;
    return InlineQueryResultGame(
      extra: extra,
      clientId: clientId,
      id: id,
      game: game,
    );
  }
}

/// Represents an animation file.
///
class InlineQueryResultAnimation extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultAnimation";

  /// Unique identifier of the query result.
  late String id;

  /// Animation file.
  late Animation animation;

  /// Animation title.
  late String title;

  /// Represents an animation file
  InlineQueryResultAnimation(
      {required this.id,
      required this.animation,
      required this.title,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultAnimation',
      if (extra != null) '@extra': extra,
      'id': id,
      'animation': animation,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var animation = Animation.fromMap(_map['animation'])!;
    var title = _map['title']! as String;
    return InlineQueryResultAnimation(
      extra: extra,
      clientId: clientId,
      id: id,
      animation: animation,
      title: title,
    );
  }
}

/// Represents an audio file.
///
class InlineQueryResultAudio extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultAudio";

  /// Unique identifier of the query result.
  late String id;

  /// Audio file.
  late Audio audio;

  /// Represents an audio file
  InlineQueryResultAudio(
      {required this.id, required this.audio, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultAudio',
      if (extra != null) '@extra': extra,
      'id': id,
      'audio': audio
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultAudio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var audio = Audio.fromMap(_map['audio'])!;
    return InlineQueryResultAudio(
      extra: extra,
      clientId: clientId,
      id: id,
      audio: audio,
    );
  }
}

/// Represents a document.
///
class InlineQueryResultDocument extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultDocument";

  /// Unique identifier of the query result.
  late String id;

  /// Document.
  late Document document;

  /// Document title.
  late String title;

  /// Document description.
  late String description;

  /// Represents a document
  InlineQueryResultDocument(
      {required this.id,
      required this.document,
      required this.title,
      required this.description,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultDocument',
      if (extra != null) '@extra': extra,
      'id': id,
      'document': document,
      'title': title,
      'description': description
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var document = Document.fromMap(_map['document'])!;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    return InlineQueryResultDocument(
      extra: extra,
      clientId: clientId,
      id: id,
      document: document,
      title: title,
      description: description,
    );
  }
}

/// Represents a photo.
///
class InlineQueryResultPhoto extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultPhoto";

  /// Unique identifier of the query result.
  late String id;

  /// Photo.
  late Photo photo;

  /// Title of the result, if known.
  late String title;

  /// A short description of the result, if known.
  late String description;

  /// Represents a photo
  InlineQueryResultPhoto(
      {required this.id,
      required this.photo,
      required this.title,
      required this.description,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultPhoto',
      if (extra != null) '@extra': extra,
      'id': id,
      'photo': photo,
      'title': title,
      'description': description
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var photo = Photo.fromMap(_map['photo'])!;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    return InlineQueryResultPhoto(
      extra: extra,
      clientId: clientId,
      id: id,
      photo: photo,
      title: title,
      description: description,
    );
  }
}

/// Represents a sticker.
///
class InlineQueryResultSticker extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultSticker";

  /// Unique identifier of the query result.
  late String id;

  /// Sticker.
  late Sticker sticker;

  /// Represents a sticker
  InlineQueryResultSticker(
      {required this.id, required this.sticker, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultSticker',
      if (extra != null) '@extra': extra,
      'id': id,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var sticker = Sticker.fromMap(_map['sticker'])!;
    return InlineQueryResultSticker(
      extra: extra,
      clientId: clientId,
      id: id,
      sticker: sticker,
    );
  }
}

/// Represents a video.
///
class InlineQueryResultVideo extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultVideo";

  /// Unique identifier of the query result.
  late String id;

  /// Video.
  late Video video;

  /// Title of the video.
  late String title;

  /// Description of the video.
  late String description;

  /// Represents a video
  InlineQueryResultVideo(
      {required this.id,
      required this.video,
      required this.title,
      required this.description,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultVideo',
      if (extra != null) '@extra': extra,
      'id': id,
      'video': video,
      'title': title,
      'description': description
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var video = Video.fromMap(_map['video'])!;
    var title = _map['title']! as String;
    var description = _map['description']! as String;
    return InlineQueryResultVideo(
      extra: extra,
      clientId: clientId,
      id: id,
      video: video,
      title: title,
      description: description,
    );
  }
}

/// Represents a voice note.
///
class InlineQueryResultVoiceNote extends InlineQueryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultVoiceNote";

  /// Unique identifier of the query result.
  late String id;

  /// Voice note.
  late VoiceNote voice_note;

  /// Title of the voice note.
  late String title;

  /// Represents a voice note
  InlineQueryResultVoiceNote(
      {required this.id,
      required this.voice_note,
      required this.title,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultVoiceNote',
      if (extra != null) '@extra': extra,
      'id': id,
      'voice_note': voice_note,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var voice_note = VoiceNote.fromMap(_map['voice_note'])!;
    var title = _map['title']! as String;
    return InlineQueryResultVoiceNote(
      extra: extra,
      clientId: clientId,
      id: id,
      voice_note: voice_note,
      title: title,
    );
  }
}

/// Describes the button that opens a private chat with the bot and sends a start message to the bot with the given parameter.
///
class InlineQueryResultsButtonTypeStartBot
    extends InlineQueryResultsButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultsButtonTypeStartBot";

  /// The parameter for the bot start message.
  late String parameter;

  /// Describes the button that opens a private chat with the bot and sends a start message to the bot with the given parameter
  InlineQueryResultsButtonTypeStartBot(
      {required this.parameter, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultsButtonTypeStartBot',
      if (extra != null) '@extra': extra,
      'parameter': parameter
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultsButtonTypeStartBot? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var parameter = _map['parameter']! as String;
    return InlineQueryResultsButtonTypeStartBot(
      extra: extra,
      clientId: clientId,
      parameter: parameter,
    );
  }
}

/// Describes the button that opens a Web App by calling getWebAppUrl.
///
class InlineQueryResultsButtonTypeWebApp extends InlineQueryResultsButtonType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultsButtonTypeWebApp";

  /// An HTTP URL to pass to getWebAppUrl.
  late String url;

  /// Describes the button that opens a Web App by calling getWebAppUrl
  InlineQueryResultsButtonTypeWebApp(
      {required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultsButtonTypeWebApp',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultsButtonTypeWebApp? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return InlineQueryResultsButtonTypeWebApp(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// Represents a button to be shown above inline query results.
///
class InlineQueryResultsButton extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResultsButton";

  /// The text of the button.
  late String text;

  /// Type of the button.
  late InlineQueryResultsButtonType type;

  /// Represents a button to be shown above inline query results
  InlineQueryResultsButton(
      {required this.text, required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResultsButton',
      if (extra != null) '@extra': extra,
      'text': text,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResultsButton? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var type = InlineQueryResultsButtonType.fromMap(_map['type'])!;
    return InlineQueryResultsButton(
      extra: extra,
      clientId: clientId,
      text: text,
      type: type,
    );
  }
}

/// Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query.
///
class InlineQueryResults extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inlineQueryResults";

  /// Unique identifier of the inline query.
  /// ; string representation of int, use `int.parse`
  late int64 inline_query_id;

  /// Button to be shown above inline query results; may be null.
  InlineQueryResultsButton? button;

  /// Results of the query.
  late List<InlineQueryResult> results;

  /// The offset for the next request. If empty, there are no more results.
  String? next_offset;

  /// Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
  InlineQueryResults(
      {required this.inline_query_id,
      this.button,
      required this.results,
      this.next_offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inlineQueryResults',
      if (extra != null) '@extra': extra,
      'inline_query_id': inline_query_id,
      'button': button,
      'results': results,
      'next_offset': next_offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InlineQueryResults? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_query_id = _map['inline_query_id']! as int64;
    var button = InlineQueryResultsButton.fromMap(_map['button']);
    var results = List<InlineQueryResult>.from(
      (_map["results"] ?? []).map(
        (e) => InlineQueryResult.fromMap(e),
      ),
    );
    var next_offset = _map['next_offset'] as String?;
    return InlineQueryResults(
      extra: extra,
      clientId: clientId,
      inline_query_id: inline_query_id,
      button: button,
      results: results,
      next_offset: next_offset,
    );
  }
}

/// The payload for a general callback button.
///
class CallbackQueryPayloadData extends CallbackQueryPayload {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callbackQueryPayloadData";

  /// Data that was attached to the callback button.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// The payload for a general callback button
  CallbackQueryPayloadData({required this.data, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callbackQueryPayloadData',
      if (extra != null) '@extra': extra,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallbackQueryPayloadData? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var data = _map['data']! as bytes;
    return CallbackQueryPayloadData(
      extra: extra,
      clientId: clientId,
      data: data,
    );
  }
}

/// The payload for a callback button requiring password.
///
class CallbackQueryPayloadDataWithPassword extends CallbackQueryPayload {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callbackQueryPayloadDataWithPassword";

  /// The 2-step verification password for the current user.
  late String password;

  /// Data that was attached to the callback button.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// The payload for a callback button requiring password
  CallbackQueryPayloadDataWithPassword(
      {required this.password, required this.data, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callbackQueryPayloadDataWithPassword',
      if (extra != null) '@extra': extra,
      'password': password,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallbackQueryPayloadDataWithPassword? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var password = _map['password']! as String;
    var data = _map['data']! as bytes;
    return CallbackQueryPayloadDataWithPassword(
      extra: extra,
      clientId: clientId,
      password: password,
      data: data,
    );
  }
}

/// The payload for a game callback button.
///
class CallbackQueryPayloadGame extends CallbackQueryPayload {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callbackQueryPayloadGame";

  /// A short name of the game that was attached to the callback button.
  late String game_short_name;

  /// The payload for a game callback button
  CallbackQueryPayloadGame(
      {required this.game_short_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callbackQueryPayloadGame',
      if (extra != null) '@extra': extra,
      'game_short_name': game_short_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallbackQueryPayloadGame? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var game_short_name = _map['game_short_name']! as String;
    return CallbackQueryPayloadGame(
      extra: extra,
      clientId: clientId,
      game_short_name: game_short_name,
    );
  }
}

/// Contains a bot's answer to a callback query.
///
class CallbackQueryAnswer extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "callbackQueryAnswer";

  /// Text of the answer.
  late String text;

  /// True, if an alert must be shown to the user instead of a toast notification.
  late bool show_alert;

  /// URL to be opened.
  late String url;

  /// Contains a bot's answer to a callback query
  CallbackQueryAnswer(
      {required this.text,
      required this.show_alert,
      required this.url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'callbackQueryAnswer',
      if (extra != null) '@extra': extra,
      'text': text,
      'show_alert': show_alert,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CallbackQueryAnswer? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var show_alert = _map['show_alert']! as bool;
    var url = _map['url']! as String;
    return CallbackQueryAnswer(
      extra: extra,
      clientId: clientId,
      text: text,
      show_alert: show_alert,
      url: url,
    );
  }
}

/// Contains the result of a custom request.
///
class CustomRequestResult extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "customRequestResult";

  /// A JSON-serialized result.
  late String result;

  /// Contains the result of a custom request
  CustomRequestResult({required this.result, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'customRequestResult',
      if (extra != null) '@extra': extra,
      'result': result
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CustomRequestResult? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var result = _map['result']! as String;
    return CustomRequestResult(
      extra: extra,
      clientId: clientId,
      result: result,
    );
  }
}

/// Contains one row of the game high score table.
///
class GameHighScore extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "gameHighScore";

  /// Position in the high score table.
  late int position;

  /// User identifier.
  late int user_id;

  /// User score.
  late int score;

  /// Contains one row of the game high score table
  GameHighScore(
      {required this.position,
      required this.user_id,
      required this.score,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'gameHighScore',
      if (extra != null) '@extra': extra,
      'position': position,
      'user_id': user_id,
      'score': score
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GameHighScore? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var position = _map['position']! as int;
    var user_id = _map['user_id']! as int;
    var score = _map['score']! as int;
    return GameHighScore(
      extra: extra,
      clientId: clientId,
      position: position,
      user_id: user_id,
      score: score,
    );
  }
}

/// Contains a list of game high scores.
///
class GameHighScores extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "gameHighScores";

  /// A list of game high scores.
  late List<GameHighScore> scores;

  /// Contains a list of game high scores
  GameHighScores({required this.scores, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'gameHighScores',
      if (extra != null) '@extra': extra,
      'scores': scores
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GameHighScores? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scores = List<GameHighScore>.from(
      (_map["scores"] ?? []).map(
        (e) => GameHighScore.fromMap(e),
      ),
    );
    return GameHighScores(
      extra: extra,
      clientId: clientId,
      scores: scores,
    );
  }
}

/// A message was edited.
///
class ChatEventMessageEdited extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMessageEdited";

  /// The original message before the edit.
  late Message old_message;

  /// The message after it was edited.
  late Message new_message;

  /// A message was edited
  ChatEventMessageEdited(
      {required this.old_message,
      required this.new_message,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMessageEdited',
      if (extra != null) '@extra': extra,
      'old_message': old_message,
      'new_message': new_message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMessageEdited? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_message = Message.fromMap(_map['old_message'])!;
    var new_message = Message.fromMap(_map['new_message'])!;
    return ChatEventMessageEdited(
      extra: extra,
      clientId: clientId,
      old_message: old_message,
      new_message: new_message,
    );
  }
}

/// A message was deleted.
///
class ChatEventMessageDeleted extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMessageDeleted";

  /// Deleted message.
  late Message message;

  /// True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive.
  late bool can_report_anti_spam_false_positive;

  /// A message was deleted
  ChatEventMessageDeleted(
      {required this.message,
      required this.can_report_anti_spam_false_positive,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMessageDeleted',
      if (extra != null) '@extra': extra,
      'message': message,
      'can_report_anti_spam_false_positive': can_report_anti_spam_false_positive
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMessageDeleted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message = Message.fromMap(_map['message'])!;
    var can_report_anti_spam_false_positive =
        _map['can_report_anti_spam_false_positive']! as bool;
    return ChatEventMessageDeleted(
      extra: extra,
      clientId: clientId,
      message: message,
      can_report_anti_spam_false_positive: can_report_anti_spam_false_positive,
    );
  }
}

/// A message was pinned.
///
class ChatEventMessagePinned extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMessagePinned";

  /// Pinned message.
  late Message message;

  /// A message was pinned
  ChatEventMessagePinned({required this.message, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMessagePinned',
      if (extra != null) '@extra': extra,
      'message': message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMessagePinned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message = Message.fromMap(_map['message'])!;
    return ChatEventMessagePinned(
      extra: extra,
      clientId: clientId,
      message: message,
    );
  }
}

/// A message was unpinned.
///
class ChatEventMessageUnpinned extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMessageUnpinned";

  /// Unpinned message.
  late Message message;

  /// A message was unpinned
  ChatEventMessageUnpinned({required this.message, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMessageUnpinned',
      if (extra != null) '@extra': extra,
      'message': message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMessageUnpinned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message = Message.fromMap(_map['message'])!;
    return ChatEventMessageUnpinned(
      extra: extra,
      clientId: clientId,
      message: message,
    );
  }
}

/// A poll in a message was stopped.
///
class ChatEventPollStopped extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventPollStopped";

  /// The message with the poll.
  late Message message;

  /// A poll in a message was stopped
  ChatEventPollStopped({required this.message, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventPollStopped',
      if (extra != null) '@extra': extra,
      'message': message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventPollStopped? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message = Message.fromMap(_map['message'])!;
    return ChatEventPollStopped(
      extra: extra,
      clientId: clientId,
      message: message,
    );
  }
}

/// A new member joined the chat.
///
class ChatEventMemberJoined extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMemberJoined";

  /// A new member joined the chat
  ChatEventMemberJoined({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMemberJoined',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMemberJoined? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatEventMemberJoined(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A new member joined the chat via an invite link.
///
class ChatEventMemberJoinedByInviteLink extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMemberJoinedByInviteLink";

  /// Invite link used to join the chat.
  late ChatInviteLink invite_link;

  /// True, if the user has joined the chat using an invite link for a chat folder.
  late bool via_chat_folder_invite_link;

  /// A new member joined the chat via an invite link
  ChatEventMemberJoinedByInviteLink(
      {required this.invite_link,
      required this.via_chat_folder_invite_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMemberJoinedByInviteLink',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link,
      'via_chat_folder_invite_link': via_chat_folder_invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMemberJoinedByInviteLink? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = ChatInviteLink.fromMap(_map['invite_link'])!;
    var via_chat_folder_invite_link =
        _map['via_chat_folder_invite_link']! as bool;
    return ChatEventMemberJoinedByInviteLink(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
      via_chat_folder_invite_link: via_chat_folder_invite_link,
    );
  }
}

/// A new member was accepted to the chat by an administrator.
///
class ChatEventMemberJoinedByRequest extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMemberJoinedByRequest";

  /// User identifier of the chat administrator, approved user join request.
  late int approver_user_id;

  /// Invite link used to join the chat; may be null.
  ChatInviteLink? invite_link;

  /// A new member was accepted to the chat by an administrator
  ChatEventMemberJoinedByRequest(
      {required this.approver_user_id,
      this.invite_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMemberJoinedByRequest',
      if (extra != null) '@extra': extra,
      'approver_user_id': approver_user_id,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMemberJoinedByRequest? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var approver_user_id = _map['approver_user_id']! as int;
    var invite_link = ChatInviteLink.fromMap(_map['invite_link']);
    return ChatEventMemberJoinedByRequest(
      extra: extra,
      clientId: clientId,
      approver_user_id: approver_user_id,
      invite_link: invite_link,
    );
  }
}

/// A new chat member was invited.
///
class ChatEventMemberInvited extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMemberInvited";

  /// New member user identifier.
  late int user_id;

  /// New member status.
  late ChatMemberStatus status;

  /// A new chat member was invited
  ChatEventMemberInvited(
      {required this.user_id, required this.status, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMemberInvited',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'status': status
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMemberInvited? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var status = ChatMemberStatus.fromMap(_map['status'])!;
    return ChatEventMemberInvited(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      status: status,
    );
  }
}

/// A member left the chat.
///
class ChatEventMemberLeft extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMemberLeft";

  /// A member left the chat
  ChatEventMemberLeft({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'chatEventMemberLeft', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMemberLeft? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ChatEventMemberLeft(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed.
///
class ChatEventMemberPromoted extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMemberPromoted";

  /// Affected chat member user identifier.
  late int user_id;

  /// Previous status of the chat member.
  late ChatMemberStatus old_status;

  /// New status of the chat member.
  late ChatMemberStatus new_status;

  /// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
  ChatEventMemberPromoted(
      {required this.user_id,
      required this.old_status,
      required this.new_status,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMemberPromoted',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'old_status': old_status,
      'new_status': new_status
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMemberPromoted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var old_status = ChatMemberStatus.fromMap(_map['old_status'])!;
    var new_status = ChatMemberStatus.fromMap(_map['new_status'])!;
    return ChatEventMemberPromoted(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      old_status: old_status,
      new_status: new_status,
    );
  }
}

/// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed.
///
class ChatEventMemberRestricted extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMemberRestricted";

  /// Affected chat member identifier.
  late MessageSender member_id;

  /// Previous status of the chat member.
  late ChatMemberStatus old_status;

  /// New status of the chat member.
  late ChatMemberStatus new_status;

  /// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
  ChatEventMemberRestricted(
      {required this.member_id,
      required this.old_status,
      required this.new_status,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMemberRestricted',
      if (extra != null) '@extra': extra,
      'member_id': member_id,
      'old_status': old_status,
      'new_status': new_status
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMemberRestricted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var member_id = MessageSender.fromMap(_map['member_id'])!;
    var old_status = ChatMemberStatus.fromMap(_map['old_status'])!;
    var new_status = ChatMemberStatus.fromMap(_map['new_status'])!;
    return ChatEventMemberRestricted(
      extra: extra,
      clientId: clientId,
      member_id: member_id,
      old_status: old_status,
      new_status: new_status,
    );
  }
}

/// The chat available reactions were changed.
///
class ChatEventAvailableReactionsChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventAvailableReactionsChanged";

  /// Previous chat available reactions.
  late ChatAvailableReactions old_available_reactions;

  /// New chat available reactions.
  late ChatAvailableReactions new_available_reactions;

  /// The chat available reactions were changed
  ChatEventAvailableReactionsChanged(
      {required this.old_available_reactions,
      required this.new_available_reactions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventAvailableReactionsChanged',
      if (extra != null) '@extra': extra,
      'old_available_reactions': old_available_reactions,
      'new_available_reactions': new_available_reactions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventAvailableReactionsChanged? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_available_reactions =
        ChatAvailableReactions.fromMap(_map['old_available_reactions'])!;
    var new_available_reactions =
        ChatAvailableReactions.fromMap(_map['new_available_reactions'])!;
    return ChatEventAvailableReactionsChanged(
      extra: extra,
      clientId: clientId,
      old_available_reactions: old_available_reactions,
      new_available_reactions: new_available_reactions,
    );
  }
}

/// The chat description was changed.
///
class ChatEventDescriptionChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventDescriptionChanged";

  /// Previous chat description.
  late String old_description;

  /// New chat description.
  late String new_description;

  /// The chat description was changed
  ChatEventDescriptionChanged(
      {required this.old_description,
      required this.new_description,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventDescriptionChanged',
      if (extra != null) '@extra': extra,
      'old_description': old_description,
      'new_description': new_description
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventDescriptionChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_description = _map['old_description']! as String;
    var new_description = _map['new_description']! as String;
    return ChatEventDescriptionChanged(
      extra: extra,
      clientId: clientId,
      old_description: old_description,
      new_description: new_description,
    );
  }
}

/// The linked chat of a supergroup was changed.
///
class ChatEventLinkedChatChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventLinkedChatChanged";

  /// Previous supergroup linked chat identifier.
  late int old_linked_chat_id;

  /// New supergroup linked chat identifier.
  late int new_linked_chat_id;

  /// The linked chat of a supergroup was changed
  ChatEventLinkedChatChanged(
      {required this.old_linked_chat_id,
      required this.new_linked_chat_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventLinkedChatChanged',
      if (extra != null) '@extra': extra,
      'old_linked_chat_id': old_linked_chat_id,
      'new_linked_chat_id': new_linked_chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventLinkedChatChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_linked_chat_id = _map['old_linked_chat_id']! as int;
    var new_linked_chat_id = _map['new_linked_chat_id']! as int;
    return ChatEventLinkedChatChanged(
      extra: extra,
      clientId: clientId,
      old_linked_chat_id: old_linked_chat_id,
      new_linked_chat_id: new_linked_chat_id,
    );
  }
}

/// The supergroup location was changed.
///
class ChatEventLocationChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventLocationChanged";

  /// Previous location; may be null.
  ChatLocation? old_location;

  /// New location; may be null.
  ChatLocation? new_location;

  /// The supergroup location was changed
  ChatEventLocationChanged(
      {this.old_location, this.new_location, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventLocationChanged',
      if (extra != null) '@extra': extra,
      'old_location': old_location,
      'new_location': new_location
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventLocationChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_location = ChatLocation.fromMap(_map['old_location']);
    var new_location = ChatLocation.fromMap(_map['new_location']);
    return ChatEventLocationChanged(
      extra: extra,
      clientId: clientId,
      old_location: old_location,
      new_location: new_location,
    );
  }
}

/// The message auto-delete timer was changed.
///
class ChatEventMessageAutoDeleteTimeChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventMessageAutoDeleteTimeChanged";

  /// Previous value of message_auto_delete_time.
  late int old_message_auto_delete_time;

  /// New value of message_auto_delete_time.
  late int new_message_auto_delete_time;

  /// The message auto-delete timer was changed
  ChatEventMessageAutoDeleteTimeChanged(
      {required this.old_message_auto_delete_time,
      required this.new_message_auto_delete_time,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventMessageAutoDeleteTimeChanged',
      if (extra != null) '@extra': extra,
      'old_message_auto_delete_time': old_message_auto_delete_time,
      'new_message_auto_delete_time': new_message_auto_delete_time
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventMessageAutoDeleteTimeChanged? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_message_auto_delete_time =
        _map['old_message_auto_delete_time']! as int;
    var new_message_auto_delete_time =
        _map['new_message_auto_delete_time']! as int;
    return ChatEventMessageAutoDeleteTimeChanged(
      extra: extra,
      clientId: clientId,
      old_message_auto_delete_time: old_message_auto_delete_time,
      new_message_auto_delete_time: new_message_auto_delete_time,
    );
  }
}

/// The chat permissions was changed.
///
class ChatEventPermissionsChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventPermissionsChanged";

  /// Previous chat permissions.
  late ChatPermissions old_permissions;

  /// New chat permissions.
  late ChatPermissions new_permissions;

  /// The chat permissions was changed
  ChatEventPermissionsChanged(
      {required this.old_permissions,
      required this.new_permissions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventPermissionsChanged',
      if (extra != null) '@extra': extra,
      'old_permissions': old_permissions,
      'new_permissions': new_permissions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventPermissionsChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_permissions = ChatPermissions.fromMap(_map['old_permissions'])!;
    var new_permissions = ChatPermissions.fromMap(_map['new_permissions'])!;
    return ChatEventPermissionsChanged(
      extra: extra,
      clientId: clientId,
      old_permissions: old_permissions,
      new_permissions: new_permissions,
    );
  }
}

/// The chat photo was changed.
///
class ChatEventPhotoChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventPhotoChanged";

  /// Previous chat photo value; may be null.
  ChatPhoto? old_photo;

  /// New chat photo value; may be null.
  ChatPhoto? new_photo;

  /// The chat photo was changed
  ChatEventPhotoChanged(
      {this.old_photo, this.new_photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventPhotoChanged',
      if (extra != null) '@extra': extra,
      'old_photo': old_photo,
      'new_photo': new_photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventPhotoChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_photo = ChatPhoto.fromMap(_map['old_photo']);
    var new_photo = ChatPhoto.fromMap(_map['new_photo']);
    return ChatEventPhotoChanged(
      extra: extra,
      clientId: clientId,
      old_photo: old_photo,
      new_photo: new_photo,
    );
  }
}

/// The slow_mode_delay setting of a supergroup was changed.
///
class ChatEventSlowModeDelayChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventSlowModeDelayChanged";

  /// Previous value of slow_mode_delay, in seconds.
  late int old_slow_mode_delay;

  /// New value of slow_mode_delay, in seconds.
  late int new_slow_mode_delay;

  /// The slow_mode_delay setting of a supergroup was changed
  ChatEventSlowModeDelayChanged(
      {required this.old_slow_mode_delay,
      required this.new_slow_mode_delay,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventSlowModeDelayChanged',
      if (extra != null) '@extra': extra,
      'old_slow_mode_delay': old_slow_mode_delay,
      'new_slow_mode_delay': new_slow_mode_delay
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventSlowModeDelayChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_slow_mode_delay = _map['old_slow_mode_delay']! as int;
    var new_slow_mode_delay = _map['new_slow_mode_delay']! as int;
    return ChatEventSlowModeDelayChanged(
      extra: extra,
      clientId: clientId,
      old_slow_mode_delay: old_slow_mode_delay,
      new_slow_mode_delay: new_slow_mode_delay,
    );
  }
}

/// The supergroup sticker set was changed.
///
class ChatEventStickerSetChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventStickerSetChanged";

  /// Previous identifier of the chat sticker set; 0 if none.
  /// ; string representation of int, use `int.parse`
  late int64 old_sticker_set_id;

  /// New identifier of the chat sticker set; 0 if none.
  /// ; string representation of int, use `int.parse`
  late int64 new_sticker_set_id;

  /// The supergroup sticker set was changed
  ChatEventStickerSetChanged(
      {required this.old_sticker_set_id,
      required this.new_sticker_set_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventStickerSetChanged',
      if (extra != null) '@extra': extra,
      'old_sticker_set_id': old_sticker_set_id,
      'new_sticker_set_id': new_sticker_set_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventStickerSetChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_sticker_set_id = _map['old_sticker_set_id']! as int64;
    var new_sticker_set_id = _map['new_sticker_set_id']! as int64;
    return ChatEventStickerSetChanged(
      extra: extra,
      clientId: clientId,
      old_sticker_set_id: old_sticker_set_id,
      new_sticker_set_id: new_sticker_set_id,
    );
  }
}

/// The chat title was changed.
///
class ChatEventTitleChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventTitleChanged";

  /// Previous chat title.
  late String old_title;

  /// New chat title.
  late String new_title;

  /// The chat title was changed
  ChatEventTitleChanged(
      {required this.old_title,
      required this.new_title,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventTitleChanged',
      if (extra != null) '@extra': extra,
      'old_title': old_title,
      'new_title': new_title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventTitleChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_title = _map['old_title']! as String;
    var new_title = _map['new_title']! as String;
    return ChatEventTitleChanged(
      extra: extra,
      clientId: clientId,
      old_title: old_title,
      new_title: new_title,
    );
  }
}

/// The chat editable username was changed.
///
class ChatEventUsernameChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventUsernameChanged";

  /// Previous chat username.
  late String old_username;

  /// New chat username.
  late String new_username;

  /// The chat editable username was changed
  ChatEventUsernameChanged(
      {required this.old_username,
      required this.new_username,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventUsernameChanged',
      if (extra != null) '@extra': extra,
      'old_username': old_username,
      'new_username': new_username
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventUsernameChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_username = _map['old_username']! as String;
    var new_username = _map['new_username']! as String;
    return ChatEventUsernameChanged(
      extra: extra,
      clientId: clientId,
      old_username: old_username,
      new_username: new_username,
    );
  }
}

/// The chat active usernames were changed.
///
class ChatEventActiveUsernamesChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventActiveUsernamesChanged";

  /// Previous list of active usernames.
  late List<String> old_usernames;

  /// New list of active usernames.
  late List<String> new_usernames;

  /// The chat active usernames were changed
  ChatEventActiveUsernamesChanged(
      {required this.old_usernames,
      required this.new_usernames,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventActiveUsernamesChanged',
      if (extra != null) '@extra': extra,
      'old_usernames': old_usernames,
      'new_usernames': new_usernames
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventActiveUsernamesChanged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_usernames = List<String>.from(
      (_map["old_usernames"] ?? []).map(
        (e) => e as String,
      ),
    );
    var new_usernames = List<String>.from(
      (_map["new_usernames"] ?? []).map(
        (e) => e as String,
      ),
    );
    return ChatEventActiveUsernamesChanged(
      extra: extra,
      clientId: clientId,
      old_usernames: old_usernames,
      new_usernames: new_usernames,
    );
  }
}

/// The has_protected_content setting of a channel was toggled.
///
class ChatEventHasProtectedContentToggled extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventHasProtectedContentToggled";

  /// New value of has_protected_content.
  late bool has_protected_content;

  /// The has_protected_content setting of a channel was toggled
  ChatEventHasProtectedContentToggled(
      {required this.has_protected_content, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventHasProtectedContentToggled',
      if (extra != null) '@extra': extra,
      'has_protected_content': has_protected_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventHasProtectedContentToggled? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var has_protected_content = _map['has_protected_content']! as bool;
    return ChatEventHasProtectedContentToggled(
      extra: extra,
      clientId: clientId,
      has_protected_content: has_protected_content,
    );
  }
}

/// The can_invite_users permission of a supergroup chat was toggled.
///
class ChatEventInvitesToggled extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventInvitesToggled";

  /// New value of can_invite_users permission.
  late bool can_invite_users;

  /// The can_invite_users permission of a supergroup chat was toggled
  ChatEventInvitesToggled(
      {required this.can_invite_users, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventInvitesToggled',
      if (extra != null) '@extra': extra,
      'can_invite_users': can_invite_users
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventInvitesToggled? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var can_invite_users = _map['can_invite_users']! as bool;
    return ChatEventInvitesToggled(
      extra: extra,
      clientId: clientId,
      can_invite_users: can_invite_users,
    );
  }
}

/// The is_all_history_available setting of a supergroup was toggled.
///
class ChatEventIsAllHistoryAvailableToggled extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventIsAllHistoryAvailableToggled";

  /// New value of is_all_history_available.
  late bool is_all_history_available;

  /// The is_all_history_available setting of a supergroup was toggled
  ChatEventIsAllHistoryAvailableToggled(
      {required this.is_all_history_available, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventIsAllHistoryAvailableToggled',
      if (extra != null) '@extra': extra,
      'is_all_history_available': is_all_history_available
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventIsAllHistoryAvailableToggled? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_all_history_available = _map['is_all_history_available']! as bool;
    return ChatEventIsAllHistoryAvailableToggled(
      extra: extra,
      clientId: clientId,
      is_all_history_available: is_all_history_available,
    );
  }
}

/// The has_aggressive_anti_spam_enabled setting of a supergroup was toggled.
///
class ChatEventHasAggressiveAntiSpamEnabledToggled extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "chatEventHasAggressiveAntiSpamEnabledToggled";

  /// New value of has_aggressive_anti_spam_enabled.
  late bool has_aggressive_anti_spam_enabled;

  /// The has_aggressive_anti_spam_enabled setting of a supergroup was toggled
  ChatEventHasAggressiveAntiSpamEnabledToggled(
      {required this.has_aggressive_anti_spam_enabled,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventHasAggressiveAntiSpamEnabledToggled',
      if (extra != null) '@extra': extra,
      'has_aggressive_anti_spam_enabled': has_aggressive_anti_spam_enabled
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventHasAggressiveAntiSpamEnabledToggled? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var has_aggressive_anti_spam_enabled =
        _map['has_aggressive_anti_spam_enabled']! as bool;
    return ChatEventHasAggressiveAntiSpamEnabledToggled(
      extra: extra,
      clientId: clientId,
      has_aggressive_anti_spam_enabled: has_aggressive_anti_spam_enabled,
    );
  }
}

/// The sign_messages setting of a channel was toggled.
///
class ChatEventSignMessagesToggled extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventSignMessagesToggled";

  /// New value of sign_messages.
  late bool sign_messages;

  /// The sign_messages setting of a channel was toggled
  ChatEventSignMessagesToggled(
      {required this.sign_messages, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventSignMessagesToggled',
      if (extra != null) '@extra': extra,
      'sign_messages': sign_messages
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventSignMessagesToggled? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sign_messages = _map['sign_messages']! as bool;
    return ChatEventSignMessagesToggled(
      extra: extra,
      clientId: clientId,
      sign_messages: sign_messages,
    );
  }
}

/// A chat invite link was edited.
///
class ChatEventInviteLinkEdited extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventInviteLinkEdited";

  /// Previous information about the invite link.
  late ChatInviteLink old_invite_link;

  /// New information about the invite link.
  late ChatInviteLink new_invite_link;

  /// A chat invite link was edited
  ChatEventInviteLinkEdited(
      {required this.old_invite_link,
      required this.new_invite_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventInviteLinkEdited',
      if (extra != null) '@extra': extra,
      'old_invite_link': old_invite_link,
      'new_invite_link': new_invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventInviteLinkEdited? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_invite_link = ChatInviteLink.fromMap(_map['old_invite_link'])!;
    var new_invite_link = ChatInviteLink.fromMap(_map['new_invite_link'])!;
    return ChatEventInviteLinkEdited(
      extra: extra,
      clientId: clientId,
      old_invite_link: old_invite_link,
      new_invite_link: new_invite_link,
    );
  }
}

/// A chat invite link was revoked.
///
class ChatEventInviteLinkRevoked extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventInviteLinkRevoked";

  /// The invite link.
  late ChatInviteLink invite_link;

  /// A chat invite link was revoked
  ChatEventInviteLinkRevoked(
      {required this.invite_link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventInviteLinkRevoked',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventInviteLinkRevoked? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = ChatInviteLink.fromMap(_map['invite_link'])!;
    return ChatEventInviteLinkRevoked(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
    );
  }
}

/// A revoked chat invite link was deleted.
///
class ChatEventInviteLinkDeleted extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventInviteLinkDeleted";

  /// The invite link.
  late ChatInviteLink invite_link;

  /// A revoked chat invite link was deleted
  ChatEventInviteLinkDeleted(
      {required this.invite_link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventInviteLinkDeleted',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventInviteLinkDeleted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = ChatInviteLink.fromMap(_map['invite_link'])!;
    return ChatEventInviteLinkDeleted(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
    );
  }
}

/// A video chat was created.
///
class ChatEventVideoChatCreated extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventVideoChatCreated";

  /// Identifier of the video chat. The video chat can be received through the method getGroupCall.
  late int group_call_id;

  /// A video chat was created
  ChatEventVideoChatCreated(
      {required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventVideoChatCreated',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventVideoChatCreated? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return ChatEventVideoChatCreated(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// A video chat was ended.
///
class ChatEventVideoChatEnded extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventVideoChatEnded";

  /// Identifier of the video chat. The video chat can be received through the method getGroupCall.
  late int group_call_id;

  /// A video chat was ended
  ChatEventVideoChatEnded(
      {required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventVideoChatEnded',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventVideoChatEnded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return ChatEventVideoChatEnded(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// The mute_new_participants setting of a video chat was toggled.
///
class ChatEventVideoChatMuteNewParticipantsToggled extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "chatEventVideoChatMuteNewParticipantsToggled";

  /// New value of the mute_new_participants setting.
  late bool mute_new_participants;

  /// The mute_new_participants setting of a video chat was toggled
  ChatEventVideoChatMuteNewParticipantsToggled(
      {required this.mute_new_participants, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventVideoChatMuteNewParticipantsToggled',
      if (extra != null) '@extra': extra,
      'mute_new_participants': mute_new_participants
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventVideoChatMuteNewParticipantsToggled? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var mute_new_participants = _map['mute_new_participants']! as bool;
    return ChatEventVideoChatMuteNewParticipantsToggled(
      extra: extra,
      clientId: clientId,
      mute_new_participants: mute_new_participants,
    );
  }
}

/// A video chat participant was muted or unmuted.
///
class ChatEventVideoChatParticipantIsMutedToggled extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "chatEventVideoChatParticipantIsMutedToggled";

  /// Identifier of the affected group call participant.
  late MessageSender participant_id;

  /// New value of is_muted.
  late bool is_muted;

  /// A video chat participant was muted or unmuted
  ChatEventVideoChatParticipantIsMutedToggled(
      {required this.participant_id,
      required this.is_muted,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventVideoChatParticipantIsMutedToggled',
      if (extra != null) '@extra': extra,
      'participant_id': participant_id,
      'is_muted': is_muted
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventVideoChatParticipantIsMutedToggled? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var participant_id = MessageSender.fromMap(_map['participant_id'])!;
    var is_muted = _map['is_muted']! as bool;
    return ChatEventVideoChatParticipantIsMutedToggled(
      extra: extra,
      clientId: clientId,
      participant_id: participant_id,
      is_muted: is_muted,
    );
  }
}

/// A video chat participant volume level was changed.
///
class ChatEventVideoChatParticipantVolumeLevelChanged extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "chatEventVideoChatParticipantVolumeLevelChanged";

  /// Identifier of the affected group call participant.
  late MessageSender participant_id;

  /// New value of volume_level; 1-20000 in hundreds of percents.
  late int volume_level;

  /// A video chat participant volume level was changed
  ChatEventVideoChatParticipantVolumeLevelChanged(
      {required this.participant_id,
      required this.volume_level,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventVideoChatParticipantVolumeLevelChanged',
      if (extra != null) '@extra': extra,
      'participant_id': participant_id,
      'volume_level': volume_level
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventVideoChatParticipantVolumeLevelChanged? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var participant_id = MessageSender.fromMap(_map['participant_id'])!;
    var volume_level = _map['volume_level']! as int;
    return ChatEventVideoChatParticipantVolumeLevelChanged(
      extra: extra,
      clientId: clientId,
      participant_id: participant_id,
      volume_level: volume_level,
    );
  }
}

/// The is_forum setting of a channel was toggled.
///
class ChatEventIsForumToggled extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventIsForumToggled";

  /// New value of is_forum.
  late bool is_forum;

  /// The is_forum setting of a channel was toggled
  ChatEventIsForumToggled({required this.is_forum, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventIsForumToggled',
      if (extra != null) '@extra': extra,
      'is_forum': is_forum
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventIsForumToggled? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_forum = _map['is_forum']! as bool;
    return ChatEventIsForumToggled(
      extra: extra,
      clientId: clientId,
      is_forum: is_forum,
    );
  }
}

/// A new forum topic was created.
///
class ChatEventForumTopicCreated extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventForumTopicCreated";

  /// Information about the topic.
  late ForumTopicInfo topic_info;

  /// A new forum topic was created
  ChatEventForumTopicCreated(
      {required this.topic_info, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventForumTopicCreated',
      if (extra != null) '@extra': extra,
      'topic_info': topic_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventForumTopicCreated? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var topic_info = ForumTopicInfo.fromMap(_map['topic_info'])!;
    return ChatEventForumTopicCreated(
      extra: extra,
      clientId: clientId,
      topic_info: topic_info,
    );
  }
}

/// A forum topic was edited.
///
class ChatEventForumTopicEdited extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventForumTopicEdited";

  /// Old information about the topic.
  late ForumTopicInfo old_topic_info;

  /// New information about the topic.
  late ForumTopicInfo new_topic_info;

  /// A forum topic was edited
  ChatEventForumTopicEdited(
      {required this.old_topic_info,
      required this.new_topic_info,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventForumTopicEdited',
      if (extra != null) '@extra': extra,
      'old_topic_info': old_topic_info,
      'new_topic_info': new_topic_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventForumTopicEdited? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_topic_info = ForumTopicInfo.fromMap(_map['old_topic_info'])!;
    var new_topic_info = ForumTopicInfo.fromMap(_map['new_topic_info'])!;
    return ChatEventForumTopicEdited(
      extra: extra,
      clientId: clientId,
      old_topic_info: old_topic_info,
      new_topic_info: new_topic_info,
    );
  }
}

/// A forum topic was closed or reopened.
///
class ChatEventForumTopicToggleIsClosed extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventForumTopicToggleIsClosed";

  /// New information about the topic.
  late ForumTopicInfo topic_info;

  /// A forum topic was closed or reopened
  ChatEventForumTopicToggleIsClosed(
      {required this.topic_info, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventForumTopicToggleIsClosed',
      if (extra != null) '@extra': extra,
      'topic_info': topic_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventForumTopicToggleIsClosed? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var topic_info = ForumTopicInfo.fromMap(_map['topic_info'])!;
    return ChatEventForumTopicToggleIsClosed(
      extra: extra,
      clientId: clientId,
      topic_info: topic_info,
    );
  }
}

/// The General forum topic was hidden or unhidden.
///
class ChatEventForumTopicToggleIsHidden extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventForumTopicToggleIsHidden";

  /// New information about the topic.
  late ForumTopicInfo topic_info;

  /// The General forum topic was hidden or unhidden
  ChatEventForumTopicToggleIsHidden(
      {required this.topic_info, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventForumTopicToggleIsHidden',
      if (extra != null) '@extra': extra,
      'topic_info': topic_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventForumTopicToggleIsHidden? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var topic_info = ForumTopicInfo.fromMap(_map['topic_info'])!;
    return ChatEventForumTopicToggleIsHidden(
      extra: extra,
      clientId: clientId,
      topic_info: topic_info,
    );
  }
}

/// A forum topic was deleted.
///
class ChatEventForumTopicDeleted extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventForumTopicDeleted";

  /// Information about the topic.
  late ForumTopicInfo topic_info;

  /// A forum topic was deleted
  ChatEventForumTopicDeleted(
      {required this.topic_info, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventForumTopicDeleted',
      if (extra != null) '@extra': extra,
      'topic_info': topic_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventForumTopicDeleted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var topic_info = ForumTopicInfo.fromMap(_map['topic_info'])!;
    return ChatEventForumTopicDeleted(
      extra: extra,
      clientId: clientId,
      topic_info: topic_info,
    );
  }
}

/// A pinned forum topic was changed.
///
class ChatEventForumTopicPinned extends ChatEventAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventForumTopicPinned";

  /// Information about the old pinned topic; may be null.
  ForumTopicInfo? old_topic_info;

  /// Information about the new pinned topic; may be null.
  ForumTopicInfo? new_topic_info;

  /// A pinned forum topic was changed
  ChatEventForumTopicPinned(
      {this.old_topic_info, this.new_topic_info, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventForumTopicPinned',
      if (extra != null) '@extra': extra,
      'old_topic_info': old_topic_info,
      'new_topic_info': new_topic_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventForumTopicPinned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_topic_info = ForumTopicInfo.fromMap(_map['old_topic_info']);
    var new_topic_info = ForumTopicInfo.fromMap(_map['new_topic_info']);
    return ChatEventForumTopicPinned(
      extra: extra,
      clientId: clientId,
      old_topic_info: old_topic_info,
      new_topic_info: new_topic_info,
    );
  }
}

/// Represents a chat event.
///
class ChatEvent extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEvent";

  /// Chat event identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Point in time (Unix timestamp) when the event happened.
  late int date;

  /// Identifier of the user or chat who performed the action.
  late MessageSender member_id;

  /// The action.
  late ChatEventAction action;

  /// Represents a chat event
  ChatEvent(
      {required this.id,
      required this.date,
      required this.member_id,
      required this.action,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEvent',
      if (extra != null) '@extra': extra,
      'id': id,
      'date': date,
      'member_id': member_id,
      'action': action
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEvent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var date = _map['date']! as int;
    var member_id = MessageSender.fromMap(_map['member_id'])!;
    var action = ChatEventAction.fromMap(_map['action'])!;
    return ChatEvent(
      extra: extra,
      clientId: clientId,
      id: id,
      date: date,
      member_id: member_id,
      action: action,
    );
  }
}

/// Contains a list of chat events.
///
class ChatEvents extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEvents";

  /// List of events.
  late List<ChatEvent> events;

  /// Contains a list of chat events
  ChatEvents({required this.events, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEvents',
      if (extra != null) '@extra': extra,
      'events': events
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEvents? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var events = List<ChatEvent>.from(
      (_map["events"] ?? []).map(
        (e) => ChatEvent.fromMap(e),
      ),
    );
    return ChatEvents(
      extra: extra,
      clientId: clientId,
      events: events,
    );
  }
}

/// Represents a set of filters used to obtain a chat event log.
///
class ChatEventLogFilters extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatEventLogFilters";

  /// True, if message edits need to be returned.
  late bool message_edits;

  /// True, if message deletions need to be returned.
  late bool message_deletions;

  /// True, if pin/unpin events need to be returned.
  late bool message_pins;

  /// True, if members joining events need to be returned.
  late bool member_joins;

  /// True, if members leaving events need to be returned.
  late bool member_leaves;

  /// True, if invited member events need to be returned.
  late bool member_invites;

  /// True, if member promotion/demotion events need to be returned.
  late bool member_promotions;

  /// True, if member restricted/unrestricted/banned/unbanned events need to be returned.
  late bool member_restrictions;

  /// True, if changes in chat information need to be returned.
  late bool info_changes;

  /// True, if changes in chat settings need to be returned.
  late bool setting_changes;

  /// True, if changes to invite links need to be returned.
  late bool invite_link_changes;

  /// True, if video chat actions need to be returned.
  late bool video_chat_changes;

  /// True, if forum-related actions need to be returned.
  late bool forum_changes;

  /// Represents a set of filters used to obtain a chat event log
  ChatEventLogFilters(
      {required this.message_edits,
      required this.message_deletions,
      required this.message_pins,
      required this.member_joins,
      required this.member_leaves,
      required this.member_invites,
      required this.member_promotions,
      required this.member_restrictions,
      required this.info_changes,
      required this.setting_changes,
      required this.invite_link_changes,
      required this.video_chat_changes,
      required this.forum_changes,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatEventLogFilters',
      if (extra != null) '@extra': extra,
      'message_edits': message_edits,
      'message_deletions': message_deletions,
      'message_pins': message_pins,
      'member_joins': member_joins,
      'member_leaves': member_leaves,
      'member_invites': member_invites,
      'member_promotions': member_promotions,
      'member_restrictions': member_restrictions,
      'info_changes': info_changes,
      'setting_changes': setting_changes,
      'invite_link_changes': invite_link_changes,
      'video_chat_changes': video_chat_changes,
      'forum_changes': forum_changes
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatEventLogFilters? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_edits = _map['message_edits']! as bool;
    var message_deletions = _map['message_deletions']! as bool;
    var message_pins = _map['message_pins']! as bool;
    var member_joins = _map['member_joins']! as bool;
    var member_leaves = _map['member_leaves']! as bool;
    var member_invites = _map['member_invites']! as bool;
    var member_promotions = _map['member_promotions']! as bool;
    var member_restrictions = _map['member_restrictions']! as bool;
    var info_changes = _map['info_changes']! as bool;
    var setting_changes = _map['setting_changes']! as bool;
    var invite_link_changes = _map['invite_link_changes']! as bool;
    var video_chat_changes = _map['video_chat_changes']! as bool;
    var forum_changes = _map['forum_changes']! as bool;
    return ChatEventLogFilters(
      extra: extra,
      clientId: clientId,
      message_edits: message_edits,
      message_deletions: message_deletions,
      message_pins: message_pins,
      member_joins: member_joins,
      member_leaves: member_leaves,
      member_invites: member_invites,
      member_promotions: member_promotions,
      member_restrictions: member_restrictions,
      info_changes: info_changes,
      setting_changes: setting_changes,
      invite_link_changes: invite_link_changes,
      video_chat_changes: video_chat_changes,
      forum_changes: forum_changes,
    );
  }
}

/// An ordinary language pack string.
///
class LanguagePackStringValueOrdinary extends LanguagePackStringValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "languagePackStringValueOrdinary";

  /// String value.
  late String value;

  /// An ordinary language pack string
  LanguagePackStringValueOrdinary(
      {required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'languagePackStringValueOrdinary',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LanguagePackStringValueOrdinary? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as String;
    return LanguagePackStringValueOrdinary(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information.
///
class LanguagePackStringValuePluralized extends LanguagePackStringValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "languagePackStringValuePluralized";

  /// Value for zero objects.
  late String zero_value;

  /// Value for one object.
  late String one_value;

  /// Value for two objects.
  late String two_value;

  /// Value for few objects.
  late String few_value;

  /// Value for many objects.
  late String many_value;

  /// Default value.
  late String other_value;

  /// A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
  LanguagePackStringValuePluralized(
      {required this.zero_value,
      required this.one_value,
      required this.two_value,
      required this.few_value,
      required this.many_value,
      required this.other_value,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'languagePackStringValuePluralized',
      if (extra != null) '@extra': extra,
      'zero_value': zero_value,
      'one_value': one_value,
      'two_value': two_value,
      'few_value': few_value,
      'many_value': many_value,
      'other_value': other_value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LanguagePackStringValuePluralized? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var zero_value = _map['zero_value']! as String;
    var one_value = _map['one_value']! as String;
    var two_value = _map['two_value']! as String;
    var few_value = _map['few_value']! as String;
    var many_value = _map['many_value']! as String;
    var other_value = _map['other_value']! as String;
    return LanguagePackStringValuePluralized(
      extra: extra,
      clientId: clientId,
      zero_value: zero_value,
      one_value: one_value,
      two_value: two_value,
      few_value: few_value,
      many_value: many_value,
      other_value: other_value,
    );
  }
}

/// A deleted language pack string, the value must be taken from the built-in English language pack.
///
class LanguagePackStringValueDeleted extends LanguagePackStringValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "languagePackStringValueDeleted";

  /// A deleted language pack string, the value must be taken from the built-in English language pack
  LanguagePackStringValueDeleted({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'languagePackStringValueDeleted',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LanguagePackStringValueDeleted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return LanguagePackStringValueDeleted(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents one language pack string.
///
class LanguagePackString extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "languagePackString";

  /// String key.
  late String key;

  /// String value; pass null if the string needs to be taken from the built-in English language pack.
  LanguagePackStringValue? value;

  /// Represents one language pack string
  LanguagePackString(
      {required this.key, this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'languagePackString',
      if (extra != null) '@extra': extra,
      'key': key,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LanguagePackString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var key = _map['key']! as String;
    var value = LanguagePackStringValue.fromMap(_map['value']);
    return LanguagePackString(
      extra: extra,
      clientId: clientId,
      key: key,
      value: value,
    );
  }
}

/// Contains a list of language pack strings.
///
class LanguagePackStrings extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "languagePackStrings";

  /// A list of language pack strings.
  late List<LanguagePackString> strings;

  /// Contains a list of language pack strings
  LanguagePackStrings({required this.strings, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'languagePackStrings',
      if (extra != null) '@extra': extra,
      'strings': strings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LanguagePackStrings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var strings = List<LanguagePackString>.from(
      (_map["strings"] ?? []).map(
        (e) => LanguagePackString.fromMap(e),
      ),
    );
    return LanguagePackStrings(
      extra: extra,
      clientId: clientId,
      strings: strings,
    );
  }
}

/// Contains information about a language pack.
///
class LanguagePackInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "languagePackInfo";

  /// Unique language pack identifier.
  late String id;

  /// Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs.
  late String base_language_pack_id;

  /// Language name.
  late String name;

  /// Name of the language in that language.
  late String native_name;

  /// A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information.
  late String plural_code;

  /// True, if the language pack is official.
  late bool is_official;

  /// True, if the language pack strings are RTL.
  late bool is_rtl;

  /// True, if the language pack is a beta language pack.
  late bool is_beta;

  /// True, if the language pack is installed by the current user.
  late bool is_installed;

  /// Total number of non-deleted strings from the language pack.
  late int total_string_count;

  /// Total number of translated strings from the language pack.
  late int translated_string_count;

  /// Total number of non-deleted strings from the language pack available locally.
  late int local_string_count;

  /// Link to language translation interface; empty for custom local language packs.
  late String translation_url;

  /// Contains information about a language pack
  LanguagePackInfo(
      {required this.id,
      required this.base_language_pack_id,
      required this.name,
      required this.native_name,
      required this.plural_code,
      required this.is_official,
      required this.is_rtl,
      required this.is_beta,
      required this.is_installed,
      required this.total_string_count,
      required this.translated_string_count,
      required this.local_string_count,
      required this.translation_url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'languagePackInfo',
      if (extra != null) '@extra': extra,
      'id': id,
      'base_language_pack_id': base_language_pack_id,
      'name': name,
      'native_name': native_name,
      'plural_code': plural_code,
      'is_official': is_official,
      'is_rtl': is_rtl,
      'is_beta': is_beta,
      'is_installed': is_installed,
      'total_string_count': total_string_count,
      'translated_string_count': translated_string_count,
      'local_string_count': local_string_count,
      'translation_url': translation_url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LanguagePackInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as String;
    var base_language_pack_id = _map['base_language_pack_id']! as String;
    var name = _map['name']! as String;
    var native_name = _map['native_name']! as String;
    var plural_code = _map['plural_code']! as String;
    var is_official = _map['is_official']! as bool;
    var is_rtl = _map['is_rtl']! as bool;
    var is_beta = _map['is_beta']! as bool;
    var is_installed = _map['is_installed']! as bool;
    var total_string_count = _map['total_string_count']! as int;
    var translated_string_count = _map['translated_string_count']! as int;
    var local_string_count = _map['local_string_count']! as int;
    var translation_url = _map['translation_url']! as String;
    return LanguagePackInfo(
      extra: extra,
      clientId: clientId,
      id: id,
      base_language_pack_id: base_language_pack_id,
      name: name,
      native_name: native_name,
      plural_code: plural_code,
      is_official: is_official,
      is_rtl: is_rtl,
      is_beta: is_beta,
      is_installed: is_installed,
      total_string_count: total_string_count,
      translated_string_count: translated_string_count,
      local_string_count: local_string_count,
      translation_url: translation_url,
    );
  }
}

/// Contains information about the current localization target.
///
class LocalizationTargetInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "localizationTargetInfo";

  /// List of available language packs for this application.
  late List<LanguagePackInfo> language_packs;

  /// Contains information about the current localization target
  LocalizationTargetInfo(
      {required this.language_packs, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'localizationTargetInfo',
      if (extra != null) '@extra': extra,
      'language_packs': language_packs
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LocalizationTargetInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_packs = List<LanguagePackInfo>.from(
      (_map["language_packs"] ?? []).map(
        (e) => LanguagePackInfo.fromMap(e),
      ),
    );
    return LocalizationTargetInfo(
      extra: extra,
      clientId: clientId,
      language_packs: language_packs,
    );
  }
}

/// The maximum number of joined supergroups and channels.
///
class PremiumLimitTypeSupergroupCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeSupergroupCount";

  /// The maximum number of joined supergroups and channels
  PremiumLimitTypeSupergroupCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeSupergroupCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeSupergroupCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeSupergroupCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of pinned chats in the main chat list.
///
class PremiumLimitTypePinnedChatCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypePinnedChatCount";

  /// The maximum number of pinned chats in the main chat list
  PremiumLimitTypePinnedChatCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypePinnedChatCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypePinnedChatCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypePinnedChatCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of created public chats.
///
class PremiumLimitTypeCreatedPublicChatCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeCreatedPublicChatCount";

  /// The maximum number of created public chats
  PremiumLimitTypeCreatedPublicChatCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeCreatedPublicChatCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeCreatedPublicChatCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeCreatedPublicChatCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of saved animations.
///
class PremiumLimitTypeSavedAnimationCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeSavedAnimationCount";

  /// The maximum number of saved animations
  PremiumLimitTypeSavedAnimationCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeSavedAnimationCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeSavedAnimationCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeSavedAnimationCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of favorite stickers.
///
class PremiumLimitTypeFavoriteStickerCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeFavoriteStickerCount";

  /// The maximum number of favorite stickers
  PremiumLimitTypeFavoriteStickerCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeFavoriteStickerCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeFavoriteStickerCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeFavoriteStickerCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of chat folders.
///
class PremiumLimitTypeChatFolderCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeChatFolderCount";

  /// The maximum number of chat folders
  PremiumLimitTypeChatFolderCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeChatFolderCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeChatFolderCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeChatFolderCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of pinned and always included, or always excluded chats in a chat folder.
///
class PremiumLimitTypeChatFolderChosenChatCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeChatFolderChosenChatCount";

  /// The maximum number of pinned and always included, or always excluded chats in a chat folder
  PremiumLimitTypeChatFolderChosenChatCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeChatFolderChosenChatCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeChatFolderChosenChatCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeChatFolderChosenChatCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of pinned chats in the archive chat list.
///
class PremiumLimitTypePinnedArchivedChatCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypePinnedArchivedChatCount";

  /// The maximum number of pinned chats in the archive chat list
  PremiumLimitTypePinnedArchivedChatCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypePinnedArchivedChatCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypePinnedArchivedChatCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypePinnedArchivedChatCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum length of sent media caption.
///
class PremiumLimitTypeCaptionLength extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeCaptionLength";

  /// The maximum length of sent media caption
  PremiumLimitTypeCaptionLength({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeCaptionLength',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeCaptionLength? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeCaptionLength(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum length of the user's bio.
///
class PremiumLimitTypeBioLength extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeBioLength";

  /// The maximum length of the user's bio
  PremiumLimitTypeBioLength({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeBioLength',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeBioLength? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeBioLength(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of invite links for a chat folder.
///
class PremiumLimitTypeChatFolderInviteLinkCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeChatFolderInviteLinkCount";

  /// The maximum number of invite links for a chat folder
  PremiumLimitTypeChatFolderInviteLinkCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeChatFolderInviteLinkCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeChatFolderInviteLinkCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeChatFolderInviteLinkCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of added shareable chat folders.
///
class PremiumLimitTypeShareableChatFolderCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeShareableChatFolderCount";

  /// The maximum number of added shareable chat folders
  PremiumLimitTypeShareableChatFolderCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeShareableChatFolderCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeShareableChatFolderCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeShareableChatFolderCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of active stories.
///
class PremiumLimitTypeActiveStoryCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeActiveStoryCount";

  /// The maximum number of active stories
  PremiumLimitTypeActiveStoryCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeActiveStoryCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeActiveStoryCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeActiveStoryCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of stories sent per week.
///
class PremiumLimitTypeWeeklySentStoryCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeWeeklySentStoryCount";

  /// The maximum number of stories sent per week
  PremiumLimitTypeWeeklySentStoryCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeWeeklySentStoryCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeWeeklySentStoryCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeWeeklySentStoryCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of stories sent per month.
///
class PremiumLimitTypeMonthlySentStoryCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeMonthlySentStoryCount";

  /// The maximum number of stories sent per month
  PremiumLimitTypeMonthlySentStoryCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeMonthlySentStoryCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeMonthlySentStoryCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeMonthlySentStoryCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum length of captions of sent stories.
///
class PremiumLimitTypeStoryCaptionLength extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimitTypeStoryCaptionLength";

  /// The maximum length of captions of sent stories
  PremiumLimitTypeStoryCaptionLength({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeStoryCaptionLength',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeStoryCaptionLength? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeStoryCaptionLength(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The maximum number of suggested reaction areas on a story.
///
class PremiumLimitTypeStorySuggestedReactionAreaCount extends PremiumLimitType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "premiumLimitTypeStorySuggestedReactionAreaCount";

  /// The maximum number of suggested reaction areas on a story
  PremiumLimitTypeStorySuggestedReactionAreaCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimitTypeStorySuggestedReactionAreaCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimitTypeStorySuggestedReactionAreaCount? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumLimitTypeStorySuggestedReactionAreaCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Increased limits.
///
class PremiumFeatureIncreasedLimits extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureIncreasedLimits";

  /// Increased limits
  PremiumFeatureIncreasedLimits({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureIncreasedLimits',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureIncreasedLimits? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureIncreasedLimits(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Increased maximum upload file size.
///
class PremiumFeatureIncreasedUploadFileSize extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureIncreasedUploadFileSize";

  /// Increased maximum upload file size
  PremiumFeatureIncreasedUploadFileSize({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureIncreasedUploadFileSize',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureIncreasedUploadFileSize? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureIncreasedUploadFileSize(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Improved download speed.
///
class PremiumFeatureImprovedDownloadSpeed extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureImprovedDownloadSpeed";

  /// Improved download speed
  PremiumFeatureImprovedDownloadSpeed({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureImprovedDownloadSpeed',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureImprovedDownloadSpeed? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureImprovedDownloadSpeed(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The ability to convert voice notes to text.
///
class PremiumFeatureVoiceRecognition extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureVoiceRecognition";

  /// The ability to convert voice notes to text
  PremiumFeatureVoiceRecognition({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureVoiceRecognition',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureVoiceRecognition? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureVoiceRecognition(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Disabled ads.
///
class PremiumFeatureDisabledAds extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureDisabledAds";

  /// Disabled ads
  PremiumFeatureDisabledAds({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureDisabledAds',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureDisabledAds? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureDisabledAds(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Allowed to use more reactions.
///
class PremiumFeatureUniqueReactions extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureUniqueReactions";

  /// Allowed to use more reactions
  PremiumFeatureUniqueReactions({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureUniqueReactions',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureUniqueReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureUniqueReactions(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Allowed to use premium stickers with unique effects.
///
class PremiumFeatureUniqueStickers extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureUniqueStickers";

  /// Allowed to use premium stickers with unique effects
  PremiumFeatureUniqueStickers({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureUniqueStickers',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureUniqueStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureUniqueStickers(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Allowed to use custom emoji stickers in message texts and captions.
///
class PremiumFeatureCustomEmoji extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureCustomEmoji";

  /// Allowed to use custom emoji stickers in message texts and captions
  PremiumFeatureCustomEmoji({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureCustomEmoji',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureCustomEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureCustomEmoji(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Ability to change position of the main chat list, archive and mute all new chats from non-contacts, and completely disable notifications about the user's contacts joined Telegram.
///
class PremiumFeatureAdvancedChatManagement extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureAdvancedChatManagement";

  /// Ability to change position of the main chat list, archive and mute all new chats from non-contacts, and completely disable notifications about the user's contacts joined Telegram
  PremiumFeatureAdvancedChatManagement({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureAdvancedChatManagement',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureAdvancedChatManagement? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureAdvancedChatManagement(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A badge in the user's profile.
///
class PremiumFeatureProfileBadge extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureProfileBadge";

  /// A badge in the user's profile
  PremiumFeatureProfileBadge({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureProfileBadge',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureProfileBadge? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureProfileBadge(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// An emoji status shown along with the user's name.
///
class PremiumFeatureEmojiStatus extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureEmojiStatus";

  /// An emoji status shown along with the user's name
  PremiumFeatureEmojiStatus({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureEmojiStatus',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureEmojiStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureEmojiStatus(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Profile photo animation on message and chat screens.
///
class PremiumFeatureAnimatedProfilePhoto extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureAnimatedProfilePhoto";

  /// Profile photo animation on message and chat screens
  PremiumFeatureAnimatedProfilePhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureAnimatedProfilePhoto',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureAnimatedProfilePhoto? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureAnimatedProfilePhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The ability to set a custom emoji as a forum topic icon.
///
class PremiumFeatureForumTopicIcon extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureForumTopicIcon";

  /// The ability to set a custom emoji as a forum topic icon
  PremiumFeatureForumTopicIcon({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureForumTopicIcon',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureForumTopicIcon? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureForumTopicIcon(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Allowed to set a premium application icons.
///
class PremiumFeatureAppIcons extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureAppIcons";

  /// Allowed to set a premium application icons
  PremiumFeatureAppIcons({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureAppIcons',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureAppIcons? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureAppIcons(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Allowed to translate chat messages real-time.
///
class PremiumFeatureRealTimeChatTranslation extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureRealTimeChatTranslation";

  /// Allowed to translate chat messages real-time
  PremiumFeatureRealTimeChatTranslation({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureRealTimeChatTranslation',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureRealTimeChatTranslation? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureRealTimeChatTranslation(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Allowed to use many additional features for stories.
///
class PremiumFeatureUpgradedStories extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureUpgradedStories";

  /// Allowed to use many additional features for stories
  PremiumFeatureUpgradedStories({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureUpgradedStories',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureUpgradedStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureUpgradedStories(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The ability to boost chats.
///
class PremiumFeatureChatBoost extends PremiumFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatureChatBoost";

  /// The ability to boost chats
  PremiumFeatureChatBoost({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatureChatBoost',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatureChatBoost? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumFeatureChatBoost(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// User stories are displayed before stories of non-premium contacts and channels.
///
class PremiumStoryFeaturePriorityOrder extends PremiumStoryFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumStoryFeaturePriorityOrder";

  /// User stories are displayed before stories of non-premium contacts and channels
  PremiumStoryFeaturePriorityOrder({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumStoryFeaturePriorityOrder',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumStoryFeaturePriorityOrder? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumStoryFeaturePriorityOrder(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The ability to hide the fact that the user viewed other's stories.
///
class PremiumStoryFeatureStealthMode extends PremiumStoryFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumStoryFeatureStealthMode";

  /// The ability to hide the fact that the user viewed other's stories
  PremiumStoryFeatureStealthMode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumStoryFeatureStealthMode',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumStoryFeatureStealthMode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumStoryFeatureStealthMode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The ability to check who opened the current user's stories after they expire.
///
class PremiumStoryFeaturePermanentViewsHistory extends PremiumStoryFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumStoryFeaturePermanentViewsHistory";

  /// The ability to check who opened the current user's stories after they expire
  PremiumStoryFeaturePermanentViewsHistory({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumStoryFeaturePermanentViewsHistory',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumStoryFeaturePermanentViewsHistory? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumStoryFeaturePermanentViewsHistory(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The ability to set custom expiration duration for stories.
///
class PremiumStoryFeatureCustomExpirationDuration extends PremiumStoryFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "premiumStoryFeatureCustomExpirationDuration";

  /// The ability to set custom expiration duration for stories
  PremiumStoryFeatureCustomExpirationDuration({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumStoryFeatureCustomExpirationDuration',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumStoryFeatureCustomExpirationDuration? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumStoryFeatureCustomExpirationDuration(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The ability to save other's unprotected stories.
///
class PremiumStoryFeatureSaveStories extends PremiumStoryFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumStoryFeatureSaveStories";

  /// The ability to save other's unprotected stories
  PremiumStoryFeatureSaveStories({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumStoryFeatureSaveStories',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumStoryFeatureSaveStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumStoryFeatureSaveStories(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The ability to use links and formatting in story caption.
///
class PremiumStoryFeatureLinksAndFormatting extends PremiumStoryFeature {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumStoryFeatureLinksAndFormatting";

  /// The ability to use links and formatting in story caption
  PremiumStoryFeatureLinksAndFormatting({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumStoryFeatureLinksAndFormatting',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumStoryFeatureLinksAndFormatting? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumStoryFeatureLinksAndFormatting(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains information about a limit, increased for Premium users.
///
class PremiumLimit extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumLimit";

  /// The type of the limit.
  late PremiumLimitType type;

  /// Default value of the limit.
  late int default_value;

  /// Value of the limit for Premium users.
  late int premium_value;

  /// Contains information about a limit, increased for Premium users
  PremiumLimit(
      {required this.type,
      required this.default_value,
      required this.premium_value,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumLimit',
      if (extra != null) '@extra': extra,
      'type': type,
      'default_value': default_value,
      'premium_value': premium_value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumLimit? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = PremiumLimitType.fromMap(_map['type'])!;
    var default_value = _map['default_value']! as int;
    var premium_value = _map['premium_value']! as int;
    return PremiumLimit(
      extra: extra,
      clientId: clientId,
      type: type,
      default_value: default_value,
      premium_value: premium_value,
    );
  }
}

/// Contains information about features, available to Premium users.
///
class PremiumFeatures extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeatures";

  /// The list of available features.
  late List<PremiumFeature> features;

  /// The list of limits, increased for Premium users.
  late List<PremiumLimit> limits;

  /// An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available.
  InternalLinkType? payment_link;

  /// Contains information about features, available to Premium users
  PremiumFeatures(
      {required this.features,
      required this.limits,
      this.payment_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeatures',
      if (extra != null) '@extra': extra,
      'features': features,
      'limits': limits,
      'payment_link': payment_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeatures? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var features = List<PremiumFeature>.from(
      (_map["features"] ?? []).map(
        (e) => PremiumFeature.fromMap(e),
      ),
    );
    var limits = List<PremiumLimit>.from(
      (_map["limits"] ?? []).map(
        (e) => PremiumLimit.fromMap(e),
      ),
    );
    var payment_link = InternalLinkType.fromMap(_map['payment_link']);
    return PremiumFeatures(
      extra: extra,
      clientId: clientId,
      features: features,
      limits: limits,
      payment_link: payment_link,
    );
  }
}

/// A limit was exceeded.
///
class PremiumSourceLimitExceeded extends PremiumSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumSourceLimitExceeded";

  /// Type of the exceeded limit.
  late PremiumLimitType limit_type;

  /// A limit was exceeded
  PremiumSourceLimitExceeded(
      {required this.limit_type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumSourceLimitExceeded',
      if (extra != null) '@extra': extra,
      'limit_type': limit_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumSourceLimitExceeded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var limit_type = PremiumLimitType.fromMap(_map['limit_type'])!;
    return PremiumSourceLimitExceeded(
      extra: extra,
      clientId: clientId,
      limit_type: limit_type,
    );
  }
}

/// A user tried to use a Premium feature.
///
class PremiumSourceFeature extends PremiumSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumSourceFeature";

  /// The used feature.
  late PremiumFeature feature;

  /// A user tried to use a Premium feature
  PremiumSourceFeature({required this.feature, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumSourceFeature',
      if (extra != null) '@extra': extra,
      'feature': feature
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumSourceFeature? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var feature = PremiumFeature.fromMap(_map['feature'])!;
    return PremiumSourceFeature(
      extra: extra,
      clientId: clientId,
      feature: feature,
    );
  }
}

/// A user tried to use a Premium story feature.
///
class PremiumSourceStoryFeature extends PremiumSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumSourceStoryFeature";

  /// The used feature.
  late PremiumStoryFeature feature;

  /// A user tried to use a Premium story feature
  PremiumSourceStoryFeature({required this.feature, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumSourceStoryFeature',
      if (extra != null) '@extra': extra,
      'feature': feature
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumSourceStoryFeature? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var feature = PremiumStoryFeature.fromMap(_map['feature'])!;
    return PremiumSourceStoryFeature(
      extra: extra,
      clientId: clientId,
      feature: feature,
    );
  }
}

/// A user opened an internal link of the type internalLinkTypePremiumFeatures.
///
class PremiumSourceLink extends PremiumSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumSourceLink";

  /// The referrer from the link.
  late String referrer;

  /// A user opened an internal link of the type internalLinkTypePremiumFeatures
  PremiumSourceLink({required this.referrer, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumSourceLink',
      if (extra != null) '@extra': extra,
      'referrer': referrer
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumSourceLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var referrer = _map['referrer']! as String;
    return PremiumSourceLink(
      extra: extra,
      clientId: clientId,
      referrer: referrer,
    );
  }
}

/// A user opened the Premium features screen from settings.
///
class PremiumSourceSettings extends PremiumSource {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumSourceSettings";

  /// A user opened the Premium features screen from settings
  PremiumSourceSettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumSourceSettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumSourceSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PremiumSourceSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Describes a promotion animation for a Premium feature.
///
class PremiumFeaturePromotionAnimation extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumFeaturePromotionAnimation";

  /// Premium feature.
  late PremiumFeature feature;

  /// Promotion animation for the feature.
  late Animation animation;

  /// Describes a promotion animation for a Premium feature
  PremiumFeaturePromotionAnimation(
      {required this.feature,
      required this.animation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumFeaturePromotionAnimation',
      if (extra != null) '@extra': extra,
      'feature': feature,
      'animation': animation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumFeaturePromotionAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var feature = PremiumFeature.fromMap(_map['feature'])!;
    var animation = Animation.fromMap(_map['animation'])!;
    return PremiumFeaturePromotionAnimation(
      extra: extra,
      clientId: clientId,
      feature: feature,
      animation: animation,
    );
  }
}

/// Contains state of Telegram Premium subscription and promotion videos for Premium features.
///
class PremiumState extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "premiumState";

  /// Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription.
  late FormattedText state;

  /// The list of available options for buying Telegram Premium.
  late List<PremiumStatePaymentOption> payment_options;

  /// The list of available promotion animations for Premium features.
  late List<PremiumFeaturePromotionAnimation> animations;

  /// Contains state of Telegram Premium subscription and promotion videos for Premium features
  PremiumState(
      {required this.state,
      required this.payment_options,
      required this.animations,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'premiumState',
      if (extra != null) '@extra': extra,
      'state': state,
      'payment_options': payment_options,
      'animations': animations
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PremiumState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var state = FormattedText.fromMap(_map['state'])!;
    var payment_options = List<PremiumStatePaymentOption>.from(
      (_map["payment_options"] ?? []).map(
        (e) => PremiumStatePaymentOption.fromMap(e),
      ),
    );
    var animations = List<PremiumFeaturePromotionAnimation>.from(
      (_map["animations"] ?? []).map(
        (e) => PremiumFeaturePromotionAnimation.fromMap(e),
      ),
    );
    return PremiumState(
      extra: extra,
      clientId: clientId,
      state: state,
      payment_options: payment_options,
      animations: animations,
    );
  }
}

/// The user subscribed to Telegram Premium.
///
class StorePaymentPurposePremiumSubscription extends StorePaymentPurpose {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storePaymentPurposePremiumSubscription";

  /// Pass true if this is a restore of a Telegram Premium purchase; only for App Store.
  late bool is_restore;

  /// Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store.
  late bool is_upgrade;

  /// The user subscribed to Telegram Premium
  StorePaymentPurposePremiumSubscription(
      {required this.is_restore,
      required this.is_upgrade,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storePaymentPurposePremiumSubscription',
      if (extra != null) '@extra': extra,
      'is_restore': is_restore,
      'is_upgrade': is_upgrade
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StorePaymentPurposePremiumSubscription? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_restore = _map['is_restore']! as bool;
    var is_upgrade = _map['is_upgrade']! as bool;
    return StorePaymentPurposePremiumSubscription(
      extra: extra,
      clientId: clientId,
      is_restore: is_restore,
      is_upgrade: is_upgrade,
    );
  }
}

/// The user gifted Telegram Premium to another user.
///
class StorePaymentPurposeGiftedPremium extends StorePaymentPurpose {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storePaymentPurposeGiftedPremium";

  /// Identifier of the user for which Premium was gifted.
  late int user_id;

  /// ISO 4217 currency code of the payment currency.
  late String currency;

  /// Paid amount, in the smallest units of the currency.
  late int amount;

  /// The user gifted Telegram Premium to another user
  StorePaymentPurposeGiftedPremium(
      {required this.user_id,
      required this.currency,
      required this.amount,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storePaymentPurposeGiftedPremium',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'currency': currency,
      'amount': amount
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StorePaymentPurposeGiftedPremium? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var currency = _map['currency']! as String;
    var amount = _map['amount']! as int;
    return StorePaymentPurposeGiftedPremium(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      currency: currency,
      amount: amount,
    );
  }
}

/// A token for Firebase Cloud Messaging.
///
class DeviceTokenFirebaseCloudMessaging extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenFirebaseCloudMessaging";

  /// Device registration token; may be empty to deregister a device.
  late String token;

  /// True, if push notifications must be additionally encrypted.
  late bool encrypt;

  /// A token for Firebase Cloud Messaging
  DeviceTokenFirebaseCloudMessaging(
      {required this.token, required this.encrypt, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenFirebaseCloudMessaging',
      if (extra != null) '@extra': extra,
      'token': token,
      'encrypt': encrypt
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenFirebaseCloudMessaging? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    var encrypt = _map['encrypt']! as bool;
    return DeviceTokenFirebaseCloudMessaging(
      extra: extra,
      clientId: clientId,
      token: token,
      encrypt: encrypt,
    );
  }
}

/// A token for Apple Push Notification service.
///
class DeviceTokenApplePush extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenApplePush";

  /// Device token; may be empty to deregister a device.
  late String device_token;

  /// True, if App Sandbox is enabled.
  late bool is_app_sandbox;

  /// A token for Apple Push Notification service
  DeviceTokenApplePush(
      {required this.device_token,
      required this.is_app_sandbox,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenApplePush',
      if (extra != null) '@extra': extra,
      'device_token': device_token,
      'is_app_sandbox': is_app_sandbox
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenApplePush? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var device_token = _map['device_token']! as String;
    var is_app_sandbox = _map['is_app_sandbox']! as bool;
    return DeviceTokenApplePush(
      extra: extra,
      clientId: clientId,
      device_token: device_token,
      is_app_sandbox: is_app_sandbox,
    );
  }
}

/// A token for Apple Push Notification service VoIP notifications.
///
class DeviceTokenApplePushVoIP extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenApplePushVoIP";

  /// Device token; may be empty to deregister a device.
  late String device_token;

  /// True, if App Sandbox is enabled.
  late bool is_app_sandbox;

  /// True, if push notifications must be additionally encrypted.
  late bool encrypt;

  /// A token for Apple Push Notification service VoIP notifications
  DeviceTokenApplePushVoIP(
      {required this.device_token,
      required this.is_app_sandbox,
      required this.encrypt,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenApplePushVoIP',
      if (extra != null) '@extra': extra,
      'device_token': device_token,
      'is_app_sandbox': is_app_sandbox,
      'encrypt': encrypt
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenApplePushVoIP? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var device_token = _map['device_token']! as String;
    var is_app_sandbox = _map['is_app_sandbox']! as bool;
    var encrypt = _map['encrypt']! as bool;
    return DeviceTokenApplePushVoIP(
      extra: extra,
      clientId: clientId,
      device_token: device_token,
      is_app_sandbox: is_app_sandbox,
      encrypt: encrypt,
    );
  }
}

/// A token for Windows Push Notification Services.
///
class DeviceTokenWindowsPush extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenWindowsPush";

  /// The access token that will be used to send notifications; may be empty to deregister a device.
  late String access_token;

  /// A token for Windows Push Notification Services
  DeviceTokenWindowsPush(
      {required this.access_token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenWindowsPush',
      if (extra != null) '@extra': extra,
      'access_token': access_token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenWindowsPush? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var access_token = _map['access_token']! as String;
    return DeviceTokenWindowsPush(
      extra: extra,
      clientId: clientId,
      access_token: access_token,
    );
  }
}

/// A token for Microsoft Push Notification Service.
///
class DeviceTokenMicrosoftPush extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenMicrosoftPush";

  /// Push notification channel URI; may be empty to deregister a device.
  late String channel_uri;

  /// A token for Microsoft Push Notification Service
  DeviceTokenMicrosoftPush(
      {required this.channel_uri, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenMicrosoftPush',
      if (extra != null) '@extra': extra,
      'channel_uri': channel_uri
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenMicrosoftPush? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var channel_uri = _map['channel_uri']! as String;
    return DeviceTokenMicrosoftPush(
      extra: extra,
      clientId: clientId,
      channel_uri: channel_uri,
    );
  }
}

/// A token for Microsoft Push Notification Service VoIP channel.
///
class DeviceTokenMicrosoftPushVoIP extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenMicrosoftPushVoIP";

  /// Push notification channel URI; may be empty to deregister a device.
  late String channel_uri;

  /// A token for Microsoft Push Notification Service VoIP channel
  DeviceTokenMicrosoftPushVoIP(
      {required this.channel_uri, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenMicrosoftPushVoIP',
      if (extra != null) '@extra': extra,
      'channel_uri': channel_uri
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenMicrosoftPushVoIP? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var channel_uri = _map['channel_uri']! as String;
    return DeviceTokenMicrosoftPushVoIP(
      extra: extra,
      clientId: clientId,
      channel_uri: channel_uri,
    );
  }
}

/// A token for web Push API.
///
class DeviceTokenWebPush extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenWebPush";

  /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device.
  late String endpoint;

  /// Base64url-encoded P-256 elliptic curve Diffie-Hellman public key.
  late String p256dh_base64url;

  /// Base64url-encoded authentication secret.
  late String auth_base64url;

  /// A token for web Push API
  DeviceTokenWebPush(
      {required this.endpoint,
      required this.p256dh_base64url,
      required this.auth_base64url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenWebPush',
      if (extra != null) '@extra': extra,
      'endpoint': endpoint,
      'p256dh_base64url': p256dh_base64url,
      'auth_base64url': auth_base64url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenWebPush? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var endpoint = _map['endpoint']! as String;
    var p256dh_base64url = _map['p256dh_base64url']! as String;
    var auth_base64url = _map['auth_base64url']! as String;
    return DeviceTokenWebPush(
      extra: extra,
      clientId: clientId,
      endpoint: endpoint,
      p256dh_base64url: p256dh_base64url,
      auth_base64url: auth_base64url,
    );
  }
}

/// A token for Simple Push API for Firefox OS.
///
class DeviceTokenSimplePush extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenSimplePush";

  /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device.
  late String endpoint;

  /// A token for Simple Push API for Firefox OS
  DeviceTokenSimplePush({required this.endpoint, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenSimplePush',
      if (extra != null) '@extra': extra,
      'endpoint': endpoint
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenSimplePush? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var endpoint = _map['endpoint']! as String;
    return DeviceTokenSimplePush(
      extra: extra,
      clientId: clientId,
      endpoint: endpoint,
    );
  }
}

/// A token for Ubuntu Push Client service.
///
class DeviceTokenUbuntuPush extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenUbuntuPush";

  /// Token; may be empty to deregister a device.
  late String token;

  /// A token for Ubuntu Push Client service
  DeviceTokenUbuntuPush({required this.token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenUbuntuPush',
      if (extra != null) '@extra': extra,
      'token': token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenUbuntuPush? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    return DeviceTokenUbuntuPush(
      extra: extra,
      clientId: clientId,
      token: token,
    );
  }
}

/// A token for BlackBerry Push Service.
///
class DeviceTokenBlackBerryPush extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenBlackBerryPush";

  /// Token; may be empty to deregister a device.
  late String token;

  /// A token for BlackBerry Push Service
  DeviceTokenBlackBerryPush({required this.token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenBlackBerryPush',
      if (extra != null) '@extra': extra,
      'token': token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenBlackBerryPush? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    return DeviceTokenBlackBerryPush(
      extra: extra,
      clientId: clientId,
      token: token,
    );
  }
}

/// A token for Tizen Push Service.
///
class DeviceTokenTizenPush extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenTizenPush";

  /// Push service registration identifier; may be empty to deregister a device.
  late String reg_id;

  /// A token for Tizen Push Service
  DeviceTokenTizenPush({required this.reg_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenTizenPush',
      if (extra != null) '@extra': extra,
      'reg_id': reg_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenTizenPush? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reg_id = _map['reg_id']! as String;
    return DeviceTokenTizenPush(
      extra: extra,
      clientId: clientId,
      reg_id: reg_id,
    );
  }
}

/// A token for HUAWEI Push Service.
///
class DeviceTokenHuaweiPush extends DeviceToken {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deviceTokenHuaweiPush";

  /// Device registration token; may be empty to deregister a device.
  late String token;

  /// True, if push notifications must be additionally encrypted.
  late bool encrypt;

  /// A token for HUAWEI Push Service
  DeviceTokenHuaweiPush(
      {required this.token, required this.encrypt, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deviceTokenHuaweiPush',
      if (extra != null) '@extra': extra,
      'token': token,
      'encrypt': encrypt
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeviceTokenHuaweiPush? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    var encrypt = _map['encrypt']! as bool;
    return DeviceTokenHuaweiPush(
      extra: extra,
      clientId: clientId,
      token: token,
      encrypt: encrypt,
    );
  }
}

/// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification.
///
class PushReceiverId extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushReceiverId";

  /// The globally unique identifier of push notification subscription.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
  PushReceiverId({required this.id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushReceiverId',
      if (extra != null) '@extra': extra,
      'id': id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushReceiverId? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    return PushReceiverId(
      extra: extra,
      clientId: clientId,
      id: id,
    );
  }
}

/// Describes a solid fill of a background.
///
class BackgroundFillSolid extends BackgroundFill {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "backgroundFillSolid";

  /// A color of the background in the RGB24 format.
  late int color;

  /// Describes a solid fill of a background
  BackgroundFillSolid({required this.color, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'backgroundFillSolid',
      if (extra != null) '@extra': extra,
      'color': color
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BackgroundFillSolid? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var color = _map['color']! as int;
    return BackgroundFillSolid(
      extra: extra,
      clientId: clientId,
      color: color,
    );
  }
}

/// Describes a gradient fill of a background.
///
class BackgroundFillGradient extends BackgroundFill {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "backgroundFillGradient";

  /// A top color of the background in the RGB24 format.
  late int top_color;

  /// A bottom color of the background in the RGB24 format.
  late int bottom_color;

  /// Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45.
  late int rotation_angle;

  /// Describes a gradient fill of a background
  BackgroundFillGradient(
      {required this.top_color,
      required this.bottom_color,
      required this.rotation_angle,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'backgroundFillGradient',
      if (extra != null) '@extra': extra,
      'top_color': top_color,
      'bottom_color': bottom_color,
      'rotation_angle': rotation_angle
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BackgroundFillGradient? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var top_color = _map['top_color']! as int;
    var bottom_color = _map['bottom_color']! as int;
    var rotation_angle = _map['rotation_angle']! as int;
    return BackgroundFillGradient(
      extra: extra,
      clientId: clientId,
      top_color: top_color,
      bottom_color: bottom_color,
      rotation_angle: rotation_angle,
    );
  }
}

/// Describes a freeform gradient fill of a background.
///
class BackgroundFillFreeformGradient extends BackgroundFill {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "backgroundFillFreeformGradient";

  /// A list of 3 or 4 colors of the freeform gradients in the RGB24 format.
  late List<int> colors;

  /// Describes a freeform gradient fill of a background
  BackgroundFillFreeformGradient(
      {required this.colors, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'backgroundFillFreeformGradient',
      if (extra != null) '@extra': extra,
      'colors': colors
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BackgroundFillFreeformGradient? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var colors = List<int>.from(
      (_map["colors"] ?? []).map(
        (e) => e as int,
      ),
    );
    return BackgroundFillFreeformGradient(
      extra: extra,
      clientId: clientId,
      colors: colors,
    );
  }
}

/// A wallpaper in JPEG format.
///
class BackgroundTypeWallpaper extends BackgroundType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "backgroundTypeWallpaper";

  /// True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12.
  late bool is_blurred;

  /// True, if the background needs to be slightly moved when device is tilted.
  late bool is_moving;

  /// A wallpaper in JPEG format
  BackgroundTypeWallpaper(
      {required this.is_blurred,
      required this.is_moving,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'backgroundTypeWallpaper',
      if (extra != null) '@extra': extra,
      'is_blurred': is_blurred,
      'is_moving': is_moving
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BackgroundTypeWallpaper? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_blurred = _map['is_blurred']! as bool;
    var is_moving = _map['is_moving']! as bool;
    return BackgroundTypeWallpaper(
      extra: extra,
      clientId: clientId,
      is_blurred: is_blurred,
      is_moving: is_moving,
    );
  }
}

/// A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user.
///
class BackgroundTypePattern extends BackgroundType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "backgroundTypePattern";

  /// Fill of the background.
  late BackgroundFill fill;

  /// Intensity of the pattern when it is shown above the filled background; 0-100..
  late int intensity;

  /// True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only.
  late bool is_inverted;

  /// True, if the background needs to be slightly moved when device is tilted.
  late bool is_moving;

  /// A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
  BackgroundTypePattern(
      {required this.fill,
      required this.intensity,
      required this.is_inverted,
      required this.is_moving,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'backgroundTypePattern',
      if (extra != null) '@extra': extra,
      'fill': fill,
      'intensity': intensity,
      'is_inverted': is_inverted,
      'is_moving': is_moving
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BackgroundTypePattern? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var fill = BackgroundFill.fromMap(_map['fill'])!;
    var intensity = _map['intensity']! as int;
    var is_inverted = _map['is_inverted']! as bool;
    var is_moving = _map['is_moving']! as bool;
    return BackgroundTypePattern(
      extra: extra,
      clientId: clientId,
      fill: fill,
      intensity: intensity,
      is_inverted: is_inverted,
      is_moving: is_moving,
    );
  }
}

/// A filled background.
///
class BackgroundTypeFill extends BackgroundType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "backgroundTypeFill";

  /// The background fill.
  late BackgroundFill fill;

  /// A filled background
  BackgroundTypeFill({required this.fill, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'backgroundTypeFill',
      if (extra != null) '@extra': extra,
      'fill': fill
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BackgroundTypeFill? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var fill = BackgroundFill.fromMap(_map['fill'])!;
    return BackgroundTypeFill(
      extra: extra,
      clientId: clientId,
      fill: fill,
    );
  }
}

/// A background from a local file.
///
class InputBackgroundLocal extends InputBackground {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputBackgroundLocal";

  /// Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns.
  late InputFile background;

  /// A background from a local file
  InputBackgroundLocal({required this.background, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputBackgroundLocal',
      if (extra != null) '@extra': extra,
      'background': background
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputBackgroundLocal? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var background = InputFile.fromMap(_map['background'])!;
    return InputBackgroundLocal(
      extra: extra,
      clientId: clientId,
      background: background,
    );
  }
}

/// A background from the server.
///
class InputBackgroundRemote extends InputBackground {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputBackgroundRemote";

  /// The background identifier.
  /// ; string representation of int, use `int.parse`
  late int64 background_id;

  /// A background from the server
  InputBackgroundRemote(
      {required this.background_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputBackgroundRemote',
      if (extra != null) '@extra': extra,
      'background_id': background_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputBackgroundRemote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var background_id = _map['background_id']! as int64;
    return InputBackgroundRemote(
      extra: extra,
      clientId: clientId,
      background_id: background_id,
    );
  }
}

/// A background previously set in the chat; for chat backgrounds only.
///
class InputBackgroundPrevious extends InputBackground {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputBackgroundPrevious";

  /// Identifier of the message with the background.
  late int message_id;

  /// A background previously set in the chat; for chat backgrounds only
  InputBackgroundPrevious(
      {required this.message_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputBackgroundPrevious',
      if (extra != null) '@extra': extra,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputBackgroundPrevious? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_id = _map['message_id']! as int;
    return InputBackgroundPrevious(
      extra: extra,
      clientId: clientId,
      message_id: message_id,
    );
  }
}

/// Describes theme settings.
///
class ThemeSettings extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "themeSettings";

  /// Theme accent color in ARGB format.
  late int accent_color;

  /// The background to be used in chats; may be null.
  Background? background;

  /// The fill to be used as a background for outgoing messages.
  late BackgroundFill outgoing_message_fill;

  /// If true, the freeform gradient fill needs to be animated on every sent message.
  late bool animate_outgoing_message_fill;

  /// Accent color of outgoing messages in ARGB format.
  late int outgoing_message_accent_color;

  /// Describes theme settings
  ThemeSettings(
      {required this.accent_color,
      this.background,
      required this.outgoing_message_fill,
      required this.animate_outgoing_message_fill,
      required this.outgoing_message_accent_color,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'themeSettings',
      if (extra != null) '@extra': extra,
      'accent_color': accent_color,
      'background': background,
      'outgoing_message_fill': outgoing_message_fill,
      'animate_outgoing_message_fill': animate_outgoing_message_fill,
      'outgoing_message_accent_color': outgoing_message_accent_color
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ThemeSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var accent_color = _map['accent_color']! as int;
    var background = Background.fromMap(_map['background']);
    var outgoing_message_fill =
        BackgroundFill.fromMap(_map['outgoing_message_fill'])!;
    var animate_outgoing_message_fill =
        _map['animate_outgoing_message_fill']! as bool;
    var outgoing_message_accent_color =
        _map['outgoing_message_accent_color']! as int;
    return ThemeSettings(
      extra: extra,
      clientId: clientId,
      accent_color: accent_color,
      background: background,
      outgoing_message_fill: outgoing_message_fill,
      animate_outgoing_message_fill: animate_outgoing_message_fill,
      outgoing_message_accent_color: outgoing_message_accent_color,
    );
  }
}

/// Describes a chat theme.
///
class ChatTheme extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatTheme";

  /// Theme name.
  late String name;

  /// Theme settings for a light chat theme.
  late ThemeSettings light_settings;

  /// Theme settings for a dark chat theme.
  late ThemeSettings dark_settings;

  /// Describes a chat theme
  ChatTheme(
      {required this.name,
      required this.light_settings,
      required this.dark_settings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatTheme',
      if (extra != null) '@extra': extra,
      'name': name,
      'light_settings': light_settings,
      'dark_settings': dark_settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatTheme? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var light_settings = ThemeSettings.fromMap(_map['light_settings'])!;
    var dark_settings = ThemeSettings.fromMap(_map['dark_settings'])!;
    return ChatTheme(
      extra: extra,
      clientId: clientId,
      name: name,
      light_settings: light_settings,
      dark_settings: dark_settings,
    );
  }
}

/// Contains a list of hashtags.
///
class Hashtags extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "hashtags";

  /// A list of hashtags.
  late List<String> hashtags;

  /// Contains a list of hashtags
  Hashtags({required this.hashtags, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'hashtags',
      if (extra != null) '@extra': extra,
      'hashtags': hashtags
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Hashtags? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var hashtags = List<String>.from(
      (_map["hashtags"] ?? []).map(
        (e) => e as String,
      ),
    );
    return Hashtags(
      extra: extra,
      clientId: clientId,
      hashtags: hashtags,
    );
  }
}

/// A story can be sent.
///
class CanSendStoryResultOk extends CanSendStoryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canSendStoryResultOk";

  /// A story can be sent
  CanSendStoryResultOk({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canSendStoryResultOk',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanSendStoryResultOk? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanSendStoryResultOk(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user must subscribe to Telegram Premium to be able to post stories.
///
class CanSendStoryResultPremiumNeeded extends CanSendStoryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canSendStoryResultPremiumNeeded";

  /// The user must subscribe to Telegram Premium to be able to post stories
  CanSendStoryResultPremiumNeeded({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canSendStoryResultPremiumNeeded',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanSendStoryResultPremiumNeeded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanSendStoryResultPremiumNeeded(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The channel chat must be boosted first by Telegram Premium subscribers to post more stories. Call getChatBoostStatus to get current boost status of the chat.
///
class CanSendStoryResultBoostNeeded extends CanSendStoryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canSendStoryResultBoostNeeded";

  /// The channel chat must be boosted first by Telegram Premium subscribers to post more stories. Call getChatBoostStatus to get current boost status of the chat
  CanSendStoryResultBoostNeeded({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canSendStoryResultBoostNeeded',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanSendStoryResultBoostNeeded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanSendStoryResultBoostNeeded(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The limit for the number of active stories exceeded. The user can buy Telegram Premium, delete an active story, or wait for the oldest story to expire.
///
class CanSendStoryResultActiveStoryLimitExceeded extends CanSendStoryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "canSendStoryResultActiveStoryLimitExceeded";

  /// The limit for the number of active stories exceeded. The user can buy Telegram Premium, delete an active story, or wait for the oldest story to expire
  CanSendStoryResultActiveStoryLimitExceeded({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canSendStoryResultActiveStoryLimitExceeded',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanSendStoryResultActiveStoryLimitExceeded? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanSendStoryResultActiveStoryLimitExceeded(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The weekly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time.
///
class CanSendStoryResultWeeklyLimitExceeded extends CanSendStoryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canSendStoryResultWeeklyLimitExceeded";

  /// Time left before the user can send the next story.
  late int retry_after;

  /// The weekly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
  CanSendStoryResultWeeklyLimitExceeded(
      {required this.retry_after, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canSendStoryResultWeeklyLimitExceeded',
      if (extra != null) '@extra': extra,
      'retry_after': retry_after
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanSendStoryResultWeeklyLimitExceeded? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var retry_after = _map['retry_after']! as int;
    return CanSendStoryResultWeeklyLimitExceeded(
      extra: extra,
      clientId: clientId,
      retry_after: retry_after,
    );
  }
}

/// The monthly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time.
///
class CanSendStoryResultMonthlyLimitExceeded extends CanSendStoryResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canSendStoryResultMonthlyLimitExceeded";

  /// Time left before the user can send the next story.
  late int retry_after;

  /// The monthly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
  CanSendStoryResultMonthlyLimitExceeded(
      {required this.retry_after, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canSendStoryResultMonthlyLimitExceeded',
      if (extra != null) '@extra': extra,
      'retry_after': retry_after
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanSendStoryResultMonthlyLimitExceeded? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var retry_after = _map['retry_after']! as int;
    return CanSendStoryResultMonthlyLimitExceeded(
      extra: extra,
      clientId: clientId,
      retry_after: retry_after,
    );
  }
}

/// The chat can be boosted.
///
class CanBoostChatResultOk extends CanBoostChatResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canBoostChatResultOk";

  /// Identifier of the currently boosted chat from which boost will be removed; 0 if none.
  late int currently_boosted_chat_id;

  /// The chat can be boosted
  CanBoostChatResultOk(
      {required this.currently_boosted_chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canBoostChatResultOk',
      if (extra != null) '@extra': extra,
      'currently_boosted_chat_id': currently_boosted_chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanBoostChatResultOk? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var currently_boosted_chat_id = _map['currently_boosted_chat_id']! as int;
    return CanBoostChatResultOk(
      extra: extra,
      clientId: clientId,
      currently_boosted_chat_id: currently_boosted_chat_id,
    );
  }
}

/// The chat can't be boosted.
///
class CanBoostChatResultInvalidChat extends CanBoostChatResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canBoostChatResultInvalidChat";

  /// The chat can't be boosted
  CanBoostChatResultInvalidChat({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canBoostChatResultInvalidChat',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanBoostChatResultInvalidChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanBoostChatResultInvalidChat(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat is already boosted by the user.
///
class CanBoostChatResultAlreadyBoosted extends CanBoostChatResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canBoostChatResultAlreadyBoosted";

  /// The chat is already boosted by the user
  CanBoostChatResultAlreadyBoosted({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canBoostChatResultAlreadyBoosted',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanBoostChatResultAlreadyBoosted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanBoostChatResultAlreadyBoosted(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user must subscribe to Telegram Premium to be able to boost chats.
///
class CanBoostChatResultPremiumNeeded extends CanBoostChatResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canBoostChatResultPremiumNeeded";

  /// The user must subscribe to Telegram Premium to be able to boost chats
  CanBoostChatResultPremiumNeeded({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canBoostChatResultPremiumNeeded',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanBoostChatResultPremiumNeeded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanBoostChatResultPremiumNeeded(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user must have Telegram Premium subscription instead of a gifted Telegram Premium.
///
class CanBoostChatResultPremiumSubscriptionNeeded extends CanBoostChatResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "canBoostChatResultPremiumSubscriptionNeeded";

  /// The user must have Telegram Premium subscription instead of a gifted Telegram Premium
  CanBoostChatResultPremiumSubscriptionNeeded({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canBoostChatResultPremiumSubscriptionNeeded',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanBoostChatResultPremiumSubscriptionNeeded? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanBoostChatResultPremiumSubscriptionNeeded(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user must wait the specified time before the boost can be moved to another chat.
///
class CanBoostChatResultWaitNeeded extends CanBoostChatResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canBoostChatResultWaitNeeded";

  /// Time left before the user can boost another chat.
  late int retry_after;

  /// The user must wait the specified time before the boost can be moved to another chat
  CanBoostChatResultWaitNeeded(
      {required this.retry_after, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canBoostChatResultWaitNeeded',
      if (extra != null) '@extra': extra,
      'retry_after': retry_after
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanBoostChatResultWaitNeeded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var retry_after = _map['retry_after']! as int;
    return CanBoostChatResultWaitNeeded(
      extra: extra,
      clientId: clientId,
      retry_after: retry_after,
    );
  }
}

/// The session can be used.
///
class CanTransferOwnershipResultOk extends CanTransferOwnershipResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canTransferOwnershipResultOk";

  /// The session can be used
  CanTransferOwnershipResultOk({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canTransferOwnershipResultOk',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanTransferOwnershipResultOk? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanTransferOwnershipResultOk(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The 2-step verification needs to be enabled first.
///
class CanTransferOwnershipResultPasswordNeeded
    extends CanTransferOwnershipResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canTransferOwnershipResultPasswordNeeded";

  /// The 2-step verification needs to be enabled first
  CanTransferOwnershipResultPasswordNeeded({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canTransferOwnershipResultPasswordNeeded',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanTransferOwnershipResultPasswordNeeded? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanTransferOwnershipResultPasswordNeeded(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The 2-step verification was enabled recently, user needs to wait.
///
class CanTransferOwnershipResultPasswordTooFresh
    extends CanTransferOwnershipResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "canTransferOwnershipResultPasswordTooFresh";

  /// Time left before the session can be used to transfer ownership of a chat, in seconds.
  late int retry_after;

  /// The 2-step verification was enabled recently, user needs to wait
  CanTransferOwnershipResultPasswordTooFresh(
      {required this.retry_after, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canTransferOwnershipResultPasswordTooFresh',
      if (extra != null) '@extra': extra,
      'retry_after': retry_after
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanTransferOwnershipResultPasswordTooFresh? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var retry_after = _map['retry_after']! as int;
    return CanTransferOwnershipResultPasswordTooFresh(
      extra: extra,
      clientId: clientId,
      retry_after: retry_after,
    );
  }
}

/// The session was created recently, user needs to wait.
///
class CanTransferOwnershipResultSessionTooFresh
    extends CanTransferOwnershipResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canTransferOwnershipResultSessionTooFresh";

  /// Time left before the session can be used to transfer ownership of a chat, in seconds.
  late int retry_after;

  /// The session was created recently, user needs to wait
  CanTransferOwnershipResultSessionTooFresh(
      {required this.retry_after, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canTransferOwnershipResultSessionTooFresh',
      if (extra != null) '@extra': extra,
      'retry_after': retry_after
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanTransferOwnershipResultSessionTooFresh? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var retry_after = _map['retry_after']! as int;
    return CanTransferOwnershipResultSessionTooFresh(
      extra: extra,
      clientId: clientId,
      retry_after: retry_after,
    );
  }
}

/// The username can be set.
///
class CheckChatUsernameResultOk extends CheckChatUsernameResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkChatUsernameResultOk";

  /// The username can be set
  CheckChatUsernameResultOk({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChatUsernameResultOk',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChatUsernameResultOk? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CheckChatUsernameResultOk(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The username is invalid.
///
class CheckChatUsernameResultUsernameInvalid extends CheckChatUsernameResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkChatUsernameResultUsernameInvalid";

  /// The username is invalid
  CheckChatUsernameResultUsernameInvalid({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChatUsernameResultUsernameInvalid',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChatUsernameResultUsernameInvalid? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CheckChatUsernameResultUsernameInvalid(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The username is occupied.
///
class CheckChatUsernameResultUsernameOccupied extends CheckChatUsernameResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkChatUsernameResultUsernameOccupied";

  /// The username is occupied
  CheckChatUsernameResultUsernameOccupied({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChatUsernameResultUsernameOccupied',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChatUsernameResultUsernameOccupied? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CheckChatUsernameResultUsernameOccupied(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The username can be purchased at fragment.com.
///
class CheckChatUsernameResultUsernamePurchasable
    extends CheckChatUsernameResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "checkChatUsernameResultUsernamePurchasable";

  /// The username can be purchased at fragment.com
  CheckChatUsernameResultUsernamePurchasable({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChatUsernameResultUsernamePurchasable',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChatUsernameResultUsernamePurchasable? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CheckChatUsernameResultUsernamePurchasable(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user has too many chats with username, one of them must be made private first.
///
class CheckChatUsernameResultPublicChatsTooMany
    extends CheckChatUsernameResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkChatUsernameResultPublicChatsTooMany";

  /// The user has too many chats with username, one of them must be made private first
  CheckChatUsernameResultPublicChatsTooMany({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChatUsernameResultPublicChatsTooMany',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChatUsernameResultPublicChatsTooMany? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CheckChatUsernameResultPublicChatsTooMany(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The user can't be a member of a public supergroup.
///
class CheckChatUsernameResultPublicGroupsUnavailable
    extends CheckChatUsernameResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "checkChatUsernameResultPublicGroupsUnavailable";

  /// The user can't be a member of a public supergroup
  CheckChatUsernameResultPublicGroupsUnavailable({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChatUsernameResultPublicGroupsUnavailable',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChatUsernameResultPublicGroupsUnavailable? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CheckChatUsernameResultPublicGroupsUnavailable(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The name can be set.
///
class CheckStickerSetNameResultOk extends CheckStickerSetNameResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkStickerSetNameResultOk";

  /// The name can be set
  CheckStickerSetNameResultOk({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkStickerSetNameResultOk',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckStickerSetNameResultOk? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CheckStickerSetNameResultOk(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The name is invalid.
///
class CheckStickerSetNameResultNameInvalid extends CheckStickerSetNameResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkStickerSetNameResultNameInvalid";

  /// The name is invalid
  CheckStickerSetNameResultNameInvalid({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkStickerSetNameResultNameInvalid',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckStickerSetNameResultNameInvalid? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CheckStickerSetNameResultNameInvalid(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The name is occupied.
///
class CheckStickerSetNameResultNameOccupied extends CheckStickerSetNameResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkStickerSetNameResultNameOccupied";

  /// The name is occupied
  CheckStickerSetNameResultNameOccupied({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkStickerSetNameResultNameOccupied',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckStickerSetNameResultNameOccupied? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CheckStickerSetNameResultNameOccupied(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The password was reset.
///
class ResetPasswordResultOk extends ResetPasswordResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resetPasswordResultOk";

  /// The password was reset
  ResetPasswordResultOk({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resetPasswordResultOk',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResetPasswordResultOk? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResetPasswordResultOk(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The password reset request is pending.
///
class ResetPasswordResultPending extends ResetPasswordResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resetPasswordResultPending";

  /// Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword.
  late int pending_reset_date;

  /// The password reset request is pending
  ResetPasswordResultPending(
      {required this.pending_reset_date, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resetPasswordResultPending',
      if (extra != null) '@extra': extra,
      'pending_reset_date': pending_reset_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResetPasswordResultPending? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var pending_reset_date = _map['pending_reset_date']! as int;
    return ResetPasswordResultPending(
      extra: extra,
      clientId: clientId,
      pending_reset_date: pending_reset_date,
    );
  }
}

/// The password reset request was declined.
///
class ResetPasswordResultDeclined extends ResetPasswordResult {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resetPasswordResultDeclined";

  /// Point in time (Unix timestamp) when the password reset can be retried.
  late int retry_date;

  /// The password reset request was declined
  ResetPasswordResultDeclined(
      {required this.retry_date, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resetPasswordResultDeclined',
      if (extra != null) '@extra': extra,
      'retry_date': retry_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResetPasswordResultDeclined? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var retry_date = _map['retry_date']! as int;
    return ResetPasswordResultDeclined(
      extra: extra,
      clientId: clientId,
      retry_date: retry_date,
    );
  }
}

/// The messages was exported from a private chat.
///
class MessageFileTypePrivate extends MessageFileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageFileTypePrivate";

  /// Name of the other party; may be empty if unrecognized.
  late String name;

  /// The messages was exported from a private chat
  MessageFileTypePrivate({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageFileTypePrivate',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageFileTypePrivate? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return MessageFileTypePrivate(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// The messages was exported from a group chat.
///
class MessageFileTypeGroup extends MessageFileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageFileTypeGroup";

  /// Title of the group chat; may be empty if unrecognized.
  late String title;

  /// The messages was exported from a group chat
  MessageFileTypeGroup({required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageFileTypeGroup',
      if (extra != null) '@extra': extra,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageFileTypeGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    return MessageFileTypeGroup(
      extra: extra,
      clientId: clientId,
      title: title,
    );
  }
}

/// The messages was exported from a chat of unknown type.
///
class MessageFileTypeUnknown extends MessageFileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageFileTypeUnknown";

  /// The messages was exported from a chat of unknown type
  MessageFileTypeUnknown({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageFileTypeUnknown',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageFileTypeUnknown? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return MessageFileTypeUnknown(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A general message with hidden content.
///
class PushMessageContentHidden extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentHidden";

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A general message with hidden content
  PushMessageContentHidden(
      {required this.is_pinned, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentHidden',
      if (extra != null) '@extra': extra,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentHidden? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentHidden(
      extra: extra,
      clientId: clientId,
      is_pinned: is_pinned,
    );
  }
}

/// An animation message (GIF-style)..
///
class PushMessageContentAnimation extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentAnimation";

  /// Message content; may be null.
  Animation? animation;

  /// Animation caption.
  late String caption;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// An animation message (GIF-style).
  PushMessageContentAnimation(
      {this.animation,
      required this.caption,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentAnimation',
      if (extra != null) '@extra': extra,
      'animation': animation,
      'caption': caption,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animation = Animation.fromMap(_map['animation']);
    var caption = _map['caption']! as String;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentAnimation(
      extra: extra,
      clientId: clientId,
      animation: animation,
      caption: caption,
      is_pinned: is_pinned,
    );
  }
}

/// An audio message.
///
class PushMessageContentAudio extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentAudio";

  /// Message content; may be null.
  Audio? audio;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// An audio message
  PushMessageContentAudio(
      {this.audio, required this.is_pinned, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentAudio',
      if (extra != null) '@extra': extra,
      'audio': audio,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentAudio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var audio = Audio.fromMap(_map['audio']);
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentAudio(
      extra: extra,
      clientId: clientId,
      audio: audio,
      is_pinned: is_pinned,
    );
  }
}

/// A message with a user contact.
///
class PushMessageContentContact extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentContact";

  /// Contact's name.
  late String name;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A message with a user contact
  PushMessageContentContact(
      {required this.name, required this.is_pinned, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentContact',
      if (extra != null) '@extra': extra,
      'name': name,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentContact? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentContact(
      extra: extra,
      clientId: clientId,
      name: name,
      is_pinned: is_pinned,
    );
  }
}

/// A contact has registered with Telegram.
///
class PushMessageContentContactRegistered extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentContactRegistered";

  /// A contact has registered with Telegram
  PushMessageContentContactRegistered({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentContactRegistered',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentContactRegistered? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PushMessageContentContactRegistered(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A document message (a general file).
///
class PushMessageContentDocument extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentDocument";

  /// Message content; may be null.
  Document? document;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A document message (a general file)
  PushMessageContentDocument(
      {this.document, required this.is_pinned, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentDocument',
      if (extra != null) '@extra': extra,
      'document': document,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var document = Document.fromMap(_map['document']);
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentDocument(
      extra: extra,
      clientId: clientId,
      document: document,
      is_pinned: is_pinned,
    );
  }
}

/// A message with a game.
///
class PushMessageContentGame extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentGame";

  /// Game title, empty for pinned game message.
  late String title;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A message with a game
  PushMessageContentGame(
      {required this.title,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentGame',
      if (extra != null) '@extra': extra,
      'title': title,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentGame? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentGame(
      extra: extra,
      clientId: clientId,
      title: title,
      is_pinned: is_pinned,
    );
  }
}

/// A new high score was achieved in a game.
///
class PushMessageContentGameScore extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentGameScore";

  /// Game title, empty for pinned message.
  late String title;

  /// New score, 0 for pinned message.
  late int score;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A new high score was achieved in a game
  PushMessageContentGameScore(
      {required this.title,
      required this.score,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentGameScore',
      if (extra != null) '@extra': extra,
      'title': title,
      'score': score,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentGameScore? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var score = _map['score']! as int;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentGameScore(
      extra: extra,
      clientId: clientId,
      title: title,
      score: score,
      is_pinned: is_pinned,
    );
  }
}

/// A message with an invoice from a bot.
///
class PushMessageContentInvoice extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentInvoice";

  /// Product price.
  late String price;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A message with an invoice from a bot
  PushMessageContentInvoice(
      {required this.price,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentInvoice',
      if (extra != null) '@extra': extra,
      'price': price,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentInvoice? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var price = _map['price']! as String;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentInvoice(
      extra: extra,
      clientId: clientId,
      price: price,
      is_pinned: is_pinned,
    );
  }
}

/// A message with a location.
///
class PushMessageContentLocation extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentLocation";

  /// True, if the location is live.
  late bool is_live;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A message with a location
  PushMessageContentLocation(
      {required this.is_live,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentLocation',
      if (extra != null) '@extra': extra,
      'is_live': is_live,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_live = _map['is_live']! as bool;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentLocation(
      extra: extra,
      clientId: clientId,
      is_live: is_live,
      is_pinned: is_pinned,
    );
  }
}

/// A photo message.
///
class PushMessageContentPhoto extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentPhoto";

  /// Message content; may be null.
  Photo? photo;

  /// Photo caption.
  late String caption;

  /// True, if the photo is secret.
  late bool is_secret;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A photo message
  PushMessageContentPhoto(
      {this.photo,
      required this.caption,
      required this.is_secret,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentPhoto',
      if (extra != null) '@extra': extra,
      'photo': photo,
      'caption': caption,
      'is_secret': is_secret,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = Photo.fromMap(_map['photo']);
    var caption = _map['caption']! as String;
    var is_secret = _map['is_secret']! as bool;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentPhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
      caption: caption,
      is_secret: is_secret,
      is_pinned: is_pinned,
    );
  }
}

/// A message with a poll.
///
class PushMessageContentPoll extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentPoll";

  /// Poll question.
  late String question;

  /// True, if the poll is regular and not in quiz mode.
  late bool is_regular;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A message with a poll
  PushMessageContentPoll(
      {required this.question,
      required this.is_regular,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentPoll',
      if (extra != null) '@extra': extra,
      'question': question,
      'is_regular': is_regular,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentPoll? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var question = _map['question']! as String;
    var is_regular = _map['is_regular']! as bool;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentPoll(
      extra: extra,
      clientId: clientId,
      question: question,
      is_regular: is_regular,
      is_pinned: is_pinned,
    );
  }
}

/// A screenshot of a message in the chat has been taken.
///
class PushMessageContentScreenshotTaken extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentScreenshotTaken";

  /// A screenshot of a message in the chat has been taken
  PushMessageContentScreenshotTaken({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentScreenshotTaken',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentScreenshotTaken? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PushMessageContentScreenshotTaken(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A message with a sticker.
///
class PushMessageContentSticker extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentSticker";

  /// Message content; may be null.
  Sticker? sticker;

  /// Emoji corresponding to the sticker; may be empty.
  late String emoji;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A message with a sticker
  PushMessageContentSticker(
      {this.sticker,
      required this.emoji,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentSticker',
      if (extra != null) '@extra': extra,
      'sticker': sticker,
      'emoji': emoji,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = Sticker.fromMap(_map['sticker']);
    var emoji = _map['emoji']! as String;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentSticker(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
      emoji: emoji,
      is_pinned: is_pinned,
    );
  }
}

/// A message with a story.
///
class PushMessageContentStory extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentStory";

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A message with a story
  PushMessageContentStory({required this.is_pinned, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentStory',
      if (extra != null) '@extra': extra,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentStory(
      extra: extra,
      clientId: clientId,
      is_pinned: is_pinned,
    );
  }
}

/// A text message.
///
class PushMessageContentText extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentText";

  /// Message text.
  late String text;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A text message
  PushMessageContentText(
      {required this.text, required this.is_pinned, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentText',
      if (extra != null) '@extra': extra,
      'text': text,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentText(
      extra: extra,
      clientId: clientId,
      text: text,
      is_pinned: is_pinned,
    );
  }
}

/// A video message.
///
class PushMessageContentVideo extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentVideo";

  /// Message content; may be null.
  Video? video;

  /// Video caption.
  late String caption;

  /// True, if the video is secret.
  late bool is_secret;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A video message
  PushMessageContentVideo(
      {this.video,
      required this.caption,
      required this.is_secret,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentVideo',
      if (extra != null) '@extra': extra,
      'video': video,
      'caption': caption,
      'is_secret': is_secret,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video = Video.fromMap(_map['video']);
    var caption = _map['caption']! as String;
    var is_secret = _map['is_secret']! as bool;
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentVideo(
      extra: extra,
      clientId: clientId,
      video: video,
      caption: caption,
      is_secret: is_secret,
      is_pinned: is_pinned,
    );
  }
}

/// A video note message.
///
class PushMessageContentVideoNote extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentVideoNote";

  /// Message content; may be null.
  VideoNote? video_note;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A video note message
  PushMessageContentVideoNote(
      {this.video_note, required this.is_pinned, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentVideoNote',
      if (extra != null) '@extra': extra,
      'video_note': video_note,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentVideoNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var video_note = VideoNote.fromMap(_map['video_note']);
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentVideoNote(
      extra: extra,
      clientId: clientId,
      video_note: video_note,
      is_pinned: is_pinned,
    );
  }
}

/// A voice note message.
///
class PushMessageContentVoiceNote extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentVoiceNote";

  /// Message content; may be null.
  VoiceNote? voice_note;

  /// True, if the message is a pinned message with the specified content.
  late bool is_pinned;

  /// A voice note message
  PushMessageContentVoiceNote(
      {this.voice_note, required this.is_pinned, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentVoiceNote',
      if (extra != null) '@extra': extra,
      'voice_note': voice_note,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var voice_note = VoiceNote.fromMap(_map['voice_note']);
    var is_pinned = _map['is_pinned']! as bool;
    return PushMessageContentVoiceNote(
      extra: extra,
      clientId: clientId,
      voice_note: voice_note,
      is_pinned: is_pinned,
    );
  }
}

/// A newly created basic group.
///
class PushMessageContentBasicGroupChatCreate extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentBasicGroupChatCreate";

  /// A newly created basic group
  PushMessageContentBasicGroupChatCreate({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentBasicGroupChatCreate',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentBasicGroupChatCreate? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PushMessageContentBasicGroupChatCreate(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// New chat members were invited to a group.
///
class PushMessageContentChatAddMembers extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentChatAddMembers";

  /// Name of the added member.
  late String member_name;

  /// True, if the current user was added to the group.
  late bool is_current_user;

  /// True, if the user has returned to the group themselves.
  late bool is_returned;

  /// New chat members were invited to a group
  PushMessageContentChatAddMembers(
      {required this.member_name,
      required this.is_current_user,
      required this.is_returned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentChatAddMembers',
      if (extra != null) '@extra': extra,
      'member_name': member_name,
      'is_current_user': is_current_user,
      'is_returned': is_returned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentChatAddMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var member_name = _map['member_name']! as String;
    var is_current_user = _map['is_current_user']! as bool;
    var is_returned = _map['is_returned']! as bool;
    return PushMessageContentChatAddMembers(
      extra: extra,
      clientId: clientId,
      member_name: member_name,
      is_current_user: is_current_user,
      is_returned: is_returned,
    );
  }
}

/// A chat photo was edited.
///
class PushMessageContentChatChangePhoto extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentChatChangePhoto";

  /// A chat photo was edited
  PushMessageContentChatChangePhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentChatChangePhoto',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentChatChangePhoto? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PushMessageContentChatChangePhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A chat title was edited.
///
class PushMessageContentChatChangeTitle extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentChatChangeTitle";

  /// New chat title.
  late String title;

  /// A chat title was edited
  PushMessageContentChatChangeTitle(
      {required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentChatChangeTitle',
      if (extra != null) '@extra': extra,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentChatChangeTitle? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    return PushMessageContentChatChangeTitle(
      extra: extra,
      clientId: clientId,
      title: title,
    );
  }
}

/// A chat background was edited.
///
class PushMessageContentChatSetBackground extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentChatSetBackground";

  /// True, if the set background is the same as the background of the current user.
  late bool is_same;

  /// A chat background was edited
  PushMessageContentChatSetBackground(
      {required this.is_same, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentChatSetBackground',
      if (extra != null) '@extra': extra,
      'is_same': is_same
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentChatSetBackground? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_same = _map['is_same']! as bool;
    return PushMessageContentChatSetBackground(
      extra: extra,
      clientId: clientId,
      is_same: is_same,
    );
  }
}

/// A chat theme was edited.
///
class PushMessageContentChatSetTheme extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentChatSetTheme";

  /// If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme was reset to the default one.
  late String theme_name;

  /// A chat theme was edited
  PushMessageContentChatSetTheme(
      {required this.theme_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentChatSetTheme',
      if (extra != null) '@extra': extra,
      'theme_name': theme_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentChatSetTheme? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var theme_name = _map['theme_name']! as String;
    return PushMessageContentChatSetTheme(
      extra: extra,
      clientId: clientId,
      theme_name: theme_name,
    );
  }
}

/// A chat member was deleted.
///
class PushMessageContentChatDeleteMember extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentChatDeleteMember";

  /// Name of the deleted member.
  late String member_name;

  /// True, if the current user was deleted from the group.
  late bool is_current_user;

  /// True, if the user has left the group themselves.
  late bool is_left;

  /// A chat member was deleted
  PushMessageContentChatDeleteMember(
      {required this.member_name,
      required this.is_current_user,
      required this.is_left,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentChatDeleteMember',
      if (extra != null) '@extra': extra,
      'member_name': member_name,
      'is_current_user': is_current_user,
      'is_left': is_left
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentChatDeleteMember? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var member_name = _map['member_name']! as String;
    var is_current_user = _map['is_current_user']! as bool;
    var is_left = _map['is_left']! as bool;
    return PushMessageContentChatDeleteMember(
      extra: extra,
      clientId: clientId,
      member_name: member_name,
      is_current_user: is_current_user,
      is_left: is_left,
    );
  }
}

/// A new member joined the chat via an invite link.
///
class PushMessageContentChatJoinByLink extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentChatJoinByLink";

  /// A new member joined the chat via an invite link
  PushMessageContentChatJoinByLink({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentChatJoinByLink',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentChatJoinByLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PushMessageContentChatJoinByLink(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A new member was accepted to the chat by an administrator.
///
class PushMessageContentChatJoinByRequest extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentChatJoinByRequest";

  /// A new member was accepted to the chat by an administrator
  PushMessageContentChatJoinByRequest({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentChatJoinByRequest',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentChatJoinByRequest? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PushMessageContentChatJoinByRequest(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A new recurring payment was made by the current user.
///
class PushMessageContentRecurringPayment extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentRecurringPayment";

  /// The paid amount.
  late String amount;

  /// A new recurring payment was made by the current user
  PushMessageContentRecurringPayment(
      {required this.amount, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentRecurringPayment',
      if (extra != null) '@extra': extra,
      'amount': amount
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentRecurringPayment? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var amount = _map['amount']! as String;
    return PushMessageContentRecurringPayment(
      extra: extra,
      clientId: clientId,
      amount: amount,
    );
  }
}

/// A profile photo was suggested to the user.
///
class PushMessageContentSuggestProfilePhoto extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentSuggestProfilePhoto";

  /// A profile photo was suggested to the user
  PushMessageContentSuggestProfilePhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentSuggestProfilePhoto',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentSuggestProfilePhoto? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return PushMessageContentSuggestProfilePhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A forwarded messages.
///
class PushMessageContentMessageForwards extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentMessageForwards";

  /// Number of forwarded messages.
  late int total_count;

  /// A forwarded messages
  PushMessageContentMessageForwards(
      {required this.total_count, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentMessageForwards',
      if (extra != null) '@extra': extra,
      'total_count': total_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentMessageForwards? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    return PushMessageContentMessageForwards(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
    );
  }
}

/// A media album.
///
class PushMessageContentMediaAlbum extends PushMessageContent {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pushMessageContentMediaAlbum";

  /// Number of messages in the album.
  late int total_count;

  /// True, if the album has at least one photo.
  late bool has_photos;

  /// True, if the album has at least one video file.
  late bool has_videos;

  /// True, if the album has at least one audio file.
  late bool has_audios;

  /// True, if the album has at least one document.
  late bool has_documents;

  /// A media album
  PushMessageContentMediaAlbum(
      {required this.total_count,
      required this.has_photos,
      required this.has_videos,
      required this.has_audios,
      required this.has_documents,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pushMessageContentMediaAlbum',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'has_photos': has_photos,
      'has_videos': has_videos,
      'has_audios': has_audios,
      'has_documents': has_documents
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PushMessageContentMediaAlbum? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var has_photos = _map['has_photos']! as bool;
    var has_videos = _map['has_videos']! as bool;
    var has_audios = _map['has_audios']! as bool;
    var has_documents = _map['has_documents']! as bool;
    return PushMessageContentMediaAlbum(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      has_photos: has_photos,
      has_videos: has_videos,
      has_audios: has_audios,
      has_documents: has_documents,
    );
  }
}

/// New message was received.
///
class NotificationTypeNewMessage extends NotificationType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationTypeNewMessage";

  /// The message.
  late Message message;

  /// True, if message content must be displayed in notifications.
  late bool show_preview;

  /// New message was received
  NotificationTypeNewMessage(
      {required this.message,
      required this.show_preview,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationTypeNewMessage',
      if (extra != null) '@extra': extra,
      'message': message,
      'show_preview': show_preview
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationTypeNewMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message = Message.fromMap(_map['message'])!;
    var show_preview = _map['show_preview']! as bool;
    return NotificationTypeNewMessage(
      extra: extra,
      clientId: clientId,
      message: message,
      show_preview: show_preview,
    );
  }
}

/// New secret chat was created.
///
class NotificationTypeNewSecretChat extends NotificationType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationTypeNewSecretChat";

  /// New secret chat was created
  NotificationTypeNewSecretChat({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationTypeNewSecretChat',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationTypeNewSecretChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NotificationTypeNewSecretChat(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// New call was received.
///
class NotificationTypeNewCall extends NotificationType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationTypeNewCall";

  /// Call identifier.
  late int call_id;

  /// New call was received
  NotificationTypeNewCall({required this.call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationTypeNewCall',
      if (extra != null) '@extra': extra,
      'call_id': call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationTypeNewCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var call_id = _map['call_id']! as int;
    return NotificationTypeNewCall(
      extra: extra,
      clientId: clientId,
      call_id: call_id,
    );
  }
}

/// New message was received through a push notification.
///
class NotificationTypeNewPushMessage extends NotificationType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationTypeNewPushMessage";

  /// The message identifier. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to reply.
  late int message_id;

  /// Identifier of the sender of the message. Corresponding user or chat may be inaccessible.
  late MessageSender sender_id;

  /// Name of the sender.
  late String sender_name;

  /// True, if the message is outgoing.
  late bool is_outgoing;

  /// Push message content.
  late PushMessageContent content;

  /// New message was received through a push notification
  NotificationTypeNewPushMessage(
      {required this.message_id,
      required this.sender_id,
      required this.sender_name,
      required this.is_outgoing,
      required this.content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationTypeNewPushMessage',
      if (extra != null) '@extra': extra,
      'message_id': message_id,
      'sender_id': sender_id,
      'sender_name': sender_name,
      'is_outgoing': is_outgoing,
      'content': content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationTypeNewPushMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_id = _map['message_id']! as int;
    var sender_id = MessageSender.fromMap(_map['sender_id'])!;
    var sender_name = _map['sender_name']! as String;
    var is_outgoing = _map['is_outgoing']! as bool;
    var content = PushMessageContent.fromMap(_map['content'])!;
    return NotificationTypeNewPushMessage(
      extra: extra,
      clientId: clientId,
      message_id: message_id,
      sender_id: sender_id,
      sender_name: sender_name,
      is_outgoing: is_outgoing,
      content: content,
    );
  }
}

/// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages.
///
class NotificationGroupTypeMessages extends NotificationGroupType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationGroupTypeMessages";

  /// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
  NotificationGroupTypeMessages({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationGroupTypeMessages',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationGroupTypeMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NotificationGroupTypeMessages(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message.
///
class NotificationGroupTypeMentions extends NotificationGroupType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationGroupTypeMentions";

  /// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
  NotificationGroupTypeMentions({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationGroupTypeMentions',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationGroupTypeMentions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NotificationGroupTypeMentions(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A group containing a notification of type notificationTypeNewSecretChat.
///
class NotificationGroupTypeSecretChat extends NotificationGroupType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationGroupTypeSecretChat";

  /// A group containing a notification of type notificationTypeNewSecretChat
  NotificationGroupTypeSecretChat({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationGroupTypeSecretChat',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationGroupTypeSecretChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NotificationGroupTypeSecretChat(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A group containing notifications of type notificationTypeNewCall.
///
class NotificationGroupTypeCalls extends NotificationGroupType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationGroupTypeCalls";

  /// A group containing notifications of type notificationTypeNewCall
  NotificationGroupTypeCalls({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationGroupTypeCalls',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationGroupTypeCalls? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NotificationGroupTypeCalls(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Describes a notification sound in MP3 format.
///
class NotificationSound extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationSound";

  /// Unique identifier of the notification sound.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Duration of the sound, in seconds.
  late int duration;

  /// Point in time (Unix timestamp) when the sound was created.
  late int date;

  /// Title of the notification sound.
  late String title;

  /// Arbitrary data, defined while the sound was uploaded.
  late String data;

  /// File containing the sound.
  late File sound;

  /// Describes a notification sound in MP3 format
  NotificationSound(
      {required this.id,
      required this.duration,
      required this.date,
      required this.title,
      required this.data,
      required this.sound,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationSound',
      if (extra != null) '@extra': extra,
      'id': id,
      'duration': duration,
      'date': date,
      'title': title,
      'data': data,
      'sound': sound
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationSound? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var duration = _map['duration']! as int;
    var date = _map['date']! as int;
    var title = _map['title']! as String;
    var data = _map['data']! as String;
    var sound = File.fromMap(_map['sound'])!;
    return NotificationSound(
      extra: extra,
      clientId: clientId,
      id: id,
      duration: duration,
      date: date,
      title: title,
      data: data,
      sound: sound,
    );
  }
}

/// Contains a list of notification sounds.
///
class NotificationSounds extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationSounds";

  /// A list of notification sounds.
  late List<NotificationSound> notification_sounds;

  /// Contains a list of notification sounds
  NotificationSounds(
      {required this.notification_sounds, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationSounds',
      if (extra != null) '@extra': extra,
      'notification_sounds': notification_sounds
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationSounds? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var notification_sounds = List<NotificationSound>.from(
      (_map["notification_sounds"] ?? []).map(
        (e) => NotificationSound.fromMap(e),
      ),
    );
    return NotificationSounds(
      extra: extra,
      clientId: clientId,
      notification_sounds: notification_sounds,
    );
  }
}

/// Contains information about a notification.
///
class Notification extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notification";

  /// Unique persistent identifier of this notification.
  late int id;

  /// Notification date.
  late int date;

  /// True, if the notification was explicitly sent without sound.
  late bool is_silent;

  /// Notification type.
  late NotificationType type;

  /// Contains information about a notification
  Notification(
      {required this.id,
      required this.date,
      required this.is_silent,
      required this.type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notification',
      if (extra != null) '@extra': extra,
      'id': id,
      'date': date,
      'is_silent': is_silent,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Notification? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var date = _map['date']! as int;
    var is_silent = _map['is_silent']! as bool;
    var type = NotificationType.fromMap(_map['type'])!;
    return Notification(
      extra: extra,
      clientId: clientId,
      id: id,
      date: date,
      is_silent: is_silent,
      type: type,
    );
  }
}

/// Describes a group of notifications.
///
class NotificationGroup extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "notificationGroup";

  /// Unique persistent auto-incremented from 1 identifier of the notification group.
  late int id;

  /// Type of the group.
  late NotificationGroupType type;

  /// Identifier of a chat to which all notifications in the group belong.
  late int chat_id;

  /// Total number of active notifications in the group.
  late int total_count;

  /// The list of active notifications.
  late List<Notification> notifications;

  /// Describes a group of notifications
  NotificationGroup(
      {required this.id,
      required this.type,
      required this.chat_id,
      required this.total_count,
      required this.notifications,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'notificationGroup',
      if (extra != null) '@extra': extra,
      'id': id,
      'type': type,
      'chat_id': chat_id,
      'total_count': total_count,
      'notifications': notifications
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NotificationGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var type = NotificationGroupType.fromMap(_map['type'])!;
    var chat_id = _map['chat_id']! as int;
    var total_count = _map['total_count']! as int;
    var notifications = List<Notification>.from(
      (_map["notifications"] ?? []).map(
        (e) => Notification.fromMap(e),
      ),
    );
    return NotificationGroup(
      extra: extra,
      clientId: clientId,
      id: id,
      type: type,
      chat_id: chat_id,
      total_count: total_count,
      notifications: notifications,
    );
  }
}

/// Represents a boolean option.
///
class OptionValueBoolean extends OptionValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "optionValueBoolean";

  /// The value of the option.
  late bool value;

  /// Represents a boolean option
  OptionValueBoolean({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'optionValueBoolean',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OptionValueBoolean? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as bool;
    return OptionValueBoolean(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// Represents an unknown option or an option which has a default value.
///
class OptionValueEmpty extends OptionValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "optionValueEmpty";

  /// Represents an unknown option or an option which has a default value
  OptionValueEmpty({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'optionValueEmpty', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OptionValueEmpty? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return OptionValueEmpty(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents an integer option.
///
class OptionValueInteger extends OptionValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "optionValueInteger";

  /// The value of the option.
  /// ; string representation of int, use `int.parse`
  late int64 value;

  /// Represents an integer option
  OptionValueInteger({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'optionValueInteger',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OptionValueInteger? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as int64;
    return OptionValueInteger(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// Represents a string option.
///
class OptionValueString extends OptionValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "optionValueString";

  /// The value of the option.
  late String value;

  /// Represents a string option
  OptionValueString({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'optionValueString',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OptionValueString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as String;
    return OptionValueString(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// Represents one member of a JSON object.
///
class JsonObjectMember extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "jsonObjectMember";

  /// Member's key.
  late String key;

  /// Member's value.
  late JsonValue value;

  /// Represents one member of a JSON object
  JsonObjectMember(
      {required this.key, required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'jsonObjectMember',
      if (extra != null) '@extra': extra,
      'key': key,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JsonObjectMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var key = _map['key']! as String;
    var value = JsonValue.fromMap(_map['value'])!;
    return JsonObjectMember(
      extra: extra,
      clientId: clientId,
      key: key,
      value: value,
    );
  }
}

/// Represents a null JSON value.
///
class JsonValueNull extends JsonValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "jsonValueNull";

  /// Represents a null JSON value
  JsonValueNull({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'jsonValueNull', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JsonValueNull? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return JsonValueNull(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Represents a boolean JSON value.
///
class JsonValueBoolean extends JsonValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "jsonValueBoolean";

  /// The value.
  late bool value;

  /// Represents a boolean JSON value
  JsonValueBoolean({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'jsonValueBoolean',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JsonValueBoolean? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as bool;
    return JsonValueBoolean(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// Represents a numeric JSON value.
///
class JsonValueNumber extends JsonValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "jsonValueNumber";

  /// The value.
  late double value;

  /// Represents a numeric JSON value
  JsonValueNumber({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'jsonValueNumber',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JsonValueNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as double;
    return JsonValueNumber(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// Represents a string JSON value.
///
class JsonValueString extends JsonValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "jsonValueString";

  /// The value.
  late String value;

  /// Represents a string JSON value
  JsonValueString({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'jsonValueString',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JsonValueString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as String;
    return JsonValueString(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// Represents a JSON array.
///
class JsonValueArray extends JsonValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "jsonValueArray";

  /// The list of array elements.
  late List<JsonValue> values;

  /// Represents a JSON array
  JsonValueArray({required this.values, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'jsonValueArray',
      if (extra != null) '@extra': extra,
      'values': values
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JsonValueArray? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var values = List<JsonValue>.from(
      (_map["values"] ?? []).map(
        (e) => JsonValue.fromMap(e),
      ),
    );
    return JsonValueArray(
      extra: extra,
      clientId: clientId,
      values: values,
    );
  }
}

/// Represents a JSON object.
///
class JsonValueObject extends JsonValue {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "jsonValueObject";

  /// The list of object members.
  late List<JsonObjectMember> members;

  /// Represents a JSON object
  JsonValueObject({required this.members, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'jsonValueObject',
      if (extra != null) '@extra': extra,
      'members': members
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JsonValueObject? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var members = List<JsonObjectMember>.from(
      (_map["members"] ?? []).map(
        (e) => JsonObjectMember.fromMap(e),
      ),
    );
    return JsonValueObject(
      extra: extra,
      clientId: clientId,
      members: members,
    );
  }
}

/// The story can be viewed by everyone.
///
class StoryPrivacySettingsEveryone extends StoryPrivacySettings {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyPrivacySettingsEveryone";

  /// Identifiers of the users that can't see the story; always unknown and empty for non-owned stories.
  late List<int> except_user_ids;

  /// The story can be viewed by everyone
  StoryPrivacySettingsEveryone(
      {required this.except_user_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyPrivacySettingsEveryone',
      if (extra != null) '@extra': extra,
      'except_user_ids': except_user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryPrivacySettingsEveryone? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var except_user_ids = List<int>.from(
      (_map["except_user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return StoryPrivacySettingsEveryone(
      extra: extra,
      clientId: clientId,
      except_user_ids: except_user_ids,
    );
  }
}

/// The story can be viewed by all contacts except chosen users.
///
class StoryPrivacySettingsContacts extends StoryPrivacySettings {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyPrivacySettingsContacts";

  /// User identifiers of the contacts that can't see the story; always unknown and empty for non-owned stories.
  late List<int> except_user_ids;

  /// The story can be viewed by all contacts except chosen users
  StoryPrivacySettingsContacts(
      {required this.except_user_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyPrivacySettingsContacts',
      if (extra != null) '@extra': extra,
      'except_user_ids': except_user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryPrivacySettingsContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var except_user_ids = List<int>.from(
      (_map["except_user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return StoryPrivacySettingsContacts(
      extra: extra,
      clientId: clientId,
      except_user_ids: except_user_ids,
    );
  }
}

/// The story can be viewed by all close friends.
///
class StoryPrivacySettingsCloseFriends extends StoryPrivacySettings {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyPrivacySettingsCloseFriends";

  /// The story can be viewed by all close friends
  StoryPrivacySettingsCloseFriends({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyPrivacySettingsCloseFriends',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryPrivacySettingsCloseFriends? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return StoryPrivacySettingsCloseFriends(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The story can be viewed by certain specified users.
///
class StoryPrivacySettingsSelectedUsers extends StoryPrivacySettings {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storyPrivacySettingsSelectedUsers";

  /// Identifiers of the users; always unknown and empty for non-owned stories.
  late List<int> user_ids;

  /// The story can be viewed by certain specified users
  StoryPrivacySettingsSelectedUsers(
      {required this.user_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storyPrivacySettingsSelectedUsers',
      if (extra != null) '@extra': extra,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StoryPrivacySettingsSelectedUsers? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return StoryPrivacySettingsSelectedUsers(
      extra: extra,
      clientId: clientId,
      user_ids: user_ids,
    );
  }
}

/// A rule to allow all users to do something.
///
class UserPrivacySettingRuleAllowAll extends UserPrivacySettingRule {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingRuleAllowAll";

  /// A rule to allow all users to do something
  UserPrivacySettingRuleAllowAll({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingRuleAllowAll',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingRuleAllowAll? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingRuleAllowAll(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A rule to allow all contacts of the user to do something.
///
class UserPrivacySettingRuleAllowContacts extends UserPrivacySettingRule {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingRuleAllowContacts";

  /// A rule to allow all contacts of the user to do something
  UserPrivacySettingRuleAllowContacts({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingRuleAllowContacts',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingRuleAllowContacts? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingRuleAllowContacts(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A rule to allow certain specified users to do something.
///
class UserPrivacySettingRuleAllowUsers extends UserPrivacySettingRule {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingRuleAllowUsers";

  /// The user identifiers, total number of users in all rules must not exceed 1000.
  late List<int> user_ids;

  /// A rule to allow certain specified users to do something
  UserPrivacySettingRuleAllowUsers(
      {required this.user_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingRuleAllowUsers',
      if (extra != null) '@extra': extra,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingRuleAllowUsers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UserPrivacySettingRuleAllowUsers(
      extra: extra,
      clientId: clientId,
      user_ids: user_ids,
    );
  }
}

/// A rule to allow all members of certain specified basic groups and supergroups to doing something.
///
class UserPrivacySettingRuleAllowChatMembers extends UserPrivacySettingRule {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingRuleAllowChatMembers";

  /// The chat identifiers, total number of chats in all rules must not exceed 20.
  late List<int> chat_ids;

  /// A rule to allow all members of certain specified basic groups and supergroups to doing something
  UserPrivacySettingRuleAllowChatMembers(
      {required this.chat_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingRuleAllowChatMembers',
      if (extra != null) '@extra': extra,
      'chat_ids': chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingRuleAllowChatMembers? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_ids = List<int>.from(
      (_map["chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UserPrivacySettingRuleAllowChatMembers(
      extra: extra,
      clientId: clientId,
      chat_ids: chat_ids,
    );
  }
}

/// A rule to restrict all users from doing something.
///
class UserPrivacySettingRuleRestrictAll extends UserPrivacySettingRule {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingRuleRestrictAll";

  /// A rule to restrict all users from doing something
  UserPrivacySettingRuleRestrictAll({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingRuleRestrictAll',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingRuleRestrictAll? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingRuleRestrictAll(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A rule to restrict all contacts of the user from doing something.
///
class UserPrivacySettingRuleRestrictContacts extends UserPrivacySettingRule {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingRuleRestrictContacts";

  /// A rule to restrict all contacts of the user from doing something
  UserPrivacySettingRuleRestrictContacts({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingRuleRestrictContacts',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingRuleRestrictContacts? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingRuleRestrictContacts(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A rule to restrict all specified users from doing something.
///
class UserPrivacySettingRuleRestrictUsers extends UserPrivacySettingRule {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingRuleRestrictUsers";

  /// The user identifiers, total number of users in all rules must not exceed 1000.
  late List<int> user_ids;

  /// A rule to restrict all specified users from doing something
  UserPrivacySettingRuleRestrictUsers(
      {required this.user_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingRuleRestrictUsers',
      if (extra != null) '@extra': extra,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingRuleRestrictUsers? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UserPrivacySettingRuleRestrictUsers(
      extra: extra,
      clientId: clientId,
      user_ids: user_ids,
    );
  }
}

/// A rule to restrict all members of specified basic groups and supergroups from doing something.
///
class UserPrivacySettingRuleRestrictChatMembers extends UserPrivacySettingRule {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingRuleRestrictChatMembers";

  /// The chat identifiers, total number of chats in all rules must not exceed 20.
  late List<int> chat_ids;

  /// A rule to restrict all members of specified basic groups and supergroups from doing something
  UserPrivacySettingRuleRestrictChatMembers(
      {required this.chat_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingRuleRestrictChatMembers',
      if (extra != null) '@extra': extra,
      'chat_ids': chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingRuleRestrictChatMembers? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_ids = List<int>.from(
      (_map["chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UserPrivacySettingRuleRestrictChatMembers(
      extra: extra,
      clientId: clientId,
      chat_ids: chat_ids,
    );
  }
}

/// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed.
///
class UserPrivacySettingRules extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingRules";

  /// A list of rules.
  late List<UserPrivacySettingRule> rules;

  /// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
  UserPrivacySettingRules({required this.rules, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingRules',
      if (extra != null) '@extra': extra,
      'rules': rules
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingRules? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var rules = List<UserPrivacySettingRule>.from(
      (_map["rules"] ?? []).map(
        (e) => UserPrivacySettingRule.fromMap(e),
      ),
    );
    return UserPrivacySettingRules(
      extra: extra,
      clientId: clientId,
      rules: rules,
    );
  }
}

/// A privacy setting for managing whether the user's online status is visible.
///
class UserPrivacySettingShowStatus extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingShowStatus";

  /// A privacy setting for managing whether the user's online status is visible
  UserPrivacySettingShowStatus({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingShowStatus',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingShowStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingShowStatus(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A privacy setting for managing whether the user's profile photo is visible.
///
class UserPrivacySettingShowProfilePhoto extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingShowProfilePhoto";

  /// A privacy setting for managing whether the user's profile photo is visible
  UserPrivacySettingShowProfilePhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingShowProfilePhoto',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingShowProfilePhoto? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingShowProfilePhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A privacy setting for managing whether a link to the user's account is included in forwarded messages.
///
class UserPrivacySettingShowLinkInForwardedMessages extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "userPrivacySettingShowLinkInForwardedMessages";

  /// A privacy setting for managing whether a link to the user's account is included in forwarded messages
  UserPrivacySettingShowLinkInForwardedMessages({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingShowLinkInForwardedMessages',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingShowLinkInForwardedMessages? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingShowLinkInForwardedMessages(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A privacy setting for managing whether the user's phone number is visible.
///
class UserPrivacySettingShowPhoneNumber extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingShowPhoneNumber";

  /// A privacy setting for managing whether the user's phone number is visible
  UserPrivacySettingShowPhoneNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingShowPhoneNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingShowPhoneNumber? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingShowPhoneNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A privacy setting for managing whether the user's bio is visible.
///
class UserPrivacySettingShowBio extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingShowBio";

  /// A privacy setting for managing whether the user's bio is visible
  UserPrivacySettingShowBio({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingShowBio',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingShowBio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingShowBio(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A privacy setting for managing whether the user can be invited to chats.
///
class UserPrivacySettingAllowChatInvites extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingAllowChatInvites";

  /// A privacy setting for managing whether the user can be invited to chats
  UserPrivacySettingAllowChatInvites({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingAllowChatInvites',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingAllowChatInvites? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingAllowChatInvites(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A privacy setting for managing whether the user can be called.
///
class UserPrivacySettingAllowCalls extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingAllowCalls";

  /// A privacy setting for managing whether the user can be called
  UserPrivacySettingAllowCalls({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingAllowCalls',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingAllowCalls? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingAllowCalls(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A privacy setting for managing whether peer-to-peer connections can be used for calls.
///
class UserPrivacySettingAllowPeerToPeerCalls extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userPrivacySettingAllowPeerToPeerCalls";

  /// A privacy setting for managing whether peer-to-peer connections can be used for calls
  UserPrivacySettingAllowPeerToPeerCalls({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingAllowPeerToPeerCalls',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingAllowPeerToPeerCalls? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingAllowPeerToPeerCalls(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all".
///
class UserPrivacySettingAllowFindingByPhoneNumber extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "userPrivacySettingAllowFindingByPhoneNumber";

  /// A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
  UserPrivacySettingAllowFindingByPhoneNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingAllowFindingByPhoneNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingAllowFindingByPhoneNumber? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingAllowFindingByPhoneNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A privacy setting for managing whether the user can receive voice and video messages in private chats.
///
class UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
    extends UserPrivacySetting {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages";

  /// A privacy setting for managing whether the user can receive voice and video messages in private chats
  UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages(
      {this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains information about the period of inactivity after which the current user's account will automatically be deleted.
///
class AccountTtl extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "accountTtl";

  /// Number of days of inactivity before the account will be flagged for deletion; 30-366 days.
  late int days;

  /// Contains information about the period of inactivity after which the current user's account will automatically be deleted
  AccountTtl({required this.days, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'accountTtl',
      if (extra != null) '@extra': extra,
      'days': days
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AccountTtl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var days = _map['days']! as int;
    return AccountTtl(
      extra: extra,
      clientId: clientId,
      days: days,
    );
  }
}

/// Contains default auto-delete timer setting for new chats.
///
class MessageAutoDeleteTime extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageAutoDeleteTime";

  /// Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically.
  late int time;

  /// Contains default auto-delete timer setting for new chats
  MessageAutoDeleteTime({required this.time, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageAutoDeleteTime',
      if (extra != null) '@extra': extra,
      'time': time
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageAutoDeleteTime? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var time = _map['time']! as int;
    return MessageAutoDeleteTime(
      extra: extra,
      clientId: clientId,
      time: time,
    );
  }
}

/// The session is running on an Android device.
///
class SessionTypeAndroid extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeAndroid";

  /// The session is running on an Android device
  SessionTypeAndroid({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeAndroid', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeAndroid? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeAndroid(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on a generic Apple device.
///
class SessionTypeApple extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeApple";

  /// The session is running on a generic Apple device
  SessionTypeApple({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeApple', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeApple? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeApple(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on the Brave browser.
///
class SessionTypeBrave extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeBrave";

  /// The session is running on the Brave browser
  SessionTypeBrave({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeBrave', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeBrave? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeBrave(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on the Chrome browser.
///
class SessionTypeChrome extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeChrome";

  /// The session is running on the Chrome browser
  SessionTypeChrome({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeChrome', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeChrome? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeChrome(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on the Edge browser.
///
class SessionTypeEdge extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeEdge";

  /// The session is running on the Edge browser
  SessionTypeEdge({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeEdge', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeEdge? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeEdge(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on the Firefox browser.
///
class SessionTypeFirefox extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeFirefox";

  /// The session is running on the Firefox browser
  SessionTypeFirefox({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeFirefox', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeFirefox? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeFirefox(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on an iPad device.
///
class SessionTypeIpad extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeIpad";

  /// The session is running on an iPad device
  SessionTypeIpad({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeIpad', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeIpad? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeIpad(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on an iPhone device.
///
class SessionTypeIphone extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeIphone";

  /// The session is running on an iPhone device
  SessionTypeIphone({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeIphone', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeIphone? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeIphone(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on a Linux device.
///
class SessionTypeLinux extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeLinux";

  /// The session is running on a Linux device
  SessionTypeLinux({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeLinux', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeLinux? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeLinux(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on a Mac device.
///
class SessionTypeMac extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeMac";

  /// The session is running on a Mac device
  SessionTypeMac({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeMac', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeMac? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeMac(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on the Opera browser.
///
class SessionTypeOpera extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeOpera";

  /// The session is running on the Opera browser
  SessionTypeOpera({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeOpera', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeOpera? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeOpera(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on the Safari browser.
///
class SessionTypeSafari extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeSafari";

  /// The session is running on the Safari browser
  SessionTypeSafari({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeSafari', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeSafari? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeSafari(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on an Ubuntu device.
///
class SessionTypeUbuntu extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeUbuntu";

  /// The session is running on an Ubuntu device
  SessionTypeUbuntu({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeUbuntu', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeUbuntu? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeUbuntu(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on an unknown type of device.
///
class SessionTypeUnknown extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeUnknown";

  /// The session is running on an unknown type of device
  SessionTypeUnknown({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeUnknown', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeUnknown? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeUnknown(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on the Vivaldi browser.
///
class SessionTypeVivaldi extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeVivaldi";

  /// The session is running on the Vivaldi browser
  SessionTypeVivaldi({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeVivaldi', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeVivaldi? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeVivaldi(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on a Windows device.
///
class SessionTypeWindows extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeWindows";

  /// The session is running on a Windows device
  SessionTypeWindows({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeWindows', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeWindows? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeWindows(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The session is running on an Xbox console.
///
class SessionTypeXbox extends SessionType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessionTypeXbox";

  /// The session is running on an Xbox console
  SessionTypeXbox({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'sessionTypeXbox', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SessionTypeXbox? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SessionTypeXbox(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order.
///
class Session extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "session";

  /// Session identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// True, if this session is the current session.
  late bool is_current;

  /// True, if a 2-step verification password is needed to complete authorization of the session.
  late bool is_password_pending;

  /// True, if the session wasn't confirmed from another session.
  late bool is_unconfirmed;

  /// True, if incoming secret chats can be accepted by the session.
  late bool can_accept_secret_chats;

  /// True, if incoming calls can be accepted by the session.
  late bool can_accept_calls;

  /// Session type based on the system and application version, which can be used to display a corresponding icon.
  late SessionType type;

  /// Telegram API identifier, as provided by the application.
  late int api_id;

  /// Name of the application, as provided by the application.
  late String application_name;

  /// The version of the application, as provided by the application.
  late String application_version;

  /// True, if the application is an official application or uses the api_id of an official application.
  late bool is_official_application;

  /// Model of the device the application has been run or is running on, as provided by the application.
  late String device_model;

  /// Operating system the application has been run or is running on, as provided by the application.
  late String platform;

  /// Version of the operating system the application has been run or is running on, as provided by the application.
  late String system_version;

  /// Point in time (Unix timestamp) when the user has logged in.
  late int log_in_date;

  /// Point in time (Unix timestamp) when the session was last used.
  late int last_active_date;

  /// IP address from which the session was created, in human-readable format.
  late String ip_address;

  /// A human-readable description of the location from which the session was created, based on the IP address.
  late String location;

  /// Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order
  Session(
      {required this.id,
      required this.is_current,
      required this.is_password_pending,
      required this.is_unconfirmed,
      required this.can_accept_secret_chats,
      required this.can_accept_calls,
      required this.type,
      required this.api_id,
      required this.application_name,
      required this.application_version,
      required this.is_official_application,
      required this.device_model,
      required this.platform,
      required this.system_version,
      required this.log_in_date,
      required this.last_active_date,
      required this.ip_address,
      required this.location,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'session',
      if (extra != null) '@extra': extra,
      'id': id,
      'is_current': is_current,
      'is_password_pending': is_password_pending,
      'is_unconfirmed': is_unconfirmed,
      'can_accept_secret_chats': can_accept_secret_chats,
      'can_accept_calls': can_accept_calls,
      'type': type,
      'api_id': api_id,
      'application_name': application_name,
      'application_version': application_version,
      'is_official_application': is_official_application,
      'device_model': device_model,
      'platform': platform,
      'system_version': system_version,
      'log_in_date': log_in_date,
      'last_active_date': last_active_date,
      'ip_address': ip_address,
      'location': location
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Session? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var is_current = _map['is_current']! as bool;
    var is_password_pending = _map['is_password_pending']! as bool;
    var is_unconfirmed = _map['is_unconfirmed']! as bool;
    var can_accept_secret_chats = _map['can_accept_secret_chats']! as bool;
    var can_accept_calls = _map['can_accept_calls']! as bool;
    var type = SessionType.fromMap(_map['type'])!;
    var api_id = _map['api_id']! as int;
    var application_name = _map['application_name']! as String;
    var application_version = _map['application_version']! as String;
    var is_official_application = _map['is_official_application']! as bool;
    var device_model = _map['device_model']! as String;
    var platform = _map['platform']! as String;
    var system_version = _map['system_version']! as String;
    var log_in_date = _map['log_in_date']! as int;
    var last_active_date = _map['last_active_date']! as int;
    var ip_address = _map['ip_address']! as String;
    var location = _map['location']! as String;
    return Session(
      extra: extra,
      clientId: clientId,
      id: id,
      is_current: is_current,
      is_password_pending: is_password_pending,
      is_unconfirmed: is_unconfirmed,
      can_accept_secret_chats: can_accept_secret_chats,
      can_accept_calls: can_accept_calls,
      type: type,
      api_id: api_id,
      application_name: application_name,
      application_version: application_version,
      is_official_application: is_official_application,
      device_model: device_model,
      platform: platform,
      system_version: system_version,
      log_in_date: log_in_date,
      last_active_date: last_active_date,
      ip_address: ip_address,
      location: location,
    );
  }
}

/// Contains a list of sessions.
///
class Sessions extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sessions";

  /// List of sessions.
  late List<Session> sessions;

  /// Number of days of inactivity before sessions will automatically be terminated; 1-366 days.
  late int inactive_session_ttl_days;

  /// Contains a list of sessions
  Sessions(
      {required this.sessions,
      required this.inactive_session_ttl_days,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sessions',
      if (extra != null) '@extra': extra,
      'sessions': sessions,
      'inactive_session_ttl_days': inactive_session_ttl_days
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Sessions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sessions = List<Session>.from(
      (_map["sessions"] ?? []).map(
        (e) => Session.fromMap(e),
      ),
    );
    var inactive_session_ttl_days = _map['inactive_session_ttl_days']! as int;
    return Sessions(
      extra: extra,
      clientId: clientId,
      sessions: sessions,
      inactive_session_ttl_days: inactive_session_ttl_days,
    );
  }
}

/// Contains information about an unconfirmed session.
///
class UnconfirmedSession extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "unconfirmedSession";

  /// Session identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Point in time (Unix timestamp) when the user has logged in.
  late int log_in_date;

  /// Model of the device that was used for the session creation, as provided by the application.
  late String device_model;

  /// A human-readable description of the location from which the session was created, based on the IP address.
  late String location;

  /// Contains information about an unconfirmed session
  UnconfirmedSession(
      {required this.id,
      required this.log_in_date,
      required this.device_model,
      required this.location,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'unconfirmedSession',
      if (extra != null) '@extra': extra,
      'id': id,
      'log_in_date': log_in_date,
      'device_model': device_model,
      'location': location
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UnconfirmedSession? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var log_in_date = _map['log_in_date']! as int;
    var device_model = _map['device_model']! as String;
    var location = _map['location']! as String;
    return UnconfirmedSession(
      extra: extra,
      clientId: clientId,
      id: id,
      log_in_date: log_in_date,
      device_model: device_model,
      location: location,
    );
  }
}

/// Contains information about one website the current user is logged in with Telegram.
///
class ConnectedWebsite extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "connectedWebsite";

  /// Website identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// The domain name of the website.
  late String domain_name;

  /// User identifier of a bot linked with the website.
  late int bot_user_id;

  /// The version of a browser used to log in.
  late String browser;

  /// Operating system the browser is running on.
  late String platform;

  /// Point in time (Unix timestamp) when the user was logged in.
  late int log_in_date;

  /// Point in time (Unix timestamp) when obtained authorization was last used.
  late int last_active_date;

  /// IP address from which the user was logged in, in human-readable format.
  late String ip_address;

  /// Human-readable description of a country and a region from which the user was logged in, based on the IP address.
  late String location;

  /// Contains information about one website the current user is logged in with Telegram
  ConnectedWebsite(
      {required this.id,
      required this.domain_name,
      required this.bot_user_id,
      required this.browser,
      required this.platform,
      required this.log_in_date,
      required this.last_active_date,
      required this.ip_address,
      required this.location,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'connectedWebsite',
      if (extra != null) '@extra': extra,
      'id': id,
      'domain_name': domain_name,
      'bot_user_id': bot_user_id,
      'browser': browser,
      'platform': platform,
      'log_in_date': log_in_date,
      'last_active_date': last_active_date,
      'ip_address': ip_address,
      'location': location
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ConnectedWebsite? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var domain_name = _map['domain_name']! as String;
    var bot_user_id = _map['bot_user_id']! as int;
    var browser = _map['browser']! as String;
    var platform = _map['platform']! as String;
    var log_in_date = _map['log_in_date']! as int;
    var last_active_date = _map['last_active_date']! as int;
    var ip_address = _map['ip_address']! as String;
    var location = _map['location']! as String;
    return ConnectedWebsite(
      extra: extra,
      clientId: clientId,
      id: id,
      domain_name: domain_name,
      bot_user_id: bot_user_id,
      browser: browser,
      platform: platform,
      log_in_date: log_in_date,
      last_active_date: last_active_date,
      ip_address: ip_address,
      location: location,
    );
  }
}

/// Contains a list of websites the current user is logged in with Telegram.
///
class ConnectedWebsites extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "connectedWebsites";

  /// List of connected websites.
  late List<ConnectedWebsite> websites;

  /// Contains a list of websites the current user is logged in with Telegram
  ConnectedWebsites({required this.websites, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'connectedWebsites',
      if (extra != null) '@extra': extra,
      'websites': websites
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ConnectedWebsites? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var websites = List<ConnectedWebsite>.from(
      (_map["websites"] ?? []).map(
        (e) => ConnectedWebsite.fromMap(e),
      ),
    );
    return ConnectedWebsites(
      extra: extra,
      clientId: clientId,
      websites: websites,
    );
  }
}

/// The chat contains spam messages.
///
class ReportReasonSpam extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonSpam";

  /// The chat contains spam messages
  ReportReasonSpam({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'reportReasonSpam', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonSpam? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonSpam(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat promotes violence.
///
class ReportReasonViolence extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonViolence";

  /// The chat promotes violence
  ReportReasonViolence({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportReasonViolence',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonViolence? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonViolence(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat contains pornographic messages.
///
class ReportReasonPornography extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonPornography";

  /// The chat contains pornographic messages
  ReportReasonPornography({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportReasonPornography',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonPornography? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonPornography(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat has child abuse related content.
///
class ReportReasonChildAbuse extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonChildAbuse";

  /// The chat has child abuse related content
  ReportReasonChildAbuse({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportReasonChildAbuse',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonChildAbuse? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonChildAbuse(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat contains copyrighted content.
///
class ReportReasonCopyright extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonCopyright";

  /// The chat contains copyrighted content
  ReportReasonCopyright({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportReasonCopyright',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonCopyright? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonCopyright(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The location-based chat is unrelated to its stated location.
///
class ReportReasonUnrelatedLocation extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonUnrelatedLocation";

  /// The location-based chat is unrelated to its stated location
  ReportReasonUnrelatedLocation({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportReasonUnrelatedLocation',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonUnrelatedLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonUnrelatedLocation(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat represents a fake account.
///
class ReportReasonFake extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonFake";

  /// The chat represents a fake account
  ReportReasonFake({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'reportReasonFake', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonFake? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonFake(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat has illegal drugs related content.
///
class ReportReasonIllegalDrugs extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonIllegalDrugs";

  /// The chat has illegal drugs related content
  ReportReasonIllegalDrugs({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportReasonIllegalDrugs',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonIllegalDrugs? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonIllegalDrugs(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat contains messages with personal details.
///
class ReportReasonPersonalDetails extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonPersonalDetails";

  /// The chat contains messages with personal details
  ReportReasonPersonalDetails({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportReasonPersonalDetails',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonPersonalDetails? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonPersonalDetails(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A custom reason provided by the user.
///
class ReportReasonCustom extends ReportReason {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportReasonCustom";

  /// A custom reason provided by the user
  ReportReasonCustom({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'reportReasonCustom', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportReasonCustom? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ReportReasonCustom(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The currently opened chat needs to be kept.
///
class TargetChatCurrent extends TargetChat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "targetChatCurrent";

  /// The currently opened chat needs to be kept
  TargetChatCurrent({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'targetChatCurrent', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TargetChatCurrent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TargetChatCurrent(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The chat needs to be chosen by the user among chats of the specified types.
///
class TargetChatChosen extends TargetChat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "targetChatChosen";

  /// True, if private chats with ordinary users are allowed.
  late bool allow_user_chats;

  /// True, if private chats with other bots are allowed.
  late bool allow_bot_chats;

  /// True, if basic group and supergroup chats are allowed.
  late bool allow_group_chats;

  /// True, if channel chats are allowed.
  late bool allow_channel_chats;

  /// The chat needs to be chosen by the user among chats of the specified types
  TargetChatChosen(
      {required this.allow_user_chats,
      required this.allow_bot_chats,
      required this.allow_group_chats,
      required this.allow_channel_chats,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'targetChatChosen',
      if (extra != null) '@extra': extra,
      'allow_user_chats': allow_user_chats,
      'allow_bot_chats': allow_bot_chats,
      'allow_group_chats': allow_group_chats,
      'allow_channel_chats': allow_channel_chats
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TargetChatChosen? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var allow_user_chats = _map['allow_user_chats']! as bool;
    var allow_bot_chats = _map['allow_bot_chats']! as bool;
    var allow_group_chats = _map['allow_group_chats']! as bool;
    var allow_channel_chats = _map['allow_channel_chats']! as bool;
    return TargetChatChosen(
      extra: extra,
      clientId: clientId,
      allow_user_chats: allow_user_chats,
      allow_bot_chats: allow_bot_chats,
      allow_group_chats: allow_group_chats,
      allow_channel_chats: allow_channel_chats,
    );
  }
}

/// The chat needs to be open with the provided internal link.
///
class TargetChatInternalLink extends TargetChat {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "targetChatInternalLink";

  /// An internal link pointing to the chat.
  late InternalLinkType link;

  /// The chat needs to be open with the provided internal link
  TargetChatInternalLink({required this.link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'targetChatInternalLink',
      if (extra != null) '@extra': extra,
      'link': link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TargetChatInternalLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = InternalLinkType.fromMap(_map['link'])!;
    return TargetChatInternalLink(
      extra: extra,
      clientId: clientId,
      link: link,
    );
  }
}

/// The link is a link to the active sessions section of the application. Use getActiveSessions to handle the link.
///
class InternalLinkTypeActiveSessions extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeActiveSessions";

  /// The link is a link to the active sessions section of the application. Use getActiveSessions to handle the link
  InternalLinkTypeActiveSessions({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeActiveSessions',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeActiveSessions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeActiveSessions(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a link to an attachment menu bot to be opened in the specified or a chosen chat. Process given target_chat to open the chat..
///
class InternalLinkTypeAttachmentMenuBot extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeAttachmentMenuBot";

  /// Target chat to be opened.
  late TargetChat target_chat;

  /// Username of the bot.
  late String bot_username;

  /// URL to be passed to openWebApp.
  late String url;

  /// The link is a link to an attachment menu bot to be opened in the specified or a chosen chat. Process given target_chat to open the chat.
  InternalLinkTypeAttachmentMenuBot(
      {required this.target_chat,
      required this.bot_username,
      required this.url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeAttachmentMenuBot',
      if (extra != null) '@extra': extra,
      'target_chat': target_chat,
      'bot_username': bot_username,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeAttachmentMenuBot? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var target_chat = TargetChat.fromMap(_map['target_chat'])!;
    var bot_username = _map['bot_username']! as String;
    var url = _map['url']! as String;
    return InternalLinkTypeAttachmentMenuBot(
      extra: extra,
      clientId: clientId,
      target_chat: target_chat,
      bot_username: bot_username,
      url: url,
    );
  }
}

/// The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode.
///
class InternalLinkTypeAuthenticationCode extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeAuthenticationCode";

  /// The authentication code.
  late String code;

  /// The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode
  InternalLinkTypeAuthenticationCode(
      {required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeAuthenticationCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeAuthenticationCode? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = _map['code']! as String;
    return InternalLinkTypeAuthenticationCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// The link is a link to a background. Call searchBackground with the given background name to process the link.
///
class InternalLinkTypeBackground extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeBackground";

  /// Name of the background.
  late String background_name;

  /// The link is a link to a background. Call searchBackground with the given background name to process the link
  InternalLinkTypeBackground(
      {required this.background_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeBackground',
      if (extra != null) '@extra': extra,
      'background_name': background_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeBackground? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var background_name = _map['background_name']! as String;
    return InternalLinkTypeBackground(
      extra: extra,
      clientId: clientId,
      background_name: background_name,
    );
  }
}

/// The link is a link to a Telegram bot, which is supposed to be added to a channel chat as an administrator. Call searchPublicChat with the given bot username and check that the user is a bot,.
///
class InternalLinkTypeBotAddToChannel extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeBotAddToChannel";

  /// Username of the bot.
  late String bot_username;

  /// Expected administrator rights for the bot.
  late ChatAdministratorRights administrator_rights;

  /// The link is a link to a Telegram bot, which is supposed to be added to a channel chat as an administrator. Call searchPublicChat with the given bot username and check that the user is a bot,
  InternalLinkTypeBotAddToChannel(
      {required this.bot_username,
      required this.administrator_rights,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeBotAddToChannel',
      if (extra != null) '@extra': extra,
      'bot_username': bot_username,
      'administrator_rights': administrator_rights
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeBotAddToChannel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_username = _map['bot_username']! as String;
    var administrator_rights =
        ChatAdministratorRights.fromMap(_map['administrator_rights'])!;
    return InternalLinkTypeBotAddToChannel(
      extra: extra,
      clientId: clientId,
      bot_username: bot_username,
      administrator_rights: administrator_rights,
    );
  }
}

/// The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot,.
///
class InternalLinkTypeBotStart extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeBotStart";

  /// Username of the bot.
  late String bot_username;

  /// The parameter to be passed to sendBotStartMessage.
  late String start_parameter;

  /// True, if sendBotStartMessage must be called automatically without showing the START button.
  late bool autostart;

  /// The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot,
  InternalLinkTypeBotStart(
      {required this.bot_username,
      required this.start_parameter,
      required this.autostart,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeBotStart',
      if (extra != null) '@extra': extra,
      'bot_username': bot_username,
      'start_parameter': start_parameter,
      'autostart': autostart
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeBotStart? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_username = _map['bot_username']! as String;
    var start_parameter = _map['start_parameter']! as String;
    var autostart = _map['autostart']! as bool;
    return InternalLinkTypeBotStart(
      extra: extra,
      clientId: clientId,
      bot_username: bot_username,
      start_parameter: start_parameter,
      autostart: autostart,
    );
  }
}

/// The link is a link to a Telegram bot, which is supposed to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups,.
///
class InternalLinkTypeBotStartInGroup extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeBotStartInGroup";

  /// Username of the bot.
  late String bot_username;

  /// The parameter to be passed to sendBotStartMessage.
  late String start_parameter;

  /// Expected administrator rights for the bot; may be null.
  ChatAdministratorRights? administrator_rights;

  /// The link is a link to a Telegram bot, which is supposed to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups,
  InternalLinkTypeBotStartInGroup(
      {required this.bot_username,
      required this.start_parameter,
      this.administrator_rights,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeBotStartInGroup',
      if (extra != null) '@extra': extra,
      'bot_username': bot_username,
      'start_parameter': start_parameter,
      'administrator_rights': administrator_rights
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeBotStartInGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_username = _map['bot_username']! as String;
    var start_parameter = _map['start_parameter']! as String;
    var administrator_rights =
        ChatAdministratorRights.fromMap(_map['administrator_rights']);
    return InternalLinkTypeBotStartInGroup(
      extra: extra,
      clientId: clientId,
      bot_username: bot_username,
      start_parameter: start_parameter,
      administrator_rights: administrator_rights,
    );
  }
}

/// The link is a link to the change phone number section of the app.
///
class InternalLinkTypeChangePhoneNumber extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeChangePhoneNumber";

  /// The link is a link to the change phone number section of the app
  InternalLinkTypeChangePhoneNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeChangePhoneNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeChangePhoneNumber? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeChangePhoneNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with the given URL to process the link..
///
class InternalLinkTypeChatBoost extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeChatBoost";

  /// URL to be passed to getChatBoostLinkInfo.
  late String url;

  /// The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with the given URL to process the link.
  InternalLinkTypeChatBoost({required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeChatBoost',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeChatBoost? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return InternalLinkTypeChatBoost(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// The link is an invite link to a chat folder. Call checkChatFolderInviteLink with the given invite link to process the link.
///
class InternalLinkTypeChatFolderInvite extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeChatFolderInvite";

  /// Internal representation of the invite link.
  late String invite_link;

  /// The link is an invite link to a chat folder. Call checkChatFolderInviteLink with the given invite link to process the link
  InternalLinkTypeChatFolderInvite(
      {required this.invite_link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeChatFolderInvite',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeChatFolderInvite? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = _map['invite_link']! as String;
    return InternalLinkTypeChatFolderInvite(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
    );
  }
}

/// The link is a link to the folder section of the app settings.
///
class InternalLinkTypeChatFolderSettings extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeChatFolderSettings";

  /// The link is a link to the folder section of the app settings
  InternalLinkTypeChatFolderSettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeChatFolderSettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeChatFolderSettings? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeChatFolderSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link.
///
class InternalLinkTypeChatInvite extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeChatInvite";

  /// Internal representation of the invite link.
  late String invite_link;

  /// The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link
  InternalLinkTypeChatInvite(
      {required this.invite_link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeChatInvite',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeChatInvite? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = _map['invite_link']! as String;
    return InternalLinkTypeChatInvite(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
    );
  }
}

/// The link is a link to the default message auto-delete timer settings section of the app settings.
///
class InternalLinkTypeDefaultMessageAutoDeleteTimerSettings
    extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "internalLinkTypeDefaultMessageAutoDeleteTimerSettings";

  /// The link is a link to the default message auto-delete timer settings section of the app settings
  InternalLinkTypeDefaultMessageAutoDeleteTimerSettings(
      {this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeDefaultMessageAutoDeleteTimerSettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeDefaultMessageAutoDeleteTimerSettings? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeDefaultMessageAutoDeleteTimerSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a link to the edit profile section of the app settings.
///
class InternalLinkTypeEditProfileSettings extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeEditProfileSettings";

  /// The link is a link to the edit profile section of the app settings
  InternalLinkTypeEditProfileSettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeEditProfileSettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeEditProfileSettings? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeEditProfileSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame.
///
class InternalLinkTypeGame extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeGame";

  /// Username of the bot that owns the game.
  late String bot_username;

  /// Short name of the game.
  late String game_short_name;

  /// The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame
  InternalLinkTypeGame(
      {required this.bot_username,
      required this.game_short_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeGame',
      if (extra != null) '@extra': extra,
      'bot_username': bot_username,
      'game_short_name': game_short_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeGame? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_username = _map['bot_username']! as String;
    var game_short_name = _map['game_short_name']! as String;
    return InternalLinkTypeGame(
      extra: extra,
      clientId: clientId,
      bot_username: bot_username,
      game_short_name: game_short_name,
    );
  }
}

/// The link must be opened in an Instant View. Call getWebPageInstantView with the given URL to process the link.
///
class InternalLinkTypeInstantView extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeInstantView";

  /// URL to be passed to getWebPageInstantView.
  late String url;

  /// An URL to open if getWebPageInstantView fails.
  late String fallback_url;

  /// The link must be opened in an Instant View. Call getWebPageInstantView with the given URL to process the link
  InternalLinkTypeInstantView(
      {required this.url,
      required this.fallback_url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeInstantView',
      if (extra != null) '@extra': extra,
      'url': url,
      'fallback_url': fallback_url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeInstantView? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var fallback_url = _map['fallback_url']! as String;
    return InternalLinkTypeInstantView(
      extra: extra,
      clientId: clientId,
      url: url,
      fallback_url: fallback_url,
    );
  }
}

/// The link is a link to an invoice. Call getPaymentForm with the given invoice name to process the link.
///
class InternalLinkTypeInvoice extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeInvoice";

  /// Name of the invoice.
  late String invoice_name;

  /// The link is a link to an invoice. Call getPaymentForm with the given invoice name to process the link
  InternalLinkTypeInvoice(
      {required this.invoice_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeInvoice',
      if (extra != null) '@extra': extra,
      'invoice_name': invoice_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeInvoice? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invoice_name = _map['invoice_name']! as String;
    return InternalLinkTypeInvoice(
      extra: extra,
      clientId: clientId,
      invoice_name: invoice_name,
    );
  }
}

/// The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link.
///
class InternalLinkTypeLanguagePack extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeLanguagePack";

  /// Language pack identifier.
  late String language_pack_id;

  /// The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link
  InternalLinkTypeLanguagePack(
      {required this.language_pack_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeLanguagePack',
      if (extra != null) '@extra': extra,
      'language_pack_id': language_pack_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeLanguagePack? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_pack_id = _map['language_pack_id']! as String;
    return InternalLinkTypeLanguagePack(
      extra: extra,
      clientId: clientId,
      language_pack_id: language_pack_id,
    );
  }
}

/// The link is a link to the language section of the app settings.
///
class InternalLinkTypeLanguageSettings extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeLanguageSettings";

  /// The link is a link to the language section of the app settings
  InternalLinkTypeLanguageSettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeLanguageSettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeLanguageSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeLanguageSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo with the given URL to process the link.
///
class InternalLinkTypeMessage extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeMessage";

  /// URL to be passed to getMessageLinkInfo.
  late String url;

  /// The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo with the given URL to process the link
  InternalLinkTypeMessage({required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeMessage',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return InternalLinkTypeMessage(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field.
///
class InternalLinkTypeMessageDraft extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeMessageDraft";

  /// Message draft text.
  late FormattedText text;

  /// True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected.
  late bool contains_link;

  /// The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field
  InternalLinkTypeMessageDraft(
      {required this.text,
      required this.contains_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeMessageDraft',
      if (extra != null) '@extra': extra,
      'text': text,
      'contains_link': contains_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeMessageDraft? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = FormattedText.fromMap(_map['text'])!;
    var contains_link = _map['contains_link']! as bool;
    return InternalLinkTypeMessageDraft(
      extra: extra,
      clientId: clientId,
      text: text,
      contains_link: contains_link,
    );
  }
}

/// The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application; otherwise, ignore it.
///
class InternalLinkTypePassportDataRequest extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypePassportDataRequest";

  /// User identifier of the service's bot.
  late int bot_user_id;

  /// Telegram Passport element types requested by the service.
  late String scope;

  /// Service's public key.
  late String public_key;

  /// Unique request identifier provided by the service.
  late String nonce;

  /// An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=... respectively..
  late String callback_url;

  /// The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application; otherwise, ignore it
  InternalLinkTypePassportDataRequest(
      {required this.bot_user_id,
      required this.scope,
      required this.public_key,
      required this.nonce,
      required this.callback_url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypePassportDataRequest',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'scope': scope,
      'public_key': public_key,
      'nonce': nonce,
      'callback_url': callback_url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypePassportDataRequest? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var scope = _map['scope']! as String;
    var public_key = _map['public_key']! as String;
    var nonce = _map['nonce']! as String;
    var callback_url = _map['callback_url']! as String;
    return InternalLinkTypePassportDataRequest(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      scope: scope,
      public_key: public_key,
      nonce: nonce,
      callback_url: callback_url,
    );
  }
}

/// The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone number to process the link.
///
class InternalLinkTypePhoneNumberConfirmation extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypePhoneNumberConfirmation";

  /// Hash value from the link.
  late String hash;

  /// Phone number value from the link.
  late String phone_number;

  /// The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone number to process the link
  InternalLinkTypePhoneNumberConfirmation(
      {required this.hash,
      required this.phone_number,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypePhoneNumberConfirmation',
      if (extra != null) '@extra': extra,
      'hash': hash,
      'phone_number': phone_number
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypePhoneNumberConfirmation? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var hash = _map['hash']! as String;
    var phone_number = _map['phone_number']! as String;
    return InternalLinkTypePhoneNumberConfirmation(
      extra: extra,
      clientId: clientId,
      hash: hash,
      phone_number: phone_number,
    );
  }
}

/// The link is a link to the Premium features screen of the application from which the user can subscribe to Telegram Premium. Call getPremiumFeatures with the given referrer to process the link.
///
class InternalLinkTypePremiumFeatures extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypePremiumFeatures";

  /// Referrer specified in the link.
  late String referrer;

  /// The link is a link to the Premium features screen of the application from which the user can subscribe to Telegram Premium. Call getPremiumFeatures with the given referrer to process the link
  InternalLinkTypePremiumFeatures(
      {required this.referrer, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypePremiumFeatures',
      if (extra != null) '@extra': extra,
      'referrer': referrer
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypePremiumFeatures? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var referrer = _map['referrer']! as String;
    return InternalLinkTypePremiumFeatures(
      extra: extra,
      clientId: clientId,
      referrer: referrer,
    );
  }
}

/// The link is a link to the privacy and security section of the app settings.
///
class InternalLinkTypePrivacyAndSecuritySettings extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "internalLinkTypePrivacyAndSecuritySettings";

  /// The link is a link to the privacy and security section of the app settings
  InternalLinkTypePrivacyAndSecuritySettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypePrivacyAndSecuritySettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypePrivacyAndSecuritySettings? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypePrivacyAndSecuritySettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy.
///
class InternalLinkTypeProxy extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeProxy";

  /// Proxy server domain or IP address.
  late String server;

  /// Proxy server port.
  late int port;

  /// Type of the proxy.
  late ProxyType type;

  /// The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy
  InternalLinkTypeProxy(
      {required this.server,
      required this.port,
      required this.type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeProxy',
      if (extra != null) '@extra': extra,
      'server': server,
      'port': port,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var server = _map['server']! as String;
    var port = _map['port']! as int;
    var type = ProxyType.fromMap(_map['type'])!;
    return InternalLinkTypeProxy(
      extra: extra,
      clientId: clientId,
      server: server,
      port: port,
      type: type,
    );
  }
}

/// The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link.
///
class InternalLinkTypePublicChat extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypePublicChat";

  /// Username of the chat.
  late String chat_username;

  /// The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link
  InternalLinkTypePublicChat(
      {required this.chat_username, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypePublicChat',
      if (extra != null) '@extra': extra,
      'chat_username': chat_username
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypePublicChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_username = _map['chat_username']! as String;
    return InternalLinkTypePublicChat(
      extra: extra,
      clientId: clientId,
      chat_username: chat_username,
    );
  }
}

/// The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to.
///
class InternalLinkTypeQrCodeAuthentication extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeQrCodeAuthentication";

  /// The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to
  InternalLinkTypeQrCodeAuthentication({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeQrCodeAuthentication',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeQrCodeAuthentication? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeQrCodeAuthentication(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link forces restore of App Store purchases when opened. For official iOS application only.
///
class InternalLinkTypeRestorePurchases extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeRestorePurchases";

  /// The link forces restore of App Store purchases when opened. For official iOS application only
  InternalLinkTypeRestorePurchases({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeRestorePurchases',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeRestorePurchases? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeRestorePurchases(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a link to application settings.
///
class InternalLinkTypeSettings extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeSettings";

  /// The link is a link to application settings
  InternalLinkTypeSettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeSettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a link to a bot, which can be installed to the side menu. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu..
///
class InternalLinkTypeSideMenuBot extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeSideMenuBot";

  /// Username of the bot.
  late String bot_username;

  /// URL to be passed to getWebAppUrl.
  late String url;

  /// The link is a link to a bot, which can be installed to the side menu. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu.
  InternalLinkTypeSideMenuBot(
      {required this.bot_username,
      required this.url,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeSideMenuBot',
      if (extra != null) '@extra': extra,
      'bot_username': bot_username,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeSideMenuBot? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_username = _map['bot_username']! as String;
    var url = _map['url']! as String;
    return InternalLinkTypeSideMenuBot(
      extra: extra,
      clientId: clientId,
      bot_username: bot_username,
      url: url,
    );
  }
}

/// The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set.
///
class InternalLinkTypeStickerSet extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeStickerSet";

  /// Name of the sticker set.
  late String sticker_set_name;

  /// True, if the sticker set is expected to contain custom emoji.
  late bool expect_custom_emoji;

  /// The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set
  InternalLinkTypeStickerSet(
      {required this.sticker_set_name,
      required this.expect_custom_emoji,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeStickerSet',
      if (extra != null) '@extra': extra,
      'sticker_set_name': sticker_set_name,
      'expect_custom_emoji': expect_custom_emoji
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeStickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_set_name = _map['sticker_set_name']! as String;
    var expect_custom_emoji = _map['expect_custom_emoji']! as bool;
    return InternalLinkTypeStickerSet(
      extra: extra,
      clientId: clientId,
      sticker_set_name: sticker_set_name,
      expect_custom_emoji: expect_custom_emoji,
    );
  }
}

/// The link is a link to a story. Call searchPublicChat with the given sender username, then call getStory with the received chat identifier and the given story identifier.
///
class InternalLinkTypeStory extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeStory";

  /// Username of the sender of the story.
  late String story_sender_username;

  /// Story identifier.
  late int story_id;

  /// The link is a link to a story. Call searchPublicChat with the given sender username, then call getStory with the received chat identifier and the given story identifier
  InternalLinkTypeStory(
      {required this.story_sender_username,
      required this.story_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeStory',
      if (extra != null) '@extra': extra,
      'story_sender_username': story_sender_username,
      'story_id': story_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_username = _map['story_sender_username']! as String;
    var story_id = _map['story_id']! as int;
    return InternalLinkTypeStory(
      extra: extra,
      clientId: clientId,
      story_sender_username: story_sender_username,
      story_id: story_id,
    );
  }
}

/// The link is a link to a theme. TDLib has no theme support yet.
///
class InternalLinkTypeTheme extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeTheme";

  /// Name of the theme.
  late String theme_name;

  /// The link is a link to a theme. TDLib has no theme support yet
  InternalLinkTypeTheme({required this.theme_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeTheme',
      if (extra != null) '@extra': extra,
      'theme_name': theme_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeTheme? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var theme_name = _map['theme_name']! as String;
    return InternalLinkTypeTheme(
      extra: extra,
      clientId: clientId,
      theme_name: theme_name,
    );
  }
}

/// The link is a link to the theme section of the app settings.
///
class InternalLinkTypeThemeSettings extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeThemeSettings";

  /// The link is a link to the theme section of the app settings
  InternalLinkTypeThemeSettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeThemeSettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeThemeSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeThemeSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is an unknown tg: link. Call getDeepLinkInfo to process the link.
///
class InternalLinkTypeUnknownDeepLink extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeUnknownDeepLink";

  /// Link to be passed to getDeepLinkInfo.
  late String link;

  /// The link is an unknown tg: link. Call getDeepLinkInfo to process the link
  InternalLinkTypeUnknownDeepLink(
      {required this.link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeUnknownDeepLink',
      if (extra != null) '@extra': extra,
      'link': link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeUnknownDeepLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = _map['link']! as String;
    return InternalLinkTypeUnknownDeepLink(
      extra: extra,
      clientId: clientId,
      link: link,
    );
  }
}

/// The link is a link to an unsupported proxy. An alert can be shown to the user.
///
class InternalLinkTypeUnsupportedProxy extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeUnsupportedProxy";

  /// The link is a link to an unsupported proxy. An alert can be shown to the user
  InternalLinkTypeUnsupportedProxy({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeUnsupportedProxy',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeUnsupportedProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return InternalLinkTypeUnsupportedProxy(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The link is a link to a user by its phone number. Call searchUserByPhoneNumber with the given phone number to process the link.
///
class InternalLinkTypeUserPhoneNumber extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeUserPhoneNumber";

  /// Phone number of the user.
  late String phone_number;

  /// The link is a link to a user by its phone number. Call searchUserByPhoneNumber with the given phone number to process the link
  InternalLinkTypeUserPhoneNumber(
      {required this.phone_number, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeUserPhoneNumber',
      if (extra != null) '@extra': extra,
      'phone_number': phone_number
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeUserPhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number = _map['phone_number']! as String;
    return InternalLinkTypeUserPhoneNumber(
      extra: extra,
      clientId: clientId,
      phone_number: phone_number,
    );
  }
}

/// The link is a link to a user by a temporary token. Call searchUserByToken with the given token to process the link.
///
class InternalLinkTypeUserToken extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeUserToken";

  /// The token.
  late String token;

  /// The link is a link to a user by a temporary token. Call searchUserByToken with the given token to process the link
  InternalLinkTypeUserToken({required this.token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeUserToken',
      if (extra != null) '@extra': extra,
      'token': token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeUserToken? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    return InternalLinkTypeUserToken(
      extra: extra,
      clientId: clientId,
      token: token,
    );
  }
}

/// The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link.
///
class InternalLinkTypeVideoChat extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeVideoChat";

  /// Username of the chat with the video chat.
  late String chat_username;

  /// If non-empty, invite hash to be used to join the video chat without being muted by administrators.
  late String invite_hash;

  /// True, if the video chat is expected to be a live stream in a channel or a broadcast group.
  late bool is_live_stream;

  /// The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link
  InternalLinkTypeVideoChat(
      {required this.chat_username,
      required this.invite_hash,
      required this.is_live_stream,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeVideoChat',
      if (extra != null) '@extra': extra,
      'chat_username': chat_username,
      'invite_hash': invite_hash,
      'is_live_stream': is_live_stream
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeVideoChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_username = _map['chat_username']! as String;
    var invite_hash = _map['invite_hash']! as String;
    var is_live_stream = _map['is_live_stream']! as bool;
    return InternalLinkTypeVideoChat(
      extra: extra,
      clientId: clientId,
      chat_username: chat_username,
      invite_hash: invite_hash,
      is_live_stream: is_live_stream,
    );
  }
}

/// The link is a link to a Web App. Call searchPublicChat with the given bot username, check that the user is a bot, then call searchWebApp with the received bot and the given web_app_short_name..
///
class InternalLinkTypeWebApp extends InternalLinkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "internalLinkTypeWebApp";

  /// Username of the bot that owns the Web App.
  late String bot_username;

  /// Short name of the Web App.
  late String web_app_short_name;

  /// Start parameter to be passed to getWebAppLinkUrl.
  late String start_parameter;

  /// The link is a link to a Web App. Call searchPublicChat with the given bot username, check that the user is a bot, then call searchWebApp with the received bot and the given web_app_short_name.
  InternalLinkTypeWebApp(
      {required this.bot_username,
      required this.web_app_short_name,
      required this.start_parameter,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'internalLinkTypeWebApp',
      if (extra != null) '@extra': extra,
      'bot_username': bot_username,
      'web_app_short_name': web_app_short_name,
      'start_parameter': start_parameter
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InternalLinkTypeWebApp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_username = _map['bot_username']! as String;
    var web_app_short_name = _map['web_app_short_name']! as String;
    var start_parameter = _map['start_parameter']! as String;
    return InternalLinkTypeWebApp(
      extra: extra,
      clientId: clientId,
      bot_username: bot_username,
      web_app_short_name: web_app_short_name,
      start_parameter: start_parameter,
    );
  }
}

/// Contains an HTTPS link to a message in a supergroup or channel, or a forum topic.
///
class MessageLink extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageLink";

  /// The link.
  late String link;

  /// True, if the link will work for non-members of the chat.
  late bool is_public;

  /// Contains an HTTPS link to a message in a supergroup or channel, or a forum topic
  MessageLink(
      {required this.link, required this.is_public, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageLink',
      if (extra != null) '@extra': extra,
      'link': link,
      'is_public': is_public
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = _map['link']! as String;
    var is_public = _map['is_public']! as bool;
    return MessageLink(
      extra: extra,
      clientId: clientId,
      link: link,
      is_public: is_public,
    );
  }
}

/// Contains information about a link to a message or a forum topic in a chat.
///
class MessageLinkInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageLinkInfo";

  /// True, if the link is a public link for a message or a forum topic in a chat.
  late bool is_public;

  /// If found, identifier of the chat to which the link points, 0 otherwise.
  late int chat_id;

  /// If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing.
  late int message_thread_id;

  /// If found, the linked message; may be null.
  Message? message;

  /// Timestamp from which the video/audio/video note/voice note playing must start, in seconds; 0 if not specified. The media can be in the message content or in its web page preview.
  late int media_timestamp;

  /// True, if the whole media album to which the message belongs is linked.
  late bool for_album;

  /// Contains information about a link to a message or a forum topic in a chat
  MessageLinkInfo(
      {required this.is_public,
      required this.chat_id,
      required this.message_thread_id,
      this.message,
      required this.media_timestamp,
      required this.for_album,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageLinkInfo',
      if (extra != null) '@extra': extra,
      'is_public': is_public,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'message': message,
      'media_timestamp': media_timestamp,
      'for_album': for_album
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageLinkInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_public = _map['is_public']! as bool;
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var message = Message.fromMap(_map['message']);
    var media_timestamp = _map['media_timestamp']! as int;
    var for_album = _map['for_album']! as bool;
    return MessageLinkInfo(
      extra: extra,
      clientId: clientId,
      is_public: is_public,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      message: message,
      media_timestamp: media_timestamp,
      for_album: for_album,
    );
  }
}

/// Contains an HTTPS link to boost a chat.
///
class ChatBoostLink extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatBoostLink";

  /// The link.
  late String link;

  /// True, if the link will work for non-members of the chat.
  late bool is_public;

  /// Contains an HTTPS link to boost a chat
  ChatBoostLink(
      {required this.link, required this.is_public, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatBoostLink',
      if (extra != null) '@extra': extra,
      'link': link,
      'is_public': is_public
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatBoostLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = _map['link']! as String;
    var is_public = _map['is_public']! as bool;
    return ChatBoostLink(
      extra: extra,
      clientId: clientId,
      link: link,
      is_public: is_public,
    );
  }
}

/// Contains information about a link to boost a a chat.
///
class ChatBoostLinkInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatBoostLinkInfo";

  /// True, if the link will work for non-members of the chat.
  late bool is_public;

  /// Identifier of the chat to which the link points; 0 if the chat isn't found.
  late int chat_id;

  /// Contains information about a link to boost a a chat
  ChatBoostLinkInfo(
      {required this.is_public,
      required this.chat_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatBoostLinkInfo',
      if (extra != null) '@extra': extra,
      'is_public': is_public,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatBoostLinkInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_public = _map['is_public']! as bool;
    var chat_id = _map['chat_id']! as int;
    return ChatBoostLinkInfo(
      extra: extra,
      clientId: clientId,
      is_public: is_public,
      chat_id: chat_id,
    );
  }
}

/// The main block list that disallows writing messages to the current user, receiving their status and photo, viewing of stories, and some other actions.
///
class BlockListMain extends BlockList {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "blockListMain";

  /// The main block list that disallows writing messages to the current user, receiving their status and photo, viewing of stories, and some other actions
  BlockListMain({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'blockListMain', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BlockListMain? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return BlockListMain(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The block list that disallows viewing of stories of the current user.
///
class BlockListStories extends BlockList {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "blockListStories";

  /// The block list that disallows viewing of stories of the current user
  BlockListStories({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'blockListStories', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BlockListStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return BlockListStories(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains a part of a file.
///
class FilePart extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "filePart";

  /// File bytes.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// Contains a part of a file
  FilePart({required this.data, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'filePart',
      if (extra != null) '@extra': extra,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FilePart? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var data = _map['data']! as bytes;
    return FilePart(
      extra: extra,
      clientId: clientId,
      data: data,
    );
  }
}

/// The data is not a file.
///
class FileTypeNone extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeNone";

  /// The data is not a file
  FileTypeNone({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeNone', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeNone? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeNone(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is an animation.
///
class FileTypeAnimation extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeAnimation";

  /// The file is an animation
  FileTypeAnimation({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeAnimation', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeAnimation(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is an audio file.
///
class FileTypeAudio extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeAudio";

  /// The file is an audio file
  FileTypeAudio({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeAudio', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeAudio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeAudio(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a document.
///
class FileTypeDocument extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeDocument";

  /// The file is a document
  FileTypeDocument({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeDocument', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeDocument? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeDocument(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a notification sound.
///
class FileTypeNotificationSound extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeNotificationSound";

  /// The file is a notification sound
  FileTypeNotificationSound({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'fileTypeNotificationSound',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeNotificationSound? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeNotificationSound(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a photo.
///
class FileTypePhoto extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypePhoto";

  /// The file is a photo
  FileTypePhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypePhoto', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypePhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a photo published as a story.
///
class FileTypePhotoStory extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypePhotoStory";

  /// The file is a photo published as a story
  FileTypePhotoStory({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypePhotoStory', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypePhotoStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypePhotoStory(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a profile photo.
///
class FileTypeProfilePhoto extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeProfilePhoto";

  /// The file is a profile photo
  FileTypeProfilePhoto({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'fileTypeProfilePhoto',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeProfilePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeProfilePhoto(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file was sent to a secret chat (the file type is not known to the server).
///
class FileTypeSecret extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeSecret";

  /// The file was sent to a secret chat (the file type is not known to the server)
  FileTypeSecret({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeSecret', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeSecret? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeSecret(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a thumbnail of a file from a secret chat.
///
class FileTypeSecretThumbnail extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeSecretThumbnail";

  /// The file is a thumbnail of a file from a secret chat
  FileTypeSecretThumbnail({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'fileTypeSecretThumbnail',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeSecretThumbnail? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeSecretThumbnail(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a file from Secure storage used for storing Telegram Passport files.
///
class FileTypeSecure extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeSecure";

  /// The file is a file from Secure storage used for storing Telegram Passport files
  FileTypeSecure({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeSecure', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeSecure? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeSecure(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a sticker.
///
class FileTypeSticker extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeSticker";

  /// The file is a sticker
  FileTypeSticker({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeSticker', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeSticker(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a thumbnail of another file.
///
class FileTypeThumbnail extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeThumbnail";

  /// The file is a thumbnail of another file
  FileTypeThumbnail({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeThumbnail', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeThumbnail? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeThumbnail(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file type is not yet known.
///
class FileTypeUnknown extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeUnknown";

  /// The file type is not yet known
  FileTypeUnknown({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeUnknown', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeUnknown? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeUnknown(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a video.
///
class FileTypeVideo extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeVideo";

  /// The file is a video
  FileTypeVideo({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeVideo', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeVideo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeVideo(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a video note.
///
class FileTypeVideoNote extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeVideoNote";

  /// The file is a video note
  FileTypeVideoNote({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeVideoNote', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeVideoNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeVideoNote(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a video published as a story.
///
class FileTypeVideoStory extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeVideoStory";

  /// The file is a video published as a story
  FileTypeVideoStory({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeVideoStory', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeVideoStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeVideoStory(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a voice note.
///
class FileTypeVoiceNote extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeVoiceNote";

  /// The file is a voice note
  FileTypeVoiceNote({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeVoiceNote', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeVoiceNote? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeVoiceNote(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The file is a wallpaper or a background pattern.
///
class FileTypeWallpaper extends FileType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileTypeWallpaper";

  /// The file is a wallpaper or a background pattern
  FileTypeWallpaper({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'fileTypeWallpaper', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileTypeWallpaper? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return FileTypeWallpaper(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains the storage usage statistics for a specific file type.
///
class StorageStatisticsByFileType extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storageStatisticsByFileType";

  /// File type.
  late FileType file_type;

  /// Total size of the files, in bytes.
  late int size;

  /// Total number of files.
  late int count;

  /// Contains the storage usage statistics for a specific file type
  StorageStatisticsByFileType(
      {required this.file_type,
      required this.size,
      required this.count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storageStatisticsByFileType',
      if (extra != null) '@extra': extra,
      'file_type': file_type,
      'size': size,
      'count': count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StorageStatisticsByFileType? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_type = FileType.fromMap(_map['file_type'])!;
    var size = _map['size']! as int;
    var count = _map['count']! as int;
    return StorageStatisticsByFileType(
      extra: extra,
      clientId: clientId,
      file_type: file_type,
      size: size,
      count: count,
    );
  }
}

/// Contains the storage usage statistics for a specific chat.
///
class StorageStatisticsByChat extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storageStatisticsByChat";

  /// Chat identifier; 0 if none.
  late int chat_id;

  /// Total size of the files in the chat, in bytes.
  late int size;

  /// Total number of files in the chat.
  late int count;

  /// Statistics split by file types.
  late List<StorageStatisticsByFileType> by_file_type;

  /// Contains the storage usage statistics for a specific chat
  StorageStatisticsByChat(
      {required this.chat_id,
      required this.size,
      required this.count,
      required this.by_file_type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storageStatisticsByChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'size': size,
      'count': count,
      'by_file_type': by_file_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StorageStatisticsByChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var size = _map['size']! as int;
    var count = _map['count']! as int;
    var by_file_type = List<StorageStatisticsByFileType>.from(
      (_map["by_file_type"] ?? []).map(
        (e) => StorageStatisticsByFileType.fromMap(e),
      ),
    );
    return StorageStatisticsByChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      size: size,
      count: count,
      by_file_type: by_file_type,
    );
  }
}

/// Contains the exact storage usage statistics split by chats and file type.
///
class StorageStatistics extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storageStatistics";

  /// Total size of files, in bytes.
  late int size;

  /// Total number of files.
  late int count;

  /// Statistics split by chats.
  late List<StorageStatisticsByChat> by_chat;

  /// Contains the exact storage usage statistics split by chats and file type
  StorageStatistics(
      {required this.size,
      required this.count,
      required this.by_chat,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storageStatistics',
      if (extra != null) '@extra': extra,
      'size': size,
      'count': count,
      'by_chat': by_chat
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StorageStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var size = _map['size']! as int;
    var count = _map['count']! as int;
    var by_chat = List<StorageStatisticsByChat>.from(
      (_map["by_chat"] ?? []).map(
        (e) => StorageStatisticsByChat.fromMap(e),
      ),
    );
    return StorageStatistics(
      extra: extra,
      clientId: clientId,
      size: size,
      count: count,
      by_chat: by_chat,
    );
  }
}

/// Contains approximate storage usage statistics, excluding files of unknown file type.
///
class StorageStatisticsFast extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "storageStatisticsFast";

  /// Approximate total size of files, in bytes.
  late int files_size;

  /// Approximate number of files.
  late int file_count;

  /// Size of the database.
  late int database_size;

  /// Size of the language pack database.
  late int language_pack_database_size;

  /// Size of the TDLib internal log.
  late int log_size;

  /// Contains approximate storage usage statistics, excluding files of unknown file type
  StorageStatisticsFast(
      {required this.files_size,
      required this.file_count,
      required this.database_size,
      required this.language_pack_database_size,
      required this.log_size,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'storageStatisticsFast',
      if (extra != null) '@extra': extra,
      'files_size': files_size,
      'file_count': file_count,
      'database_size': database_size,
      'language_pack_database_size': language_pack_database_size,
      'log_size': log_size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StorageStatisticsFast? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var files_size = _map['files_size']! as int;
    var file_count = _map['file_count']! as int;
    var database_size = _map['database_size']! as int;
    var language_pack_database_size =
        _map['language_pack_database_size']! as int;
    var log_size = _map['log_size']! as int;
    return StorageStatisticsFast(
      extra: extra,
      clientId: clientId,
      files_size: files_size,
      file_count: file_count,
      database_size: database_size,
      language_pack_database_size: language_pack_database_size,
      log_size: log_size,
    );
  }
}

/// Contains database statistics.
///
class DatabaseStatistics extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "databaseStatistics";

  /// Database statistics in an unspecified human-readable format.
  late String statistics;

  /// Contains database statistics
  DatabaseStatistics({required this.statistics, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'databaseStatistics',
      if (extra != null) '@extra': extra,
      'statistics': statistics
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DatabaseStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var statistics = _map['statistics']! as String;
    return DatabaseStatistics(
      extra: extra,
      clientId: clientId,
      statistics: statistics,
    );
  }
}

/// The network is not available.
///
class NetworkTypeNone extends NetworkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "networkTypeNone";

  /// The network is not available
  NetworkTypeNone({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'networkTypeNone', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NetworkTypeNone? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NetworkTypeNone(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A mobile network.
///
class NetworkTypeMobile extends NetworkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "networkTypeMobile";

  /// A mobile network
  NetworkTypeMobile({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'networkTypeMobile', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NetworkTypeMobile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NetworkTypeMobile(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A mobile roaming network.
///
class NetworkTypeMobileRoaming extends NetworkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "networkTypeMobileRoaming";

  /// A mobile roaming network
  NetworkTypeMobileRoaming({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'networkTypeMobileRoaming',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NetworkTypeMobileRoaming? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NetworkTypeMobileRoaming(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A Wi-Fi network.
///
class NetworkTypeWiFi extends NetworkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "networkTypeWiFi";

  /// A Wi-Fi network
  NetworkTypeWiFi({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'networkTypeWiFi', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NetworkTypeWiFi? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NetworkTypeWiFi(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A different network type (e.g., Ethernet network).
///
class NetworkTypeOther extends NetworkType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "networkTypeOther";

  /// A different network type (e.g., Ethernet network)
  NetworkTypeOther({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'networkTypeOther', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NetworkTypeOther? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return NetworkTypeOther(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains information about the total amount of data that was used to send and receive files.
///
class NetworkStatisticsEntryFile extends NetworkStatisticsEntry {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "networkStatisticsEntryFile";

  /// Type of the file the data is part of; pass null if the data isn't related to files.
  FileType? file_type;

  /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type.
  late NetworkType network_type;

  /// Total number of bytes sent.
  late int sent_bytes;

  /// Total number of bytes received.
  late int received_bytes;

  /// Contains information about the total amount of data that was used to send and receive files
  NetworkStatisticsEntryFile(
      {this.file_type,
      required this.network_type,
      required this.sent_bytes,
      required this.received_bytes,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'networkStatisticsEntryFile',
      if (extra != null) '@extra': extra,
      'file_type': file_type,
      'network_type': network_type,
      'sent_bytes': sent_bytes,
      'received_bytes': received_bytes
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NetworkStatisticsEntryFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_type = FileType.fromMap(_map['file_type']);
    var network_type = NetworkType.fromMap(_map['network_type'])!;
    var sent_bytes = _map['sent_bytes']! as int;
    var received_bytes = _map['received_bytes']! as int;
    return NetworkStatisticsEntryFile(
      extra: extra,
      clientId: clientId,
      file_type: file_type,
      network_type: network_type,
      sent_bytes: sent_bytes,
      received_bytes: received_bytes,
    );
  }
}

/// Contains information about the total amount of data that was used for calls.
///
class NetworkStatisticsEntryCall extends NetworkStatisticsEntry {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "networkStatisticsEntryCall";

  /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type.
  late NetworkType network_type;

  /// Total number of bytes sent.
  late int sent_bytes;

  /// Total number of bytes received.
  late int received_bytes;

  /// Total call duration, in seconds.
  late double duration;

  /// Contains information about the total amount of data that was used for calls
  NetworkStatisticsEntryCall(
      {required this.network_type,
      required this.sent_bytes,
      required this.received_bytes,
      required this.duration,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'networkStatisticsEntryCall',
      if (extra != null) '@extra': extra,
      'network_type': network_type,
      'sent_bytes': sent_bytes,
      'received_bytes': received_bytes,
      'duration': duration
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NetworkStatisticsEntryCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var network_type = NetworkType.fromMap(_map['network_type'])!;
    var sent_bytes = _map['sent_bytes']! as int;
    var received_bytes = _map['received_bytes']! as int;
    var duration = _map['duration']! as double;
    return NetworkStatisticsEntryCall(
      extra: extra,
      clientId: clientId,
      network_type: network_type,
      sent_bytes: sent_bytes,
      received_bytes: received_bytes,
      duration: duration,
    );
  }
}

/// A full list of available network statistic entries.
///
class NetworkStatistics extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "networkStatistics";

  /// Point in time (Unix timestamp) from which the statistics are collected.
  late int since_date;

  /// Network statistics entries.
  late List<NetworkStatisticsEntry> entries;

  /// A full list of available network statistic entries
  NetworkStatistics(
      {required this.since_date,
      required this.entries,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'networkStatistics',
      if (extra != null) '@extra': extra,
      'since_date': since_date,
      'entries': entries
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static NetworkStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var since_date = _map['since_date']! as int;
    var entries = List<NetworkStatisticsEntry>.from(
      (_map["entries"] ?? []).map(
        (e) => NetworkStatisticsEntry.fromMap(e),
      ),
    );
    return NetworkStatistics(
      extra: extra,
      clientId: clientId,
      since_date: since_date,
      entries: entries,
    );
  }
}

/// Contains auto-download settings.
///
class AutoDownloadSettings extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "autoDownloadSettings";

  /// True, if the auto-download is enabled.
  late bool is_auto_download_enabled;

  /// The maximum size of a photo file to be auto-downloaded, in bytes.
  late int max_photo_file_size;

  /// The maximum size of a video file to be auto-downloaded, in bytes.
  late int max_video_file_size;

  /// The maximum size of other file types to be auto-downloaded, in bytes.
  late int max_other_file_size;

  /// The maximum suggested bitrate for uploaded videos, in kbit/s.
  late int video_upload_bitrate;

  /// True, if the beginning of video files needs to be preloaded for instant playback.
  late bool preload_large_videos;

  /// True, if the next audio track needs to be preloaded while the user is listening to an audio file.
  late bool preload_next_audio;

  /// True, if stories needs to be preloaded.
  late bool preload_stories;

  /// True, if "use less data for calls" option needs to be enabled.
  late bool use_less_data_for_calls;

  /// Contains auto-download settings
  AutoDownloadSettings(
      {required this.is_auto_download_enabled,
      required this.max_photo_file_size,
      required this.max_video_file_size,
      required this.max_other_file_size,
      required this.video_upload_bitrate,
      required this.preload_large_videos,
      required this.preload_next_audio,
      required this.preload_stories,
      required this.use_less_data_for_calls,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'autoDownloadSettings',
      if (extra != null) '@extra': extra,
      'is_auto_download_enabled': is_auto_download_enabled,
      'max_photo_file_size': max_photo_file_size,
      'max_video_file_size': max_video_file_size,
      'max_other_file_size': max_other_file_size,
      'video_upload_bitrate': video_upload_bitrate,
      'preload_large_videos': preload_large_videos,
      'preload_next_audio': preload_next_audio,
      'preload_stories': preload_stories,
      'use_less_data_for_calls': use_less_data_for_calls
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AutoDownloadSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_auto_download_enabled = _map['is_auto_download_enabled']! as bool;
    var max_photo_file_size = _map['max_photo_file_size']! as int;
    var max_video_file_size = _map['max_video_file_size']! as int;
    var max_other_file_size = _map['max_other_file_size']! as int;
    var video_upload_bitrate = _map['video_upload_bitrate']! as int;
    var preload_large_videos = _map['preload_large_videos']! as bool;
    var preload_next_audio = _map['preload_next_audio']! as bool;
    var preload_stories = _map['preload_stories']! as bool;
    var use_less_data_for_calls = _map['use_less_data_for_calls']! as bool;
    return AutoDownloadSettings(
      extra: extra,
      clientId: clientId,
      is_auto_download_enabled: is_auto_download_enabled,
      max_photo_file_size: max_photo_file_size,
      max_video_file_size: max_video_file_size,
      max_other_file_size: max_other_file_size,
      video_upload_bitrate: video_upload_bitrate,
      preload_large_videos: preload_large_videos,
      preload_next_audio: preload_next_audio,
      preload_stories: preload_stories,
      use_less_data_for_calls: use_less_data_for_calls,
    );
  }
}

/// Contains auto-download settings presets for the current user.
///
class AutoDownloadSettingsPresets extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "autoDownloadSettingsPresets";

  /// Preset with lowest settings; supposed to be used by default when roaming.
  late AutoDownloadSettings low;

  /// Preset with medium settings; supposed to be used by default when using mobile data.
  late AutoDownloadSettings medium;

  /// Preset with highest settings; supposed to be used by default when connected on Wi-Fi.
  late AutoDownloadSettings high;

  /// Contains auto-download settings presets for the current user
  AutoDownloadSettingsPresets(
      {required this.low,
      required this.medium,
      required this.high,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'autoDownloadSettingsPresets',
      if (extra != null) '@extra': extra,
      'low': low,
      'medium': medium,
      'high': high
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AutoDownloadSettingsPresets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var low = AutoDownloadSettings.fromMap(_map['low'])!;
    var medium = AutoDownloadSettings.fromMap(_map['medium'])!;
    var high = AutoDownloadSettings.fromMap(_map['high'])!;
    return AutoDownloadSettingsPresets(
      extra: extra,
      clientId: clientId,
      low: low,
      medium: medium,
      high: high,
    );
  }
}

/// Autosave settings applied to all private chats without chat-specific settings.
///
class AutosaveSettingsScopePrivateChats extends AutosaveSettingsScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "autosaveSettingsScopePrivateChats";

  /// Autosave settings applied to all private chats without chat-specific settings
  AutosaveSettingsScopePrivateChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'autosaveSettingsScopePrivateChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AutosaveSettingsScopePrivateChats? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return AutosaveSettingsScopePrivateChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Autosave settings applied to all basic group and supergroup chats without chat-specific settings.
///
class AutosaveSettingsScopeGroupChats extends AutosaveSettingsScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "autosaveSettingsScopeGroupChats";

  /// Autosave settings applied to all basic group and supergroup chats without chat-specific settings
  AutosaveSettingsScopeGroupChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'autosaveSettingsScopeGroupChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AutosaveSettingsScopeGroupChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return AutosaveSettingsScopeGroupChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Autosave settings applied to all channel chats without chat-specific settings.
///
class AutosaveSettingsScopeChannelChats extends AutosaveSettingsScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "autosaveSettingsScopeChannelChats";

  /// Autosave settings applied to all channel chats without chat-specific settings
  AutosaveSettingsScopeChannelChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'autosaveSettingsScopeChannelChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AutosaveSettingsScopeChannelChats? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return AutosaveSettingsScopeChannelChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Autosave settings applied to a chat.
///
class AutosaveSettingsScopeChat extends AutosaveSettingsScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "autosaveSettingsScopeChat";

  /// Chat identifier.
  late int chat_id;

  /// Autosave settings applied to a chat
  AutosaveSettingsScopeChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'autosaveSettingsScopeChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AutosaveSettingsScopeChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return AutosaveSettingsScopeChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Contains autosave settings for an autosave settings scope.
///
class ScopeAutosaveSettings extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "scopeAutosaveSettings";

  /// True, if photo autosave is enabled.
  late bool autosave_photos;

  /// True, if video autosave is enabled.
  late bool autosave_videos;

  /// The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB.
  late int max_video_file_size;

  /// Contains autosave settings for an autosave settings scope
  ScopeAutosaveSettings(
      {required this.autosave_photos,
      required this.autosave_videos,
      required this.max_video_file_size,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'scopeAutosaveSettings',
      if (extra != null) '@extra': extra,
      'autosave_photos': autosave_photos,
      'autosave_videos': autosave_videos,
      'max_video_file_size': max_video_file_size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ScopeAutosaveSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var autosave_photos = _map['autosave_photos']! as bool;
    var autosave_videos = _map['autosave_videos']! as bool;
    var max_video_file_size = _map['max_video_file_size']! as int;
    return ScopeAutosaveSettings(
      extra: extra,
      clientId: clientId,
      autosave_photos: autosave_photos,
      autosave_videos: autosave_videos,
      max_video_file_size: max_video_file_size,
    );
  }
}

/// Contains autosave settings for a chat, which overrides default settings for the corresponding scope.
///
class AutosaveSettingsException extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "autosaveSettingsException";

  /// Chat identifier.
  late int chat_id;

  /// Autosave settings for the chat.
  late ScopeAutosaveSettings settings;

  /// Contains autosave settings for a chat, which overrides default settings for the corresponding scope
  AutosaveSettingsException(
      {required this.chat_id,
      required this.settings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'autosaveSettingsException',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'settings': settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AutosaveSettingsException? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var settings = ScopeAutosaveSettings.fromMap(_map['settings'])!;
    return AutosaveSettingsException(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      settings: settings,
    );
  }
}

/// Describes autosave settings.
///
class AutosaveSettings extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "autosaveSettings";

  /// Default autosave settings for private chats.
  late ScopeAutosaveSettings private_chat_settings;

  /// Default autosave settings for basic group and supergroup chats.
  late ScopeAutosaveSettings group_settings;

  /// Default autosave settings for channel chats.
  late ScopeAutosaveSettings channel_settings;

  /// Autosave settings for specific chats.
  late List<AutosaveSettingsException> exceptions;

  /// Describes autosave settings
  AutosaveSettings(
      {required this.private_chat_settings,
      required this.group_settings,
      required this.channel_settings,
      required this.exceptions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'autosaveSettings',
      if (extra != null) '@extra': extra,
      'private_chat_settings': private_chat_settings,
      'group_settings': group_settings,
      'channel_settings': channel_settings,
      'exceptions': exceptions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AutosaveSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var private_chat_settings =
        ScopeAutosaveSettings.fromMap(_map['private_chat_settings'])!;
    var group_settings = ScopeAutosaveSettings.fromMap(_map['group_settings'])!;
    var channel_settings =
        ScopeAutosaveSettings.fromMap(_map['channel_settings'])!;
    var exceptions = List<AutosaveSettingsException>.from(
      (_map["exceptions"] ?? []).map(
        (e) => AutosaveSettingsException.fromMap(e),
      ),
    );
    return AutosaveSettings(
      extra: extra,
      clientId: clientId,
      private_chat_settings: private_chat_settings,
      group_settings: group_settings,
      channel_settings: channel_settings,
      exceptions: exceptions,
    );
  }
}

/// Currently waiting for the network to become available. Use setNetworkType to change the available network type.
///
class ConnectionStateWaitingForNetwork extends ConnectionState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "connectionStateWaitingForNetwork";

  /// Currently waiting for the network to become available. Use setNetworkType to change the available network type
  ConnectionStateWaitingForNetwork({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'connectionStateWaitingForNetwork',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ConnectionStateWaitingForNetwork? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ConnectionStateWaitingForNetwork(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Currently establishing a connection with a proxy server.
///
class ConnectionStateConnectingToProxy extends ConnectionState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "connectionStateConnectingToProxy";

  /// Currently establishing a connection with a proxy server
  ConnectionStateConnectingToProxy({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'connectionStateConnectingToProxy',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ConnectionStateConnectingToProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ConnectionStateConnectingToProxy(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Currently establishing a connection to the Telegram servers.
///
class ConnectionStateConnecting extends ConnectionState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "connectionStateConnecting";

  /// Currently establishing a connection to the Telegram servers
  ConnectionStateConnecting({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'connectionStateConnecting',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ConnectionStateConnecting? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ConnectionStateConnecting(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Downloading data received while the application was offline.
///
class ConnectionStateUpdating extends ConnectionState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "connectionStateUpdating";

  /// Downloading data received while the application was offline
  ConnectionStateUpdating({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'connectionStateUpdating',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ConnectionStateUpdating? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ConnectionStateUpdating(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// There is a working connection to the Telegram servers.
///
class ConnectionStateReady extends ConnectionState {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "connectionStateReady";

  /// There is a working connection to the Telegram servers
  ConnectionStateReady({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'connectionStateReady',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ConnectionStateReady? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ConnectionStateReady(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A category containing frequently used private chats with non-bot users.
///
class TopChatCategoryUsers extends TopChatCategory {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "topChatCategoryUsers";

  /// A category containing frequently used private chats with non-bot users
  TopChatCategoryUsers({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'topChatCategoryUsers',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TopChatCategoryUsers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TopChatCategoryUsers(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A category containing frequently used private chats with bot users.
///
class TopChatCategoryBots extends TopChatCategory {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "topChatCategoryBots";

  /// A category containing frequently used private chats with bot users
  TopChatCategoryBots({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'topChatCategoryBots', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TopChatCategoryBots? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TopChatCategoryBots(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A category containing frequently used basic groups and supergroups.
///
class TopChatCategoryGroups extends TopChatCategory {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "topChatCategoryGroups";

  /// A category containing frequently used basic groups and supergroups
  TopChatCategoryGroups({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'topChatCategoryGroups',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TopChatCategoryGroups? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TopChatCategoryGroups(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A category containing frequently used channels.
///
class TopChatCategoryChannels extends TopChatCategory {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "topChatCategoryChannels";

  /// A category containing frequently used channels
  TopChatCategoryChannels({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'topChatCategoryChannels',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TopChatCategoryChannels? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TopChatCategoryChannels(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A category containing frequently used chats with inline bots sorted by their usage in inline mode.
///
class TopChatCategoryInlineBots extends TopChatCategory {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "topChatCategoryInlineBots";

  /// A category containing frequently used chats with inline bots sorted by their usage in inline mode
  TopChatCategoryInlineBots({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'topChatCategoryInlineBots',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TopChatCategoryInlineBots? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TopChatCategoryInlineBots(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A category containing frequently used chats used for calls.
///
class TopChatCategoryCalls extends TopChatCategory {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "topChatCategoryCalls";

  /// A category containing frequently used chats used for calls
  TopChatCategoryCalls({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'topChatCategoryCalls',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TopChatCategoryCalls? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TopChatCategoryCalls(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A category containing frequently used chats used to forward messages.
///
class TopChatCategoryForwardChats extends TopChatCategory {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "topChatCategoryForwardChats";

  /// A category containing frequently used chats used to forward messages
  TopChatCategoryForwardChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'topChatCategoryForwardChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TopChatCategoryForwardChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TopChatCategoryForwardChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains 0-based positions of matched objects.
///
class FoundPositions extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "foundPositions";

  /// Total number of matched objects.
  late int total_count;

  /// The positions of the matched objects.
  late List<int> positions;

  /// Contains 0-based positions of matched objects
  FoundPositions(
      {required this.total_count,
      required this.positions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'foundPositions',
      if (extra != null) '@extra': extra,
      'total_count': total_count,
      'positions': positions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FoundPositions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_count = _map['total_count']! as int;
    var positions = List<int>.from(
      (_map["positions"] ?? []).map(
        (e) => e as int,
      ),
    );
    return FoundPositions(
      extra: extra,
      clientId: clientId,
      total_count: total_count,
      positions: positions,
    );
  }
}

/// A URL linking to a user.
///
class TMeUrlTypeUser extends TMeUrlType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "tMeUrlTypeUser";

  /// Identifier of the user.
  late int user_id;

  /// A URL linking to a user
  TMeUrlTypeUser({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'tMeUrlTypeUser',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TMeUrlTypeUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return TMeUrlTypeUser(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// A URL linking to a public supergroup or channel.
///
class TMeUrlTypeSupergroup extends TMeUrlType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "tMeUrlTypeSupergroup";

  /// Identifier of the supergroup or channel.
  late int supergroup_id;

  /// A URL linking to a public supergroup or channel
  TMeUrlTypeSupergroup(
      {required this.supergroup_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'tMeUrlTypeSupergroup',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TMeUrlTypeSupergroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    return TMeUrlTypeSupergroup(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
    );
  }
}

/// A chat invite link.
///
class TMeUrlTypeChatInvite extends TMeUrlType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "tMeUrlTypeChatInvite";

  /// Information about the chat invite link.
  late ChatInviteLinkInfo info;

  /// A chat invite link
  TMeUrlTypeChatInvite({required this.info, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'tMeUrlTypeChatInvite',
      if (extra != null) '@extra': extra,
      'info': info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TMeUrlTypeChatInvite? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var info = ChatInviteLinkInfo.fromMap(_map['info'])!;
    return TMeUrlTypeChatInvite(
      extra: extra,
      clientId: clientId,
      info: info,
    );
  }
}

/// A URL linking to a sticker set.
///
class TMeUrlTypeStickerSet extends TMeUrlType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "tMeUrlTypeStickerSet";

  /// Identifier of the sticker set.
  /// ; string representation of int, use `int.parse`
  late int64 sticker_set_id;

  /// A URL linking to a sticker set
  TMeUrlTypeStickerSet(
      {required this.sticker_set_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'tMeUrlTypeStickerSet',
      if (extra != null) '@extra': extra,
      'sticker_set_id': sticker_set_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TMeUrlTypeStickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_set_id = _map['sticker_set_id']! as int64;
    return TMeUrlTypeStickerSet(
      extra: extra,
      clientId: clientId,
      sticker_set_id: sticker_set_id,
    );
  }
}

/// Represents a URL linking to an internal Telegram entity.
///
class TMeUrl extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "tMeUrl";

  /// URL.
  late String url;

  /// Type of the URL.
  late TMeUrlType type;

  /// Represents a URL linking to an internal Telegram entity
  TMeUrl({required this.url, required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'tMeUrl',
      if (extra != null) '@extra': extra,
      'url': url,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TMeUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var type = TMeUrlType.fromMap(_map['type'])!;
    return TMeUrl(
      extra: extra,
      clientId: clientId,
      url: url,
      type: type,
    );
  }
}

/// Contains a list of t.me URLs.
///
class TMeUrls extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "tMeUrls";

  /// List of URLs.
  late List<TMeUrl> urls;

  /// Contains a list of t.me URLs
  TMeUrls({required this.urls, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'tMeUrls',
      if (extra != null) '@extra': extra,
      'urls': urls
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TMeUrls? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var urls = List<TMeUrl>.from(
      (_map["urls"] ?? []).map(
        (e) => TMeUrl.fromMap(e),
      ),
    );
    return TMeUrls(
      extra: extra,
      clientId: clientId,
      urls: urls,
    );
  }
}

/// Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting in archiveChatListSettings.
///
class SuggestedActionEnableArchiveAndMuteNewChats extends SuggestedAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "suggestedActionEnableArchiveAndMuteNewChats";

  /// Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting in archiveChatListSettings
  SuggestedActionEnableArchiveAndMuteNewChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestedActionEnableArchiveAndMuteNewChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestedActionEnableArchiveAndMuteNewChats? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SuggestedActionEnableArchiveAndMuteNewChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Suggests the user to check whether they still remember their 2-step verification password.
///
class SuggestedActionCheckPassword extends SuggestedAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "suggestedActionCheckPassword";

  /// Suggests the user to check whether they still remember their 2-step verification password
  SuggestedActionCheckPassword({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestedActionCheckPassword',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestedActionCheckPassword? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SuggestedActionCheckPassword(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible.
///
class SuggestedActionCheckPhoneNumber extends SuggestedAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "suggestedActionCheckPhoneNumber";

  /// Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible
  SuggestedActionCheckPhoneNumber({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestedActionCheckPhoneNumber',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestedActionCheckPhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SuggestedActionCheckPhoneNumber(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Suggests the user to view a hint about the meaning of one and two check marks on sent messages.
///
class SuggestedActionViewChecksHint extends SuggestedAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "suggestedActionViewChecksHint";

  /// Suggests the user to view a hint about the meaning of one and two check marks on sent messages
  SuggestedActionViewChecksHint({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestedActionViewChecksHint',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestedActionViewChecksHint? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SuggestedActionViewChecksHint(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Suggests the user to convert specified supergroup to a broadcast group.
///
class SuggestedActionConvertToBroadcastGroup extends SuggestedAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "suggestedActionConvertToBroadcastGroup";

  /// Supergroup identifier.
  late int supergroup_id;

  /// Suggests the user to convert specified supergroup to a broadcast group
  SuggestedActionConvertToBroadcastGroup(
      {required this.supergroup_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestedActionConvertToBroadcastGroup',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestedActionConvertToBroadcastGroup? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    return SuggestedActionConvertToBroadcastGroup(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
    );
  }
}

/// Suggests the user to set a 2-step verification password to be able to log in again.
///
class SuggestedActionSetPassword extends SuggestedAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "suggestedActionSetPassword";

  /// The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons.
  late int authorization_delay;

  /// Suggests the user to set a 2-step verification password to be able to log in again
  SuggestedActionSetPassword(
      {required this.authorization_delay, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestedActionSetPassword',
      if (extra != null) '@extra': extra,
      'authorization_delay': authorization_delay
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestedActionSetPassword? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var authorization_delay = _map['authorization_delay']! as int;
    return SuggestedActionSetPassword(
      extra: extra,
      clientId: clientId,
      authorization_delay: authorization_delay,
    );
  }
}

/// Suggests the user to upgrade the Premium subscription from monthly payments to annual payments.
///
class SuggestedActionUpgradePremium extends SuggestedAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "suggestedActionUpgradePremium";

  /// Suggests the user to upgrade the Premium subscription from monthly payments to annual payments
  SuggestedActionUpgradePremium({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestedActionUpgradePremium',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestedActionUpgradePremium? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SuggestedActionUpgradePremium(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Suggests the user to restore a recently expired Premium subscription.
///
class SuggestedActionRestorePremium extends SuggestedAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "suggestedActionRestorePremium";

  /// Suggests the user to restore a recently expired Premium subscription
  SuggestedActionRestorePremium({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestedActionRestorePremium',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestedActionRestorePremium? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SuggestedActionRestorePremium(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Suggests the user to subscribe to the Premium subscription with annual payments.
///
class SuggestedActionSubscribeToAnnualPremium extends SuggestedAction {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "suggestedActionSubscribeToAnnualPremium";

  /// Suggests the user to subscribe to the Premium subscription with annual payments
  SuggestedActionSubscribeToAnnualPremium({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestedActionSubscribeToAnnualPremium',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestedActionSubscribeToAnnualPremium? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return SuggestedActionSubscribeToAnnualPremium(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains a counter.
///
class Count extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "count";

  /// Count.
  late int count;

  /// Contains a counter
  Count({required this.count, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'count',
      if (extra != null) '@extra': extra,
      'count': count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Count? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var count = _map['count']! as int;
    return Count(
      extra: extra,
      clientId: clientId,
      count: count,
    );
  }
}

/// Contains some text.
///
class Text extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "text";

  /// Text.
  late String text;

  /// Contains some text
  Text({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'text', if (extra != null) '@extra': extra, 'text': text};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Text? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    return Text(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// Contains a value representing a number of seconds.
///
class Seconds extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "seconds";

  /// Number of seconds.
  late double seconds;

  /// Contains a value representing a number of seconds
  Seconds({required this.seconds, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'seconds',
      if (extra != null) '@extra': extra,
      'seconds': seconds
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Seconds? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var seconds = _map['seconds']! as double;
    return Seconds(
      extra: extra,
      clientId: clientId,
      seconds: seconds,
    );
  }
}

/// Contains size of downloaded prefix of a file.
///
class FileDownloadedPrefixSize extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "fileDownloadedPrefixSize";

  /// The prefix size, in bytes.
  late int size;

  /// Contains size of downloaded prefix of a file
  FileDownloadedPrefixSize({required this.size, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'fileDownloadedPrefixSize',
      if (extra != null) '@extra': extra,
      'size': size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FileDownloadedPrefixSize? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var size = _map['size']! as int;
    return FileDownloadedPrefixSize(
      extra: extra,
      clientId: clientId,
      size: size,
    );
  }
}

/// Contains information about a tg: deep link.
///
class DeepLinkInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deepLinkInfo";

  /// Text to be shown to the user.
  late FormattedText text;

  /// True, if the user must be asked to update the application.
  late bool need_update_application;

  /// Contains information about a tg: deep link
  DeepLinkInfo(
      {required this.text,
      required this.need_update_application,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deepLinkInfo',
      if (extra != null) '@extra': extra,
      'text': text,
      'need_update_application': need_update_application
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeepLinkInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = FormattedText.fromMap(_map['text'])!;
    var need_update_application = _map['need_update_application']! as bool;
    return DeepLinkInfo(
      extra: extra,
      clientId: clientId,
      text: text,
      need_update_application: need_update_application,
    );
  }
}

/// The text uses Markdown-style formatting.
///
class TextParseModeMarkdown extends TextParseMode {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textParseModeMarkdown";

  /// Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode.
  late int version;

  /// The text uses Markdown-style formatting
  TextParseModeMarkdown({required this.version, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'textParseModeMarkdown',
      if (extra != null) '@extra': extra,
      'version': version
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextParseModeMarkdown? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var version = _map['version']! as int;
    return TextParseModeMarkdown(
      extra: extra,
      clientId: clientId,
      version: version,
    );
  }
}

/// The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode.
///
class TextParseModeHTML extends TextParseMode {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "textParseModeHTML";

  /// The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode
  TextParseModeHTML({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'textParseModeHTML', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TextParseModeHTML? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TextParseModeHTML(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A SOCKS5 proxy server.
///
class ProxyTypeSocks5 extends ProxyType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "proxyTypeSocks5";

  /// Username for logging in; may be empty.
  late String username;

  /// Password for logging in; may be empty.
  late String password;

  /// A SOCKS5 proxy server
  ProxyTypeSocks5(
      {required this.username,
      required this.password,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'proxyTypeSocks5',
      if (extra != null) '@extra': extra,
      'username': username,
      'password': password
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ProxyTypeSocks5? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var username = _map['username']! as String;
    var password = _map['password']! as String;
    return ProxyTypeSocks5(
      extra: extra,
      clientId: clientId,
      username: username,
      password: password,
    );
  }
}

/// A HTTP transparent proxy server.
///
class ProxyTypeHttp extends ProxyType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "proxyTypeHttp";

  /// Username for logging in; may be empty.
  late String username;

  /// Password for logging in; may be empty.
  late String password;

  /// Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method.
  late bool http_only;

  /// A HTTP transparent proxy server
  ProxyTypeHttp(
      {required this.username,
      required this.password,
      required this.http_only,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'proxyTypeHttp',
      if (extra != null) '@extra': extra,
      'username': username,
      'password': password,
      'http_only': http_only
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ProxyTypeHttp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var username = _map['username']! as String;
    var password = _map['password']! as String;
    var http_only = _map['http_only']! as bool;
    return ProxyTypeHttp(
      extra: extra,
      clientId: clientId,
      username: username,
      password: password,
      http_only: http_only,
    );
  }
}

/// An MTProto proxy server.
///
class ProxyTypeMtproto extends ProxyType {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "proxyTypeMtproto";

  /// The proxy's secret in hexadecimal encoding.
  late String secret;

  /// An MTProto proxy server
  ProxyTypeMtproto({required this.secret, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'proxyTypeMtproto',
      if (extra != null) '@extra': extra,
      'secret': secret
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ProxyTypeMtproto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var secret = _map['secret']! as String;
    return ProxyTypeMtproto(
      extra: extra,
      clientId: clientId,
      secret: secret,
    );
  }
}

/// Contains information about a proxy server.
///
class Proxy extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "proxy";

  /// Unique identifier of the proxy.
  late int id;

  /// Proxy server domain or IP address.
  late String server;

  /// Proxy server port.
  late int port;

  /// Point in time (Unix timestamp) when the proxy was last used; 0 if never.
  late int last_used_date;

  /// True, if the proxy is enabled now.
  late bool is_enabled;

  /// Type of the proxy.
  late ProxyType type;

  /// Contains information about a proxy server
  Proxy(
      {required this.id,
      required this.server,
      required this.port,
      required this.last_used_date,
      required this.is_enabled,
      required this.type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'proxy',
      if (extra != null) '@extra': extra,
      'id': id,
      'server': server,
      'port': port,
      'last_used_date': last_used_date,
      'is_enabled': is_enabled,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Proxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int;
    var server = _map['server']! as String;
    var port = _map['port']! as int;
    var last_used_date = _map['last_used_date']! as int;
    var is_enabled = _map['is_enabled']! as bool;
    var type = ProxyType.fromMap(_map['type'])!;
    return Proxy(
      extra: extra,
      clientId: clientId,
      id: id,
      server: server,
      port: port,
      last_used_date: last_used_date,
      is_enabled: is_enabled,
      type: type,
    );
  }
}

/// Represents a list of proxy servers.
///
class Proxies extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "proxies";

  /// List of proxy servers.
  late List<Proxy> proxies;

  /// Represents a list of proxy servers
  Proxies({required this.proxies, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'proxies',
      if (extra != null) '@extra': extra,
      'proxies': proxies
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Proxies? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var proxies = List<Proxy>.from(
      (_map["proxies"] ?? []).map(
        (e) => Proxy.fromMap(e),
      ),
    );
    return Proxies(
      extra: extra,
      clientId: clientId,
      proxies: proxies,
    );
  }
}

/// A sticker to be added to a sticker set.
///
class InputSticker extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inputSticker";

  /// File with the sticker; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side..
  late InputFile sticker;

  /// String with 1-20 emoji corresponding to the sticker.
  late String emojis;

  /// Position where the mask is placed; pass null if not specified.
  MaskPosition? mask_position;

  /// List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker.
  late List<String> keywords;

  /// A sticker to be added to a sticker set
  InputSticker(
      {required this.sticker,
      required this.emojis,
      this.mask_position,
      required this.keywords,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inputSticker',
      if (extra != null) '@extra': extra,
      'sticker': sticker,
      'emojis': emojis,
      'mask_position': mask_position,
      'keywords': keywords
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InputSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    var emojis = _map['emojis']! as String;
    var mask_position = MaskPosition.fromMap(_map['mask_position']);
    var keywords = List<String>.from(
      (_map["keywords"] ?? []).map(
        (e) => e as String,
      ),
    );
    return InputSticker(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
      emojis: emojis,
      mask_position: mask_position,
      keywords: keywords,
    );
  }
}

/// Represents a date range.
///
class DateRange extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "dateRange";

  /// Point in time (Unix timestamp) at which the date range begins.
  late int start_date;

  /// Point in time (Unix timestamp) at which the date range ends.
  late int end_date;

  /// Represents a date range
  DateRange(
      {required this.start_date,
      required this.end_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'dateRange',
      if (extra != null) '@extra': extra,
      'start_date': start_date,
      'end_date': end_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DateRange? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var start_date = _map['start_date']! as int;
    var end_date = _map['end_date']! as int;
    return DateRange(
      extra: extra,
      clientId: clientId,
      start_date: start_date,
      end_date: end_date,
    );
  }
}

/// A value with information about its recent changes.
///
class StatisticalValue extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "statisticalValue";

  /// The current value.
  late double value;

  /// The value for the previous day.
  late double previous_value;

  /// The growth rate of the value, as a percentage.
  late double growth_rate_percentage;

  /// A value with information about its recent changes
  StatisticalValue(
      {required this.value,
      required this.previous_value,
      required this.growth_rate_percentage,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'statisticalValue',
      if (extra != null) '@extra': extra,
      'value': value,
      'previous_value': previous_value,
      'growth_rate_percentage': growth_rate_percentage
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StatisticalValue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as double;
    var previous_value = _map['previous_value']! as double;
    var growth_rate_percentage = _map['growth_rate_percentage']! as double;
    return StatisticalValue(
      extra: extra,
      clientId: clientId,
      value: value,
      previous_value: previous_value,
      growth_rate_percentage: growth_rate_percentage,
    );
  }
}

/// A graph data.
///
class StatisticalGraphData extends StatisticalGraph {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "statisticalGraphData";

  /// Graph data in JSON format.
  late String json_data;

  /// If non-empty, a token which can be used to receive a zoomed in graph.
  late String zoom_token;

  /// A graph data
  StatisticalGraphData(
      {required this.json_data,
      required this.zoom_token,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'statisticalGraphData',
      if (extra != null) '@extra': extra,
      'json_data': json_data,
      'zoom_token': zoom_token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StatisticalGraphData? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var json_data = _map['json_data']! as String;
    var zoom_token = _map['zoom_token']! as String;
    return StatisticalGraphData(
      extra: extra,
      clientId: clientId,
      json_data: json_data,
      zoom_token: zoom_token,
    );
  }
}

/// The graph data to be asynchronously loaded through getStatisticalGraph.
///
class StatisticalGraphAsync extends StatisticalGraph {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "statisticalGraphAsync";

  /// The token to use for data loading.
  late String token;

  /// The graph data to be asynchronously loaded through getStatisticalGraph
  StatisticalGraphAsync({required this.token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'statisticalGraphAsync',
      if (extra != null) '@extra': extra,
      'token': token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StatisticalGraphAsync? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    return StatisticalGraphAsync(
      extra: extra,
      clientId: clientId,
      token: token,
    );
  }
}

/// An error message to be shown to the user instead of the graph.
///
class StatisticalGraphError extends StatisticalGraph {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "statisticalGraphError";

  /// The error message.
  late String error_message;

  /// An error message to be shown to the user instead of the graph
  StatisticalGraphError(
      {required this.error_message, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'statisticalGraphError',
      if (extra != null) '@extra': extra,
      'error_message': error_message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StatisticalGraphError? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var error_message = _map['error_message']! as String;
    return StatisticalGraphError(
      extra: extra,
      clientId: clientId,
      error_message: error_message,
    );
  }
}

/// Contains statistics about interactions with a message.
///
class ChatStatisticsMessageInteractionInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatStatisticsMessageInteractionInfo";

  /// Message identifier.
  late int message_id;

  /// Number of times the message was viewed.
  late int view_count;

  /// Number of times the message was forwarded.
  late int forward_count;

  /// Contains statistics about interactions with a message
  ChatStatisticsMessageInteractionInfo(
      {required this.message_id,
      required this.view_count,
      required this.forward_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatStatisticsMessageInteractionInfo',
      if (extra != null) '@extra': extra,
      'message_id': message_id,
      'view_count': view_count,
      'forward_count': forward_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatStatisticsMessageInteractionInfo? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_id = _map['message_id']! as int;
    var view_count = _map['view_count']! as int;
    var forward_count = _map['forward_count']! as int;
    return ChatStatisticsMessageInteractionInfo(
      extra: extra,
      clientId: clientId,
      message_id: message_id,
      view_count: view_count,
      forward_count: forward_count,
    );
  }
}

/// Contains statistics about messages sent by a user.
///
class ChatStatisticsMessageSenderInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatStatisticsMessageSenderInfo";

  /// User identifier.
  late int user_id;

  /// Number of sent messages.
  late int sent_message_count;

  /// Average number of characters in sent messages; 0 if unknown.
  late int average_character_count;

  /// Contains statistics about messages sent by a user
  ChatStatisticsMessageSenderInfo(
      {required this.user_id,
      required this.sent_message_count,
      required this.average_character_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatStatisticsMessageSenderInfo',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'sent_message_count': sent_message_count,
      'average_character_count': average_character_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatStatisticsMessageSenderInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var sent_message_count = _map['sent_message_count']! as int;
    var average_character_count = _map['average_character_count']! as int;
    return ChatStatisticsMessageSenderInfo(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      sent_message_count: sent_message_count,
      average_character_count: average_character_count,
    );
  }
}

/// Contains statistics about administrator actions done by a user.
///
class ChatStatisticsAdministratorActionsInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatStatisticsAdministratorActionsInfo";

  /// Administrator user identifier.
  late int user_id;

  /// Number of messages deleted by the administrator.
  late int deleted_message_count;

  /// Number of users banned by the administrator.
  late int banned_user_count;

  /// Number of users restricted by the administrator.
  late int restricted_user_count;

  /// Contains statistics about administrator actions done by a user
  ChatStatisticsAdministratorActionsInfo(
      {required this.user_id,
      required this.deleted_message_count,
      required this.banned_user_count,
      required this.restricted_user_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatStatisticsAdministratorActionsInfo',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'deleted_message_count': deleted_message_count,
      'banned_user_count': banned_user_count,
      'restricted_user_count': restricted_user_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatStatisticsAdministratorActionsInfo? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var deleted_message_count = _map['deleted_message_count']! as int;
    var banned_user_count = _map['banned_user_count']! as int;
    var restricted_user_count = _map['restricted_user_count']! as int;
    return ChatStatisticsAdministratorActionsInfo(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      deleted_message_count: deleted_message_count,
      banned_user_count: banned_user_count,
      restricted_user_count: restricted_user_count,
    );
  }
}

/// Contains statistics about number of new members invited by a user.
///
class ChatStatisticsInviterInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatStatisticsInviterInfo";

  /// User identifier.
  late int user_id;

  /// Number of new members invited by the user.
  late int added_member_count;

  /// Contains statistics about number of new members invited by a user
  ChatStatisticsInviterInfo(
      {required this.user_id,
      required this.added_member_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatStatisticsInviterInfo',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'added_member_count': added_member_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatStatisticsInviterInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var added_member_count = _map['added_member_count']! as int;
    return ChatStatisticsInviterInfo(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      added_member_count: added_member_count,
    );
  }
}

/// A detailed statistics about a supergroup chat.
///
class ChatStatisticsSupergroup extends ChatStatistics {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatStatisticsSupergroup";

  /// A period to which the statistics applies.
  late DateRange period;

  /// Number of members in the chat.
  late StatisticalValue member_count;

  /// Number of messages sent to the chat.
  late StatisticalValue message_count;

  /// Number of users who viewed messages in the chat.
  late StatisticalValue viewer_count;

  /// Number of users who sent messages to the chat.
  late StatisticalValue sender_count;

  /// A graph containing number of members in the chat.
  late StatisticalGraph member_count_graph;

  /// A graph containing number of members joined and left the chat.
  late StatisticalGraph join_graph;

  /// A graph containing number of new member joins per source.
  late StatisticalGraph join_by_source_graph;

  /// A graph containing distribution of active users per language.
  late StatisticalGraph language_graph;

  /// A graph containing distribution of sent messages by content type.
  late StatisticalGraph message_content_graph;

  /// A graph containing number of different actions in the chat.
  late StatisticalGraph action_graph;

  /// A graph containing distribution of message views per hour.
  late StatisticalGraph day_graph;

  /// A graph containing distribution of message views per day of week.
  late StatisticalGraph week_graph;

  /// List of users sent most messages in the last week.
  late List<ChatStatisticsMessageSenderInfo> top_senders;

  /// List of most active administrators in the last week.
  late List<ChatStatisticsAdministratorActionsInfo> top_administrators;

  /// List of most active inviters of new members in the last week.
  late List<ChatStatisticsInviterInfo> top_inviters;

  /// A detailed statistics about a supergroup chat
  ChatStatisticsSupergroup(
      {required this.period,
      required this.member_count,
      required this.message_count,
      required this.viewer_count,
      required this.sender_count,
      required this.member_count_graph,
      required this.join_graph,
      required this.join_by_source_graph,
      required this.language_graph,
      required this.message_content_graph,
      required this.action_graph,
      required this.day_graph,
      required this.week_graph,
      required this.top_senders,
      required this.top_administrators,
      required this.top_inviters,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatStatisticsSupergroup',
      if (extra != null) '@extra': extra,
      'period': period,
      'member_count': member_count,
      'message_count': message_count,
      'viewer_count': viewer_count,
      'sender_count': sender_count,
      'member_count_graph': member_count_graph,
      'join_graph': join_graph,
      'join_by_source_graph': join_by_source_graph,
      'language_graph': language_graph,
      'message_content_graph': message_content_graph,
      'action_graph': action_graph,
      'day_graph': day_graph,
      'week_graph': week_graph,
      'top_senders': top_senders,
      'top_administrators': top_administrators,
      'top_inviters': top_inviters
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatStatisticsSupergroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var period = DateRange.fromMap(_map['period'])!;
    var member_count = StatisticalValue.fromMap(_map['member_count'])!;
    var message_count = StatisticalValue.fromMap(_map['message_count'])!;
    var viewer_count = StatisticalValue.fromMap(_map['viewer_count'])!;
    var sender_count = StatisticalValue.fromMap(_map['sender_count'])!;
    var member_count_graph =
        StatisticalGraph.fromMap(_map['member_count_graph'])!;
    var join_graph = StatisticalGraph.fromMap(_map['join_graph'])!;
    var join_by_source_graph =
        StatisticalGraph.fromMap(_map['join_by_source_graph'])!;
    var language_graph = StatisticalGraph.fromMap(_map['language_graph'])!;
    var message_content_graph =
        StatisticalGraph.fromMap(_map['message_content_graph'])!;
    var action_graph = StatisticalGraph.fromMap(_map['action_graph'])!;
    var day_graph = StatisticalGraph.fromMap(_map['day_graph'])!;
    var week_graph = StatisticalGraph.fromMap(_map['week_graph'])!;
    var top_senders = List<ChatStatisticsMessageSenderInfo>.from(
      (_map["top_senders"] ?? []).map(
        (e) => ChatStatisticsMessageSenderInfo.fromMap(e),
      ),
    );
    var top_administrators = List<ChatStatisticsAdministratorActionsInfo>.from(
      (_map["top_administrators"] ?? []).map(
        (e) => ChatStatisticsAdministratorActionsInfo.fromMap(e),
      ),
    );
    var top_inviters = List<ChatStatisticsInviterInfo>.from(
      (_map["top_inviters"] ?? []).map(
        (e) => ChatStatisticsInviterInfo.fromMap(e),
      ),
    );
    return ChatStatisticsSupergroup(
      extra: extra,
      clientId: clientId,
      period: period,
      member_count: member_count,
      message_count: message_count,
      viewer_count: viewer_count,
      sender_count: sender_count,
      member_count_graph: member_count_graph,
      join_graph: join_graph,
      join_by_source_graph: join_by_source_graph,
      language_graph: language_graph,
      message_content_graph: message_content_graph,
      action_graph: action_graph,
      day_graph: day_graph,
      week_graph: week_graph,
      top_senders: top_senders,
      top_administrators: top_administrators,
      top_inviters: top_inviters,
    );
  }
}

/// A detailed statistics about a channel chat.
///
class ChatStatisticsChannel extends ChatStatistics {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "chatStatisticsChannel";

  /// A period to which the statistics applies.
  late DateRange period;

  /// Number of members in the chat.
  late StatisticalValue member_count;

  /// Mean number of times the recently sent messages was viewed.
  late StatisticalValue mean_view_count;

  /// Mean number of times the recently sent messages was shared.
  late StatisticalValue mean_share_count;

  /// A percentage of users with enabled notifications for the chat.
  late double enabled_notifications_percentage;

  /// A graph containing number of members in the chat.
  late StatisticalGraph member_count_graph;

  /// A graph containing number of members joined and left the chat.
  late StatisticalGraph join_graph;

  /// A graph containing number of members muted and unmuted the chat.
  late StatisticalGraph mute_graph;

  /// A graph containing number of message views in a given hour in the last two weeks.
  late StatisticalGraph view_count_by_hour_graph;

  /// A graph containing number of message views per source.
  late StatisticalGraph view_count_by_source_graph;

  /// A graph containing number of new member joins per source.
  late StatisticalGraph join_by_source_graph;

  /// A graph containing number of users viewed chat messages per language.
  late StatisticalGraph language_graph;

  /// A graph containing number of chat message views and shares.
  late StatisticalGraph message_interaction_graph;

  /// A graph containing number of views of associated with the chat instant views.
  late StatisticalGraph instant_view_interaction_graph;

  /// Detailed statistics about number of views and shares of recently sent messages.
  late List<ChatStatisticsMessageInteractionInfo> recent_message_interactions;

  /// A detailed statistics about a channel chat
  ChatStatisticsChannel(
      {required this.period,
      required this.member_count,
      required this.mean_view_count,
      required this.mean_share_count,
      required this.enabled_notifications_percentage,
      required this.member_count_graph,
      required this.join_graph,
      required this.mute_graph,
      required this.view_count_by_hour_graph,
      required this.view_count_by_source_graph,
      required this.join_by_source_graph,
      required this.language_graph,
      required this.message_interaction_graph,
      required this.instant_view_interaction_graph,
      required this.recent_message_interactions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'chatStatisticsChannel',
      if (extra != null) '@extra': extra,
      'period': period,
      'member_count': member_count,
      'mean_view_count': mean_view_count,
      'mean_share_count': mean_share_count,
      'enabled_notifications_percentage': enabled_notifications_percentage,
      'member_count_graph': member_count_graph,
      'join_graph': join_graph,
      'mute_graph': mute_graph,
      'view_count_by_hour_graph': view_count_by_hour_graph,
      'view_count_by_source_graph': view_count_by_source_graph,
      'join_by_source_graph': join_by_source_graph,
      'language_graph': language_graph,
      'message_interaction_graph': message_interaction_graph,
      'instant_view_interaction_graph': instant_view_interaction_graph,
      'recent_message_interactions': recent_message_interactions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChatStatisticsChannel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var period = DateRange.fromMap(_map['period'])!;
    var member_count = StatisticalValue.fromMap(_map['member_count'])!;
    var mean_view_count = StatisticalValue.fromMap(_map['mean_view_count'])!;
    var mean_share_count = StatisticalValue.fromMap(_map['mean_share_count'])!;
    var enabled_notifications_percentage =
        _map['enabled_notifications_percentage']! as double;
    var member_count_graph =
        StatisticalGraph.fromMap(_map['member_count_graph'])!;
    var join_graph = StatisticalGraph.fromMap(_map['join_graph'])!;
    var mute_graph = StatisticalGraph.fromMap(_map['mute_graph'])!;
    var view_count_by_hour_graph =
        StatisticalGraph.fromMap(_map['view_count_by_hour_graph'])!;
    var view_count_by_source_graph =
        StatisticalGraph.fromMap(_map['view_count_by_source_graph'])!;
    var join_by_source_graph =
        StatisticalGraph.fromMap(_map['join_by_source_graph'])!;
    var language_graph = StatisticalGraph.fromMap(_map['language_graph'])!;
    var message_interaction_graph =
        StatisticalGraph.fromMap(_map['message_interaction_graph'])!;
    var instant_view_interaction_graph =
        StatisticalGraph.fromMap(_map['instant_view_interaction_graph'])!;
    var recent_message_interactions =
        List<ChatStatisticsMessageInteractionInfo>.from(
      (_map["recent_message_interactions"] ?? []).map(
        (e) => ChatStatisticsMessageInteractionInfo.fromMap(e),
      ),
    );
    return ChatStatisticsChannel(
      extra: extra,
      clientId: clientId,
      period: period,
      member_count: member_count,
      mean_view_count: mean_view_count,
      mean_share_count: mean_share_count,
      enabled_notifications_percentage: enabled_notifications_percentage,
      member_count_graph: member_count_graph,
      join_graph: join_graph,
      mute_graph: mute_graph,
      view_count_by_hour_graph: view_count_by_hour_graph,
      view_count_by_source_graph: view_count_by_source_graph,
      join_by_source_graph: join_by_source_graph,
      language_graph: language_graph,
      message_interaction_graph: message_interaction_graph,
      instant_view_interaction_graph: instant_view_interaction_graph,
      recent_message_interactions: recent_message_interactions,
    );
  }
}

/// A detailed statistics about a message.
///
class MessageStatistics extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "messageStatistics";

  /// A graph containing number of message views and shares.
  late StatisticalGraph message_interaction_graph;

  /// A detailed statistics about a message
  MessageStatistics(
      {required this.message_interaction_graph, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'messageStatistics',
      if (extra != null) '@extra': extra,
      'message_interaction_graph': message_interaction_graph
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static MessageStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_interaction_graph =
        StatisticalGraph.fromMap(_map['message_interaction_graph'])!;
    return MessageStatistics(
      extra: extra,
      clientId: clientId,
      message_interaction_graph: message_interaction_graph,
    );
  }
}

/// A point on a Cartesian plane.
///
class Point extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "point";

  /// The point's first coordinate.
  late double x;

  /// The point's second coordinate.
  late double y;

  /// A point on a Cartesian plane
  Point({required this.x, required this.y, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'point',
      if (extra != null) '@extra': extra,
      'x': x,
      'y': y
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Point? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var x = _map['x']! as double;
    var y = _map['y']! as double;
    return Point(
      extra: extra,
      clientId: clientId,
      x: x,
      y: y,
    );
  }
}

/// A straight line to a given point.
///
class VectorPathCommandLine extends VectorPathCommand {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "vectorPathCommandLine";

  /// The end point of the straight line.
  late Point end_point;

  /// A straight line to a given point
  VectorPathCommandLine({required this.end_point, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'vectorPathCommandLine',
      if (extra != null) '@extra': extra,
      'end_point': end_point
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static VectorPathCommandLine? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var end_point = Point.fromMap(_map['end_point'])!;
    return VectorPathCommandLine(
      extra: extra,
      clientId: clientId,
      end_point: end_point,
    );
  }
}

/// A cubic Bézier curve to a given point.
///
class VectorPathCommandCubicBezierCurve extends VectorPathCommand {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "vectorPathCommandCubicBezierCurve";

  /// The start control point of the curve.
  late Point start_control_point;

  /// The end control point of the curve.
  late Point end_control_point;

  /// The end point of the curve.
  late Point end_point;

  /// A cubic Bézier curve to a given point
  VectorPathCommandCubicBezierCurve(
      {required this.start_control_point,
      required this.end_control_point,
      required this.end_point,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'vectorPathCommandCubicBezierCurve',
      if (extra != null) '@extra': extra,
      'start_control_point': start_control_point,
      'end_control_point': end_control_point,
      'end_point': end_point
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static VectorPathCommandCubicBezierCurve? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var start_control_point = Point.fromMap(_map['start_control_point'])!;
    var end_control_point = Point.fromMap(_map['end_control_point'])!;
    var end_point = Point.fromMap(_map['end_point'])!;
    return VectorPathCommandCubicBezierCurve(
      extra: extra,
      clientId: clientId,
      start_control_point: start_control_point,
      end_control_point: end_control_point,
      end_point: end_point,
    );
  }
}

/// A scope covering all users.
///
class BotCommandScopeDefault extends BotCommandScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botCommandScopeDefault";

  /// A scope covering all users
  BotCommandScopeDefault({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botCommandScopeDefault',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotCommandScopeDefault? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return BotCommandScopeDefault(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A scope covering all private chats.
///
class BotCommandScopeAllPrivateChats extends BotCommandScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botCommandScopeAllPrivateChats";

  /// A scope covering all private chats
  BotCommandScopeAllPrivateChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botCommandScopeAllPrivateChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotCommandScopeAllPrivateChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return BotCommandScopeAllPrivateChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A scope covering all group and supergroup chats.
///
class BotCommandScopeAllGroupChats extends BotCommandScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botCommandScopeAllGroupChats";

  /// A scope covering all group and supergroup chats
  BotCommandScopeAllGroupChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botCommandScopeAllGroupChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotCommandScopeAllGroupChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return BotCommandScopeAllGroupChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A scope covering all group and supergroup chat administrators.
///
class BotCommandScopeAllChatAdministrators extends BotCommandScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botCommandScopeAllChatAdministrators";

  /// A scope covering all group and supergroup chat administrators
  BotCommandScopeAllChatAdministrators({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botCommandScopeAllChatAdministrators',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotCommandScopeAllChatAdministrators? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return BotCommandScopeAllChatAdministrators(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// A scope covering all members of a chat.
///
class BotCommandScopeChat extends BotCommandScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botCommandScopeChat";

  /// Chat identifier.
  late int chat_id;

  /// A scope covering all members of a chat
  BotCommandScopeChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botCommandScopeChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotCommandScopeChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return BotCommandScopeChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// A scope covering all administrators of a chat.
///
class BotCommandScopeChatAdministrators extends BotCommandScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botCommandScopeChatAdministrators";

  /// Chat identifier.
  late int chat_id;

  /// A scope covering all administrators of a chat
  BotCommandScopeChatAdministrators(
      {required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botCommandScopeChatAdministrators',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotCommandScopeChatAdministrators? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return BotCommandScopeChatAdministrators(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// A scope covering a member of a chat.
///
class BotCommandScopeChatMember extends BotCommandScope {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "botCommandScopeChatMember";

  /// Chat identifier.
  late int chat_id;

  /// User identifier.
  late int user_id;

  /// A scope covering a member of a chat
  BotCommandScopeChatMember(
      {required this.chat_id,
      required this.user_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'botCommandScopeChatMember',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BotCommandScopeChatMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var user_id = _map['user_id']! as int;
    return BotCommandScopeChatMember(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      user_id: user_id,
    );
  }
}

/// The user authorization state has changed.
///
class UpdateAuthorizationState extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateAuthorizationState";

  /// New authorization state.
  late AuthorizationState authorization_state;

  /// The user authorization state has changed
  UpdateAuthorizationState(
      {required this.authorization_state, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateAuthorizationState',
      if (extra != null) '@extra': extra,
      'authorization_state': authorization_state
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateAuthorizationState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var authorization_state =
        AuthorizationState.fromMap(_map['authorization_state'])!;
    return UpdateAuthorizationState(
      extra: extra,
      clientId: clientId,
      authorization_state: authorization_state,
    );
  }
}

/// A new message was received; can also be an outgoing message.
///
class UpdateNewMessage extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewMessage";

  /// The new message.
  late Message message;

  /// A new message was received; can also be an outgoing message
  UpdateNewMessage({required this.message, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewMessage',
      if (extra != null) '@extra': extra,
      'message': message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message = Message.fromMap(_map['message'])!;
    return UpdateNewMessage(
      extra: extra,
      clientId: clientId,
      message: message,
    );
  }
}

/// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed..
///
class UpdateMessageSendAcknowledged extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageSendAcknowledged";

  /// The chat identifier of the sent message.
  late int chat_id;

  /// A temporary message identifier.
  late int message_id;

  /// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed.
  UpdateMessageSendAcknowledged(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageSendAcknowledged',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageSendAcknowledged? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return UpdateMessageSendAcknowledged(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// A message has been successfully sent.
///
class UpdateMessageSendSucceeded extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageSendSucceeded";

  /// The sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change.
  late Message message;

  /// The previous temporary message identifier.
  late int old_message_id;

  /// A message has been successfully sent
  UpdateMessageSendSucceeded(
      {required this.message,
      required this.old_message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageSendSucceeded',
      if (extra != null) '@extra': extra,
      'message': message,
      'old_message_id': old_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageSendSucceeded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message = Message.fromMap(_map['message'])!;
    var old_message_id = _map['old_message_id']! as int;
    return UpdateMessageSendSucceeded(
      extra: extra,
      clientId: clientId,
      message: message,
      old_message_id: old_message_id,
    );
  }
}

/// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update.
///
class UpdateMessageSendFailed extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageSendFailed";

  /// The failed to send message.
  late Message message;

  /// The previous temporary message identifier.
  late int old_message_id;

  /// The cause of the message sending failure.
  late Error error;

  /// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
  UpdateMessageSendFailed(
      {required this.message,
      required this.old_message_id,
      required this.error,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageSendFailed',
      if (extra != null) '@extra': extra,
      'message': message,
      'old_message_id': old_message_id,
      'error': error
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageSendFailed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message = Message.fromMap(_map['message'])!;
    var old_message_id = _map['old_message_id']! as int;
    var error = Error.fromMap(_map['error'])!;
    return UpdateMessageSendFailed(
      extra: extra,
      clientId: clientId,
      message: message,
      old_message_id: old_message_id,
      error: error,
    );
  }
}

/// The message content has changed.
///
class UpdateMessageContent extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageContent";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// New message content.
  late MessageContent new_content;

  /// The message content has changed
  UpdateMessageContent(
      {required this.chat_id,
      required this.message_id,
      required this.new_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageContent',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'new_content': new_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageContent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var new_content = MessageContent.fromMap(_map['new_content'])!;
    return UpdateMessageContent(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      new_content: new_content,
    );
  }
}

/// A message was edited. Changes in the message content will come in a separate updateMessageContent.
///
class UpdateMessageEdited extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageEdited";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// Point in time (Unix timestamp) when the message was edited.
  late int edit_date;

  /// New message reply markup; may be null.
  ReplyMarkup? reply_markup;

  /// A message was edited. Changes in the message content will come in a separate updateMessageContent
  UpdateMessageEdited(
      {required this.chat_id,
      required this.message_id,
      required this.edit_date,
      this.reply_markup,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageEdited',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'edit_date': edit_date,
      'reply_markup': reply_markup
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageEdited? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var edit_date = _map['edit_date']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    return UpdateMessageEdited(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      edit_date: edit_date,
      reply_markup: reply_markup,
    );
  }
}

/// The message pinned state was changed.
///
class UpdateMessageIsPinned extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageIsPinned";

  /// Chat identifier.
  late int chat_id;

  /// The message identifier.
  late int message_id;

  /// True, if the message is pinned.
  late bool is_pinned;

  /// The message pinned state was changed
  UpdateMessageIsPinned(
      {required this.chat_id,
      required this.message_id,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageIsPinned',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageIsPinned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var is_pinned = _map['is_pinned']! as bool;
    return UpdateMessageIsPinned(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      is_pinned: is_pinned,
    );
  }
}

/// The information about interactions with a message has changed.
///
class UpdateMessageInteractionInfo extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageInteractionInfo";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// New information about interactions with the message; may be null.
  MessageInteractionInfo? interaction_info;

  /// The information about interactions with a message has changed
  UpdateMessageInteractionInfo(
      {required this.chat_id,
      required this.message_id,
      this.interaction_info,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageInteractionInfo',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'interaction_info': interaction_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageInteractionInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var interaction_info =
        MessageInteractionInfo.fromMap(_map['interaction_info']);
    return UpdateMessageInteractionInfo(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      interaction_info: interaction_info,
    );
  }
}

/// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the self-destruct timer.
///
class UpdateMessageContentOpened extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageContentOpened";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the self-destruct timer
  UpdateMessageContentOpened(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageContentOpened',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageContentOpened? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return UpdateMessageContentOpened(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// A message with an unread mention was read.
///
class UpdateMessageMentionRead extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageMentionRead";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// The new number of unread mention messages left in the chat.
  late int unread_mention_count;

  /// A message with an unread mention was read
  UpdateMessageMentionRead(
      {required this.chat_id,
      required this.message_id,
      required this.unread_mention_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageMentionRead',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'unread_mention_count': unread_mention_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageMentionRead? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var unread_mention_count = _map['unread_mention_count']! as int;
    return UpdateMessageMentionRead(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      unread_mention_count: unread_mention_count,
    );
  }
}

/// The list of unread reactions added to a message was changed.
///
class UpdateMessageUnreadReactions extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageUnreadReactions";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// The new list of unread reactions.
  late List<UnreadReaction> unread_reactions;

  /// The new number of messages with unread reactions left in the chat.
  late int unread_reaction_count;

  /// The list of unread reactions added to a message was changed
  UpdateMessageUnreadReactions(
      {required this.chat_id,
      required this.message_id,
      required this.unread_reactions,
      required this.unread_reaction_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageUnreadReactions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'unread_reactions': unread_reactions,
      'unread_reaction_count': unread_reaction_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageUnreadReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var unread_reactions = List<UnreadReaction>.from(
      (_map["unread_reactions"] ?? []).map(
        (e) => UnreadReaction.fromMap(e),
      ),
    );
    var unread_reaction_count = _map['unread_reaction_count']! as int;
    return UpdateMessageUnreadReactions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      unread_reactions: unread_reactions,
      unread_reaction_count: unread_reaction_count,
    );
  }
}

/// A message with a live location was viewed. When the update is received, the application is supposed to update the live location.
///
class UpdateMessageLiveLocationViewed extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateMessageLiveLocationViewed";

  /// Identifier of the chat with the live location message.
  late int chat_id;

  /// Identifier of the message with live location.
  late int message_id;

  /// A message with a live location was viewed. When the update is received, the application is supposed to update the live location
  UpdateMessageLiveLocationViewed(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateMessageLiveLocationViewed',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateMessageLiveLocationViewed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return UpdateMessageLiveLocationViewed(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates.
///
class UpdateNewChat extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewChat";

  /// The chat.
  late Chat chat;

  /// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates
  UpdateNewChat({required this.chat, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewChat',
      if (extra != null) '@extra': extra,
      'chat': chat
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat = Chat.fromMap(_map['chat'])!;
    return UpdateNewChat(
      extra: extra,
      clientId: clientId,
      chat: chat,
    );
  }
}

/// The title of a chat was changed.
///
class UpdateChatTitle extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatTitle";

  /// Chat identifier.
  late int chat_id;

  /// The new chat title.
  late String title;

  /// The title of a chat was changed
  UpdateChatTitle(
      {required this.chat_id, required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatTitle',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatTitle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var title = _map['title']! as String;
    return UpdateChatTitle(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      title: title,
    );
  }
}

/// A chat photo was changed.
///
class UpdateChatPhoto extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatPhoto";

  /// Chat identifier.
  late int chat_id;

  /// The new chat photo; may be null.
  ChatPhotoInfo? photo;

  /// A chat photo was changed
  UpdateChatPhoto(
      {required this.chat_id, this.photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatPhoto',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'photo': photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var photo = ChatPhotoInfo.fromMap(_map['photo']);
    return UpdateChatPhoto(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      photo: photo,
    );
  }
}

/// Chat permissions was changed.
///
class UpdateChatPermissions extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatPermissions";

  /// Chat identifier.
  late int chat_id;

  /// The new chat permissions.
  late ChatPermissions permissions;

  /// Chat permissions was changed
  UpdateChatPermissions(
      {required this.chat_id,
      required this.permissions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatPermissions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'permissions': permissions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatPermissions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var permissions = ChatPermissions.fromMap(_map['permissions'])!;
    return UpdateChatPermissions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      permissions: permissions,
    );
  }
}

/// The last message of a chat was changed. If last_message is null, then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case.
///
class UpdateChatLastMessage extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatLastMessage";

  /// Chat identifier.
  late int chat_id;

  /// The new last message in the chat; may be null.
  Message? last_message;

  /// The new chat positions in the chat lists.
  late List<ChatPosition> positions;

  /// The last message of a chat was changed. If last_message is null, then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case
  UpdateChatLastMessage(
      {required this.chat_id,
      this.last_message,
      required this.positions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatLastMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'last_message': last_message,
      'positions': positions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatLastMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var last_message = Message.fromMap(_map['last_message']);
    var positions = List<ChatPosition>.from(
      (_map["positions"] ?? []).map(
        (e) => ChatPosition.fromMap(e),
      ),
    );
    return UpdateChatLastMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      last_message: last_message,
      positions: positions,
    );
  }
}

/// The position of a chat in a chat list has changed. An updateChatLastMessage or updateChatDraftMessage update might be sent instead of the update.
///
class UpdateChatPosition extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatPosition";

  /// Chat identifier.
  late int chat_id;

  /// New chat position. If new order is 0, then the chat needs to be removed from the list.
  late ChatPosition position;

  /// The position of a chat in a chat list has changed. An updateChatLastMessage or updateChatDraftMessage update might be sent instead of the update
  UpdateChatPosition(
      {required this.chat_id,
      required this.position,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatPosition',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'position': position
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatPosition? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var position = ChatPosition.fromMap(_map['position'])!;
    return UpdateChatPosition(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      position: position,
    );
  }
}

/// Incoming messages were read or the number of unread messages has been changed.
///
class UpdateChatReadInbox extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatReadInbox";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the last read incoming message.
  late int last_read_inbox_message_id;

  /// The number of unread messages left in the chat.
  late int unread_count;

  /// Incoming messages were read or the number of unread messages has been changed
  UpdateChatReadInbox(
      {required this.chat_id,
      required this.last_read_inbox_message_id,
      required this.unread_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatReadInbox',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'last_read_inbox_message_id': last_read_inbox_message_id,
      'unread_count': unread_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatReadInbox? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var last_read_inbox_message_id = _map['last_read_inbox_message_id']! as int;
    var unread_count = _map['unread_count']! as int;
    return UpdateChatReadInbox(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      last_read_inbox_message_id: last_read_inbox_message_id,
      unread_count: unread_count,
    );
  }
}

/// Outgoing messages were read.
///
class UpdateChatReadOutbox extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatReadOutbox";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of last read outgoing message.
  late int last_read_outbox_message_id;

  /// Outgoing messages were read
  UpdateChatReadOutbox(
      {required this.chat_id,
      required this.last_read_outbox_message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatReadOutbox',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'last_read_outbox_message_id': last_read_outbox_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatReadOutbox? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var last_read_outbox_message_id =
        _map['last_read_outbox_message_id']! as int;
    return UpdateChatReadOutbox(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      last_read_outbox_message_id: last_read_outbox_message_id,
    );
  }
}

/// The chat action bar was changed.
///
class UpdateChatActionBar extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatActionBar";

  /// Chat identifier.
  late int chat_id;

  /// The new value of the action bar; may be null.
  ChatActionBar? action_bar;

  /// The chat action bar was changed
  UpdateChatActionBar(
      {required this.chat_id, this.action_bar, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatActionBar',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'action_bar': action_bar
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatActionBar? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var action_bar = ChatActionBar.fromMap(_map['action_bar']);
    return UpdateChatActionBar(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      action_bar: action_bar,
    );
  }
}

/// The chat available reactions were changed.
///
class UpdateChatAvailableReactions extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatAvailableReactions";

  /// Chat identifier.
  late int chat_id;

  /// The new reactions, available in the chat.
  late ChatAvailableReactions available_reactions;

  /// The chat available reactions were changed
  UpdateChatAvailableReactions(
      {required this.chat_id,
      required this.available_reactions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatAvailableReactions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'available_reactions': available_reactions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatAvailableReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var available_reactions =
        ChatAvailableReactions.fromMap(_map['available_reactions'])!;
    return UpdateChatAvailableReactions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      available_reactions: available_reactions,
    );
  }
}

/// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied.
///
class UpdateChatDraftMessage extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatDraftMessage";

  /// Chat identifier.
  late int chat_id;

  /// The new draft message; may be null.
  DraftMessage? draft_message;

  /// The new chat positions in the chat lists.
  late List<ChatPosition> positions;

  /// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied
  UpdateChatDraftMessage(
      {required this.chat_id,
      this.draft_message,
      required this.positions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatDraftMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'draft_message': draft_message,
      'positions': positions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatDraftMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var draft_message = DraftMessage.fromMap(_map['draft_message']);
    var positions = List<ChatPosition>.from(
      (_map["positions"] ?? []).map(
        (e) => ChatPosition.fromMap(e),
      ),
    );
    return UpdateChatDraftMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      draft_message: draft_message,
      positions: positions,
    );
  }
}

/// The message sender that is selected to send messages in a chat has changed.
///
class UpdateChatMessageSender extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatMessageSender";

  /// Chat identifier.
  late int chat_id;

  /// New value of message_sender_id; may be null if the user can't change message sender.
  MessageSender? message_sender_id;

  /// The message sender that is selected to send messages in a chat has changed
  UpdateChatMessageSender(
      {required this.chat_id,
      this.message_sender_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatMessageSender',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_sender_id': message_sender_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatMessageSender? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_sender_id = MessageSender.fromMap(_map['message_sender_id']);
    return UpdateChatMessageSender(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_sender_id: message_sender_id,
    );
  }
}

/// The message auto-delete or self-destruct timer setting for a chat was changed.
///
class UpdateChatMessageAutoDeleteTime extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatMessageAutoDeleteTime";

  /// Chat identifier.
  late int chat_id;

  /// New value of message_auto_delete_time.
  late int message_auto_delete_time;

  /// The message auto-delete or self-destruct timer setting for a chat was changed
  UpdateChatMessageAutoDeleteTime(
      {required this.chat_id,
      required this.message_auto_delete_time,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatMessageAutoDeleteTime',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_auto_delete_time': message_auto_delete_time
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatMessageAutoDeleteTime? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_auto_delete_time = _map['message_auto_delete_time']! as int;
    return UpdateChatMessageAutoDeleteTime(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_auto_delete_time: message_auto_delete_time,
    );
  }
}

/// Notification settings for a chat were changed.
///
class UpdateChatNotificationSettings extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatNotificationSettings";

  /// Chat identifier.
  late int chat_id;

  /// The new notification settings.
  late ChatNotificationSettings notification_settings;

  /// Notification settings for a chat were changed
  UpdateChatNotificationSettings(
      {required this.chat_id,
      required this.notification_settings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatNotificationSettings',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'notification_settings': notification_settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatNotificationSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var notification_settings =
        ChatNotificationSettings.fromMap(_map['notification_settings'])!;
    return UpdateChatNotificationSettings(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      notification_settings: notification_settings,
    );
  }
}

/// The chat pending join requests were changed.
///
class UpdateChatPendingJoinRequests extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatPendingJoinRequests";

  /// Chat identifier.
  late int chat_id;

  /// The new data about pending join requests; may be null.
  ChatJoinRequestsInfo? pending_join_requests;

  /// The chat pending join requests were changed
  UpdateChatPendingJoinRequests(
      {required this.chat_id,
      this.pending_join_requests,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatPendingJoinRequests',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'pending_join_requests': pending_join_requests
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatPendingJoinRequests? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var pending_join_requests =
        ChatJoinRequestsInfo.fromMap(_map['pending_join_requests']);
    return UpdateChatPendingJoinRequests(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      pending_join_requests: pending_join_requests,
    );
  }
}

/// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user.
///
class UpdateChatReplyMarkup extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatReplyMarkup";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat.
  late int reply_markup_message_id;

  /// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
  UpdateChatReplyMarkup(
      {required this.chat_id,
      required this.reply_markup_message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatReplyMarkup',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'reply_markup_message_id': reply_markup_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatReplyMarkup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var reply_markup_message_id = _map['reply_markup_message_id']! as int;
    return UpdateChatReplyMarkup(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      reply_markup_message_id: reply_markup_message_id,
    );
  }
}

/// The chat background was changed.
///
class UpdateChatBackground extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatBackground";

  /// Chat identifier.
  late int chat_id;

  /// The new chat background; may be null if background was reset to default.
  ChatBackground? background;

  /// The chat background was changed
  UpdateChatBackground(
      {required this.chat_id, this.background, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatBackground',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'background': background
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatBackground? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var background = ChatBackground.fromMap(_map['background']);
    return UpdateChatBackground(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      background: background,
    );
  }
}

/// The chat theme was changed.
///
class UpdateChatTheme extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatTheme";

  /// Chat identifier.
  late int chat_id;

  /// The new name of the chat theme; may be empty if theme was reset to default.
  late String theme_name;

  /// The chat theme was changed
  UpdateChatTheme(
      {required this.chat_id,
      required this.theme_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatTheme',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'theme_name': theme_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatTheme? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var theme_name = _map['theme_name']! as String;
    return UpdateChatTheme(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      theme_name: theme_name,
    );
  }
}

/// The chat unread_mention_count has changed.
///
class UpdateChatUnreadMentionCount extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatUnreadMentionCount";

  /// Chat identifier.
  late int chat_id;

  /// The number of unread mention messages left in the chat.
  late int unread_mention_count;

  /// The chat unread_mention_count has changed
  UpdateChatUnreadMentionCount(
      {required this.chat_id,
      required this.unread_mention_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatUnreadMentionCount',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'unread_mention_count': unread_mention_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatUnreadMentionCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var unread_mention_count = _map['unread_mention_count']! as int;
    return UpdateChatUnreadMentionCount(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      unread_mention_count: unread_mention_count,
    );
  }
}

/// The chat unread_reaction_count has changed.
///
class UpdateChatUnreadReactionCount extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatUnreadReactionCount";

  /// Chat identifier.
  late int chat_id;

  /// The number of messages with unread reactions left in the chat.
  late int unread_reaction_count;

  /// The chat unread_reaction_count has changed
  UpdateChatUnreadReactionCount(
      {required this.chat_id,
      required this.unread_reaction_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatUnreadReactionCount',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'unread_reaction_count': unread_reaction_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatUnreadReactionCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var unread_reaction_count = _map['unread_reaction_count']! as int;
    return UpdateChatUnreadReactionCount(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      unread_reaction_count: unread_reaction_count,
    );
  }
}

/// A chat video chat state has changed.
///
class UpdateChatVideoChat extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatVideoChat";

  /// Chat identifier.
  late int chat_id;

  /// New value of video_chat.
  late VideoChat video_chat;

  /// A chat video chat state has changed
  UpdateChatVideoChat(
      {required this.chat_id,
      required this.video_chat,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatVideoChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'video_chat': video_chat
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatVideoChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var video_chat = VideoChat.fromMap(_map['video_chat'])!;
    return UpdateChatVideoChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      video_chat: video_chat,
    );
  }
}

/// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed.
///
class UpdateChatDefaultDisableNotification extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatDefaultDisableNotification";

  /// Chat identifier.
  late int chat_id;

  /// The new default_disable_notification value.
  late bool default_disable_notification;

  /// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
  UpdateChatDefaultDisableNotification(
      {required this.chat_id,
      required this.default_disable_notification,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatDefaultDisableNotification',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'default_disable_notification': default_disable_notification
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatDefaultDisableNotification? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var default_disable_notification =
        _map['default_disable_notification']! as bool;
    return UpdateChatDefaultDisableNotification(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      default_disable_notification: default_disable_notification,
    );
  }
}

/// A chat content was allowed or restricted for saving.
///
class UpdateChatHasProtectedContent extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatHasProtectedContent";

  /// Chat identifier.
  late int chat_id;

  /// New value of has_protected_content.
  late bool has_protected_content;

  /// A chat content was allowed or restricted for saving
  UpdateChatHasProtectedContent(
      {required this.chat_id,
      required this.has_protected_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatHasProtectedContent',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'has_protected_content': has_protected_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatHasProtectedContent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var has_protected_content = _map['has_protected_content']! as bool;
    return UpdateChatHasProtectedContent(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      has_protected_content: has_protected_content,
    );
  }
}

/// Translation of chat messages was enabled or disabled.
///
class UpdateChatIsTranslatable extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatIsTranslatable";

  /// Chat identifier.
  late int chat_id;

  /// New value of is_translatable.
  late bool is_translatable;

  /// Translation of chat messages was enabled or disabled
  UpdateChatIsTranslatable(
      {required this.chat_id,
      required this.is_translatable,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatIsTranslatable',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'is_translatable': is_translatable
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatIsTranslatable? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var is_translatable = _map['is_translatable']! as bool;
    return UpdateChatIsTranslatable(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      is_translatable: is_translatable,
    );
  }
}

/// A chat was marked as unread or was read.
///
class UpdateChatIsMarkedAsUnread extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatIsMarkedAsUnread";

  /// Chat identifier.
  late int chat_id;

  /// New value of is_marked_as_unread.
  late bool is_marked_as_unread;

  /// A chat was marked as unread or was read
  UpdateChatIsMarkedAsUnread(
      {required this.chat_id,
      required this.is_marked_as_unread,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatIsMarkedAsUnread',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'is_marked_as_unread': is_marked_as_unread
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatIsMarkedAsUnread? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var is_marked_as_unread = _map['is_marked_as_unread']! as bool;
    return UpdateChatIsMarkedAsUnread(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      is_marked_as_unread: is_marked_as_unread,
    );
  }
}

/// A chat was blocked or unblocked.
///
class UpdateChatBlockList extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatBlockList";

  /// Chat identifier.
  late int chat_id;

  /// Block list to which the chat is added; may be null if none.
  BlockList? block_list;

  /// A chat was blocked or unblocked
  UpdateChatBlockList(
      {required this.chat_id, this.block_list, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatBlockList',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'block_list': block_list
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatBlockList? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var block_list = BlockList.fromMap(_map['block_list']);
    return UpdateChatBlockList(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      block_list: block_list,
    );
  }
}

/// A chat's has_scheduled_messages field has changed.
///
class UpdateChatHasScheduledMessages extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatHasScheduledMessages";

  /// Chat identifier.
  late int chat_id;

  /// New value of has_scheduled_messages.
  late bool has_scheduled_messages;

  /// A chat's has_scheduled_messages field has changed
  UpdateChatHasScheduledMessages(
      {required this.chat_id,
      required this.has_scheduled_messages,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatHasScheduledMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'has_scheduled_messages': has_scheduled_messages
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatHasScheduledMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var has_scheduled_messages = _map['has_scheduled_messages']! as bool;
    return UpdateChatHasScheduledMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      has_scheduled_messages: has_scheduled_messages,
    );
  }
}

/// The list of chat folders or a chat folder has changed.
///
class UpdateChatFolders extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatFolders";

  /// The new list of chat folders.
  late List<ChatFolderInfo> chat_folders;

  /// Position of the main chat list among chat folders, 0-based.
  late int main_chat_list_position;

  /// The list of chat folders or a chat folder has changed
  UpdateChatFolders(
      {required this.chat_folders,
      required this.main_chat_list_position,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatFolders',
      if (extra != null) '@extra': extra,
      'chat_folders': chat_folders,
      'main_chat_list_position': main_chat_list_position
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatFolders? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folders = List<ChatFolderInfo>.from(
      (_map["chat_folders"] ?? []).map(
        (e) => ChatFolderInfo.fromMap(e),
      ),
    );
    var main_chat_list_position = _map['main_chat_list_position']! as int;
    return UpdateChatFolders(
      extra: extra,
      clientId: clientId,
      chat_folders: chat_folders,
      main_chat_list_position: main_chat_list_position,
    );
  }
}

/// The number of online group members has changed. This update with non-zero number of online group members is sent only for currently opened chats..
///
class UpdateChatOnlineMemberCount extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatOnlineMemberCount";

  /// Identifier of the chat.
  late int chat_id;

  /// New number of online members in the chat, or 0 if unknown.
  late int online_member_count;

  /// The number of online group members has changed. This update with non-zero number of online group members is sent only for currently opened chats.
  UpdateChatOnlineMemberCount(
      {required this.chat_id,
      required this.online_member_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatOnlineMemberCount',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'online_member_count': online_member_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatOnlineMemberCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var online_member_count = _map['online_member_count']! as int;
    return UpdateChatOnlineMemberCount(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      online_member_count: online_member_count,
    );
  }
}

/// Basic information about a topic in a forum chat was changed.
///
class UpdateForumTopicInfo extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateForumTopicInfo";

  /// Chat identifier.
  late int chat_id;

  /// New information about the topic.
  late ForumTopicInfo info;

  /// Basic information about a topic in a forum chat was changed
  UpdateForumTopicInfo(
      {required this.chat_id, required this.info, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateForumTopicInfo',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'info': info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateForumTopicInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var info = ForumTopicInfo.fromMap(_map['info'])!;
    return UpdateForumTopicInfo(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      info: info,
    );
  }
}

/// Notification settings for some type of chats were updated.
///
class UpdateScopeNotificationSettings extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateScopeNotificationSettings";

  /// Types of chats for which notification settings were updated.
  late NotificationSettingsScope scope;

  /// The new notification settings.
  late ScopeNotificationSettings notification_settings;

  /// Notification settings for some type of chats were updated
  UpdateScopeNotificationSettings(
      {required this.scope,
      required this.notification_settings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateScopeNotificationSettings',
      if (extra != null) '@extra': extra,
      'scope': scope,
      'notification_settings': notification_settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateScopeNotificationSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scope = NotificationSettingsScope.fromMap(_map['scope'])!;
    var notification_settings =
        ScopeNotificationSettings.fromMap(_map['notification_settings'])!;
    return UpdateScopeNotificationSettings(
      extra: extra,
      clientId: clientId,
      scope: scope,
      notification_settings: notification_settings,
    );
  }
}

/// A notification was changed.
///
class UpdateNotification extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNotification";

  /// Unique notification group identifier.
  late int notification_group_id;

  /// Changed notification.
  late Notification notification;

  /// A notification was changed
  UpdateNotification(
      {required this.notification_group_id,
      required this.notification,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNotification',
      if (extra != null) '@extra': extra,
      'notification_group_id': notification_group_id,
      'notification': notification
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNotification? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var notification_group_id = _map['notification_group_id']! as int;
    var notification = Notification.fromMap(_map['notification'])!;
    return UpdateNotification(
      extra: extra,
      clientId: clientId,
      notification_group_id: notification_group_id,
      notification: notification,
    );
  }
}

/// A list of active notifications in a notification group has changed.
///
class UpdateNotificationGroup extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNotificationGroup";

  /// Unique notification group identifier.
  late int notification_group_id;

  /// New type of the notification group.
  late NotificationGroupType type;

  /// Identifier of a chat to which all notifications in the group belong.
  late int chat_id;

  /// Chat identifier, which notification settings must be applied to the added notifications.
  late int notification_settings_chat_id;

  /// Identifier of the notification sound to be played; 0 if sound is disabled.
  /// ; string representation of int, use `int.parse`
  late int64 notification_sound_id;

  /// Total number of unread notifications in the group, can be bigger than number of active notifications.
  late int total_count;

  /// List of added group notifications, sorted by notification identifier.
  late List<Notification> added_notifications;

  /// Identifiers of removed group notifications, sorted by notification identifier.
  late List<int> removed_notification_ids;

  /// A list of active notifications in a notification group has changed
  UpdateNotificationGroup(
      {required this.notification_group_id,
      required this.type,
      required this.chat_id,
      required this.notification_settings_chat_id,
      required this.notification_sound_id,
      required this.total_count,
      required this.added_notifications,
      required this.removed_notification_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNotificationGroup',
      if (extra != null) '@extra': extra,
      'notification_group_id': notification_group_id,
      'type': type,
      'chat_id': chat_id,
      'notification_settings_chat_id': notification_settings_chat_id,
      'notification_sound_id': notification_sound_id,
      'total_count': total_count,
      'added_notifications': added_notifications,
      'removed_notification_ids': removed_notification_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNotificationGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var notification_group_id = _map['notification_group_id']! as int;
    var type = NotificationGroupType.fromMap(_map['type'])!;
    var chat_id = _map['chat_id']! as int;
    var notification_settings_chat_id =
        _map['notification_settings_chat_id']! as int;
    var notification_sound_id = _map['notification_sound_id']! as int64;
    var total_count = _map['total_count']! as int;
    var added_notifications = List<Notification>.from(
      (_map["added_notifications"] ?? []).map(
        (e) => Notification.fromMap(e),
      ),
    );
    var removed_notification_ids = List<int>.from(
      (_map["removed_notification_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UpdateNotificationGroup(
      extra: extra,
      clientId: clientId,
      notification_group_id: notification_group_id,
      type: type,
      chat_id: chat_id,
      notification_settings_chat_id: notification_settings_chat_id,
      notification_sound_id: notification_sound_id,
      total_count: total_count,
      added_notifications: added_notifications,
      removed_notification_ids: removed_notification_ids,
    );
  }
}

/// Contains active notifications that was shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update.
///
class UpdateActiveNotifications extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateActiveNotifications";

  /// Lists of active notification groups.
  late List<NotificationGroup> groups;

  /// Contains active notifications that was shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
  UpdateActiveNotifications({required this.groups, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateActiveNotifications',
      if (extra != null) '@extra': extra,
      'groups': groups
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateActiveNotifications? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var groups = List<NotificationGroup>.from(
      (_map["groups"] ?? []).map(
        (e) => NotificationGroup.fromMap(e),
      ),
    );
    return UpdateActiveNotifications(
      extra: extra,
      clientId: clientId,
      groups: groups,
    );
  }
}

/// Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications.
///
class UpdateHavePendingNotifications extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateHavePendingNotifications";

  /// True, if there are some delayed notification updates, which will be sent soon.
  late bool have_delayed_notifications;

  /// True, if there can be some yet unreceived notifications, which are being fetched from the server.
  late bool have_unreceived_notifications;

  /// Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
  UpdateHavePendingNotifications(
      {required this.have_delayed_notifications,
      required this.have_unreceived_notifications,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateHavePendingNotifications',
      if (extra != null) '@extra': extra,
      'have_delayed_notifications': have_delayed_notifications,
      'have_unreceived_notifications': have_unreceived_notifications
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateHavePendingNotifications? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var have_delayed_notifications =
        _map['have_delayed_notifications']! as bool;
    var have_unreceived_notifications =
        _map['have_unreceived_notifications']! as bool;
    return UpdateHavePendingNotifications(
      extra: extra,
      clientId: clientId,
      have_delayed_notifications: have_delayed_notifications,
      have_unreceived_notifications: have_unreceived_notifications,
    );
  }
}

/// Some messages were deleted.
///
class UpdateDeleteMessages extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateDeleteMessages";

  /// Chat identifier.
  late int chat_id;

  /// Identifiers of the deleted messages.
  late List<int> message_ids;

  /// True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible).
  late bool is_permanent;

  /// True, if the messages are deleted only from the cache and can possibly be retrieved again in the future.
  late bool from_cache;

  /// Some messages were deleted
  UpdateDeleteMessages(
      {required this.chat_id,
      required this.message_ids,
      required this.is_permanent,
      required this.from_cache,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateDeleteMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_ids': message_ids,
      'is_permanent': is_permanent,
      'from_cache': from_cache
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateDeleteMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_ids = List<int>.from(
      (_map["message_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var is_permanent = _map['is_permanent']! as bool;
    var from_cache = _map['from_cache']! as bool;
    return UpdateDeleteMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_ids: message_ids,
      is_permanent: is_permanent,
      from_cache: from_cache,
    );
  }
}

/// A message sender activity in the chat has changed.
///
class UpdateChatAction extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatAction";

  /// Chat identifier.
  late int chat_id;

  /// If not 0, a message thread identifier in which the action was performed.
  late int message_thread_id;

  /// Identifier of a message sender performing the action.
  late MessageSender sender_id;

  /// The action.
  late ChatAction action;

  /// A message sender activity in the chat has changed
  UpdateChatAction(
      {required this.chat_id,
      required this.message_thread_id,
      required this.sender_id,
      required this.action,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatAction',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'sender_id': sender_id,
      'action': action
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatAction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var sender_id = MessageSender.fromMap(_map['sender_id'])!;
    var action = ChatAction.fromMap(_map['action'])!;
    return UpdateChatAction(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      sender_id: sender_id,
      action: action,
    );
  }
}

/// The user went online or offline.
///
class UpdateUserStatus extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateUserStatus";

  /// User identifier.
  late int user_id;

  /// New status of the user.
  late UserStatus status;

  /// The user went online or offline
  UpdateUserStatus(
      {required this.user_id, required this.status, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateUserStatus',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'status': status
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateUserStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var status = UserStatus.fromMap(_map['status'])!;
    return UpdateUserStatus(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      status: status,
    );
  }
}

/// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application.
///
class UpdateUser extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateUser";

  /// New data about the user.
  late User user;

  /// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application
  UpdateUser({required this.user, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateUser',
      if (extra != null) '@extra': extra,
      'user': user
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user = User.fromMap(_map['user'])!;
    return UpdateUser(
      extra: extra,
      clientId: clientId,
      user: user,
    );
  }
}

/// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application.
///
class UpdateBasicGroup extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateBasicGroup";

  /// New data about the group.
  late BasicGroup basic_group;

  /// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application
  UpdateBasicGroup({required this.basic_group, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateBasicGroup',
      if (extra != null) '@extra': extra,
      'basic_group': basic_group
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateBasicGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var basic_group = BasicGroup.fromMap(_map['basic_group'])!;
    return UpdateBasicGroup(
      extra: extra,
      clientId: clientId,
      basic_group: basic_group,
    );
  }
}

/// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application.
///
class UpdateSupergroup extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateSupergroup";

  /// New data about the supergroup.
  late Supergroup supergroup;

  /// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application
  UpdateSupergroup({required this.supergroup, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateSupergroup',
      if (extra != null) '@extra': extra,
      'supergroup': supergroup
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateSupergroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup = Supergroup.fromMap(_map['supergroup'])!;
    return UpdateSupergroup(
      extra: extra,
      clientId: clientId,
      supergroup: supergroup,
    );
  }
}

/// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application.
///
class UpdateSecretChat extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateSecretChat";

  /// New data about the secret chat.
  late SecretChat secret_chat;

  /// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application
  UpdateSecretChat({required this.secret_chat, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateSecretChat',
      if (extra != null) '@extra': extra,
      'secret_chat': secret_chat
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateSecretChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var secret_chat = SecretChat.fromMap(_map['secret_chat'])!;
    return UpdateSecretChat(
      extra: extra,
      clientId: clientId,
      secret_chat: secret_chat,
    );
  }
}

/// Some data in userFullInfo has been changed.
///
class UpdateUserFullInfo extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateUserFullInfo";

  /// User identifier.
  late int user_id;

  /// New full information about the user.
  late UserFullInfo user_full_info;

  /// Some data in userFullInfo has been changed
  UpdateUserFullInfo(
      {required this.user_id,
      required this.user_full_info,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateUserFullInfo',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'user_full_info': user_full_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateUserFullInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var user_full_info = UserFullInfo.fromMap(_map['user_full_info'])!;
    return UpdateUserFullInfo(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      user_full_info: user_full_info,
    );
  }
}

/// Some data in basicGroupFullInfo has been changed.
///
class UpdateBasicGroupFullInfo extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateBasicGroupFullInfo";

  /// Identifier of a basic group.
  late int basic_group_id;

  /// New full information about the group.
  late BasicGroupFullInfo basic_group_full_info;

  /// Some data in basicGroupFullInfo has been changed
  UpdateBasicGroupFullInfo(
      {required this.basic_group_id,
      required this.basic_group_full_info,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateBasicGroupFullInfo',
      if (extra != null) '@extra': extra,
      'basic_group_id': basic_group_id,
      'basic_group_full_info': basic_group_full_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateBasicGroupFullInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var basic_group_id = _map['basic_group_id']! as int;
    var basic_group_full_info =
        BasicGroupFullInfo.fromMap(_map['basic_group_full_info'])!;
    return UpdateBasicGroupFullInfo(
      extra: extra,
      clientId: clientId,
      basic_group_id: basic_group_id,
      basic_group_full_info: basic_group_full_info,
    );
  }
}

/// Some data in supergroupFullInfo has been changed.
///
class UpdateSupergroupFullInfo extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateSupergroupFullInfo";

  /// Identifier of the supergroup or channel.
  late int supergroup_id;

  /// New full information about the supergroup.
  late SupergroupFullInfo supergroup_full_info;

  /// Some data in supergroupFullInfo has been changed
  UpdateSupergroupFullInfo(
      {required this.supergroup_id,
      required this.supergroup_full_info,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateSupergroupFullInfo',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'supergroup_full_info': supergroup_full_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateSupergroupFullInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var supergroup_full_info =
        SupergroupFullInfo.fromMap(_map['supergroup_full_info'])!;
    return UpdateSupergroupFullInfo(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      supergroup_full_info: supergroup_full_info,
    );
  }
}

/// A service notification from the server was received. Upon receiving this the application must show a popup with the content of the notification.
///
class UpdateServiceNotification extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateServiceNotification";

  /// Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method.
  late String type;

  /// Notification content.
  late MessageContent content;

  /// A service notification from the server was received. Upon receiving this the application must show a popup with the content of the notification
  UpdateServiceNotification(
      {required this.type, required this.content, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateServiceNotification',
      if (extra != null) '@extra': extra,
      'type': type,
      'content': content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateServiceNotification? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = _map['type']! as String;
    var content = MessageContent.fromMap(_map['content'])!;
    return UpdateServiceNotification(
      extra: extra,
      clientId: clientId,
      type: type,
      content: content,
    );
  }
}

/// Information about a file was updated.
///
class UpdateFile extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateFile";

  /// New data about the file.
  late File file;

  /// Information about a file was updated
  UpdateFile({required this.file, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateFile',
      if (extra != null) '@extra': extra,
      'file': file
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file = File.fromMap(_map['file'])!;
    return UpdateFile(
      extra: extra,
      clientId: clientId,
      file: file,
    );
  }
}

/// The file generation process needs to be started by the application.
///
class UpdateFileGenerationStart extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateFileGenerationStart";

  /// Unique identifier for the generation process.
  /// ; string representation of int, use `int.parse`
  late int64 generation_id;

  /// The path to a file from which a new file is generated; may be empty.
  late String original_path;

  /// The path to a file that must be created and where the new file is generated.
  late String destination_path;

  /// String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application.
  late String conversion;

  /// The file generation process needs to be started by the application
  UpdateFileGenerationStart(
      {required this.generation_id,
      required this.original_path,
      required this.destination_path,
      required this.conversion,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateFileGenerationStart',
      if (extra != null) '@extra': extra,
      'generation_id': generation_id,
      'original_path': original_path,
      'destination_path': destination_path,
      'conversion': conversion
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateFileGenerationStart? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var generation_id = _map['generation_id']! as int64;
    var original_path = _map['original_path']! as String;
    var destination_path = _map['destination_path']! as String;
    var conversion = _map['conversion']! as String;
    return UpdateFileGenerationStart(
      extra: extra,
      clientId: clientId,
      generation_id: generation_id,
      original_path: original_path,
      destination_path: destination_path,
      conversion: conversion,
    );
  }
}

/// File generation is no longer needed.
///
class UpdateFileGenerationStop extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateFileGenerationStop";

  /// Unique identifier for the generation process.
  /// ; string representation of int, use `int.parse`
  late int64 generation_id;

  /// File generation is no longer needed
  UpdateFileGenerationStop(
      {required this.generation_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateFileGenerationStop',
      if (extra != null) '@extra': extra,
      'generation_id': generation_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateFileGenerationStop? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var generation_id = _map['generation_id']! as int64;
    return UpdateFileGenerationStop(
      extra: extra,
      clientId: clientId,
      generation_id: generation_id,
    );
  }
}

/// The state of the file download list has changed.
///
class UpdateFileDownloads extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateFileDownloads";

  /// Total size of files in the file download list, in bytes.
  late int total_size;

  /// Total number of files in the file download list.
  late int total_count;

  /// Total downloaded size of files in the file download list, in bytes.
  late int downloaded_size;

  /// The state of the file download list has changed
  UpdateFileDownloads(
      {required this.total_size,
      required this.total_count,
      required this.downloaded_size,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateFileDownloads',
      if (extra != null) '@extra': extra,
      'total_size': total_size,
      'total_count': total_count,
      'downloaded_size': downloaded_size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateFileDownloads? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var total_size = _map['total_size']! as int;
    var total_count = _map['total_count']! as int;
    var downloaded_size = _map['downloaded_size']! as int;
    return UpdateFileDownloads(
      extra: extra,
      clientId: clientId,
      total_size: total_size,
      total_count: total_count,
      downloaded_size: downloaded_size,
    );
  }
}

/// A file was added to the file download list. This update is sent only after file download list is loaded for the first time.
///
class UpdateFileAddedToDownloads extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateFileAddedToDownloads";

  /// The added file download.
  late FileDownload file_download;

  /// New number of being downloaded and recently downloaded files found.
  late DownloadedFileCounts counts;

  /// A file was added to the file download list. This update is sent only after file download list is loaded for the first time
  UpdateFileAddedToDownloads(
      {required this.file_download,
      required this.counts,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateFileAddedToDownloads',
      if (extra != null) '@extra': extra,
      'file_download': file_download,
      'counts': counts
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateFileAddedToDownloads? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_download = FileDownload.fromMap(_map['file_download'])!;
    var counts = DownloadedFileCounts.fromMap(_map['counts'])!;
    return UpdateFileAddedToDownloads(
      extra: extra,
      clientId: clientId,
      file_download: file_download,
      counts: counts,
    );
  }
}

/// A file download was changed. This update is sent only after file download list is loaded for the first time.
///
class UpdateFileDownload extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateFileDownload";

  /// File identifier.
  late int file_id;

  /// Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed.
  late int complete_date;

  /// True, if downloading of the file is paused.
  late bool is_paused;

  /// New number of being downloaded and recently downloaded files found.
  late DownloadedFileCounts counts;

  /// A file download was changed. This update is sent only after file download list is loaded for the first time
  UpdateFileDownload(
      {required this.file_id,
      required this.complete_date,
      required this.is_paused,
      required this.counts,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateFileDownload',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'complete_date': complete_date,
      'is_paused': is_paused,
      'counts': counts
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateFileDownload? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var complete_date = _map['complete_date']! as int;
    var is_paused = _map['is_paused']! as bool;
    var counts = DownloadedFileCounts.fromMap(_map['counts'])!;
    return UpdateFileDownload(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      complete_date: complete_date,
      is_paused: is_paused,
      counts: counts,
    );
  }
}

/// A file was removed from the file download list. This update is sent only after file download list is loaded for the first time.
///
class UpdateFileRemovedFromDownloads extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateFileRemovedFromDownloads";

  /// File identifier.
  late int file_id;

  /// New number of being downloaded and recently downloaded files found.
  late DownloadedFileCounts counts;

  /// A file was removed from the file download list. This update is sent only after file download list is loaded for the first time
  UpdateFileRemovedFromDownloads(
      {required this.file_id, required this.counts, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateFileRemovedFromDownloads',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'counts': counts
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateFileRemovedFromDownloads? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var counts = DownloadedFileCounts.fromMap(_map['counts'])!;
    return UpdateFileRemovedFromDownloads(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      counts: counts,
    );
  }
}

/// New call was created or information about a call was updated.
///
class UpdateCall extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateCall";

  /// New data about a call.
  late Call call;

  /// New call was created or information about a call was updated
  UpdateCall({required this.call, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateCall',
      if (extra != null) '@extra': extra,
      'call': call
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var call = Call.fromMap(_map['call'])!;
    return UpdateCall(
      extra: extra,
      clientId: clientId,
      call: call,
    );
  }
}

/// Information about a group call was updated.
///
class UpdateGroupCall extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateGroupCall";

  /// New data about a group call.
  late GroupCall group_call;

  /// Information about a group call was updated
  UpdateGroupCall({required this.group_call, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateGroupCall',
      if (extra != null) '@extra': extra,
      'group_call': group_call
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateGroupCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call = GroupCall.fromMap(_map['group_call'])!;
    return UpdateGroupCall(
      extra: extra,
      clientId: clientId,
      group_call: group_call,
    );
  }
}

/// Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined.
///
class UpdateGroupCallParticipant extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateGroupCallParticipant";

  /// Identifier of group call.
  late int group_call_id;

  /// New data about a participant.
  late GroupCallParticipant participant;

  /// Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined
  UpdateGroupCallParticipant(
      {required this.group_call_id,
      required this.participant,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateGroupCallParticipant',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'participant': participant
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateGroupCallParticipant? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var participant = GroupCallParticipant.fromMap(_map['participant'])!;
    return UpdateGroupCallParticipant(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      participant: participant,
    );
  }
}

/// New call signaling data arrived.
///
class UpdateNewCallSignalingData extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewCallSignalingData";

  /// The call identifier.
  late int call_id;

  /// The data.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// New call signaling data arrived
  UpdateNewCallSignalingData(
      {required this.call_id, required this.data, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewCallSignalingData',
      if (extra != null) '@extra': extra,
      'call_id': call_id,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewCallSignalingData? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var call_id = _map['call_id']! as int;
    var data = _map['data']! as bytes;
    return UpdateNewCallSignalingData(
      extra: extra,
      clientId: clientId,
      call_id: call_id,
      data: data,
    );
  }
}

/// Some privacy setting rules have been changed.
///
class UpdateUserPrivacySettingRules extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateUserPrivacySettingRules";

  /// The privacy setting.
  late UserPrivacySetting setting;

  /// New privacy rules.
  late UserPrivacySettingRules rules;

  /// Some privacy setting rules have been changed
  UpdateUserPrivacySettingRules(
      {required this.setting, required this.rules, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateUserPrivacySettingRules',
      if (extra != null) '@extra': extra,
      'setting': setting,
      'rules': rules
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateUserPrivacySettingRules? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var setting = UserPrivacySetting.fromMap(_map['setting'])!;
    var rules = UserPrivacySettingRules.fromMap(_map['rules'])!;
    return UpdateUserPrivacySettingRules(
      extra: extra,
      clientId: clientId,
      setting: setting,
      rules: rules,
    );
  }
}

/// Number of unread messages in a chat list has changed. This update is sent only if the message database is used.
///
class UpdateUnreadMessageCount extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateUnreadMessageCount";

  /// The chat list with changed number of unread messages.
  late ChatList chat_list;

  /// Total number of unread messages.
  late int unread_count;

  /// Total number of unread messages in unmuted chats.
  late int unread_unmuted_count;

  /// Number of unread messages in a chat list has changed. This update is sent only if the message database is used
  UpdateUnreadMessageCount(
      {required this.chat_list,
      required this.unread_count,
      required this.unread_unmuted_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateUnreadMessageCount',
      if (extra != null) '@extra': extra,
      'chat_list': chat_list,
      'unread_count': unread_count,
      'unread_unmuted_count': unread_unmuted_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateUnreadMessageCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_list = ChatList.fromMap(_map['chat_list'])!;
    var unread_count = _map['unread_count']! as int;
    var unread_unmuted_count = _map['unread_unmuted_count']! as int;
    return UpdateUnreadMessageCount(
      extra: extra,
      clientId: clientId,
      chat_list: chat_list,
      unread_count: unread_count,
      unread_unmuted_count: unread_unmuted_count,
    );
  }
}

/// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used.
///
class UpdateUnreadChatCount extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateUnreadChatCount";

  /// The chat list with changed number of unread messages.
  late ChatList chat_list;

  /// Approximate total number of chats in the chat list.
  late int total_count;

  /// Total number of unread chats.
  late int unread_count;

  /// Total number of unread unmuted chats.
  late int unread_unmuted_count;

  /// Total number of chats marked as unread.
  late int marked_as_unread_count;

  /// Total number of unmuted chats marked as unread.
  late int marked_as_unread_unmuted_count;

  /// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
  UpdateUnreadChatCount(
      {required this.chat_list,
      required this.total_count,
      required this.unread_count,
      required this.unread_unmuted_count,
      required this.marked_as_unread_count,
      required this.marked_as_unread_unmuted_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateUnreadChatCount',
      if (extra != null) '@extra': extra,
      'chat_list': chat_list,
      'total_count': total_count,
      'unread_count': unread_count,
      'unread_unmuted_count': unread_unmuted_count,
      'marked_as_unread_count': marked_as_unread_count,
      'marked_as_unread_unmuted_count': marked_as_unread_unmuted_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateUnreadChatCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_list = ChatList.fromMap(_map['chat_list'])!;
    var total_count = _map['total_count']! as int;
    var unread_count = _map['unread_count']! as int;
    var unread_unmuted_count = _map['unread_unmuted_count']! as int;
    var marked_as_unread_count = _map['marked_as_unread_count']! as int;
    var marked_as_unread_unmuted_count =
        _map['marked_as_unread_unmuted_count']! as int;
    return UpdateUnreadChatCount(
      extra: extra,
      clientId: clientId,
      chat_list: chat_list,
      total_count: total_count,
      unread_count: unread_count,
      unread_unmuted_count: unread_unmuted_count,
      marked_as_unread_count: marked_as_unread_count,
      marked_as_unread_unmuted_count: marked_as_unread_unmuted_count,
    );
  }
}

/// A story was changed.
///
class UpdateStory extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateStory";

  /// The new information about the story.
  late Story story;

  /// A story was changed
  UpdateStory({required this.story, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateStory',
      if (extra != null) '@extra': extra,
      'story': story
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story = Story.fromMap(_map['story'])!;
    return UpdateStory(
      extra: extra,
      clientId: clientId,
      story: story,
    );
  }
}

/// A story became inaccessible.
///
class UpdateStoryDeleted extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateStoryDeleted";

  /// Identifier of the chat that posted the story.
  late int story_sender_chat_id;

  /// Story identifier.
  late int story_id;

  /// A story became inaccessible
  UpdateStoryDeleted(
      {required this.story_sender_chat_id,
      required this.story_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateStoryDeleted',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateStoryDeleted? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    return UpdateStoryDeleted(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
    );
  }
}

/// A story has been successfully sent.
///
class UpdateStorySendSucceeded extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateStorySendSucceeded";

  /// The sent story.
  late Story story;

  /// The previous temporary story identifier.
  late int old_story_id;

  /// A story has been successfully sent
  UpdateStorySendSucceeded(
      {required this.story,
      required this.old_story_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateStorySendSucceeded',
      if (extra != null) '@extra': extra,
      'story': story,
      'old_story_id': old_story_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateStorySendSucceeded? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story = Story.fromMap(_map['story'])!;
    var old_story_id = _map['old_story_id']! as int;
    return UpdateStorySendSucceeded(
      extra: extra,
      clientId: clientId,
      story: story,
      old_story_id: old_story_id,
    );
  }
}

/// A story failed to send. If the story sending is canceled, then updateStoryDeleted will be received instead of this update.
///
class UpdateStorySendFailed extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateStorySendFailed";

  /// The failed to send story.
  late Story story;

  /// The cause of the story sending failure.
  late Error error;

  /// Type of the error; may be null if unknown.
  CanSendStoryResult? error_type;

  /// A story failed to send. If the story sending is canceled, then updateStoryDeleted will be received instead of this update
  UpdateStorySendFailed(
      {required this.story,
      required this.error,
      this.error_type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateStorySendFailed',
      if (extra != null) '@extra': extra,
      'story': story,
      'error': error,
      'error_type': error_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateStorySendFailed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story = Story.fromMap(_map['story'])!;
    var error = Error.fromMap(_map['error'])!;
    var error_type = CanSendStoryResult.fromMap(_map['error_type']);
    return UpdateStorySendFailed(
      extra: extra,
      clientId: clientId,
      story: story,
      error: error,
      error_type: error_type,
    );
  }
}

/// The list of active stories posted by a specific chat has changed.
///
class UpdateChatActiveStories extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatActiveStories";

  /// The new list of active stories.
  late ChatActiveStories active_stories;

  /// The list of active stories posted by a specific chat has changed
  UpdateChatActiveStories(
      {required this.active_stories, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatActiveStories',
      if (extra != null) '@extra': extra,
      'active_stories': active_stories
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatActiveStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var active_stories = ChatActiveStories.fromMap(_map['active_stories'])!;
    return UpdateChatActiveStories(
      extra: extra,
      clientId: clientId,
      active_stories: active_stories,
    );
  }
}

/// Number of chats in a story list has changed.
///
class UpdateStoryListChatCount extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateStoryListChatCount";

  /// The story list.
  late StoryList story_list;

  /// Approximate total number of chats with active stories in the list.
  late int chat_count;

  /// Number of chats in a story list has changed
  UpdateStoryListChatCount(
      {required this.story_list,
      required this.chat_count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateStoryListChatCount',
      if (extra != null) '@extra': extra,
      'story_list': story_list,
      'chat_count': chat_count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateStoryListChatCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_list = StoryList.fromMap(_map['story_list'])!;
    var chat_count = _map['chat_count']! as int;
    return UpdateStoryListChatCount(
      extra: extra,
      clientId: clientId,
      story_list: story_list,
      chat_count: chat_count,
    );
  }
}

/// Story stealth mode settings have changed.
///
class UpdateStoryStealthMode extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateStoryStealthMode";

  /// Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled.
  late int active_until_date;

  /// Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if there is no active cooldown.
  late int cooldown_until_date;

  /// Story stealth mode settings have changed
  UpdateStoryStealthMode(
      {required this.active_until_date,
      required this.cooldown_until_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateStoryStealthMode',
      if (extra != null) '@extra': extra,
      'active_until_date': active_until_date,
      'cooldown_until_date': cooldown_until_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateStoryStealthMode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var active_until_date = _map['active_until_date']! as int;
    var cooldown_until_date = _map['cooldown_until_date']! as int;
    return UpdateStoryStealthMode(
      extra: extra,
      clientId: clientId,
      active_until_date: active_until_date,
      cooldown_until_date: cooldown_until_date,
    );
  }
}

/// An option changed its value.
///
class UpdateOption extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateOption";

  /// The option name.
  late String name;

  /// The new option value.
  late OptionValue value;

  /// An option changed its value
  UpdateOption(
      {required this.name, required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateOption',
      if (extra != null) '@extra': extra,
      'name': name,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateOption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var value = OptionValue.fromMap(_map['value'])!;
    return UpdateOption(
      extra: extra,
      clientId: clientId,
      name: name,
      value: value,
    );
  }
}

/// A sticker set has changed.
///
class UpdateStickerSet extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateStickerSet";

  /// The sticker set.
  late StickerSet sticker_set;

  /// A sticker set has changed
  UpdateStickerSet({required this.sticker_set, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateStickerSet',
      if (extra != null) '@extra': extra,
      'sticker_set': sticker_set
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateStickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_set = StickerSet.fromMap(_map['sticker_set'])!;
    return UpdateStickerSet(
      extra: extra,
      clientId: clientId,
      sticker_set: sticker_set,
    );
  }
}

/// The list of installed sticker sets was updated.
///
class UpdateInstalledStickerSets extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateInstalledStickerSets";

  /// Type of the affected stickers.
  late StickerType sticker_type;

  /// The new list of installed ordinary sticker sets.
  late List<int64> sticker_set_ids;

  /// The list of installed sticker sets was updated
  UpdateInstalledStickerSets(
      {required this.sticker_type,
      required this.sticker_set_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateInstalledStickerSets',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type,
      'sticker_set_ids': sticker_set_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateInstalledStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var sticker_set_ids = List<int64>.from(
      (_map["sticker_set_ids"] ?? []).map(
        (e) => e as int64,
      ),
    );
    return UpdateInstalledStickerSets(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
      sticker_set_ids: sticker_set_ids,
    );
  }
}

/// The list of trending sticker sets was updated or some of them were viewed.
///
class UpdateTrendingStickerSets extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateTrendingStickerSets";

  /// Type of the affected stickers.
  late StickerType sticker_type;

  /// The prefix of the list of trending sticker sets with the newest trending sticker sets.
  late TrendingStickerSets sticker_sets;

  /// The list of trending sticker sets was updated or some of them were viewed
  UpdateTrendingStickerSets(
      {required this.sticker_type,
      required this.sticker_sets,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateTrendingStickerSets',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type,
      'sticker_sets': sticker_sets
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateTrendingStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var sticker_sets = TrendingStickerSets.fromMap(_map['sticker_sets'])!;
    return UpdateTrendingStickerSets(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
      sticker_sets: sticker_sets,
    );
  }
}

/// The list of recently used stickers was updated.
///
class UpdateRecentStickers extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateRecentStickers";

  /// True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated.
  late bool is_attached;

  /// The new list of file identifiers of recently used stickers.
  late List<int> sticker_ids;

  /// The list of recently used stickers was updated
  UpdateRecentStickers(
      {required this.is_attached,
      required this.sticker_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateRecentStickers',
      if (extra != null) '@extra': extra,
      'is_attached': is_attached,
      'sticker_ids': sticker_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateRecentStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_attached = _map['is_attached']! as bool;
    var sticker_ids = List<int>.from(
      (_map["sticker_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UpdateRecentStickers(
      extra: extra,
      clientId: clientId,
      is_attached: is_attached,
      sticker_ids: sticker_ids,
    );
  }
}

/// The list of favorite stickers was updated.
///
class UpdateFavoriteStickers extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateFavoriteStickers";

  /// The new list of file identifiers of favorite stickers.
  late List<int> sticker_ids;

  /// The list of favorite stickers was updated
  UpdateFavoriteStickers(
      {required this.sticker_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateFavoriteStickers',
      if (extra != null) '@extra': extra,
      'sticker_ids': sticker_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateFavoriteStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_ids = List<int>.from(
      (_map["sticker_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UpdateFavoriteStickers(
      extra: extra,
      clientId: clientId,
      sticker_ids: sticker_ids,
    );
  }
}

/// The list of saved animations was updated.
///
class UpdateSavedAnimations extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateSavedAnimations";

  /// The new list of file identifiers of saved animations.
  late List<int> animation_ids;

  /// The list of saved animations was updated
  UpdateSavedAnimations(
      {required this.animation_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateSavedAnimations',
      if (extra != null) '@extra': extra,
      'animation_ids': animation_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateSavedAnimations? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animation_ids = List<int>.from(
      (_map["animation_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UpdateSavedAnimations(
      extra: extra,
      clientId: clientId,
      animation_ids: animation_ids,
    );
  }
}

/// The list of saved notifications sounds was updated. This update may not be sent until information about a notification sound was requested for the first time.
///
class UpdateSavedNotificationSounds extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateSavedNotificationSounds";

  /// The new list of identifiers of saved notification sounds.
  late List<int64> notification_sound_ids;

  /// The list of saved notifications sounds was updated. This update may not be sent until information about a notification sound was requested for the first time
  UpdateSavedNotificationSounds(
      {required this.notification_sound_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateSavedNotificationSounds',
      if (extra != null) '@extra': extra,
      'notification_sound_ids': notification_sound_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateSavedNotificationSounds? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var notification_sound_ids = List<int64>.from(
      (_map["notification_sound_ids"] ?? []).map(
        (e) => e as int64,
      ),
    );
    return UpdateSavedNotificationSounds(
      extra: extra,
      clientId: clientId,
      notification_sound_ids: notification_sound_ids,
    );
  }
}

/// The selected background has changed.
///
class UpdateSelectedBackground extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateSelectedBackground";

  /// True, if background for dark theme has changed.
  late bool for_dark_theme;

  /// The new selected background; may be null.
  Background? background;

  /// The selected background has changed
  UpdateSelectedBackground(
      {required this.for_dark_theme,
      this.background,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateSelectedBackground',
      if (extra != null) '@extra': extra,
      'for_dark_theme': for_dark_theme,
      'background': background
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateSelectedBackground? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var for_dark_theme = _map['for_dark_theme']! as bool;
    var background = Background.fromMap(_map['background']);
    return UpdateSelectedBackground(
      extra: extra,
      clientId: clientId,
      for_dark_theme: for_dark_theme,
      background: background,
    );
  }
}

/// The list of available chat themes has changed.
///
class UpdateChatThemes extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatThemes";

  /// The new list of chat themes.
  late List<ChatTheme> chat_themes;

  /// The list of available chat themes has changed
  UpdateChatThemes({required this.chat_themes, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatThemes',
      if (extra != null) '@extra': extra,
      'chat_themes': chat_themes
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatThemes? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_themes = List<ChatTheme>.from(
      (_map["chat_themes"] ?? []).map(
        (e) => ChatTheme.fromMap(e),
      ),
    );
    return UpdateChatThemes(
      extra: extra,
      clientId: clientId,
      chat_themes: chat_themes,
    );
  }
}

/// Some language pack strings have been updated.
///
class UpdateLanguagePackStrings extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateLanguagePackStrings";

  /// Localization target to which the language pack belongs.
  late String localization_target;

  /// Identifier of the updated language pack.
  late String language_pack_id;

  /// List of changed language pack strings; empty if all strings have changed.
  late List<LanguagePackString> strings;

  /// Some language pack strings have been updated
  UpdateLanguagePackStrings(
      {required this.localization_target,
      required this.language_pack_id,
      required this.strings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateLanguagePackStrings',
      if (extra != null) '@extra': extra,
      'localization_target': localization_target,
      'language_pack_id': language_pack_id,
      'strings': strings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateLanguagePackStrings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var localization_target = _map['localization_target']! as String;
    var language_pack_id = _map['language_pack_id']! as String;
    var strings = List<LanguagePackString>.from(
      (_map["strings"] ?? []).map(
        (e) => LanguagePackString.fromMap(e),
      ),
    );
    return UpdateLanguagePackStrings(
      extra: extra,
      clientId: clientId,
      localization_target: localization_target,
      language_pack_id: language_pack_id,
      strings: strings,
    );
  }
}

/// The connection state has changed. This update must be used only to show a human-readable description of the connection state.
///
class UpdateConnectionState extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateConnectionState";

  /// The new connection state.
  late ConnectionState state;

  /// The connection state has changed. This update must be used only to show a human-readable description of the connection state
  UpdateConnectionState({required this.state, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateConnectionState',
      if (extra != null) '@extra': extra,
      'state': state
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateConnectionState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var state = ConnectionState.fromMap(_map['state'])!;
    return UpdateConnectionState(
      extra: extra,
      clientId: clientId,
      state: state,
    );
  }
}

/// New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update".
///
class UpdateTermsOfService extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateTermsOfService";

  /// Identifier of the terms of service.
  late String terms_of_service_id;

  /// The new terms of service.
  late TermsOfService terms_of_service;

  /// New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update"
  UpdateTermsOfService(
      {required this.terms_of_service_id,
      required this.terms_of_service,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateTermsOfService',
      if (extra != null) '@extra': extra,
      'terms_of_service_id': terms_of_service_id,
      'terms_of_service': terms_of_service
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateTermsOfService? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var terms_of_service_id = _map['terms_of_service_id']! as String;
    var terms_of_service = TermsOfService.fromMap(_map['terms_of_service'])!;
    return UpdateTermsOfService(
      extra: extra,
      clientId: clientId,
      terms_of_service_id: terms_of_service_id,
      terms_of_service: terms_of_service,
    );
  }
}

/// The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request.
///
class UpdateUsersNearby extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateUsersNearby";

  /// The new list of users nearby.
  late List<ChatNearby> users_nearby;

  /// The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request
  UpdateUsersNearby({required this.users_nearby, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateUsersNearby',
      if (extra != null) '@extra': extra,
      'users_nearby': users_nearby
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateUsersNearby? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var users_nearby = List<ChatNearby>.from(
      (_map["users_nearby"] ?? []).map(
        (e) => ChatNearby.fromMap(e),
      ),
    );
    return UpdateUsersNearby(
      extra: extra,
      clientId: clientId,
      users_nearby: users_nearby,
    );
  }
}

/// The first unconfirmed session has changed.
///
class UpdateUnconfirmedSession extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateUnconfirmedSession";

  /// The unconfirmed session; may be null if none.
  UnconfirmedSession? session;

  /// The first unconfirmed session has changed
  UpdateUnconfirmedSession({this.session, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateUnconfirmedSession',
      if (extra != null) '@extra': extra,
      'session': session
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateUnconfirmedSession? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var session = UnconfirmedSession.fromMap(_map['session']);
    return UpdateUnconfirmedSession(
      extra: extra,
      clientId: clientId,
      session: session,
    );
  }
}

/// The list of bots added to attachment or side menu has changed.
///
class UpdateAttachmentMenuBots extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateAttachmentMenuBots";

  /// The new list of bots. The bots must not be shown on scheduled messages screen.
  late List<AttachmentMenuBot> bots;

  /// The list of bots added to attachment or side menu has changed
  UpdateAttachmentMenuBots({required this.bots, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateAttachmentMenuBots',
      if (extra != null) '@extra': extra,
      'bots': bots
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateAttachmentMenuBots? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bots = List<AttachmentMenuBot>.from(
      (_map["bots"] ?? []).map(
        (e) => AttachmentMenuBot.fromMap(e),
      ),
    );
    return UpdateAttachmentMenuBots(
      extra: extra,
      clientId: clientId,
      bots: bots,
    );
  }
}

/// A message was sent by an opened Web App, so the Web App needs to be closed.
///
class UpdateWebAppMessageSent extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateWebAppMessageSent";

  /// Identifier of Web App launch.
  /// ; string representation of int, use `int.parse`
  late int64 web_app_launch_id;

  /// A message was sent by an opened Web App, so the Web App needs to be closed
  UpdateWebAppMessageSent(
      {required this.web_app_launch_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateWebAppMessageSent',
      if (extra != null) '@extra': extra,
      'web_app_launch_id': web_app_launch_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateWebAppMessageSent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var web_app_launch_id = _map['web_app_launch_id']! as int64;
    return UpdateWebAppMessageSent(
      extra: extra,
      clientId: clientId,
      web_app_launch_id: web_app_launch_id,
    );
  }
}

/// The list of active emoji reactions has changed.
///
class UpdateActiveEmojiReactions extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateActiveEmojiReactions";

  /// The new list of active emoji reactions.
  late List<String> emojis;

  /// The list of active emoji reactions has changed
  UpdateActiveEmojiReactions({required this.emojis, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateActiveEmojiReactions',
      if (extra != null) '@extra': extra,
      'emojis': emojis
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateActiveEmojiReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emojis = List<String>.from(
      (_map["emojis"] ?? []).map(
        (e) => e as String,
      ),
    );
    return UpdateActiveEmojiReactions(
      extra: extra,
      clientId: clientId,
      emojis: emojis,
    );
  }
}

/// The type of default reaction has changed.
///
class UpdateDefaultReactionType extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateDefaultReactionType";

  /// The new type of the default reaction.
  late ReactionType reaction_type;

  /// The type of default reaction has changed
  UpdateDefaultReactionType(
      {required this.reaction_type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateDefaultReactionType',
      if (extra != null) '@extra': extra,
      'reaction_type': reaction_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateDefaultReactionType? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reaction_type = ReactionType.fromMap(_map['reaction_type'])!;
    return UpdateDefaultReactionType(
      extra: extra,
      clientId: clientId,
      reaction_type: reaction_type,
    );
  }
}

/// The list of supported dice emojis has changed.
///
class UpdateDiceEmojis extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateDiceEmojis";

  /// The new list of supported dice emojis.
  late List<String> emojis;

  /// The list of supported dice emojis has changed
  UpdateDiceEmojis({required this.emojis, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateDiceEmojis',
      if (extra != null) '@extra': extra,
      'emojis': emojis
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateDiceEmojis? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emojis = List<String>.from(
      (_map["emojis"] ?? []).map(
        (e) => e as String,
      ),
    );
    return UpdateDiceEmojis(
      extra: extra,
      clientId: clientId,
      emojis: emojis,
    );
  }
}

/// Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played.
///
class UpdateAnimatedEmojiMessageClicked extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateAnimatedEmojiMessageClicked";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// The animated sticker to be played.
  late Sticker sticker;

  /// Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played
  UpdateAnimatedEmojiMessageClicked(
      {required this.chat_id,
      required this.message_id,
      required this.sticker,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateAnimatedEmojiMessageClicked',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateAnimatedEmojiMessageClicked? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var sticker = Sticker.fromMap(_map['sticker'])!;
    return UpdateAnimatedEmojiMessageClicked(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      sticker: sticker,
    );
  }
}

/// The parameters of animation search through getOption("animation_search_bot_username") bot has changed.
///
class UpdateAnimationSearchParameters extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateAnimationSearchParameters";

  /// Name of the animation search provider.
  late String provider;

  /// The new list of emojis suggested for searching.
  late List<String> emojis;

  /// The parameters of animation search through getOption("animation_search_bot_username") bot has changed
  UpdateAnimationSearchParameters(
      {required this.provider,
      required this.emojis,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateAnimationSearchParameters',
      if (extra != null) '@extra': extra,
      'provider': provider,
      'emojis': emojis
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateAnimationSearchParameters? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var provider = _map['provider']! as String;
    var emojis = List<String>.from(
      (_map["emojis"] ?? []).map(
        (e) => e as String,
      ),
    );
    return UpdateAnimationSearchParameters(
      extra: extra,
      clientId: clientId,
      provider: provider,
      emojis: emojis,
    );
  }
}

/// The list of suggested to the user actions has changed.
///
class UpdateSuggestedActions extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateSuggestedActions";

  /// Added suggested actions.
  late List<SuggestedAction> added_actions;

  /// Removed suggested actions.
  late List<SuggestedAction> removed_actions;

  /// The list of suggested to the user actions has changed
  UpdateSuggestedActions(
      {required this.added_actions,
      required this.removed_actions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateSuggestedActions',
      if (extra != null) '@extra': extra,
      'added_actions': added_actions,
      'removed_actions': removed_actions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateSuggestedActions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var added_actions = List<SuggestedAction>.from(
      (_map["added_actions"] ?? []).map(
        (e) => SuggestedAction.fromMap(e),
      ),
    );
    var removed_actions = List<SuggestedAction>.from(
      (_map["removed_actions"] ?? []).map(
        (e) => SuggestedAction.fromMap(e),
      ),
    );
    return UpdateSuggestedActions(
      extra: extra,
      clientId: clientId,
      added_actions: added_actions,
      removed_actions: removed_actions,
    );
  }
}

/// Adding users to a chat has failed because of their privacy settings. An invite link can be shared with the users if appropriate.
///
class UpdateAddChatMembersPrivacyForbidden extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateAddChatMembersPrivacyForbidden";

  /// Chat identifier.
  late int chat_id;

  /// Identifiers of users, which weren't added because of their privacy settings.
  late List<int> user_ids;

  /// Adding users to a chat has failed because of their privacy settings. An invite link can be shared with the users if appropriate
  UpdateAddChatMembersPrivacyForbidden(
      {required this.chat_id,
      required this.user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateAddChatMembersPrivacyForbidden',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateAddChatMembersPrivacyForbidden? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UpdateAddChatMembersPrivacyForbidden(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      user_ids: user_ids,
    );
  }
}

/// Autosave settings for some type of chats were updated.
///
class UpdateAutosaveSettings extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateAutosaveSettings";

  /// Type of chats for which autosave settings were updated.
  late AutosaveSettingsScope scope;

  /// The new autosave settings; may be null if the settings are reset to default.
  ScopeAutosaveSettings? settings;

  /// Autosave settings for some type of chats were updated
  UpdateAutosaveSettings(
      {required this.scope, this.settings, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateAutosaveSettings',
      if (extra != null) '@extra': extra,
      'scope': scope,
      'settings': settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateAutosaveSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scope = AutosaveSettingsScope.fromMap(_map['scope'])!;
    var settings = ScopeAutosaveSettings.fromMap(_map['settings']);
    return UpdateAutosaveSettings(
      extra: extra,
      clientId: clientId,
      scope: scope,
      settings: settings,
    );
  }
}

/// A new incoming inline query; for bots only.
///
class UpdateNewInlineQuery extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewInlineQuery";

  /// Unique query identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Identifier of the user who sent the query.
  late int sender_user_id;

  /// User location; may be null.
  Location? user_location;

  /// The type of the chat from which the query originated; may be null if unknown.
  ChatType? chat_type;

  /// Text of the query.
  late String query;

  /// Offset of the first entry to return.
  late String offset;

  /// A new incoming inline query; for bots only
  UpdateNewInlineQuery(
      {required this.id,
      required this.sender_user_id,
      this.user_location,
      this.chat_type,
      required this.query,
      required this.offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewInlineQuery',
      if (extra != null) '@extra': extra,
      'id': id,
      'sender_user_id': sender_user_id,
      'user_location': user_location,
      'chat_type': chat_type,
      'query': query,
      'offset': offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewInlineQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var sender_user_id = _map['sender_user_id']! as int;
    var user_location = Location.fromMap(_map['user_location']);
    var chat_type = ChatType.fromMap(_map['chat_type']);
    var query = _map['query']! as String;
    var offset = _map['offset']! as String;
    return UpdateNewInlineQuery(
      extra: extra,
      clientId: clientId,
      id: id,
      sender_user_id: sender_user_id,
      user_location: user_location,
      chat_type: chat_type,
      query: query,
      offset: offset,
    );
  }
}

/// The user has chosen a result of an inline query; for bots only.
///
class UpdateNewChosenInlineResult extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewChosenInlineResult";

  /// Identifier of the user who sent the query.
  late int sender_user_id;

  /// User location; may be null.
  Location? user_location;

  /// Text of the query.
  late String query;

  /// Identifier of the chosen result.
  late String result_id;

  /// Identifier of the sent inline message, if known.
  late String inline_message_id;

  /// The user has chosen a result of an inline query; for bots only
  UpdateNewChosenInlineResult(
      {required this.sender_user_id,
      this.user_location,
      required this.query,
      required this.result_id,
      required this.inline_message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewChosenInlineResult',
      if (extra != null) '@extra': extra,
      'sender_user_id': sender_user_id,
      'user_location': user_location,
      'query': query,
      'result_id': result_id,
      'inline_message_id': inline_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewChosenInlineResult? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sender_user_id = _map['sender_user_id']! as int;
    var user_location = Location.fromMap(_map['user_location']);
    var query = _map['query']! as String;
    var result_id = _map['result_id']! as String;
    var inline_message_id = _map['inline_message_id']! as String;
    return UpdateNewChosenInlineResult(
      extra: extra,
      clientId: clientId,
      sender_user_id: sender_user_id,
      user_location: user_location,
      query: query,
      result_id: result_id,
      inline_message_id: inline_message_id,
    );
  }
}

/// A new incoming callback query; for bots only.
///
class UpdateNewCallbackQuery extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewCallbackQuery";

  /// Unique query identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Identifier of the user who sent the query.
  late int sender_user_id;

  /// Identifier of the chat where the query was sent.
  late int chat_id;

  /// Identifier of the message from which the query originated.
  late int message_id;

  /// Identifier that uniquely corresponds to the chat to which the message was sent.
  /// ; string representation of int, use `int.parse`
  late int64 chat_instance;

  /// Query payload.
  late CallbackQueryPayload payload;

  /// A new incoming callback query; for bots only
  UpdateNewCallbackQuery(
      {required this.id,
      required this.sender_user_id,
      required this.chat_id,
      required this.message_id,
      required this.chat_instance,
      required this.payload,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewCallbackQuery',
      if (extra != null) '@extra': extra,
      'id': id,
      'sender_user_id': sender_user_id,
      'chat_id': chat_id,
      'message_id': message_id,
      'chat_instance': chat_instance,
      'payload': payload
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewCallbackQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var sender_user_id = _map['sender_user_id']! as int;
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var chat_instance = _map['chat_instance']! as int64;
    var payload = CallbackQueryPayload.fromMap(_map['payload'])!;
    return UpdateNewCallbackQuery(
      extra: extra,
      clientId: clientId,
      id: id,
      sender_user_id: sender_user_id,
      chat_id: chat_id,
      message_id: message_id,
      chat_instance: chat_instance,
      payload: payload,
    );
  }
}

/// A new incoming callback query from a message sent via a bot; for bots only.
///
class UpdateNewInlineCallbackQuery extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewInlineCallbackQuery";

  /// Unique query identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Identifier of the user who sent the query.
  late int sender_user_id;

  /// Identifier of the inline message from which the query originated.
  late String inline_message_id;

  /// An identifier uniquely corresponding to the chat a message was sent to.
  /// ; string representation of int, use `int.parse`
  late int64 chat_instance;

  /// Query payload.
  late CallbackQueryPayload payload;

  /// A new incoming callback query from a message sent via a bot; for bots only
  UpdateNewInlineCallbackQuery(
      {required this.id,
      required this.sender_user_id,
      required this.inline_message_id,
      required this.chat_instance,
      required this.payload,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewInlineCallbackQuery',
      if (extra != null) '@extra': extra,
      'id': id,
      'sender_user_id': sender_user_id,
      'inline_message_id': inline_message_id,
      'chat_instance': chat_instance,
      'payload': payload
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewInlineCallbackQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var sender_user_id = _map['sender_user_id']! as int;
    var inline_message_id = _map['inline_message_id']! as String;
    var chat_instance = _map['chat_instance']! as int64;
    var payload = CallbackQueryPayload.fromMap(_map['payload'])!;
    return UpdateNewInlineCallbackQuery(
      extra: extra,
      clientId: clientId,
      id: id,
      sender_user_id: sender_user_id,
      inline_message_id: inline_message_id,
      chat_instance: chat_instance,
      payload: payload,
    );
  }
}

/// A new incoming shipping query; for bots only. Only for invoices with flexible price.
///
class UpdateNewShippingQuery extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewShippingQuery";

  /// Unique query identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Identifier of the user who sent the query.
  late int sender_user_id;

  /// Invoice payload.
  late String invoice_payload;

  /// User shipping address.
  late Address shipping_address;

  /// A new incoming shipping query; for bots only. Only for invoices with flexible price
  UpdateNewShippingQuery(
      {required this.id,
      required this.sender_user_id,
      required this.invoice_payload,
      required this.shipping_address,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewShippingQuery',
      if (extra != null) '@extra': extra,
      'id': id,
      'sender_user_id': sender_user_id,
      'invoice_payload': invoice_payload,
      'shipping_address': shipping_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewShippingQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var sender_user_id = _map['sender_user_id']! as int;
    var invoice_payload = _map['invoice_payload']! as String;
    var shipping_address = Address.fromMap(_map['shipping_address'])!;
    return UpdateNewShippingQuery(
      extra: extra,
      clientId: clientId,
      id: id,
      sender_user_id: sender_user_id,
      invoice_payload: invoice_payload,
      shipping_address: shipping_address,
    );
  }
}

/// A new incoming pre-checkout query; for bots only. Contains full information about a checkout.
///
class UpdateNewPreCheckoutQuery extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewPreCheckoutQuery";

  /// Unique query identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// Identifier of the user who sent the query.
  late int sender_user_id;

  /// Currency for the product price.
  late String currency;

  /// Total price for the product, in the smallest units of the currency.
  late int total_amount;

  /// Invoice payload.
  /// ; base64-encoded bytes `List<int>`
  late bytes invoice_payload;

  /// Identifier of a shipping option chosen by the user; may be empty if not applicable.
  late String shipping_option_id;

  /// Information about the order; may be null.
  OrderInfo? order_info;

  /// A new incoming pre-checkout query; for bots only. Contains full information about a checkout
  UpdateNewPreCheckoutQuery(
      {required this.id,
      required this.sender_user_id,
      required this.currency,
      required this.total_amount,
      required this.invoice_payload,
      required this.shipping_option_id,
      this.order_info,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewPreCheckoutQuery',
      if (extra != null) '@extra': extra,
      'id': id,
      'sender_user_id': sender_user_id,
      'currency': currency,
      'total_amount': total_amount,
      'invoice_payload': invoice_payload,
      'shipping_option_id': shipping_option_id,
      'order_info': order_info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewPreCheckoutQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var sender_user_id = _map['sender_user_id']! as int;
    var currency = _map['currency']! as String;
    var total_amount = _map['total_amount']! as int;
    var invoice_payload = _map['invoice_payload']! as bytes;
    var shipping_option_id = _map['shipping_option_id']! as String;
    var order_info = OrderInfo.fromMap(_map['order_info']);
    return UpdateNewPreCheckoutQuery(
      extra: extra,
      clientId: clientId,
      id: id,
      sender_user_id: sender_user_id,
      currency: currency,
      total_amount: total_amount,
      invoice_payload: invoice_payload,
      shipping_option_id: shipping_option_id,
      order_info: order_info,
    );
  }
}

/// A new incoming event; for bots only.
///
class UpdateNewCustomEvent extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewCustomEvent";

  /// A JSON-serialized event.
  late String event;

  /// A new incoming event; for bots only
  UpdateNewCustomEvent({required this.event, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewCustomEvent',
      if (extra != null) '@extra': extra,
      'event': event
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewCustomEvent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var event = _map['event']! as String;
    return UpdateNewCustomEvent(
      extra: extra,
      clientId: clientId,
      event: event,
    );
  }
}

/// A new incoming query; for bots only.
///
class UpdateNewCustomQuery extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewCustomQuery";

  /// The query identifier.
  /// ; string representation of int, use `int.parse`
  late int64 id;

  /// JSON-serialized query data.
  late String data;

  /// Query timeout.
  late int timeout;

  /// A new incoming query; for bots only
  UpdateNewCustomQuery(
      {required this.id,
      required this.data,
      required this.timeout,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewCustomQuery',
      if (extra != null) '@extra': extra,
      'id': id,
      'data': data,
      'timeout': timeout
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewCustomQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var id = _map['id']! as int64;
    var data = _map['data']! as String;
    var timeout = _map['timeout']! as int;
    return UpdateNewCustomQuery(
      extra: extra,
      clientId: clientId,
      id: id,
      data: data,
      timeout: timeout,
    );
  }
}

/// A poll was updated; for bots only.
///
class UpdatePoll extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updatePoll";

  /// New data about the poll.
  late Poll poll;

  /// A poll was updated; for bots only
  UpdatePoll({required this.poll, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updatePoll',
      if (extra != null) '@extra': extra,
      'poll': poll
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdatePoll? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var poll = Poll.fromMap(_map['poll'])!;
    return UpdatePoll(
      extra: extra,
      clientId: clientId,
      poll: poll,
    );
  }
}

/// A user changed the answer to a poll; for bots only.
///
class UpdatePollAnswer extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updatePollAnswer";

  /// Unique poll identifier.
  /// ; string representation of int, use `int.parse`
  late int64 poll_id;

  /// Identifier of the message sender that changed the answer to the poll.
  late MessageSender voter_id;

  /// 0-based identifiers of answer options, chosen by the user.
  late List<int> option_ids;

  /// A user changed the answer to a poll; for bots only
  UpdatePollAnswer(
      {required this.poll_id,
      required this.voter_id,
      required this.option_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updatePollAnswer',
      if (extra != null) '@extra': extra,
      'poll_id': poll_id,
      'voter_id': voter_id,
      'option_ids': option_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdatePollAnswer? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var poll_id = _map['poll_id']! as int64;
    var voter_id = MessageSender.fromMap(_map['voter_id'])!;
    var option_ids = List<int>.from(
      (_map["option_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return UpdatePollAnswer(
      extra: extra,
      clientId: clientId,
      poll_id: poll_id,
      voter_id: voter_id,
      option_ids: option_ids,
    );
  }
}

/// User rights changed in a chat; for bots only.
///
class UpdateChatMember extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateChatMember";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the user, changing the rights.
  late int actor_user_id;

  /// Point in time (Unix timestamp) when the user rights was changed.
  late int date;

  /// If user has joined the chat using an invite link, the invite link; may be null.
  ChatInviteLink? invite_link;

  /// True, if the user has joined the chat using an invite link for a chat folder.
  late bool via_chat_folder_invite_link;

  /// Previous chat member.
  late ChatMember old_chat_member;

  /// New chat member.
  late ChatMember new_chat_member;

  /// User rights changed in a chat; for bots only
  UpdateChatMember(
      {required this.chat_id,
      required this.actor_user_id,
      required this.date,
      this.invite_link,
      required this.via_chat_folder_invite_link,
      required this.old_chat_member,
      required this.new_chat_member,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateChatMember',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'actor_user_id': actor_user_id,
      'date': date,
      'invite_link': invite_link,
      'via_chat_folder_invite_link': via_chat_folder_invite_link,
      'old_chat_member': old_chat_member,
      'new_chat_member': new_chat_member
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateChatMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var actor_user_id = _map['actor_user_id']! as int;
    var date = _map['date']! as int;
    var invite_link = ChatInviteLink.fromMap(_map['invite_link']);
    var via_chat_folder_invite_link =
        _map['via_chat_folder_invite_link']! as bool;
    var old_chat_member = ChatMember.fromMap(_map['old_chat_member'])!;
    var new_chat_member = ChatMember.fromMap(_map['new_chat_member'])!;
    return UpdateChatMember(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      actor_user_id: actor_user_id,
      date: date,
      invite_link: invite_link,
      via_chat_folder_invite_link: via_chat_folder_invite_link,
      old_chat_member: old_chat_member,
      new_chat_member: new_chat_member,
    );
  }
}

/// A user sent a join request to a chat; for bots only.
///
class UpdateNewChatJoinRequest extends Update {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updateNewChatJoinRequest";

  /// Chat identifier.
  late int chat_id;

  /// Join request.
  late ChatJoinRequest request;

  /// Chat identifier of the private chat with the user.
  late int user_chat_id;

  /// The invite link, which was used to send join request; may be null.
  ChatInviteLink? invite_link;

  /// A user sent a join request to a chat; for bots only
  UpdateNewChatJoinRequest(
      {required this.chat_id,
      required this.request,
      required this.user_chat_id,
      this.invite_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updateNewChatJoinRequest',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'request': request,
      'user_chat_id': user_chat_id,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpdateNewChatJoinRequest? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var request = ChatJoinRequest.fromMap(_map['request'])!;
    var user_chat_id = _map['user_chat_id']! as int;
    var invite_link = ChatInviteLink.fromMap(_map['invite_link']);
    return UpdateNewChatJoinRequest(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      request: request,
      user_chat_id: user_chat_id,
      invite_link: invite_link,
    );
  }
}

/// Contains a list of updates.
///
class Updates extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "updates";

  /// List of updates.
  late List<Update> updates;

  /// Contains a list of updates
  Updates({required this.updates, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'updates',
      if (extra != null) '@extra': extra,
      'updates': updates
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Updates? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var updates = List<Update>.from(
      (_map["updates"] ?? []).map(
        (e) => Update.fromMap(e),
      ),
    );
    return Updates(
      extra: extra,
      clientId: clientId,
      updates: updates,
    );
  }
}

/// The log is written to stderr or an OS specific log.
///
class LogStreamDefault extends LogStream {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "logStreamDefault";

  /// The log is written to stderr or an OS specific log
  LogStreamDefault({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'logStreamDefault', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LogStreamDefault? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return LogStreamDefault(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// The log is written to a file.
///
class LogStreamFile extends LogStream {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "logStreamFile";

  /// Path to the file to where the internal TDLib log will be written.
  late String path;

  /// The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes.
  late int max_file_size;

  /// Pass true to additionally redirect stderr to the log file. Ignored on Windows.
  late bool redirect_stderr;

  /// The log is written to a file
  LogStreamFile(
      {required this.path,
      required this.max_file_size,
      required this.redirect_stderr,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'logStreamFile',
      if (extra != null) '@extra': extra,
      'path': path,
      'max_file_size': max_file_size,
      'redirect_stderr': redirect_stderr
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LogStreamFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var path = _map['path']! as String;
    var max_file_size = _map['max_file_size']! as int;
    var redirect_stderr = _map['redirect_stderr']! as bool;
    return LogStreamFile(
      extra: extra,
      clientId: clientId,
      path: path,
      max_file_size: max_file_size,
      redirect_stderr: redirect_stderr,
    );
  }
}

/// The log is written nowhere.
///
class LogStreamEmpty extends LogStream {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "logStreamEmpty";

  /// The log is written nowhere
  LogStreamEmpty({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'logStreamEmpty', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LogStreamEmpty? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return LogStreamEmpty(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Contains a TDLib internal log verbosity level.
///
class LogVerbosityLevel extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "logVerbosityLevel";

  /// Log verbosity level.
  late int verbosity_level;

  /// Contains a TDLib internal log verbosity level
  LogVerbosityLevel({required this.verbosity_level, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'logVerbosityLevel',
      if (extra != null) '@extra': extra,
      'verbosity_level': verbosity_level
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LogVerbosityLevel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var verbosity_level = _map['verbosity_level']! as int;
    return LogVerbosityLevel(
      extra: extra,
      clientId: clientId,
      verbosity_level: verbosity_level,
    );
  }
}

/// Contains a list of available TDLib internal log tags.
///
class LogTags extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "logTags";

  /// List of log tags.
  late List<String> tags;

  /// Contains a list of available TDLib internal log tags
  LogTags({required this.tags, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'logTags',
      if (extra != null) '@extra': extra,
      'tags': tags
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LogTags? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var tags = List<String>.from(
      (_map["tags"] ?? []).map(
        (e) => e as String,
      ),
    );
    return LogTags(
      extra: extra,
      clientId: clientId,
      tags: tags,
    );
  }
}

/// Contains custom information about the user.
///
class UserSupportInfo extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "userSupportInfo";

  /// Information message.
  late FormattedText message;

  /// Information author.
  late String author;

  /// Information change date.
  late int date;

  /// Contains custom information about the user
  UserSupportInfo(
      {required this.message,
      required this.author,
      required this.date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'userSupportInfo',
      if (extra != null) '@extra': extra,
      'message': message,
      'author': author,
      'date': date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UserSupportInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message = FormattedText.fromMap(_map['message'])!;
    var author = _map['author']! as String;
    var date = _map['date']! as int;
    return UserSupportInfo(
      extra: extra,
      clientId: clientId,
      message: message,
      author: author,
      date: date,
    );
  }
}

/// A simple object containing a number; for testing only.
///
class TestInt extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testInt";

  /// Number.
  late int value;

  /// A simple object containing a number; for testing only
  TestInt({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testInt',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestInt? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as int;
    return TestInt(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// A simple object containing a string; for testing only.
///
class TestString extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testString";

  /// String.
  late String value;

  /// A simple object containing a string; for testing only
  TestString({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testString',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as String;
    return TestString(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// A simple object containing a sequence of bytes; for testing only.
///
class TestBytes extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testBytes";

  /// Bytes.
  /// ; base64-encoded bytes `List<int>`
  late bytes value;

  /// A simple object containing a sequence of bytes; for testing only
  TestBytes({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testBytes',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestBytes? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = _map['value']! as bytes;
    return TestBytes(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// A simple object containing a vector of numbers; for testing only.
///
class TestVectorInt extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testVectorInt";

  /// Vector of numbers.
  late List<int> value;

  /// A simple object containing a vector of numbers; for testing only
  TestVectorInt({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testVectorInt',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestVectorInt? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = List<int>.from(
      (_map["value"] ?? []).map(
        (e) => e as int,
      ),
    );
    return TestVectorInt(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// A simple object containing a vector of objects that hold a number; for testing only.
///
class TestVectorIntObject extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testVectorIntObject";

  /// Vector of objects.
  late List<TestInt> value;

  /// A simple object containing a vector of objects that hold a number; for testing only
  TestVectorIntObject({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testVectorIntObject',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestVectorIntObject? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = List<TestInt>.from(
      (_map["value"] ?? []).map(
        (e) => TestInt.fromMap(e),
      ),
    );
    return TestVectorIntObject(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// A simple object containing a vector of strings; for testing only.
///
class TestVectorString extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testVectorString";

  /// Vector of strings.
  late List<String> value;

  /// A simple object containing a vector of strings; for testing only
  TestVectorString({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testVectorString',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestVectorString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = List<String>.from(
      (_map["value"] ?? []).map(
        (e) => e as String,
      ),
    );
    return TestVectorString(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}

/// A simple object containing a vector of objects that hold a string; for testing only.
///
class TestVectorStringObject extends TlObject {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testVectorStringObject";

  /// Vector of objects.
  late List<TestString> value;

  /// A simple object containing a vector of objects that hold a string; for testing only
  TestVectorStringObject({required this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testVectorStringObject',
      if (extra != null) '@extra': extra,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestVectorStringObject? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var value = List<TestString>.from(
      (_map["value"] ?? []).map(
        (e) => TestString.fromMap(e),
      ),
    );
    return TestVectorStringObject(
      extra: extra,
      clientId: clientId,
      value: value,
    );
  }
}
