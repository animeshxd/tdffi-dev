// ignore_for_file: overridden_fields, annotate_overrides, camel_case_types, non_constant_identifier_names, unnecessary_question_mark, no_leading_underscores_for_local_identifiers, constant_identifier_names
import './abc.dart';
import './classes.dart';

/// Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization.
///
/// Returns [AuthorizationState].
class GetAuthorizationState extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getAuthorizationState";

  /// Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization
  ///
  /// Returns [AuthorizationState]
  GetAuthorizationState({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getAuthorizationState',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetAuthorizationState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetAuthorizationState(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters.
///
/// Returns [Ok].
class SetTdlibParameters extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setTdlibParameters";

  /// Pass true to use Telegram test environment instead of the production environment.
  late bool use_test_dc;

  /// The path to the directory for the persistent database; if empty, the current working directory will be used.
  String? database_directory;

  /// The path to the directory for storing files; if empty, database_directory will be used.
  String? files_directory;

  /// Encryption key for the database. If the encryption key is invalid, then an error with code 401 will be returned.
  /// ; base64-encoded bytes `List<int>`
  late bytes database_encryption_key;

  /// Pass true to keep information about downloaded and uploaded files between application restarts.
  late bool use_file_database;

  /// Pass true to keep cache of users, basic groups, supergroups, channels and secret chats between restarts. Implies use_file_database.
  late bool use_chat_info_database;

  /// Pass true to keep cache of chats and messages between restarts. Implies use_chat_info_database.
  late bool use_message_database;

  /// Pass true to enable support for secret chats.
  late bool use_secret_chats;

  /// Application identifier for Telegram API access, which can be obtained at https://my.telegram.org.
  late int api_id;

  /// Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org.
  late String api_hash;

  /// IETF language tag of the user's operating system language; must be non-empty.
  late String system_language_code;

  /// Model of the device the application is being run on; must be non-empty.
  late String device_model;

  /// Version of the operating system the application is being run on. If empty, the version is automatically detected by TDLib.
  String? system_version;

  /// Application version; must be non-empty.
  late String application_version;

  /// Pass true to automatically delete old files in background.
  late bool enable_storage_optimizer;

  /// Pass true to ignore original file names for downloaded files. Otherwise, downloaded files are saved under names as close as possible to the original name.
  late bool ignore_file_names;

  /// Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
  ///
  /// Returns [Ok]
  SetTdlibParameters(
      {required this.use_test_dc,
      this.database_directory,
      this.files_directory,
      required this.database_encryption_key,
      required this.use_file_database,
      required this.use_chat_info_database,
      required this.use_message_database,
      required this.use_secret_chats,
      required this.api_id,
      required this.api_hash,
      required this.system_language_code,
      required this.device_model,
      this.system_version,
      required this.application_version,
      required this.enable_storage_optimizer,
      required this.ignore_file_names,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setTdlibParameters',
      if (extra != null) '@extra': extra,
      'use_test_dc': use_test_dc,
      'database_directory': database_directory,
      'files_directory': files_directory,
      'database_encryption_key': database_encryption_key,
      'use_file_database': use_file_database,
      'use_chat_info_database': use_chat_info_database,
      'use_message_database': use_message_database,
      'use_secret_chats': use_secret_chats,
      'api_id': api_id,
      'api_hash': api_hash,
      'system_language_code': system_language_code,
      'device_model': device_model,
      'system_version': system_version,
      'application_version': application_version,
      'enable_storage_optimizer': enable_storage_optimizer,
      'ignore_file_names': ignore_file_names
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetTdlibParameters? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var use_test_dc = _map['use_test_dc']! as bool;
    var database_directory = _map['database_directory'] as String?;
    var files_directory = _map['files_directory'] as String?;
    var database_encryption_key = _map['database_encryption_key']! as bytes;
    var use_file_database = _map['use_file_database']! as bool;
    var use_chat_info_database = _map['use_chat_info_database']! as bool;
    var use_message_database = _map['use_message_database']! as bool;
    var use_secret_chats = _map['use_secret_chats']! as bool;
    var api_id = _map['api_id']! as int;
    var api_hash = _map['api_hash']! as String;
    var system_language_code = _map['system_language_code']! as String;
    var device_model = _map['device_model']! as String;
    var system_version = _map['system_version'] as String?;
    var application_version = _map['application_version']! as String;
    var enable_storage_optimizer = _map['enable_storage_optimizer']! as bool;
    var ignore_file_names = _map['ignore_file_names']! as bool;
    return SetTdlibParameters(
      extra: extra,
      clientId: clientId,
      use_test_dc: use_test_dc,
      database_directory: database_directory,
      files_directory: files_directory,
      database_encryption_key: database_encryption_key,
      use_file_database: use_file_database,
      use_chat_info_database: use_chat_info_database,
      use_message_database: use_message_database,
      use_secret_chats: use_secret_chats,
      api_id: api_id,
      api_hash: api_hash,
      system_language_code: system_language_code,
      device_model: device_model,
      system_version: system_version,
      application_version: application_version,
      enable_storage_optimizer: enable_storage_optimizer,
      ignore_file_names: ignore_file_names,
    );
  }
}

/// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber,.
///
/// Returns [Ok].
class SetAuthenticationPhoneNumber extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setAuthenticationPhoneNumber";

  /// The phone number of the user, in international format.
  late String phone_number;

  /// Settings for the authentication of the user's phone number; pass null to use default settings.
  PhoneNumberAuthenticationSettings? settings;

  /// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
  ///
  /// Returns [Ok]
  SetAuthenticationPhoneNumber(
      {required this.phone_number, this.settings, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setAuthenticationPhoneNumber',
      if (extra != null) '@extra': extra,
      'phone_number': phone_number,
      'settings': settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetAuthenticationPhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number = _map['phone_number']! as String;
    var settings = PhoneNumberAuthenticationSettings.fromMap(_map['settings']);
    return SetAuthenticationPhoneNumber(
      extra: extra,
      clientId: clientId,
      phone_number: phone_number,
      settings: settings,
    );
  }
}

/// Sets the email address of the user and sends an authentication code to the email address. Works only when the current authorization state is authorizationStateWaitEmailAddress.
///
/// Returns [Ok].
class SetAuthenticationEmailAddress extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setAuthenticationEmailAddress";

  /// The email address of the user.
  late String email_address;

  /// Sets the email address of the user and sends an authentication code to the email address. Works only when the current authorization state is authorizationStateWaitEmailAddress
  ///
  /// Returns [Ok]
  SetAuthenticationEmailAddress(
      {required this.email_address, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setAuthenticationEmailAddress',
      if (extra != null) '@extra': extra,
      'email_address': email_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetAuthenticationEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var email_address = _map['email_address']! as String;
    return SetAuthenticationEmailAddress(
      extra: extra,
      clientId: clientId,
      email_address: email_address,
    );
  }
}

/// Resends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed,.
///
/// Returns [Ok].
class ResendAuthenticationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resendAuthenticationCode";

  /// Resends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed,
  ///
  /// Returns [Ok]
  ResendAuthenticationCode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resendAuthenticationCode',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResendAuthenticationCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResendAuthenticationCode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks the authentication of a email address. Works only when the current authorization state is authorizationStateWaitEmailCode.
///
/// Returns [Ok].
class CheckAuthenticationEmailCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkAuthenticationEmailCode";

  /// Email address authentication to check.
  late EmailAddressAuthentication code;

  /// Checks the authentication of a email address. Works only when the current authorization state is authorizationStateWaitEmailCode
  ///
  /// Returns [Ok]
  CheckAuthenticationEmailCode({required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkAuthenticationEmailCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckAuthenticationEmailCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = EmailAddressAuthentication.fromMap(_map['code'])!;
    return CheckAuthenticationEmailCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode.
///
/// Returns [Ok].
class CheckAuthenticationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkAuthenticationCode";

  /// Authentication code to check.
  late String code;

  /// Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
  ///
  /// Returns [Ok]
  CheckAuthenticationCode({required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkAuthenticationCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckAuthenticationCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = _map['code']! as String;
    return CheckAuthenticationCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber,.
///
/// Returns [Ok].
class RequestQrCodeAuthentication extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "requestQrCodeAuthentication";

  /// List of user identifiers of other users currently using the application.
  late List<int> other_user_ids;

  /// Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
  ///
  /// Returns [Ok]
  RequestQrCodeAuthentication(
      {required this.other_user_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'requestQrCodeAuthentication',
      if (extra != null) '@extra': extra,
      'other_user_ids': other_user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RequestQrCodeAuthentication? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var other_user_ids = List<int>.from(
      (_map["other_user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return RequestQrCodeAuthentication(
      extra: extra,
      clientId: clientId,
      other_user_ids: other_user_ids,
    );
  }
}

/// Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration.
///
/// Returns [Ok].
class RegisterUser extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "registerUser";

  /// The first name of the user; 1-64 characters.
  late String first_name;

  /// The last name of the user; 0-64 characters.
  late String last_name;

  /// Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
  ///
  /// Returns [Ok]
  RegisterUser(
      {required this.first_name,
      required this.last_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'registerUser',
      if (extra != null) '@extra': extra,
      'first_name': first_name,
      'last_name': last_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RegisterUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var first_name = _map['first_name']! as String;
    var last_name = _map['last_name']! as String;
    return RegisterUser(
      extra: extra,
      clientId: clientId,
      first_name: first_name,
      last_name: last_name,
    );
  }
}

/// Resets the login email address. May return an error with a message "TASK_ALREADY_EXISTS" if reset is still pending..
///
/// Returns [Ok].
class ResetAuthenticationEmailAddress extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resetAuthenticationEmailAddress";

  /// Resets the login email address. May return an error with a message "TASK_ALREADY_EXISTS" if reset is still pending.
  ///
  /// Returns [Ok]
  ResetAuthenticationEmailAddress({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resetAuthenticationEmailAddress',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResetAuthenticationEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResetAuthenticationEmailAddress(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks the 2-step verification password for correctness. Works only when the current authorization state is authorizationStateWaitPassword.
///
/// Returns [Ok].
class CheckAuthenticationPassword extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkAuthenticationPassword";

  /// The 2-step verification password to check.
  late String password;

  /// Checks the 2-step verification password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
  ///
  /// Returns [Ok]
  CheckAuthenticationPassword(
      {required this.password, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkAuthenticationPassword',
      if (extra != null) '@extra': extra,
      'password': password
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckAuthenticationPassword? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var password = _map['password']! as String;
    return CheckAuthenticationPassword(
      extra: extra,
      clientId: clientId,
      password: password,
    );
  }
}

/// Requests to send a 2-step verification password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword.
///
/// Returns [Ok].
class RequestAuthenticationPasswordRecovery extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "requestAuthenticationPasswordRecovery";

  /// Requests to send a 2-step verification password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
  ///
  /// Returns [Ok]
  RequestAuthenticationPasswordRecovery({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'requestAuthenticationPasswordRecovery',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RequestAuthenticationPasswordRecovery? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return RequestAuthenticationPasswordRecovery(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks whether a 2-step verification password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword.
///
/// Returns [Ok].
class CheckAuthenticationPasswordRecoveryCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkAuthenticationPasswordRecoveryCode";

  /// Recovery code to check.
  late String recovery_code;

  /// Checks whether a 2-step verification password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword
  ///
  /// Returns [Ok]
  CheckAuthenticationPasswordRecoveryCode(
      {required this.recovery_code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkAuthenticationPasswordRecoveryCode',
      if (extra != null) '@extra': extra,
      'recovery_code': recovery_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckAuthenticationPasswordRecoveryCode? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var recovery_code = _map['recovery_code']! as String;
    return CheckAuthenticationPasswordRecoveryCode(
      extra: extra,
      clientId: clientId,
      recovery_code: recovery_code,
    );
  }
}

/// Recovers the 2-step verification password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword.
///
/// Returns [Ok].
class RecoverAuthenticationPassword extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "recoverAuthenticationPassword";

  /// Recovery code to check.
  late String recovery_code;

  /// New 2-step verification password of the user; may be empty to remove the password.
  late String new_password;

  /// New password hint; may be empty.
  late String new_hint;

  /// Recovers the 2-step verification password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
  ///
  /// Returns [Ok]
  RecoverAuthenticationPassword(
      {required this.recovery_code,
      required this.new_password,
      required this.new_hint,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'recoverAuthenticationPassword',
      if (extra != null) '@extra': extra,
      'recovery_code': recovery_code,
      'new_password': new_password,
      'new_hint': new_hint
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RecoverAuthenticationPassword? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var recovery_code = _map['recovery_code']! as String;
    var new_password = _map['new_password']! as String;
    var new_hint = _map['new_hint']! as String;
    return RecoverAuthenticationPassword(
      extra: extra,
      clientId: clientId,
      recovery_code: recovery_code,
      new_password: new_password,
      new_hint: new_hint,
    );
  }
}

/// Sends Firebase Authentication SMS to the phone number of the user. Works only when the current authorization state is authorizationStateWaitCode and the server returned code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos.
///
/// Returns [Ok].
class SendAuthenticationFirebaseSms extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendAuthenticationFirebaseSms";

  /// SafetyNet Attestation API token for the Android application, or secret from push notification for the iOS application.
  late String token;

  /// Sends Firebase Authentication SMS to the phone number of the user. Works only when the current authorization state is authorizationStateWaitCode and the server returned code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
  ///
  /// Returns [Ok]
  SendAuthenticationFirebaseSms(
      {required this.token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendAuthenticationFirebaseSms',
      if (extra != null) '@extra': extra,
      'token': token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendAuthenticationFirebaseSms? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    return SendAuthenticationFirebaseSms(
      extra: extra,
      clientId: clientId,
      token: token,
    );
  }
}

/// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in.
///
/// Returns [Ok].
class CheckAuthenticationBotToken extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkAuthenticationBotToken";

  /// The bot token.
  late String token;

  /// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
  ///
  /// Returns [Ok]
  CheckAuthenticationBotToken({required this.token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkAuthenticationBotToken',
      if (extra != null) '@extra': extra,
      'token': token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckAuthenticationBotToken? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    return CheckAuthenticationBotToken(
      extra: extra,
      clientId: clientId,
      token: token,
    );
  }
}

/// Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent.
///
/// Returns [Ok].
class LogOut extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "logOut";

  /// Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
  ///
  /// Returns [Ok]
  LogOut({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'logOut', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LogOut? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return LogOut(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization.
///
/// Returns [Ok].
class Close extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "close";

  /// Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
  ///
  /// Returns [Ok]
  Close({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'close', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Close? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return Close(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed..
///
/// Returns [Ok].
class Destroy extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "destroy";

  /// Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed.
  ///
  /// Returns [Ok]
  Destroy({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'destroy', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static Destroy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return Destroy(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Confirms QR code authentication on another device. Returns created session on success.
///
/// Returns [Session].
class ConfirmQrCodeAuthentication extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "confirmQrCodeAuthentication";

  /// A link from a QR code. The link must be scanned by the in-app camera.
  late String link;

  /// Confirms QR code authentication on another device. Returns created session on success
  ///
  /// Returns [Session]
  ConfirmQrCodeAuthentication({required this.link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'confirmQrCodeAuthentication',
      if (extra != null) '@extra': extra,
      'link': link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ConfirmQrCodeAuthentication? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = _map['link']! as String;
    return ConfirmQrCodeAuthentication(
      extra: extra,
      clientId: clientId,
      link: link,
    );
  }
}

/// Returns all updates needed to restore current TDLib state, i.e. all actual updateAuthorizationState/updateUser/updateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization.
///
/// Returns [Updates].
class GetCurrentState extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCurrentState";

  /// Returns all updates needed to restore current TDLib state, i.e. all actual updateAuthorizationState/updateUser/updateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization
  ///
  /// Returns [Updates]
  GetCurrentState({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getCurrentState', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCurrentState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetCurrentState(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain.
///
/// Returns [Ok].
class SetDatabaseEncryptionKey extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setDatabaseEncryptionKey";

  /// New encryption key.
  /// ; base64-encoded bytes `List<int>`
  late bytes new_encryption_key;

  /// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
  ///
  /// Returns [Ok]
  SetDatabaseEncryptionKey(
      {required this.new_encryption_key, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setDatabaseEncryptionKey',
      if (extra != null) '@extra': extra,
      'new_encryption_key': new_encryption_key
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetDatabaseEncryptionKey? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var new_encryption_key = _map['new_encryption_key']! as bytes;
    return SetDatabaseEncryptionKey(
      extra: extra,
      clientId: clientId,
      new_encryption_key: new_encryption_key,
    );
  }
}

/// Returns the current state of 2-step verification.
///
/// Returns [PasswordState].
class GetPasswordState extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPasswordState";

  /// Returns the current state of 2-step verification
  ///
  /// Returns [PasswordState]
  GetPasswordState({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getPasswordState', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPasswordState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetPasswordState(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Changes the 2-step verification password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
///
/// Returns [PasswordState].
class SetPassword extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setPassword";

  /// Previous 2-step verification password of the user.
  late String old_password;

  /// New 2-step verification password of the user; may be empty to remove the password.
  late String new_password;

  /// New password hint; may be empty.
  late String new_hint;

  /// Pass true to change also the recovery email address.
  late bool set_recovery_email_address;

  /// New recovery email address; may be empty.
  late String new_recovery_email_address;

  /// Changes the 2-step verification password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
  ///
  /// Returns [PasswordState]
  SetPassword(
      {required this.old_password,
      required this.new_password,
      required this.new_hint,
      required this.set_recovery_email_address,
      required this.new_recovery_email_address,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setPassword',
      if (extra != null) '@extra': extra,
      'old_password': old_password,
      'new_password': new_password,
      'new_hint': new_hint,
      'set_recovery_email_address': set_recovery_email_address,
      'new_recovery_email_address': new_recovery_email_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetPassword? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var old_password = _map['old_password']! as String;
    var new_password = _map['new_password']! as String;
    var new_hint = _map['new_hint']! as String;
    var set_recovery_email_address =
        _map['set_recovery_email_address']! as bool;
    var new_recovery_email_address =
        _map['new_recovery_email_address']! as String;
    return SetPassword(
      extra: extra,
      clientId: clientId,
      old_password: old_password,
      new_password: new_password,
      new_hint: new_hint,
      set_recovery_email_address: set_recovery_email_address,
      new_recovery_email_address: new_recovery_email_address,
    );
  }
}

/// Changes the login email address of the user. The email address can be changed only if the current user already has login email and passwordState.login_email_address_pattern is non-empty..
///
/// Returns [EmailAddressAuthenticationCodeInfo].
class SetLoginEmailAddress extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setLoginEmailAddress";

  /// New login email address.
  late String new_login_email_address;

  /// Changes the login email address of the user. The email address can be changed only if the current user already has login email and passwordState.login_email_address_pattern is non-empty.
  ///
  /// Returns [EmailAddressAuthenticationCodeInfo]
  SetLoginEmailAddress(
      {required this.new_login_email_address, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setLoginEmailAddress',
      if (extra != null) '@extra': extra,
      'new_login_email_address': new_login_email_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetLoginEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var new_login_email_address = _map['new_login_email_address']! as String;
    return SetLoginEmailAddress(
      extra: extra,
      clientId: clientId,
      new_login_email_address: new_login_email_address,
    );
  }
}

/// Resends the login email address verification code.
///
/// Returns [EmailAddressAuthenticationCodeInfo].
class ResendLoginEmailAddressCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resendLoginEmailAddressCode";

  /// Resends the login email address verification code
  ///
  /// Returns [EmailAddressAuthenticationCodeInfo]
  ResendLoginEmailAddressCode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resendLoginEmailAddressCode',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResendLoginEmailAddressCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResendLoginEmailAddressCode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks the login email address authentication.
///
/// Returns [Ok].
class CheckLoginEmailAddressCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkLoginEmailAddressCode";

  /// Email address authentication to check.
  late EmailAddressAuthentication code;

  /// Checks the login email address authentication
  ///
  /// Returns [Ok]
  CheckLoginEmailAddressCode({required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkLoginEmailAddressCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckLoginEmailAddressCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = EmailAddressAuthentication.fromMap(_map['code'])!;
    return CheckLoginEmailAddressCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user.
///
/// Returns [RecoveryEmailAddress].
class GetRecoveryEmailAddress extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getRecoveryEmailAddress";

  /// The 2-step verification password for the current user.
  late String password;

  /// Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
  ///
  /// Returns [RecoveryEmailAddress]
  GetRecoveryEmailAddress({required this.password, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getRecoveryEmailAddress',
      if (extra != null) '@extra': extra,
      'password': password
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetRecoveryEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var password = _map['password']! as String;
    return GetRecoveryEmailAddress(
      extra: extra,
      clientId: clientId,
      password: password,
    );
  }
}

/// Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed..
///
/// Returns [PasswordState].
class SetRecoveryEmailAddress extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setRecoveryEmailAddress";

  /// The 2-step verification password of the current user.
  late String password;

  /// New recovery email address.
  late String new_recovery_email_address;

  /// Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
  ///
  /// Returns [PasswordState]
  SetRecoveryEmailAddress(
      {required this.password,
      required this.new_recovery_email_address,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setRecoveryEmailAddress',
      if (extra != null) '@extra': extra,
      'password': password,
      'new_recovery_email_address': new_recovery_email_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetRecoveryEmailAddress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var password = _map['password']! as String;
    var new_recovery_email_address =
        _map['new_recovery_email_address']! as String;
    return SetRecoveryEmailAddress(
      extra: extra,
      clientId: clientId,
      password: password,
      new_recovery_email_address: new_recovery_email_address,
    );
  }
}

/// Checks the 2-step verification recovery email address verification code.
///
/// Returns [PasswordState].
class CheckRecoveryEmailAddressCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkRecoveryEmailAddressCode";

  /// Verification code to check.
  late String code;

  /// Checks the 2-step verification recovery email address verification code
  ///
  /// Returns [PasswordState]
  CheckRecoveryEmailAddressCode(
      {required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkRecoveryEmailAddressCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckRecoveryEmailAddressCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = _map['code']! as String;
    return CheckRecoveryEmailAddressCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// Resends the 2-step verification recovery email address verification code.
///
/// Returns [PasswordState].
class ResendRecoveryEmailAddressCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resendRecoveryEmailAddressCode";

  /// Resends the 2-step verification recovery email address verification code
  ///
  /// Returns [PasswordState]
  ResendRecoveryEmailAddressCode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resendRecoveryEmailAddressCode',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResendRecoveryEmailAddressCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResendRecoveryEmailAddressCode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Requests to send a 2-step verification password recovery code to an email address that was previously set up.
///
/// Returns [EmailAddressAuthenticationCodeInfo].
class RequestPasswordRecovery extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "requestPasswordRecovery";

  /// Requests to send a 2-step verification password recovery code to an email address that was previously set up
  ///
  /// Returns [EmailAddressAuthenticationCodeInfo]
  RequestPasswordRecovery({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'requestPasswordRecovery',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RequestPasswordRecovery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return RequestPasswordRecovery(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks whether a 2-step verification password recovery code sent to an email address is valid.
///
/// Returns [Ok].
class CheckPasswordRecoveryCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkPasswordRecoveryCode";

  /// Recovery code to check.
  late String recovery_code;

  /// Checks whether a 2-step verification password recovery code sent to an email address is valid
  ///
  /// Returns [Ok]
  CheckPasswordRecoveryCode(
      {required this.recovery_code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkPasswordRecoveryCode',
      if (extra != null) '@extra': extra,
      'recovery_code': recovery_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckPasswordRecoveryCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var recovery_code = _map['recovery_code']! as String;
    return CheckPasswordRecoveryCode(
      extra: extra,
      clientId: clientId,
      recovery_code: recovery_code,
    );
  }
}

/// Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up.
///
/// Returns [PasswordState].
class RecoverPassword extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "recoverPassword";

  /// Recovery code to check.
  late String recovery_code;

  /// New 2-step verification password of the user; may be empty to remove the password.
  late String new_password;

  /// New password hint; may be empty.
  late String new_hint;

  /// Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up
  ///
  /// Returns [PasswordState]
  RecoverPassword(
      {required this.recovery_code,
      required this.new_password,
      required this.new_hint,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'recoverPassword',
      if (extra != null) '@extra': extra,
      'recovery_code': recovery_code,
      'new_password': new_password,
      'new_hint': new_hint
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RecoverPassword? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var recovery_code = _map['recovery_code']! as String;
    var new_password = _map['new_password']! as String;
    var new_hint = _map['new_hint']! as String;
    return RecoverPassword(
      extra: extra,
      clientId: clientId,
      recovery_code: recovery_code,
      new_password: new_password,
      new_hint: new_hint,
    );
  }
}

/// Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time.
///
/// Returns [ResetPasswordResult].
class ResetPassword extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resetPassword";

  /// Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time
  ///
  /// Returns [ResetPasswordResult]
  ResetPassword({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'resetPassword', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResetPassword? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResetPassword(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date > 0.
///
/// Returns [Ok].
class CancelPasswordReset extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "cancelPasswordReset";

  /// Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date > 0
  ///
  /// Returns [Ok]
  CancelPasswordReset({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'cancelPasswordReset', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CancelPasswordReset? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CancelPasswordReset(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Creates a new temporary password for processing payments.
///
/// Returns [TemporaryPasswordState].
class CreateTemporaryPassword extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createTemporaryPassword";

  /// The 2-step verification password of the current user.
  late String password;

  /// Time during which the temporary password will be valid, in seconds; must be between 60 and 86400.
  late int valid_for;

  /// Creates a new temporary password for processing payments
  ///
  /// Returns [TemporaryPasswordState]
  CreateTemporaryPassword(
      {required this.password,
      required this.valid_for,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createTemporaryPassword',
      if (extra != null) '@extra': extra,
      'password': password,
      'valid_for': valid_for
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateTemporaryPassword? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var password = _map['password']! as String;
    var valid_for = _map['valid_for']! as int;
    return CreateTemporaryPassword(
      extra: extra,
      clientId: clientId,
      password: password,
      valid_for: valid_for,
    );
  }
}

/// Returns information about the current temporary password.
///
/// Returns [TemporaryPasswordState].
class GetTemporaryPasswordState extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getTemporaryPasswordState";

  /// Returns information about the current temporary password
  ///
  /// Returns [TemporaryPasswordState]
  GetTemporaryPasswordState({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getTemporaryPasswordState',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetTemporaryPasswordState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetTemporaryPasswordState(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns the current user.
///
/// Returns [User].
class GetMe extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMe";

  /// Returns the current user
  ///
  /// Returns [User]
  GetMe({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getMe', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMe? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetMe(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns information about a user by their identifier. This is an offline request if the current user is not a bot.
///
/// Returns [User].
class GetUser extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getUser";

  /// User identifier.
  late int user_id;

  /// Returns information about a user by their identifier. This is an offline request if the current user is not a bot
  ///
  /// Returns [User]
  GetUser({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getUser',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return GetUser(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// Returns full information about a user by their identifier.
///
/// Returns [UserFullInfo].
class GetUserFullInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getUserFullInfo";

  /// User identifier.
  late int user_id;

  /// Returns full information about a user by their identifier
  ///
  /// Returns [UserFullInfo]
  GetUserFullInfo({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getUserFullInfo',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetUserFullInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return GetUserFullInfo(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot.
///
/// Returns [BasicGroup].
class GetBasicGroup extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getBasicGroup";

  /// Basic group identifier.
  late int basic_group_id;

  /// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
  ///
  /// Returns [BasicGroup]
  GetBasicGroup({required this.basic_group_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getBasicGroup',
      if (extra != null) '@extra': extra,
      'basic_group_id': basic_group_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetBasicGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var basic_group_id = _map['basic_group_id']! as int;
    return GetBasicGroup(
      extra: extra,
      clientId: clientId,
      basic_group_id: basic_group_id,
    );
  }
}

/// Returns full information about a basic group by its identifier.
///
/// Returns [BasicGroupFullInfo].
class GetBasicGroupFullInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getBasicGroupFullInfo";

  /// Basic group identifier.
  late int basic_group_id;

  /// Returns full information about a basic group by its identifier
  ///
  /// Returns [BasicGroupFullInfo]
  GetBasicGroupFullInfo(
      {required this.basic_group_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getBasicGroupFullInfo',
      if (extra != null) '@extra': extra,
      'basic_group_id': basic_group_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetBasicGroupFullInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var basic_group_id = _map['basic_group_id']! as int;
    return GetBasicGroupFullInfo(
      extra: extra,
      clientId: clientId,
      basic_group_id: basic_group_id,
    );
  }
}

/// Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot.
///
/// Returns [Supergroup].
class GetSupergroup extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSupergroup";

  /// Supergroup or channel identifier.
  late int supergroup_id;

  /// Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
  ///
  /// Returns [Supergroup]
  GetSupergroup({required this.supergroup_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getSupergroup',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSupergroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    return GetSupergroup(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
    );
  }
}

/// Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute.
///
/// Returns [SupergroupFullInfo].
class GetSupergroupFullInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSupergroupFullInfo";

  /// Supergroup or channel identifier.
  late int supergroup_id;

  /// Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
  ///
  /// Returns [SupergroupFullInfo]
  GetSupergroupFullInfo(
      {required this.supergroup_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getSupergroupFullInfo',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSupergroupFullInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    return GetSupergroupFullInfo(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
    );
  }
}

/// Returns information about a secret chat by its identifier. This is an offline request.
///
/// Returns [SecretChat].
class GetSecretChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSecretChat";

  /// Secret chat identifier.
  late int secret_chat_id;

  /// Returns information about a secret chat by its identifier. This is an offline request
  ///
  /// Returns [SecretChat]
  GetSecretChat({required this.secret_chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getSecretChat',
      if (extra != null) '@extra': extra,
      'secret_chat_id': secret_chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSecretChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var secret_chat_id = _map['secret_chat_id']! as int;
    return GetSecretChat(
      extra: extra,
      clientId: clientId,
      secret_chat_id: secret_chat_id,
    );
  }
}

/// Returns information about a chat by its identifier; this is an offline request if the current user is not a bot.
///
/// Returns [Chat].
class GetChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChat";

  /// Chat identifier.
  late int chat_id;

  /// Returns information about a chat by its identifier; this is an offline request if the current user is not a bot
  ///
  /// Returns [Chat]
  GetChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Returns information about a message.
///
/// Returns [Message].
class GetMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessage";

  /// Identifier of the chat the message belongs to.
  late int chat_id;

  /// Identifier of the message to get.
  late int message_id;

  /// Returns information about a message
  ///
  /// Returns [Message]
  GetMessage(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return GetMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Returns information about a message, if it is available without sending network request. This is an offline request.
///
/// Returns [Message].
class GetMessageLocally extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageLocally";

  /// Identifier of the chat the message belongs to.
  late int chat_id;

  /// Identifier of the message to get.
  late int message_id;

  /// Returns information about a message, if it is available without sending network request. This is an offline request
  ///
  /// Returns [Message]
  GetMessageLocally(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageLocally',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageLocally? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return GetMessageLocally(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Returns information about a message that is replied by a given message. Also, returns the pinned message, the game message, the invoice message, and the topic creation message for messages.
///
/// Returns [Message].
class GetRepliedMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getRepliedMessage";

  /// Identifier of the chat the message belongs to.
  late int chat_id;

  /// Identifier of the reply message.
  late int message_id;

  /// Returns information about a message that is replied by a given message. Also, returns the pinned message, the game message, the invoice message, and the topic creation message for messages
  ///
  /// Returns [Message]
  GetRepliedMessage(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getRepliedMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetRepliedMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return GetRepliedMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Returns information about a newest pinned message in the chat.
///
/// Returns [Message].
class GetChatPinnedMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatPinnedMessage";

  /// Identifier of the chat the message belongs to.
  late int chat_id;

  /// Returns information about a newest pinned message in the chat
  ///
  /// Returns [Message]
  GetChatPinnedMessage({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatPinnedMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatPinnedMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatPinnedMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Returns information about a message with the callback button that originated a callback query; for bots only.
///
/// Returns [Message].
class GetCallbackQueryMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCallbackQueryMessage";

  /// Identifier of the chat the message belongs to.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// Identifier of the callback query.
  /// ; string representation of int, use `int.parse`
  late int64 callback_query_id;

  /// Returns information about a message with the callback button that originated a callback query; for bots only
  ///
  /// Returns [Message]
  GetCallbackQueryMessage(
      {required this.chat_id,
      required this.message_id,
      required this.callback_query_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getCallbackQueryMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'callback_query_id': callback_query_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCallbackQueryMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var callback_query_id = _map['callback_query_id']! as int64;
    return GetCallbackQueryMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      callback_query_id: callback_query_id,
    );
  }
}

/// Returns information about messages. If a message is not found, returns null on the corresponding position of the result.
///
/// Returns [Messages].
class GetMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessages";

  /// Identifier of the chat the messages belong to.
  late int chat_id;

  /// Identifiers of the messages to get.
  late List<int> message_ids;

  /// Returns information about messages. If a message is not found, returns null on the corresponding position of the result
  ///
  /// Returns [Messages]
  GetMessages(
      {required this.chat_id,
      required this.message_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_ids': message_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_ids = List<int>.from(
      (_map["message_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return GetMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_ids: message_ids,
    );
  }
}

/// Returns information about a message thread. Can be used only if message.can_get_message_thread == true.
///
/// Returns [MessageThreadInfo].
class GetMessageThread extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageThread";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Returns information about a message thread. Can be used only if message.can_get_message_thread == true
  ///
  /// Returns [MessageThreadInfo]
  GetMessageThread(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageThread',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageThread? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return GetMessageThread(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true.
///
/// Returns [MessageViewers].
class GetMessageViewers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageViewers";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true
  ///
  /// Returns [MessageViewers]
  GetMessageViewers(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageViewers',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageViewers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return GetMessageViewers(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Returns information about a file; this is an offline request.
///
/// Returns [File].
class GetFile extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getFile";

  /// Identifier of the file to get.
  late int file_id;

  /// Returns information about a file; this is an offline request
  ///
  /// Returns [File]
  GetFile({required this.file_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getFile',
      if (extra != null) '@extra': extra,
      'file_id': file_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    return GetFile(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
    );
  }
}

/// Returns information about a file by its remote identifier; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user..
///
/// Returns [File].
class GetRemoteFile extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getRemoteFile";

  /// Remote identifier of the file to get.
  late String remote_file_id;

  /// File type; pass null if unknown.
  FileType? file_type;

  /// Returns information about a file by its remote identifier; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user.
  ///
  /// Returns [File]
  GetRemoteFile(
      {required this.remote_file_id,
      this.file_type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getRemoteFile',
      if (extra != null) '@extra': extra,
      'remote_file_id': remote_file_id,
      'file_type': file_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetRemoteFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var remote_file_id = _map['remote_file_id']! as String;
    var file_type = FileType.fromMap(_map['file_type']);
    return GetRemoteFile(
      extra: extra,
      clientId: clientId,
      remote_file_id: remote_file_id,
      file_type: file_type,
    );
  }
}

/// Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded.
///
/// Returns [Ok].
class LoadChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "loadChats";

  /// The chat list in which to load chats; pass null to load chats from the main chat list.
  ChatList? chat_list;

  /// The maximum number of chats to be loaded. For optimal performance, the number of loaded chats is chosen by TDLib and can be smaller than the specified limit, even if the end of the list is not reached.
  late int limit;

  /// Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded
  ///
  /// Returns [Ok]
  LoadChats({this.chat_list, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'loadChats',
      if (extra != null) '@extra': extra,
      'chat_list': chat_list,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LoadChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_list = ChatList.fromMap(_map['chat_list']);
    var limit = _map['limit']! as int;
    return LoadChats(
      extra: extra,
      clientId: clientId,
      chat_list: chat_list,
      limit: limit,
    );
  }
}

/// Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state.
///
/// Returns [Chats].
class GetChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChats";

  /// The chat list in which to return chats; pass null to get chats from the main chat list.
  ChatList? chat_list;

  /// The maximum number of chats to be returned.
  late int limit;

  /// Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state
  ///
  /// Returns [Chats]
  GetChats({this.chat_list, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChats',
      if (extra != null) '@extra': extra,
      'chat_list': chat_list,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_list = ChatList.fromMap(_map['chat_list']);
    var limit = _map['limit']! as int;
    return GetChats(
      extra: extra,
      clientId: clientId,
      chat_list: chat_list,
      limit: limit,
    );
  }
}

/// Searches a public chat by its username. Currently, only private chats, supergroups and channels can be public. Returns the chat if found; otherwise, an error is returned.
///
/// Returns [Chat].
class SearchPublicChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchPublicChat";

  /// Username to be resolved.
  late String username;

  /// Searches a public chat by its username. Currently, only private chats, supergroups and channels can be public. Returns the chat if found; otherwise, an error is returned
  ///
  /// Returns [Chat]
  SearchPublicChat({required this.username, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchPublicChat',
      if (extra != null) '@extra': extra,
      'username': username
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchPublicChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var username = _map['username']! as String;
    return SearchPublicChat(
      extra: extra,
      clientId: clientId,
      username: username,
    );
  }
}

/// Searches public chats by looking for specified query in their username and title. Currently, only private chats, supergroups and channels can be public. Returns a meaningful number of results..
///
/// Returns [Chats].
class SearchPublicChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchPublicChats";

  /// Query to search for.
  late String query;

  /// Searches public chats by looking for specified query in their username and title. Currently, only private chats, supergroups and channels can be public. Returns a meaningful number of results.
  ///
  /// Returns [Chats]
  SearchPublicChats({required this.query, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchPublicChats',
      if (extra != null) '@extra': extra,
      'query': query
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchPublicChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    return SearchPublicChats(
      extra: extra,
      clientId: clientId,
      query: query,
    );
  }
}

/// Searches for the specified query in the title and username of already known chats; this is an offline request. Returns chats in the order seen in the main chat list.
///
/// Returns [Chats].
class SearchChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchChats";

  /// Query to search for. If the query is empty, returns up to 50 recently found chats.
  late String query;

  /// The maximum number of chats to be returned.
  late int limit;

  /// Searches for the specified query in the title and username of already known chats; this is an offline request. Returns chats in the order seen in the main chat list
  ///
  /// Returns [Chats]
  SearchChats(
      {required this.query, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchChats',
      if (extra != null) '@extra': extra,
      'query': query,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    var limit = _map['limit']! as int;
    return SearchChats(
      extra: extra,
      clientId: clientId,
      query: query,
      limit: limit,
    );
  }
}

/// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list.
///
/// Returns [Chats].
class SearchChatsOnServer extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchChatsOnServer";

  /// Query to search for.
  late String query;

  /// The maximum number of chats to be returned.
  late int limit;

  /// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
  ///
  /// Returns [Chats]
  SearchChatsOnServer(
      {required this.query, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchChatsOnServer',
      if (extra != null) '@extra': extra,
      'query': query,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchChatsOnServer? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    var limit = _map['limit']! as int;
    return SearchChatsOnServer(
      extra: extra,
      clientId: clientId,
      query: query,
      limit: limit,
    );
  }
}

/// Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby..
///
/// Returns [ChatsNearby].
class SearchChatsNearby extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchChatsNearby";

  /// Current user location.
  late Location location;

  /// Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby.
  ///
  /// Returns [ChatsNearby]
  SearchChatsNearby({required this.location, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchChatsNearby',
      if (extra != null) '@extra': extra,
      'location': location
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchChatsNearby? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    return SearchChatsNearby(
      extra: extra,
      clientId: clientId,
      location: location,
    );
  }
}

/// Returns a list of frequently used chats.
///
/// Returns [Chats].
class GetTopChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getTopChats";

  /// Category of chats to be returned.
  late TopChatCategory category;

  /// The maximum number of chats to be returned; up to 30.
  late int limit;

  /// Returns a list of frequently used chats
  ///
  /// Returns [Chats]
  GetTopChats(
      {required this.category, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getTopChats',
      if (extra != null) '@extra': extra,
      'category': category,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetTopChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var category = TopChatCategory.fromMap(_map['category'])!;
    var limit = _map['limit']! as int;
    return GetTopChats(
      extra: extra,
      clientId: clientId,
      category: category,
      limit: limit,
    );
  }
}

/// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled.
///
/// Returns [Ok].
class RemoveTopChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeTopChat";

  /// Category of frequently used chats.
  late TopChatCategory category;

  /// Chat identifier.
  late int chat_id;

  /// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
  ///
  /// Returns [Ok]
  RemoveTopChat(
      {required this.category,
      required this.chat_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeTopChat',
      if (extra != null) '@extra': extra,
      'category': category,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveTopChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var category = TopChatCategory.fromMap(_map['category'])!;
    var chat_id = _map['chat_id']! as int;
    return RemoveTopChat(
      extra: extra,
      clientId: clientId,
      category: category,
      chat_id: chat_id,
    );
  }
}

/// Searches for the specified query in the title and username of up to 50 recently found chats; this is an offline request.
///
/// Returns [Chats].
class SearchRecentlyFoundChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchRecentlyFoundChats";

  /// Query to search for.
  late String query;

  /// The maximum number of chats to be returned.
  late int limit;

  /// Searches for the specified query in the title and username of up to 50 recently found chats; this is an offline request
  ///
  /// Returns [Chats]
  SearchRecentlyFoundChats(
      {required this.query, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchRecentlyFoundChats',
      if (extra != null) '@extra': extra,
      'query': query,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchRecentlyFoundChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    var limit = _map['limit']! as int;
    return SearchRecentlyFoundChats(
      extra: extra,
      clientId: clientId,
      query: query,
      limit: limit,
    );
  }
}

/// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first.
///
/// Returns [Ok].
class AddRecentlyFoundChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addRecentlyFoundChat";

  /// Identifier of the chat to add.
  late int chat_id;

  /// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
  ///
  /// Returns [Ok]
  AddRecentlyFoundChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addRecentlyFoundChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddRecentlyFoundChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return AddRecentlyFoundChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Removes a chat from the list of recently found chats.
///
/// Returns [Ok].
class RemoveRecentlyFoundChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeRecentlyFoundChat";

  /// Identifier of the chat to be removed.
  late int chat_id;

  /// Removes a chat from the list of recently found chats
  ///
  /// Returns [Ok]
  RemoveRecentlyFoundChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeRecentlyFoundChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveRecentlyFoundChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return RemoveRecentlyFoundChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Clears the list of recently found chats.
///
/// Returns [Ok].
class ClearRecentlyFoundChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clearRecentlyFoundChats";

  /// Clears the list of recently found chats
  ///
  /// Returns [Ok]
  ClearRecentlyFoundChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clearRecentlyFoundChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClearRecentlyFoundChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ClearRecentlyFoundChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns recently opened chats; this is an offline request. Returns chats in the order of last opening.
///
/// Returns [Chats].
class GetRecentlyOpenedChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getRecentlyOpenedChats";

  /// The maximum number of chats to be returned.
  late int limit;

  /// Returns recently opened chats; this is an offline request. Returns chats in the order of last opening
  ///
  /// Returns [Chats]
  GetRecentlyOpenedChats({required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getRecentlyOpenedChats',
      if (extra != null) '@extra': extra,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetRecentlyOpenedChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var limit = _map['limit']! as int;
    return GetRecentlyOpenedChats(
      extra: extra,
      clientId: clientId,
      limit: limit,
    );
  }
}

/// Checks whether a username can be set for a chat.
///
/// Returns [CheckChatUsernameResult].
class CheckChatUsername extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkChatUsername";

  /// Chat identifier; must be identifier of a supergroup chat, or a channel chat, or a private chat with self, or 0 if the chat is being created.
  late int chat_id;

  /// Username to be checked.
  late String username;

  /// Checks whether a username can be set for a chat
  ///
  /// Returns [CheckChatUsernameResult]
  CheckChatUsername(
      {required this.chat_id,
      required this.username,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChatUsername',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'username': username
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChatUsername? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var username = _map['username']! as String;
    return CheckChatUsername(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      username: username,
    );
  }
}

/// Returns a list of public chats of the specified type, owned by the user.
///
/// Returns [Chats].
class GetCreatedPublicChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCreatedPublicChats";

  /// Type of the public chats to return.
  late PublicChatType type;

  /// Returns a list of public chats of the specified type, owned by the user
  ///
  /// Returns [Chats]
  GetCreatedPublicChats({required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getCreatedPublicChats',
      if (extra != null) '@extra': extra,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCreatedPublicChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = PublicChatType.fromMap(_map['type'])!;
    return GetCreatedPublicChats(
      extra: extra,
      clientId: clientId,
      type: type,
    );
  }
}

/// Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached. The limit can be increased with Telegram Premium.
///
/// Returns [Ok].
class CheckCreatedPublicChatsLimit extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkCreatedPublicChatsLimit";

  /// Type of the public chats, for which to check the limit.
  late PublicChatType type;

  /// Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached. The limit can be increased with Telegram Premium
  ///
  /// Returns [Ok]
  CheckCreatedPublicChatsLimit({required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkCreatedPublicChatsLimit',
      if (extra != null) '@extra': extra,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckCreatedPublicChatsLimit? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = PublicChatType.fromMap(_map['type'])!;
    return CheckCreatedPublicChatsLimit(
      extra: extra,
      clientId: clientId,
      type: type,
    );
  }
}

/// Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group..
///
/// Returns [Chats].
class GetSuitableDiscussionChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSuitableDiscussionChats";

  /// Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group.
  ///
  /// Returns [Chats]
  GetSuitableDiscussionChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getSuitableDiscussionChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSuitableDiscussionChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetSuitableDiscussionChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium.
///
/// Returns [Chats].
class GetInactiveSupergroupChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getInactiveSupergroupChats";

  /// Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium
  ///
  /// Returns [Chats]
  GetInactiveSupergroupChats({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getInactiveSupergroupChats',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetInactiveSupergroupChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetInactiveSupergroupChats(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns a list of common group chats with a given user. Chats are sorted by their type and creation date.
///
/// Returns [Chats].
class GetGroupsInCommon extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getGroupsInCommon";

  /// User identifier.
  late int user_id;

  /// Chat identifier starting from which to return chats; use 0 for the first request.
  late int offset_chat_id;

  /// The maximum number of chats to be returned; up to 100.
  late int limit;

  /// Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
  ///
  /// Returns [Chats]
  GetGroupsInCommon(
      {required this.user_id,
      required this.offset_chat_id,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getGroupsInCommon',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'offset_chat_id': offset_chat_id,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetGroupsInCommon? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var offset_chat_id = _map['offset_chat_id']! as int;
    var limit = _map['limit']! as int;
    return GetGroupsInCommon(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      offset_chat_id: offset_chat_id,
      limit: limit,
    );
  }
}

/// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)..
///
/// Returns [Messages].
class GetChatHistory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatHistory";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message.
  late int from_message_id;

  /// Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages.
  late int offset;

  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset..
  late int limit;

  /// Pass true to get only messages that are available without sending network requests.
  late bool only_local;

  /// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id).
  ///
  /// Returns [Messages]
  GetChatHistory(
      {required this.chat_id,
      required this.from_message_id,
      required this.offset,
      required this.limit,
      required this.only_local,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatHistory',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'from_message_id': from_message_id,
      'offset': offset,
      'limit': limit,
      'only_local': only_local
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatHistory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var from_message_id = _map['from_message_id']! as int;
    var offset = _map['offset']! as int;
    var limit = _map['limit']! as int;
    var only_local = _map['only_local']! as bool;
    return GetChatHistory(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      from_message_id: from_message_id,
      offset: offset,
      limit: limit,
      only_local: only_local,
    );
  }
}

/// Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup..
///
/// Returns [Messages].
class GetMessageThreadHistory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageThreadHistory";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier, which thread history needs to be returned.
  late int message_id;

  /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message.
  late int from_message_id;

  /// Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages.
  late int offset;

  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset..
  late int limit;

  /// Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup.
  ///
  /// Returns [Messages]
  GetMessageThreadHistory(
      {required this.chat_id,
      required this.message_id,
      required this.from_message_id,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageThreadHistory',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'from_message_id': from_message_id,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageThreadHistory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var from_message_id = _map['from_message_id']! as int;
    var offset = _map['offset']! as int;
    var limit = _map['limit']! as int;
    return GetMessageThreadHistory(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      from_message_id: from_message_id,
      offset: offset,
      limit: limit,
    );
  }
}

/// Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat.
///
/// Returns [Ok].
class DeleteChatHistory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteChatHistory";

  /// Chat identifier.
  late int chat_id;

  /// Pass true to remove the chat from all chat lists.
  late bool remove_from_chat_list;

  /// Pass true to delete chat history for all users.
  late bool revoke;

  /// Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
  ///
  /// Returns [Ok]
  DeleteChatHistory(
      {required this.chat_id,
      required this.remove_from_chat_list,
      required this.revoke,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteChatHistory',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'remove_from_chat_list': remove_from_chat_list,
      'revoke': revoke
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteChatHistory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var remove_from_chat_list = _map['remove_from_chat_list']! as bool;
    var revoke = _map['revoke']! as bool;
    return DeleteChatHistory(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      remove_from_chat_list: remove_from_chat_list,
      revoke: revoke,
    );
  }
}

/// Deletes a chat along with all messages in the corresponding chat for all chat members. For group chats this will release the usernames and remove all members..
///
/// Returns [Ok].
class DeleteChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteChat";

  /// Chat identifier.
  late int chat_id;

  /// Deletes a chat along with all messages in the corresponding chat for all chat members. For group chats this will release the usernames and remove all members.
  ///
  /// Returns [Ok]
  DeleteChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return DeleteChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query.
///
/// Returns [FoundChatMessages].
class SearchChatMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchChatMessages";

  /// Identifier of the chat in which to search messages.
  late int chat_id;

  /// Query to search for.
  late String query;

  /// Identifier of the sender of messages to search for; pass null to search for messages from any sender. Not supported in secret chats.
  MessageSender? sender_id;

  /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message.
  late int from_message_id;

  /// Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages.
  late int offset;

  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset..
  late int limit;

  /// Additional filter for messages to search; pass null to search for all messages.
  SearchMessagesFilter? filter;

  /// If not 0, only messages in the specified thread will be returned; supergroups only.
  late int message_thread_id;

  /// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query
  ///
  /// Returns [FoundChatMessages]
  SearchChatMessages(
      {required this.chat_id,
      required this.query,
      this.sender_id,
      required this.from_message_id,
      required this.offset,
      required this.limit,
      this.filter,
      required this.message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchChatMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'query': query,
      'sender_id': sender_id,
      'from_message_id': from_message_id,
      'offset': offset,
      'limit': limit,
      'filter': filter,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchChatMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var query = _map['query']! as String;
    var sender_id = MessageSender.fromMap(_map['sender_id']);
    var from_message_id = _map['from_message_id']! as int;
    var offset = _map['offset']! as int;
    var limit = _map['limit']! as int;
    var filter = SearchMessagesFilter.fromMap(_map['filter']);
    var message_thread_id = _map['message_thread_id']! as int;
    return SearchChatMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      query: query,
      sender_id: sender_id,
      from_message_id: from_message_id,
      offset: offset,
      limit: limit,
      filter: filter,
      message_thread_id: message_thread_id,
    );
  }
}

/// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id))..
///
/// Returns [FoundMessages].
class SearchMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchMessages";

  /// Chat list in which to search messages; pass null to search in all chats regardless of their chat list. Only Main and Archive chat lists are supported.
  ChatList? chat_list;

  /// Query to search for.
  late String query;

  /// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results.
  late String offset;

  /// The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
  late int limit;

  /// Additional filter for messages to search; pass null to search for all messages. Filters searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction, searchMessagesFilterFailedToSend, and searchMessagesFilterPinned are unsupported in this function.
  SearchMessagesFilter? filter;

  /// If not 0, the minimum date of the messages to return.
  late int min_date;

  /// If not 0, the maximum date of the messages to return.
  late int max_date;

  /// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)).
  ///
  /// Returns [FoundMessages]
  SearchMessages(
      {this.chat_list,
      required this.query,
      required this.offset,
      required this.limit,
      this.filter,
      required this.min_date,
      required this.max_date,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchMessages',
      if (extra != null) '@extra': extra,
      'chat_list': chat_list,
      'query': query,
      'offset': offset,
      'limit': limit,
      'filter': filter,
      'min_date': min_date,
      'max_date': max_date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_list = ChatList.fromMap(_map['chat_list']);
    var query = _map['query']! as String;
    var offset = _map['offset']! as String;
    var limit = _map['limit']! as int;
    var filter = SearchMessagesFilter.fromMap(_map['filter']);
    var min_date = _map['min_date']! as int;
    var max_date = _map['max_date']! as int;
    return SearchMessages(
      extra: extra,
      clientId: clientId,
      chat_list: chat_list,
      query: query,
      offset: offset,
      limit: limit,
      filter: filter,
      min_date: min_date,
      max_date: max_date,
    );
  }
}

/// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib.
///
/// Returns [FoundMessages].
class SearchSecretMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchSecretMessages";

  /// Identifier of the chat in which to search. Specify 0 to search in all secret chats.
  late int chat_id;

  /// Query to search for. If empty, searchChatMessages must be used instead.
  String? query;

  /// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results.
  late String offset;

  /// The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
  late int limit;

  /// Additional filter for messages to search; pass null to search for all messages.
  SearchMessagesFilter? filter;

  /// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib
  ///
  /// Returns [FoundMessages]
  SearchSecretMessages(
      {required this.chat_id,
      this.query,
      required this.offset,
      required this.limit,
      this.filter,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchSecretMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'query': query,
      'offset': offset,
      'limit': limit,
      'filter': filter
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchSecretMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var query = _map['query'] as String?;
    var offset = _map['offset']! as String;
    var limit = _map['limit']! as int;
    var filter = SearchMessagesFilter.fromMap(_map['filter']);
    return SearchSecretMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      query: query,
      offset: offset,
      limit: limit,
      filter: filter,
    );
  }
}

/// Searches for call messages. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib.
///
/// Returns [FoundMessages].
class SearchCallMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchCallMessages";

  /// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results.
  late String offset;

  /// The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
  late int limit;

  /// Pass true to search only for messages with missed/declined calls.
  late bool only_missed;

  /// Searches for call messages. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
  ///
  /// Returns [FoundMessages]
  SearchCallMessages(
      {required this.offset,
      required this.limit,
      required this.only_missed,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchCallMessages',
      if (extra != null) '@extra': extra,
      'offset': offset,
      'limit': limit,
      'only_missed': only_missed
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchCallMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var offset = _map['offset']! as String;
    var limit = _map['limit']! as int;
    var only_missed = _map['only_missed']! as bool;
    return SearchCallMessages(
      extra: extra,
      clientId: clientId,
      offset: offset,
      limit: limit,
      only_missed: only_missed,
    );
  }
}

/// Searches for outgoing messages with content of the type messageDocument in all chats except secret chats. Returns the results in reverse chronological order.
///
/// Returns [FoundMessages].
class SearchOutgoingDocumentMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchOutgoingDocumentMessages";

  /// Query to search for in document file name and message caption.
  late String query;

  /// The maximum number of messages to be returned; up to 100.
  late int limit;

  /// Searches for outgoing messages with content of the type messageDocument in all chats except secret chats. Returns the results in reverse chronological order
  ///
  /// Returns [FoundMessages]
  SearchOutgoingDocumentMessages(
      {required this.query, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchOutgoingDocumentMessages',
      if (extra != null) '@extra': extra,
      'query': query,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchOutgoingDocumentMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    var limit = _map['limit']! as int;
    return SearchOutgoingDocumentMessages(
      extra: extra,
      clientId: clientId,
      query: query,
      limit: limit,
    );
  }
}

/// Deletes all call messages.
///
/// Returns [Ok].
class DeleteAllCallMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteAllCallMessages";

  /// Pass true to delete the messages for all users.
  late bool revoke;

  /// Deletes all call messages
  ///
  /// Returns [Ok]
  DeleteAllCallMessages({required this.revoke, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteAllCallMessages',
      if (extra != null) '@extra': extra,
      'revoke': revoke
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteAllCallMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var revoke = _map['revoke']! as bool;
    return DeleteAllCallMessages(
      extra: extra,
      clientId: clientId,
      revoke: revoke,
    );
  }
}

/// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user.
///
/// Returns [Messages].
class SearchChatRecentLocationMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchChatRecentLocationMessages";

  /// Chat identifier.
  late int chat_id;

  /// The maximum number of messages to be returned.
  late int limit;

  /// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
  ///
  /// Returns [Messages]
  SearchChatRecentLocationMessages(
      {required this.chat_id, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchChatRecentLocationMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchChatRecentLocationMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var limit = _map['limit']! as int;
    return SearchChatRecentLocationMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      limit: limit,
    );
  }
}

/// Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used.
///
/// Returns [Messages].
class GetActiveLiveLocationMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getActiveLiveLocationMessages";

  /// Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used
  ///
  /// Returns [Messages]
  GetActiveLiveLocationMessages({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getActiveLiveLocationMessages',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetActiveLiveLocationMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetActiveLiveLocationMessages(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns the last message sent in a chat no later than the specified date.
///
/// Returns [Message].
class GetChatMessageByDate extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatMessageByDate";

  /// Chat identifier.
  late int chat_id;

  /// Point in time (Unix timestamp) relative to which to search for messages.
  late int date;

  /// Returns the last message sent in a chat no later than the specified date
  ///
  /// Returns [Message]
  GetChatMessageByDate(
      {required this.chat_id, required this.date, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatMessageByDate',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'date': date
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatMessageByDate? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var date = _map['date']! as int;
    return GetChatMessageByDate(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      date: date,
    );
  }
}

/// Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id)..
///
/// Returns [MessagePositions].
class GetChatSparseMessagePositions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatSparseMessagePositions";

  /// Identifier of the chat in which to return information about message positions.
  late int chat_id;

  /// Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention, searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are unsupported in this function.
  late SearchMessagesFilter filter;

  /// The message identifier from which to return information about message positions.
  late int from_message_id;

  /// The expected number of message positions to be returned; 50-2000. A smaller number of positions can be returned, if there are not enough appropriate messages.
  late int limit;

  /// Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id).
  ///
  /// Returns [MessagePositions]
  GetChatSparseMessagePositions(
      {required this.chat_id,
      required this.filter,
      required this.from_message_id,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatSparseMessagePositions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'filter': filter,
      'from_message_id': from_message_id,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatSparseMessagePositions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var filter = SearchMessagesFilter.fromMap(_map['filter'])!;
    var from_message_id = _map['from_message_id']! as int;
    var limit = _map['limit']! as int;
    return GetChatSparseMessagePositions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      filter: filter,
      from_message_id: from_message_id,
      limit: limit,
    );
  }
}

/// Returns information about the next messages of the specified type in the chat split by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset".
///
/// Returns [MessageCalendar].
class GetChatMessageCalendar extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatMessageCalendar";

  /// Identifier of the chat in which to return information about messages.
  late int chat_id;

  /// Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention, searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are unsupported in this function.
  late SearchMessagesFilter filter;

  /// The message identifier from which to return information about messages; use 0 to get results from the last message.
  late int from_message_id;

  /// Returns information about the next messages of the specified type in the chat split by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset"
  ///
  /// Returns [MessageCalendar]
  GetChatMessageCalendar(
      {required this.chat_id,
      required this.filter,
      required this.from_message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatMessageCalendar',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'filter': filter,
      'from_message_id': from_message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatMessageCalendar? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var filter = SearchMessagesFilter.fromMap(_map['filter'])!;
    var from_message_id = _map['from_message_id']! as int;
    return GetChatMessageCalendar(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      filter: filter,
      from_message_id: from_message_id,
    );
  }
}

/// Returns approximate number of messages of the specified type in the chat.
///
/// Returns [Count].
class GetChatMessageCount extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatMessageCount";

  /// Identifier of the chat in which to count messages.
  late int chat_id;

  /// Filter for message content; searchMessagesFilterEmpty is unsupported in this function.
  late SearchMessagesFilter filter;

  /// Pass true to get the number of messages without sending network requests, or -1 if the number of messages is unknown locally.
  late bool return_local;

  /// Returns approximate number of messages of the specified type in the chat
  ///
  /// Returns [Count]
  GetChatMessageCount(
      {required this.chat_id,
      required this.filter,
      required this.return_local,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatMessageCount',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'filter': filter,
      'return_local': return_local
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatMessageCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var filter = SearchMessagesFilter.fromMap(_map['filter'])!;
    var return_local = _map['return_local']! as bool;
    return GetChatMessageCount(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      filter: filter,
      return_local: return_local,
    );
  }
}

/// Returns approximate 1-based position of a message among messages, which can be found by the specified filter in the chat. Cannot be used in secret chats.
///
/// Returns [Count].
class GetChatMessagePosition extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatMessagePosition";

  /// Identifier of the chat in which to find message position.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// Filter for message content; searchMessagesFilterEmpty, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction, and searchMessagesFilterFailedToSend are unsupported in this function.
  late SearchMessagesFilter filter;

  /// If not 0, only messages in the specified thread will be considered; supergroups only.
  late int message_thread_id;

  /// Returns approximate 1-based position of a message among messages, which can be found by the specified filter in the chat. Cannot be used in secret chats
  ///
  /// Returns [Count]
  GetChatMessagePosition(
      {required this.chat_id,
      required this.message_id,
      required this.filter,
      required this.message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatMessagePosition',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'filter': filter,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatMessagePosition? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var filter = SearchMessagesFilter.fromMap(_map['filter'])!;
    var message_thread_id = _map['message_thread_id']! as int;
    return GetChatMessagePosition(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      filter: filter,
      message_thread_id: message_thread_id,
    );
  }
}

/// Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id).
///
/// Returns [Messages].
class GetChatScheduledMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatScheduledMessages";

  /// Chat identifier.
  late int chat_id;

  /// Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
  ///
  /// Returns [Messages]
  GetChatScheduledMessages({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatScheduledMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatScheduledMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatScheduledMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Returns forwarded copies of a channel message to different public channels. For optimal performance, the number of returned messages is chosen by TDLib.
///
/// Returns [FoundMessages].
class GetMessagePublicForwards extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessagePublicForwards";

  /// Chat identifier of the message.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results.
  late String offset;

  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
  late int limit;

  /// Returns forwarded copies of a channel message to different public channels. For optimal performance, the number of returned messages is chosen by TDLib
  ///
  /// Returns [FoundMessages]
  GetMessagePublicForwards(
      {required this.chat_id,
      required this.message_id,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessagePublicForwards',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessagePublicForwards? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var offset = _map['offset']! as String;
    var limit = _map['limit']! as int;
    return GetMessagePublicForwards(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      offset: offset,
      limit: limit,
    );
  }
}

/// Returns sponsored messages to be shown in a chat; for channel chats only.
///
/// Returns [SponsoredMessages].
class GetChatSponsoredMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatSponsoredMessages";

  /// Identifier of the chat.
  late int chat_id;

  /// Returns sponsored messages to be shown in a chat; for channel chats only
  ///
  /// Returns [SponsoredMessages]
  GetChatSponsoredMessages({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatSponsoredMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatSponsoredMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatSponsoredMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Informs TDLib that the user opened the sponsored chat via the button, the name, the photo, or a mention in the sponsored message.
///
/// Returns [Ok].
class ClickChatSponsoredMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clickChatSponsoredMessage";

  /// Chat identifier of the sponsored message.
  late int chat_id;

  /// Identifier of the sponsored message.
  late int message_id;

  /// Informs TDLib that the user opened the sponsored chat via the button, the name, the photo, or a mention in the sponsored message
  ///
  /// Returns [Ok]
  ClickChatSponsoredMessage(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clickChatSponsoredMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClickChatSponsoredMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return ClickChatSponsoredMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user.
///
/// Returns [Ok].
class RemoveNotification extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeNotification";

  /// Identifier of notification group to which the notification belongs.
  late int notification_group_id;

  /// Identifier of removed notification.
  late int notification_id;

  /// Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
  ///
  /// Returns [Ok]
  RemoveNotification(
      {required this.notification_group_id,
      required this.notification_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeNotification',
      if (extra != null) '@extra': extra,
      'notification_group_id': notification_group_id,
      'notification_id': notification_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveNotification? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var notification_group_id = _map['notification_group_id']! as int;
    var notification_id = _map['notification_id']! as int;
    return RemoveNotification(
      extra: extra,
      clientId: clientId,
      notification_group_id: notification_group_id,
      notification_id: notification_id,
    );
  }
}

/// Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user.
///
/// Returns [Ok].
class RemoveNotificationGroup extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeNotificationGroup";

  /// Notification group identifier.
  late int notification_group_id;

  /// The maximum identifier of removed notifications.
  late int max_notification_id;

  /// Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
  ///
  /// Returns [Ok]
  RemoveNotificationGroup(
      {required this.notification_group_id,
      required this.max_notification_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeNotificationGroup',
      if (extra != null) '@extra': extra,
      'notification_group_id': notification_group_id,
      'max_notification_id': max_notification_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveNotificationGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var notification_group_id = _map['notification_group_id']! as int;
    var max_notification_id = _map['max_notification_id']! as int;
    return RemoveNotificationGroup(
      extra: extra,
      clientId: clientId,
      notification_group_id: notification_group_id,
      max_notification_id: max_notification_id,
    );
  }
}

/// Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request.
///
/// Returns [MessageLink].
class GetMessageLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageLink";

  /// Identifier of the chat to which the message belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// If not 0, timestamp from which the video/audio/video note/voice note playing must start, in seconds. The media can be in the message content or in its web page preview.
  late int media_timestamp;

  /// Pass true to create a link for the whole media album.
  late bool for_album;

  /// Pass true to create a link to the message as a channel post comment, in a message thread, or a forum topic.
  late bool in_message_thread;

  /// Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request
  ///
  /// Returns [MessageLink]
  GetMessageLink(
      {required this.chat_id,
      required this.message_id,
      required this.media_timestamp,
      required this.for_album,
      required this.in_message_thread,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageLink',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'media_timestamp': media_timestamp,
      'for_album': for_album,
      'in_message_thread': in_message_thread
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var media_timestamp = _map['media_timestamp']! as int;
    var for_album = _map['for_album']! as bool;
    var in_message_thread = _map['in_message_thread']! as bool;
    return GetMessageLink(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      media_timestamp: media_timestamp,
      for_album: for_album,
      in_message_thread: in_message_thread,
    );
  }
}

/// Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username.
///
/// Returns [Text].
class GetMessageEmbeddingCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageEmbeddingCode";

  /// Identifier of the chat to which the message belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Pass true to return an HTML code for embedding of the whole media album.
  late bool for_album;

  /// Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
  ///
  /// Returns [Text]
  GetMessageEmbeddingCode(
      {required this.chat_id,
      required this.message_id,
      required this.for_album,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageEmbeddingCode',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'for_album': for_album
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageEmbeddingCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var for_album = _map['for_album']! as bool;
    return GetMessageEmbeddingCode(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      for_album: for_album,
    );
  }
}

/// Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage.
///
/// Returns [MessageLinkInfo].
class GetMessageLinkInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageLinkInfo";

  /// The message link.
  late String url;

  /// Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage
  ///
  /// Returns [MessageLinkInfo]
  GetMessageLinkInfo({required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageLinkInfo',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageLinkInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return GetMessageLinkInfo(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// Translates a text to the given language. If the current user is a Telegram Premium user, then text formatting is preserved.
///
/// Returns [FormattedText].
class TranslateText extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "translateText";

  /// Text to translate.
  late FormattedText text;

  /// Language code of the language to which the message is translated. Must be one of.
  late String to_language_code;

  /// Translates a text to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
  ///
  /// Returns [FormattedText]
  TranslateText(
      {required this.text,
      required this.to_language_code,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'translateText',
      if (extra != null) '@extra': extra,
      'text': text,
      'to_language_code': to_language_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TranslateText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = FormattedText.fromMap(_map['text'])!;
    var to_language_code = _map['to_language_code']! as String;
    return TranslateText(
      extra: extra,
      clientId: clientId,
      text: text,
      to_language_code: to_language_code,
    );
  }
}

/// Extracts text or caption of the given message and translates it to the given language. If the current user is a Telegram Premium user, then text formatting is preserved.
///
/// Returns [FormattedText].
class TranslateMessageText extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "translateMessageText";

  /// Identifier of the chat to which the message belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Language code of the language to which the message is translated. Must be one of.
  late String to_language_code;

  /// Extracts text or caption of the given message and translates it to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
  ///
  /// Returns [FormattedText]
  TranslateMessageText(
      {required this.chat_id,
      required this.message_id,
      required this.to_language_code,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'translateMessageText',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'to_language_code': to_language_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TranslateMessageText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var to_language_code = _map['to_language_code']! as String;
    return TranslateMessageText(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      to_language_code: to_language_code,
    );
  }
}

/// Recognizes speech in a video note or a voice note message. The message must be successfully sent and must not be scheduled. May return an error with a message "MSG_VOICE_TOO_LONG" if media duration is too big to be recognized.
///
/// Returns [Ok].
class RecognizeSpeech extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "recognizeSpeech";

  /// Identifier of the chat to which the message belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Recognizes speech in a video note or a voice note message. The message must be successfully sent and must not be scheduled. May return an error with a message "MSG_VOICE_TOO_LONG" if media duration is too big to be recognized
  ///
  /// Returns [Ok]
  RecognizeSpeech(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'recognizeSpeech',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RecognizeSpeech? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return RecognizeSpeech(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Rates recognized speech in a video note or a voice note message.
///
/// Returns [Ok].
class RateSpeechRecognition extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "rateSpeechRecognition";

  /// Identifier of the chat to which the message belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Pass true if the speech recognition is good.
  late bool is_good;

  /// Rates recognized speech in a video note or a voice note message
  ///
  /// Returns [Ok]
  RateSpeechRecognition(
      {required this.chat_id,
      required this.message_id,
      required this.is_good,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'rateSpeechRecognition',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'is_good': is_good
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RateSpeechRecognition? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var is_good = _map['is_good']! as bool;
    return RateSpeechRecognition(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      is_good: is_good,
    );
  }
}

/// Returns list of message sender identifiers, which can be used to send messages in a chat.
///
/// Returns [ChatMessageSenders].
class GetChatAvailableMessageSenders extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatAvailableMessageSenders";

  /// Chat identifier.
  late int chat_id;

  /// Returns list of message sender identifiers, which can be used to send messages in a chat
  ///
  /// Returns [ChatMessageSenders]
  GetChatAvailableMessageSenders(
      {required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatAvailableMessageSenders',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatAvailableMessageSenders? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatAvailableMessageSenders(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Selects a message sender to send messages in a chat.
///
/// Returns [Ok].
class SetChatMessageSender extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatMessageSender";

  /// Chat identifier.
  late int chat_id;

  /// New message sender for the chat.
  late MessageSender message_sender_id;

  /// Selects a message sender to send messages in a chat
  ///
  /// Returns [Ok]
  SetChatMessageSender(
      {required this.chat_id,
      required this.message_sender_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatMessageSender',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_sender_id': message_sender_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatMessageSender? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_sender_id = MessageSender.fromMap(_map['message_sender_id'])!;
    return SetChatMessageSender(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_sender_id: message_sender_id,
    );
  }
}

/// Sends a message. Returns the sent message.
///
/// Returns [Message].
class SendMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendMessage";

  /// Target chat.
  late int chat_id;

  /// If not 0, a message thread identifier in which the message will be sent.
  late int message_thread_id;

  /// Identifier of the replied message or story; pass null if none.
  MessageReplyTo? reply_to;

  /// Options to be used to send the message; pass null to use default options.
  MessageSendOptions? options;

  /// Markup for replying to the message; pass null if none; for bots only.
  ReplyMarkup? reply_markup;

  /// The content of the message to be sent.
  late InputMessageContent input_message_content;

  /// Sends a message. Returns the sent message
  ///
  /// Returns [Message]
  SendMessage(
      {required this.chat_id,
      required this.message_thread_id,
      this.reply_to,
      this.options,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'reply_to': reply_to,
      'options': options,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var reply_to = MessageReplyTo.fromMap(_map['reply_to']);
    var options = MessageSendOptions.fromMap(_map['options']);
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return SendMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      reply_to: reply_to,
      options: options,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Sends 2-10 messages grouped together into an album. Currently, only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages.
///
/// Returns [Messages].
class SendMessageAlbum extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendMessageAlbum";

  /// Target chat.
  late int chat_id;

  /// If not 0, a message thread identifier in which the messages will be sent.
  late int message_thread_id;

  /// Identifier of the replied message or story; pass null if none.
  MessageReplyTo? reply_to;

  /// Options to be used to send the messages; pass null to use default options.
  MessageSendOptions? options;

  /// Contents of messages to be sent. At most 10 messages can be added to an album.
  late List<InputMessageContent> input_message_contents;

  /// Pass true to get fake messages instead of actually sending them.
  late bool only_preview;

  /// Sends 2-10 messages grouped together into an album. Currently, only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages
  ///
  /// Returns [Messages]
  SendMessageAlbum(
      {required this.chat_id,
      required this.message_thread_id,
      this.reply_to,
      this.options,
      required this.input_message_contents,
      required this.only_preview,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendMessageAlbum',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'reply_to': reply_to,
      'options': options,
      'input_message_contents': input_message_contents,
      'only_preview': only_preview
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendMessageAlbum? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var reply_to = MessageReplyTo.fromMap(_map['reply_to']);
    var options = MessageSendOptions.fromMap(_map['options']);
    var input_message_contents = List<InputMessageContent>.from(
      (_map["input_message_contents"] ?? []).map(
        (e) => InputMessageContent.fromMap(e),
      ),
    );
    var only_preview = _map['only_preview']! as bool;
    return SendMessageAlbum(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      reply_to: reply_to,
      options: options,
      input_message_contents: input_message_contents,
      only_preview: only_preview,
    );
  }
}

/// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message.
///
/// Returns [Message].
class SendBotStartMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendBotStartMessage";

  /// Identifier of the bot.
  late int bot_user_id;

  /// Identifier of the target chat.
  late int chat_id;

  /// A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking).
  late String parameter;

  /// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
  ///
  /// Returns [Message]
  SendBotStartMessage(
      {required this.bot_user_id,
      required this.chat_id,
      required this.parameter,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendBotStartMessage',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'chat_id': chat_id,
      'parameter': parameter
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendBotStartMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var chat_id = _map['chat_id']! as int;
    var parameter = _map['parameter']! as String;
    return SendBotStartMessage(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      chat_id: chat_id,
      parameter: parameter,
    );
  }
}

/// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message.
///
/// Returns [Message].
class SendInlineQueryResultMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendInlineQueryResultMessage";

  /// Target chat.
  late int chat_id;

  /// If not 0, a message thread identifier in which the message will be sent.
  late int message_thread_id;

  /// Identifier of the replied message or story; pass null if none.
  MessageReplyTo? reply_to;

  /// Options to be used to send the message; pass null to use default options.
  MessageSendOptions? options;

  /// Identifier of the inline query.
  /// ; string representation of int, use `int.parse`
  late int64 query_id;

  /// Identifier of the inline query result.
  late String result_id;

  /// Pass true to hide the bot, via which the message is sent. Can be used only for bots getOption("animation_search_bot_username"), getOption("photo_search_bot_username"), and getOption("venue_search_bot_username").
  late bool hide_via_bot;

  /// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
  ///
  /// Returns [Message]
  SendInlineQueryResultMessage(
      {required this.chat_id,
      required this.message_thread_id,
      this.reply_to,
      this.options,
      required this.query_id,
      required this.result_id,
      required this.hide_via_bot,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendInlineQueryResultMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'reply_to': reply_to,
      'options': options,
      'query_id': query_id,
      'result_id': result_id,
      'hide_via_bot': hide_via_bot
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendInlineQueryResultMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var reply_to = MessageReplyTo.fromMap(_map['reply_to']);
    var options = MessageSendOptions.fromMap(_map['options']);
    var query_id = _map['query_id']! as int64;
    var result_id = _map['result_id']! as String;
    var hide_via_bot = _map['hide_via_bot']! as bool;
    return SendInlineQueryResultMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      reply_to: reply_to,
      options: options,
      query_id: query_id,
      result_id: result_id,
      hide_via_bot: hide_via_bot,
    );
  }
}

/// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message.
///
/// Returns [Messages].
class ForwardMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "forwardMessages";

  /// Identifier of the chat to which to forward messages.
  late int chat_id;

  /// If not 0, a message thread identifier in which the message will be sent; for forum threads only.
  late int message_thread_id;

  /// Identifier of the chat from which to forward messages.
  late int from_chat_id;

  /// Identifiers of the messages to forward. Message identifiers must be in a strictly increasing order. At most 100 messages can be forwarded simultaneously.
  late List<int> message_ids;

  /// Options to be used to send the messages; pass null to use default options.
  MessageSendOptions? options;

  /// Pass true to copy content of the messages without reference to the original sender. Always true if the messages are forwarded to a secret chat or are local.
  late bool send_copy;

  /// Pass true to remove media captions of message copies. Ignored if send_copy is false.
  late bool remove_caption;

  /// Pass true to get fake messages instead of actually forwarding them.
  late bool only_preview;

  /// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
  ///
  /// Returns [Messages]
  ForwardMessages(
      {required this.chat_id,
      required this.message_thread_id,
      required this.from_chat_id,
      required this.message_ids,
      this.options,
      required this.send_copy,
      required this.remove_caption,
      required this.only_preview,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'forwardMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'from_chat_id': from_chat_id,
      'message_ids': message_ids,
      'options': options,
      'send_copy': send_copy,
      'remove_caption': remove_caption,
      'only_preview': only_preview
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ForwardMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var from_chat_id = _map['from_chat_id']! as int;
    var message_ids = List<int>.from(
      (_map["message_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var options = MessageSendOptions.fromMap(_map['options']);
    var send_copy = _map['send_copy']! as bool;
    var remove_caption = _map['remove_caption']! as bool;
    var only_preview = _map['only_preview']! as bool;
    return ForwardMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      from_chat_id: from_chat_id,
      message_ids: message_ids,
      options: options,
      send_copy: send_copy,
      remove_caption: remove_caption,
      only_preview: only_preview,
    );
  }
}

/// Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed..
///
/// Returns [Messages].
class ResendMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resendMessages";

  /// Identifier of the chat to send messages.
  late int chat_id;

  /// Identifiers of the messages to resend. Message identifiers must be in a strictly increasing order.
  late List<int> message_ids;

  /// Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed.
  ///
  /// Returns [Messages]
  ResendMessages(
      {required this.chat_id,
      required this.message_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resendMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_ids': message_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResendMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_ids = List<int>.from(
      (_map["message_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return ResendMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_ids: message_ids,
    );
  }
}

/// Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message.
///
/// Returns [Message].
class AddLocalMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addLocalMessage";

  /// Target chat.
  late int chat_id;

  /// Identifier of the sender of the message.
  late MessageSender sender_id;

  /// Identifier of the replied message or story; pass null if none.
  MessageReplyTo? reply_to;

  /// Pass true to disable notification for the message.
  late bool disable_notification;

  /// The content of the message to be added.
  late InputMessageContent input_message_content;

  /// Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
  ///
  /// Returns [Message]
  AddLocalMessage(
      {required this.chat_id,
      required this.sender_id,
      this.reply_to,
      required this.disable_notification,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addLocalMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'sender_id': sender_id,
      'reply_to': reply_to,
      'disable_notification': disable_notification,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddLocalMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var sender_id = MessageSender.fromMap(_map['sender_id'])!;
    var reply_to = MessageReplyTo.fromMap(_map['reply_to']);
    var disable_notification = _map['disable_notification']! as bool;
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return AddLocalMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      sender_id: sender_id,
      reply_to: reply_to,
      disable_notification: disable_notification,
      input_message_content: input_message_content,
    );
  }
}

/// Deletes messages.
///
/// Returns [Ok].
class DeleteMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteMessages";

  /// Chat identifier.
  late int chat_id;

  /// Identifiers of the messages to be deleted.
  late List<int> message_ids;

  /// Pass true to delete messages for all chat members. Always true for supergroups, channels and secret chats.
  late bool revoke;

  /// Deletes messages
  ///
  /// Returns [Ok]
  DeleteMessages(
      {required this.chat_id,
      required this.message_ids,
      required this.revoke,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_ids': message_ids,
      'revoke': revoke
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_ids = List<int>.from(
      (_map["message_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var revoke = _map['revoke']! as bool;
    return DeleteMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_ids: message_ids,
      revoke: revoke,
    );
  }
}

/// Deletes all messages sent by the specified message sender in a chat. Supported only for supergroups; requires can_delete_messages administrator privileges.
///
/// Returns [Ok].
class DeleteChatMessagesBySender extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteChatMessagesBySender";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the sender of messages to delete.
  late MessageSender sender_id;

  /// Deletes all messages sent by the specified message sender in a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
  ///
  /// Returns [Ok]
  DeleteChatMessagesBySender(
      {required this.chat_id,
      required this.sender_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteChatMessagesBySender',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'sender_id': sender_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteChatMessagesBySender? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var sender_id = MessageSender.fromMap(_map['sender_id'])!;
    return DeleteChatMessagesBySender(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      sender_id: sender_id,
    );
  }
}

/// Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted.
///
/// Returns [Ok].
class DeleteChatMessagesByDate extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteChatMessagesByDate";

  /// Chat identifier.
  late int chat_id;

  /// The minimum date of the messages to delete.
  late int min_date;

  /// The maximum date of the messages to delete.
  late int max_date;

  /// Pass true to delete chat messages for all users; private chats only.
  late bool revoke;

  /// Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted
  ///
  /// Returns [Ok]
  DeleteChatMessagesByDate(
      {required this.chat_id,
      required this.min_date,
      required this.max_date,
      required this.revoke,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteChatMessagesByDate',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'min_date': min_date,
      'max_date': max_date,
      'revoke': revoke
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteChatMessagesByDate? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var min_date = _map['min_date']! as int;
    var max_date = _map['max_date']! as int;
    var revoke = _map['revoke']! as bool;
    return DeleteChatMessagesByDate(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      min_date: min_date,
      max_date: max_date,
      revoke: revoke,
    );
  }
}

/// Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side.
///
/// Returns [Message].
class EditMessageText extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editMessageText";

  /// The chat the message belongs to.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// The new message reply markup; pass null if none; for bots only.
  ReplyMarkup? reply_markup;

  /// New text content of the message. Must be of type inputMessageText.
  late InputMessageContent input_message_content;

  /// Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
  ///
  /// Returns [Message]
  EditMessageText(
      {required this.chat_id,
      required this.message_id,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editMessageText',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditMessageText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return EditMessageText(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side.
///
/// Returns [Message].
class EditMessageLiveLocation extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editMessageLiveLocation";

  /// The chat the message belongs to.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// The new message reply markup; pass null if none; for bots only.
  ReplyMarkup? reply_markup;

  /// New location content of the message; pass null to stop sharing the live location.
  Location? location;

  /// The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown.
  late int heading;

  /// The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled.
  late int proximity_alert_radius;

  /// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
  ///
  /// Returns [Message]
  EditMessageLiveLocation(
      {required this.chat_id,
      required this.message_id,
      this.reply_markup,
      this.location,
      required this.heading,
      required this.proximity_alert_radius,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editMessageLiveLocation',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'reply_markup': reply_markup,
      'location': location,
      'heading': heading,
      'proximity_alert_radius': proximity_alert_radius
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditMessageLiveLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var location = Location.fromMap(_map['location']);
    var heading = _map['heading']! as int;
    var proximity_alert_radius = _map['proximity_alert_radius']! as int;
    return EditMessageLiveLocation(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      reply_markup: reply_markup,
      location: location,
      heading: heading,
      proximity_alert_radius: proximity_alert_radius,
    );
  }
}

/// Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead..
///
/// Returns [Message].
class EditMessageMedia extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editMessageMedia";

  /// The chat the message belongs to.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// The new message reply markup; pass null if none; for bots only.
  ReplyMarkup? reply_markup;

  /// New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo.
  late InputMessageContent input_message_content;

  /// Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead.
  ///
  /// Returns [Message]
  EditMessageMedia(
      {required this.chat_id,
      required this.message_id,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editMessageMedia',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditMessageMedia? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return EditMessageMedia(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Edits the message content caption. Returns the edited message after the edit is completed on the server side.
///
/// Returns [Message].
class EditMessageCaption extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editMessageCaption";

  /// The chat the message belongs to.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// The new message reply markup; pass null if none; for bots only.
  ReplyMarkup? reply_markup;

  /// New message content caption; 0-getOption("message_caption_length_max") characters; pass null to remove caption.
  FormattedText? caption;

  /// Edits the message content caption. Returns the edited message after the edit is completed on the server side
  ///
  /// Returns [Message]
  EditMessageCaption(
      {required this.chat_id,
      required this.message_id,
      this.reply_markup,
      this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editMessageCaption',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'reply_markup': reply_markup,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditMessageCaption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var caption = FormattedText.fromMap(_map['caption']);
    return EditMessageCaption(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      reply_markup: reply_markup,
      caption: caption,
    );
  }
}

/// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side.
///
/// Returns [Message].
class EditMessageReplyMarkup extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editMessageReplyMarkup";

  /// The chat the message belongs to.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// The new message reply markup; pass null if none.
  ReplyMarkup? reply_markup;

  /// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
  ///
  /// Returns [Message]
  EditMessageReplyMarkup(
      {required this.chat_id,
      required this.message_id,
      this.reply_markup,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editMessageReplyMarkup',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'reply_markup': reply_markup
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditMessageReplyMarkup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    return EditMessageReplyMarkup(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      reply_markup: reply_markup,
    );
  }
}

/// Edits the text of an inline text or game message sent via a bot; for bots only.
///
/// Returns [Ok].
class EditInlineMessageText extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editInlineMessageText";

  /// Inline message identifier.
  late String inline_message_id;

  /// The new message reply markup; pass null if none.
  ReplyMarkup? reply_markup;

  /// New text content of the message. Must be of type inputMessageText.
  late InputMessageContent input_message_content;

  /// Edits the text of an inline text or game message sent via a bot; for bots only
  ///
  /// Returns [Ok]
  EditInlineMessageText(
      {required this.inline_message_id,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editInlineMessageText',
      if (extra != null) '@extra': extra,
      'inline_message_id': inline_message_id,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditInlineMessageText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_message_id = _map['inline_message_id']! as String;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return EditInlineMessageText(
      extra: extra,
      clientId: clientId,
      inline_message_id: inline_message_id,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Edits the content of a live location in an inline message sent via a bot; for bots only.
///
/// Returns [Ok].
class EditInlineMessageLiveLocation extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editInlineMessageLiveLocation";

  /// Inline message identifier.
  late String inline_message_id;

  /// The new message reply markup; pass null if none.
  ReplyMarkup? reply_markup;

  /// New location content of the message; pass null to stop sharing the live location.
  Location? location;

  /// The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown.
  late int heading;

  /// The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled.
  late int proximity_alert_radius;

  /// Edits the content of a live location in an inline message sent via a bot; for bots only
  ///
  /// Returns [Ok]
  EditInlineMessageLiveLocation(
      {required this.inline_message_id,
      this.reply_markup,
      this.location,
      required this.heading,
      required this.proximity_alert_radius,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editInlineMessageLiveLocation',
      if (extra != null) '@extra': extra,
      'inline_message_id': inline_message_id,
      'reply_markup': reply_markup,
      'location': location,
      'heading': heading,
      'proximity_alert_radius': proximity_alert_radius
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditInlineMessageLiveLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_message_id = _map['inline_message_id']! as String;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var location = Location.fromMap(_map['location']);
    var heading = _map['heading']! as int;
    var proximity_alert_radius = _map['proximity_alert_radius']! as int;
    return EditInlineMessageLiveLocation(
      extra: extra,
      clientId: clientId,
      inline_message_id: inline_message_id,
      reply_markup: reply_markup,
      location: location,
      heading: heading,
      proximity_alert_radius: proximity_alert_radius,
    );
  }
}

/// Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only.
///
/// Returns [Ok].
class EditInlineMessageMedia extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editInlineMessageMedia";

  /// Inline message identifier.
  late String inline_message_id;

  /// The new message reply markup; pass null if none; for bots only.
  ReplyMarkup? reply_markup;

  /// New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo.
  late InputMessageContent input_message_content;

  /// Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
  ///
  /// Returns [Ok]
  EditInlineMessageMedia(
      {required this.inline_message_id,
      this.reply_markup,
      required this.input_message_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editInlineMessageMedia',
      if (extra != null) '@extra': extra,
      'inline_message_id': inline_message_id,
      'reply_markup': reply_markup,
      'input_message_content': input_message_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditInlineMessageMedia? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_message_id = _map['inline_message_id']! as String;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var input_message_content =
        InputMessageContent.fromMap(_map['input_message_content'])!;
    return EditInlineMessageMedia(
      extra: extra,
      clientId: clientId,
      inline_message_id: inline_message_id,
      reply_markup: reply_markup,
      input_message_content: input_message_content,
    );
  }
}

/// Edits the caption of an inline message sent via a bot; for bots only.
///
/// Returns [Ok].
class EditInlineMessageCaption extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editInlineMessageCaption";

  /// Inline message identifier.
  late String inline_message_id;

  /// The new message reply markup; pass null if none.
  ReplyMarkup? reply_markup;

  /// New message content caption; pass null to remove caption; 0-getOption("message_caption_length_max") characters.
  FormattedText? caption;

  /// Edits the caption of an inline message sent via a bot; for bots only
  ///
  /// Returns [Ok]
  EditInlineMessageCaption(
      {required this.inline_message_id,
      this.reply_markup,
      this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editInlineMessageCaption',
      if (extra != null) '@extra': extra,
      'inline_message_id': inline_message_id,
      'reply_markup': reply_markup,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditInlineMessageCaption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_message_id = _map['inline_message_id']! as String;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    var caption = FormattedText.fromMap(_map['caption']);
    return EditInlineMessageCaption(
      extra: extra,
      clientId: clientId,
      inline_message_id: inline_message_id,
      reply_markup: reply_markup,
      caption: caption,
    );
  }
}

/// Edits the reply markup of an inline message sent via a bot; for bots only.
///
/// Returns [Ok].
class EditInlineMessageReplyMarkup extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editInlineMessageReplyMarkup";

  /// Inline message identifier.
  late String inline_message_id;

  /// The new message reply markup; pass null if none.
  ReplyMarkup? reply_markup;

  /// Edits the reply markup of an inline message sent via a bot; for bots only
  ///
  /// Returns [Ok]
  EditInlineMessageReplyMarkup(
      {required this.inline_message_id,
      this.reply_markup,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editInlineMessageReplyMarkup',
      if (extra != null) '@extra': extra,
      'inline_message_id': inline_message_id,
      'reply_markup': reply_markup
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditInlineMessageReplyMarkup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_message_id = _map['inline_message_id']! as String;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    return EditInlineMessageReplyMarkup(
      extra: extra,
      clientId: clientId,
      inline_message_id: inline_message_id,
      reply_markup: reply_markup,
    );
  }
}

/// Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed.
///
/// Returns [Ok].
class EditMessageSchedulingState extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editMessageSchedulingState";

  /// The chat the message belongs to.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// The new message scheduling state; pass null to send the message immediately.
  MessageSchedulingState? scheduling_state;

  /// Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
  ///
  /// Returns [Ok]
  EditMessageSchedulingState(
      {required this.chat_id,
      required this.message_id,
      this.scheduling_state,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editMessageSchedulingState',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'scheduling_state': scheduling_state
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditMessageSchedulingState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var scheduling_state =
        MessageSchedulingState.fromMap(_map['scheduling_state']);
    return EditMessageSchedulingState(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      scheduling_state: scheduling_state,
    );
  }
}

/// Returns list of custom emojis, which can be used as forum topic icon by all users.
///
/// Returns [Stickers].
class GetForumTopicDefaultIcons extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getForumTopicDefaultIcons";

  /// Returns list of custom emojis, which can be used as forum topic icon by all users
  ///
  /// Returns [Stickers]
  GetForumTopicDefaultIcons({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getForumTopicDefaultIcons',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetForumTopicDefaultIcons? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetForumTopicDefaultIcons(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Creates a topic in a forum supergroup chat; requires can_manage_topics rights in the supergroup.
///
/// Returns [ForumTopicInfo].
class CreateForumTopic extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createForumTopic";

  /// Identifier of the chat.
  late int chat_id;

  /// Name of the topic; 1-128 characters.
  late String name;

  /// Icon of the topic. Icon color must be one of 0x6FB9F0, 0xFFD67E, 0xCB86DB, 0x8EEE98, 0xFF93B2, or 0xFB6F5F. Telegram Premium users can use any custom emoji as topic icon, other users can use only a custom emoji returned by getForumTopicDefaultIcons.
  late ForumTopicIcon icon;

  /// Creates a topic in a forum supergroup chat; requires can_manage_topics rights in the supergroup
  ///
  /// Returns [ForumTopicInfo]
  CreateForumTopic(
      {required this.chat_id,
      required this.name,
      required this.icon,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createForumTopic',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'name': name,
      'icon': icon
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateForumTopic? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var name = _map['name']! as String;
    var icon = ForumTopicIcon.fromMap(_map['icon'])!;
    return CreateForumTopic(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      name: name,
      icon: icon,
    );
  }
}

/// Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic.
///
/// Returns [Ok].
class EditForumTopic extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editForumTopic";

  /// Identifier of the chat.
  late int chat_id;

  /// Message thread identifier of the forum topic.
  late int message_thread_id;

  /// New name of the topic; 0-128 characters. If empty, the previous topic name is kept.
  String? name;

  /// Pass true to edit the icon of the topic. Icon of the General topic can't be edited.
  late bool edit_icon_custom_emoji;

  /// Identifier of the new custom emoji for topic icon; pass 0 to remove the custom emoji. Ignored if edit_icon_custom_emoji is false. Telegram Premium users can use any custom emoji, other users can use only a custom emoji returned by getForumTopicDefaultIcons.
  /// ; string representation of int, use `int.parse`
  late int64 icon_custom_emoji_id;

  /// Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
  ///
  /// Returns [Ok]
  EditForumTopic(
      {required this.chat_id,
      required this.message_thread_id,
      this.name,
      required this.edit_icon_custom_emoji,
      required this.icon_custom_emoji_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editForumTopic',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'name': name,
      'edit_icon_custom_emoji': edit_icon_custom_emoji,
      'icon_custom_emoji_id': icon_custom_emoji_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditForumTopic? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var name = _map['name'] as String?;
    var edit_icon_custom_emoji = _map['edit_icon_custom_emoji']! as bool;
    var icon_custom_emoji_id = _map['icon_custom_emoji_id']! as int64;
    return EditForumTopic(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      name: name,
      edit_icon_custom_emoji: edit_icon_custom_emoji,
      icon_custom_emoji_id: icon_custom_emoji_id,
    );
  }
}

/// Returns information about a forum topic.
///
/// Returns [ForumTopic].
class GetForumTopic extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getForumTopic";

  /// Identifier of the chat.
  late int chat_id;

  /// Message thread identifier of the forum topic.
  late int message_thread_id;

  /// Returns information about a forum topic
  ///
  /// Returns [ForumTopic]
  GetForumTopic(
      {required this.chat_id,
      required this.message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getForumTopic',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetForumTopic? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    return GetForumTopic(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
    );
  }
}

/// Returns an HTTPS link to a topic in a forum chat. This is an offline request.
///
/// Returns [MessageLink].
class GetForumTopicLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getForumTopicLink";

  /// Identifier of the chat.
  late int chat_id;

  /// Message thread identifier of the forum topic.
  late int message_thread_id;

  /// Returns an HTTPS link to a topic in a forum chat. This is an offline request
  ///
  /// Returns [MessageLink]
  GetForumTopicLink(
      {required this.chat_id,
      required this.message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getForumTopicLink',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetForumTopicLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    return GetForumTopicLink(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
    );
  }
}

/// Returns found forum topics in a forum chat. This is a temporary method for getting information about topic list from the server.
///
/// Returns [ForumTopics].
class GetForumTopics extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getForumTopics";

  /// Identifier of the forum chat.
  late int chat_id;

  /// Query to search for in the forum topic's name.
  late String query;

  /// The date starting from which the results need to be fetched. Use 0 or any date in the future to get results from the last topic.
  late int offset_date;

  /// The message identifier of the last message in the last found topic, or 0 for the first request.
  late int offset_message_id;

  /// The message thread identifier of the last found topic, or 0 for the first request.
  late int offset_message_thread_id;

  /// The maximum number of forum topics to be returned; up to 100. For optimal performance, the number of returned forum topics is chosen by TDLib and can be smaller than the specified limit.
  late int limit;

  /// Returns found forum topics in a forum chat. This is a temporary method for getting information about topic list from the server
  ///
  /// Returns [ForumTopics]
  GetForumTopics(
      {required this.chat_id,
      required this.query,
      required this.offset_date,
      required this.offset_message_id,
      required this.offset_message_thread_id,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getForumTopics',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'query': query,
      'offset_date': offset_date,
      'offset_message_id': offset_message_id,
      'offset_message_thread_id': offset_message_thread_id,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetForumTopics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var query = _map['query']! as String;
    var offset_date = _map['offset_date']! as int;
    var offset_message_id = _map['offset_message_id']! as int;
    var offset_message_thread_id = _map['offset_message_thread_id']! as int;
    var limit = _map['limit']! as int;
    return GetForumTopics(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      query: query,
      offset_date: offset_date,
      offset_message_id: offset_message_id,
      offset_message_thread_id: offset_message_thread_id,
      limit: limit,
    );
  }
}

/// Changes the notification settings of a forum topic.
///
/// Returns [Ok].
class SetForumTopicNotificationSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setForumTopicNotificationSettings";

  /// Chat identifier.
  late int chat_id;

  /// Message thread identifier of the forum topic.
  late int message_thread_id;

  /// New notification settings for the forum topic. If the topic is muted for more than 366 days, it is considered to be muted forever.
  late ChatNotificationSettings notification_settings;

  /// Changes the notification settings of a forum topic
  ///
  /// Returns [Ok]
  SetForumTopicNotificationSettings(
      {required this.chat_id,
      required this.message_thread_id,
      required this.notification_settings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setForumTopicNotificationSettings',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'notification_settings': notification_settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetForumTopicNotificationSettings? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var notification_settings =
        ChatNotificationSettings.fromMap(_map['notification_settings'])!;
    return SetForumTopicNotificationSettings(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      notification_settings: notification_settings,
    );
  }
}

/// Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic.
///
/// Returns [Ok].
class ToggleForumTopicIsClosed extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleForumTopicIsClosed";

  /// Identifier of the chat.
  late int chat_id;

  /// Message thread identifier of the forum topic.
  late int message_thread_id;

  /// Pass true to close the topic; pass false to reopen it.
  late bool is_closed;

  /// Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
  ///
  /// Returns [Ok]
  ToggleForumTopicIsClosed(
      {required this.chat_id,
      required this.message_thread_id,
      required this.is_closed,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleForumTopicIsClosed',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'is_closed': is_closed
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleForumTopicIsClosed? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var is_closed = _map['is_closed']! as bool;
    return ToggleForumTopicIsClosed(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      is_closed: is_closed,
    );
  }
}

/// Toggles whether a General topic is hidden in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup.
///
/// Returns [Ok].
class ToggleGeneralForumTopicIsHidden extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleGeneralForumTopicIsHidden";

  /// Identifier of the chat.
  late int chat_id;

  /// Pass true to hide and close the General topic; pass false to unhide it.
  late bool is_hidden;

  /// Toggles whether a General topic is hidden in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup
  ///
  /// Returns [Ok]
  ToggleGeneralForumTopicIsHidden(
      {required this.chat_id,
      required this.is_hidden,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleGeneralForumTopicIsHidden',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'is_hidden': is_hidden
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleGeneralForumTopicIsHidden? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var is_hidden = _map['is_hidden']! as bool;
    return ToggleGeneralForumTopicIsHidden(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      is_hidden: is_hidden,
    );
  }
}

/// Changes the pinned state of a forum topic; requires can_manage_topics administrator right in the supergroup. There can be up to getOption("pinned_forum_topic_count_max") pinned forum topics.
///
/// Returns [Ok].
class ToggleForumTopicIsPinned extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleForumTopicIsPinned";

  /// Chat identifier.
  late int chat_id;

  /// Message thread identifier of the forum topic.
  late int message_thread_id;

  /// Pass true to pin the topic; pass false to unpin it.
  late bool is_pinned;

  /// Changes the pinned state of a forum topic; requires can_manage_topics administrator right in the supergroup. There can be up to getOption("pinned_forum_topic_count_max") pinned forum topics
  ///
  /// Returns [Ok]
  ToggleForumTopicIsPinned(
      {required this.chat_id,
      required this.message_thread_id,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleForumTopicIsPinned',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleForumTopicIsPinned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var is_pinned = _map['is_pinned']! as bool;
    return ToggleForumTopicIsPinned(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      is_pinned: is_pinned,
    );
  }
}

/// Changes the order of pinned forum topics.
///
/// Returns [Ok].
class SetPinnedForumTopics extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setPinnedForumTopics";

  /// Chat identifier.
  late int chat_id;

  /// The new list of pinned forum topics.
  late List<int> message_thread_ids;

  /// Changes the order of pinned forum topics
  ///
  /// Returns [Ok]
  SetPinnedForumTopics(
      {required this.chat_id,
      required this.message_thread_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setPinnedForumTopics',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_ids': message_thread_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetPinnedForumTopics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_ids = List<int>.from(
      (_map["message_thread_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return SetPinnedForumTopics(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_ids: message_thread_ids,
    );
  }
}

/// Deletes all messages in a forum topic; requires can_delete_messages administrator right in the supergroup unless the user is creator of the topic, the topic has no messages from other users and has at most 11 messages.
///
/// Returns [Ok].
class DeleteForumTopic extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteForumTopic";

  /// Identifier of the chat.
  late int chat_id;

  /// Message thread identifier of the forum topic.
  late int message_thread_id;

  /// Deletes all messages in a forum topic; requires can_delete_messages administrator right in the supergroup unless the user is creator of the topic, the topic has no messages from other users and has at most 11 messages
  ///
  /// Returns [Ok]
  DeleteForumTopic(
      {required this.chat_id,
      required this.message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteForumTopic',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteForumTopic? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    return DeleteForumTopic(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
    );
  }
}

/// Returns information about a emoji reaction. Returns a 404 error if the reaction is not found.
///
/// Returns [EmojiReaction].
class GetEmojiReaction extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getEmojiReaction";

  /// Text representation of the reaction.
  late String emoji;

  /// Returns information about a emoji reaction. Returns a 404 error if the reaction is not found
  ///
  /// Returns [EmojiReaction]
  GetEmojiReaction({required this.emoji, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getEmojiReaction',
      if (extra != null) '@extra': extra,
      'emoji': emoji
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetEmojiReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emoji = _map['emoji']! as String;
    return GetEmojiReaction(
      extra: extra,
      clientId: clientId,
      emoji: emoji,
    );
  }
}

/// Returns TGS stickers with generic animations for custom emoji reactions.
///
/// Returns [Stickers].
class GetCustomEmojiReactionAnimations extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCustomEmojiReactionAnimations";

  /// Returns TGS stickers with generic animations for custom emoji reactions
  ///
  /// Returns [Stickers]
  GetCustomEmojiReactionAnimations({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getCustomEmojiReactionAnimations',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCustomEmojiReactionAnimations? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetCustomEmojiReactionAnimations(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns reactions, which can be added to a message. The list can change after updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo for the message.
///
/// Returns [AvailableReactions].
class GetMessageAvailableReactions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageAvailableReactions";

  /// Identifier of the chat to which the message belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Number of reaction per row, 5-25.
  late int row_size;

  /// Returns reactions, which can be added to a message. The list can change after updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo for the message
  ///
  /// Returns [AvailableReactions]
  GetMessageAvailableReactions(
      {required this.chat_id,
      required this.message_id,
      required this.row_size,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageAvailableReactions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'row_size': row_size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageAvailableReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var row_size = _map['row_size']! as int;
    return GetMessageAvailableReactions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      row_size: row_size,
    );
  }
}

/// Clears the list of recently used reactions.
///
/// Returns [Ok].
class ClearRecentReactions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clearRecentReactions";

  /// Clears the list of recently used reactions
  ///
  /// Returns [Ok]
  ClearRecentReactions({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clearRecentReactions',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClearRecentReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ClearRecentReactions(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Adds a reaction to a message. Use getMessageAvailableReactions to receive the list of available reactions for the message.
///
/// Returns [Ok].
class AddMessageReaction extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addMessageReaction";

  /// Identifier of the chat to which the message belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Type of the reaction to add.
  late ReactionType reaction_type;

  /// Pass true if the reaction is added with a big animation.
  late bool is_big;

  /// Pass true if the reaction needs to be added to recent reactions.
  late bool update_recent_reactions;

  /// Adds a reaction to a message. Use getMessageAvailableReactions to receive the list of available reactions for the message
  ///
  /// Returns [Ok]
  AddMessageReaction(
      {required this.chat_id,
      required this.message_id,
      required this.reaction_type,
      required this.is_big,
      required this.update_recent_reactions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addMessageReaction',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'reaction_type': reaction_type,
      'is_big': is_big,
      'update_recent_reactions': update_recent_reactions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddMessageReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var reaction_type = ReactionType.fromMap(_map['reaction_type'])!;
    var is_big = _map['is_big']! as bool;
    var update_recent_reactions = _map['update_recent_reactions']! as bool;
    return AddMessageReaction(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      reaction_type: reaction_type,
      is_big: is_big,
      update_recent_reactions: update_recent_reactions,
    );
  }
}

/// Removes a reaction from a message. A chosen reaction can always be removed.
///
/// Returns [Ok].
class RemoveMessageReaction extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeMessageReaction";

  /// Identifier of the chat to which the message belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Type of the reaction to remove.
  late ReactionType reaction_type;

  /// Removes a reaction from a message. A chosen reaction can always be removed
  ///
  /// Returns [Ok]
  RemoveMessageReaction(
      {required this.chat_id,
      required this.message_id,
      required this.reaction_type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeMessageReaction',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'reaction_type': reaction_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveMessageReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var reaction_type = ReactionType.fromMap(_map['reaction_type'])!;
    return RemoveMessageReaction(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      reaction_type: reaction_type,
    );
  }
}

/// Returns reactions added for a message, along with their sender.
///
/// Returns [AddedReactions].
class GetMessageAddedReactions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageAddedReactions";

  /// Identifier of the chat to which the message belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Type of the reactions to return; pass null to return all added reactions.
  ReactionType? reaction_type;

  /// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results.
  late String offset;

  /// The maximum number of reactions to be returned; must be positive and can't be greater than 100.
  late int limit;

  /// Returns reactions added for a message, along with their sender
  ///
  /// Returns [AddedReactions]
  GetMessageAddedReactions(
      {required this.chat_id,
      required this.message_id,
      this.reaction_type,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageAddedReactions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'reaction_type': reaction_type,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageAddedReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var reaction_type = ReactionType.fromMap(_map['reaction_type']);
    var offset = _map['offset']! as String;
    var limit = _map['limit']! as int;
    return GetMessageAddedReactions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      reaction_type: reaction_type,
      offset: offset,
      limit: limit,
    );
  }
}

/// Changes type of default reaction for the current user.
///
/// Returns [Ok].
class SetDefaultReactionType extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setDefaultReactionType";

  /// New type of the default reaction.
  late ReactionType reaction_type;

  /// Changes type of default reaction for the current user
  ///
  /// Returns [Ok]
  SetDefaultReactionType(
      {required this.reaction_type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setDefaultReactionType',
      if (extra != null) '@extra': extra,
      'reaction_type': reaction_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetDefaultReactionType? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reaction_type = ReactionType.fromMap(_map['reaction_type'])!;
    return SetDefaultReactionType(
      extra: extra,
      clientId: clientId,
      reaction_type: reaction_type,
    );
  }
}

/// Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) found in the text. Can be called synchronously.
///
/// Returns [TextEntities].
class GetTextEntities extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getTextEntities";

  /// The text in which to look for entities.
  late String text;

  /// Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) found in the text. Can be called synchronously
  ///
  /// Returns [TextEntities]
  GetTextEntities({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getTextEntities',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetTextEntities? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    return GetTextEntities(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre, PreCode, TextUrl and MentionName entities from a marked-up text. Can be called synchronously.
///
/// Returns [FormattedText].
class ParseTextEntities extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "parseTextEntities";

  /// The text to parse.
  late String text;

  /// Text parse mode.
  late TextParseMode parse_mode;

  /// Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre, PreCode, TextUrl and MentionName entities from a marked-up text. Can be called synchronously
  ///
  /// Returns [FormattedText]
  ParseTextEntities(
      {required this.text,
      required this.parse_mode,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'parseTextEntities',
      if (extra != null) '@extra': extra,
      'text': text,
      'parse_mode': parse_mode
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ParseTextEntities? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var parse_mode = TextParseMode.fromMap(_map['parse_mode'])!;
    return ParseTextEntities(
      extra: extra,
      clientId: clientId,
      text: text,
      parse_mode: parse_mode,
    );
  }
}

/// Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously.
///
/// Returns [FormattedText].
class ParseMarkdown extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "parseMarkdown";

  /// The text to parse. For example, "__italic__ ~~strikethrough~~ ||spoiler|| **bold** `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**".
  late FormattedText text;

  /// Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
  ///
  /// Returns [FormattedText]
  ParseMarkdown({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'parseMarkdown',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ParseMarkdown? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = FormattedText.fromMap(_map['text'])!;
    return ParseMarkdown(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously.
///
/// Returns [FormattedText].
class GetMarkdownText extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMarkdownText";

  /// The text.
  late FormattedText text;

  /// Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
  ///
  /// Returns [FormattedText]
  GetMarkdownText({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMarkdownText',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMarkdownText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = FormattedText.fromMap(_map['text'])!;
    return GetMarkdownText(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously.
///
/// Returns [Text].
class GetFileMimeType extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getFileMimeType";

  /// The name of the file or path to the file.
  late String file_name;

  /// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
  ///
  /// Returns [Text]
  GetFileMimeType({required this.file_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getFileMimeType',
      if (extra != null) '@extra': extra,
      'file_name': file_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetFileMimeType? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_name = _map['file_name']! as String;
    return GetFileMimeType(
      extra: extra,
      clientId: clientId,
      file_name: file_name,
    );
  }
}

/// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously.
///
/// Returns [Text].
class GetFileExtension extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getFileExtension";

  /// The MIME type of the file.
  late String mime_type;

  /// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
  ///
  /// Returns [Text]
  GetFileExtension({required this.mime_type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getFileExtension',
      if (extra != null) '@extra': extra,
      'mime_type': mime_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetFileExtension? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var mime_type = _map['mime_type']! as String;
    return GetFileExtension(
      extra: extra,
      clientId: clientId,
      mime_type: mime_type,
    );
  }
}

/// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously.
///
/// Returns [Text].
class CleanFileName extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "cleanFileName";

  /// File name or path to the file.
  late String file_name;

  /// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
  ///
  /// Returns [Text]
  CleanFileName({required this.file_name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'cleanFileName',
      if (extra != null) '@extra': extra,
      'file_name': file_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CleanFileName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_name = _map['file_name']! as String;
    return CleanFileName(
      extra: extra,
      clientId: clientId,
      file_name: file_name,
    );
  }
}

/// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously.
///
/// Returns [LanguagePackStringValue].
class GetLanguagePackString extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLanguagePackString";

  /// Path to the language pack database in which strings are stored.
  late String language_pack_database_path;

  /// Localization target to which the language pack belongs.
  late String localization_target;

  /// Language pack identifier.
  late String language_pack_id;

  /// Language pack key of the string to be returned.
  late String key;

  /// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
  ///
  /// Returns [LanguagePackStringValue]
  GetLanguagePackString(
      {required this.language_pack_database_path,
      required this.localization_target,
      required this.language_pack_id,
      required this.key,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getLanguagePackString',
      if (extra != null) '@extra': extra,
      'language_pack_database_path': language_pack_database_path,
      'localization_target': localization_target,
      'language_pack_id': language_pack_id,
      'key': key
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLanguagePackString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_pack_database_path =
        _map['language_pack_database_path']! as String;
    var localization_target = _map['localization_target']! as String;
    var language_pack_id = _map['language_pack_id']! as String;
    var key = _map['key']! as String;
    return GetLanguagePackString(
      extra: extra,
      clientId: clientId,
      language_pack_database_path: language_pack_database_path,
      localization_target: localization_target,
      language_pack_id: language_pack_id,
      key: key,
    );
  }
}

/// Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously.
///
/// Returns [JsonValue].
class GetJsonValue extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getJsonValue";

  /// The JSON-serialized string.
  late String json;

  /// Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
  ///
  /// Returns [JsonValue]
  GetJsonValue({required this.json, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getJsonValue',
      if (extra != null) '@extra': extra,
      'json': json
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetJsonValue? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var json = _map['json']! as String;
    return GetJsonValue(
      extra: extra,
      clientId: clientId,
      json: json,
    );
  }
}

/// Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously.
///
/// Returns [Text].
class GetJsonString extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getJsonString";

  /// The JsonValue object.
  late JsonValue json_value;

  /// Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
  ///
  /// Returns [Text]
  GetJsonString({required this.json_value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getJsonString',
      if (extra != null) '@extra': extra,
      'json_value': json_value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetJsonString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var json_value = JsonValue.fromMap(_map['json_value'])!;
    return GetJsonString(
      extra: extra,
      clientId: clientId,
      json_value: json_value,
    );
  }
}

/// Converts a themeParameters object to corresponding JSON-serialized string. Can be called synchronously.
///
/// Returns [Text].
class GetThemeParametersJsonString extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getThemeParametersJsonString";

  /// Theme parameters to convert to JSON.
  late ThemeParameters theme;

  /// Converts a themeParameters object to corresponding JSON-serialized string. Can be called synchronously
  ///
  /// Returns [Text]
  GetThemeParametersJsonString(
      {required this.theme, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getThemeParametersJsonString',
      if (extra != null) '@extra': extra,
      'theme': theme
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetThemeParametersJsonString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var theme = ThemeParameters.fromMap(_map['theme'])!;
    return GetThemeParametersJsonString(
      extra: extra,
      clientId: clientId,
      theme: theme,
    );
  }
}

/// Changes the user answer to a poll. A poll in quiz mode can be answered only once.
///
/// Returns [Ok].
class SetPollAnswer extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setPollAnswer";

  /// Identifier of the chat to which the poll belongs.
  late int chat_id;

  /// Identifier of the message containing the poll.
  late int message_id;

  /// 0-based identifiers of answer options, chosen by the user. User can choose more than 1 answer option only is the poll allows multiple answers.
  late List<int> option_ids;

  /// Changes the user answer to a poll. A poll in quiz mode can be answered only once
  ///
  /// Returns [Ok]
  SetPollAnswer(
      {required this.chat_id,
      required this.message_id,
      required this.option_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setPollAnswer',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'option_ids': option_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetPollAnswer? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var option_ids = List<int>.from(
      (_map["option_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return SetPollAnswer(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      option_ids: option_ids,
    );
  }
}

/// Returns message senders voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib.
///
/// Returns [MessageSenders].
class GetPollVoters extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPollVoters";

  /// Identifier of the chat to which the poll belongs.
  late int chat_id;

  /// Identifier of the message containing the poll.
  late int message_id;

  /// 0-based identifier of the answer option.
  late int option_id;

  /// Number of voters to skip in the result; must be non-negative.
  late int offset;

  /// The maximum number of voters to be returned; must be positive and can't be greater than 50. For optimal performance, the number of returned voters is chosen by TDLib and can be smaller than the specified limit, even if the end of the voter list has not been reached.
  late int limit;

  /// Returns message senders voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib
  ///
  /// Returns [MessageSenders]
  GetPollVoters(
      {required this.chat_id,
      required this.message_id,
      required this.option_id,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPollVoters',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'option_id': option_id,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPollVoters? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var option_id = _map['option_id']! as int;
    var offset = _map['offset']! as int;
    var limit = _map['limit']! as int;
    return GetPollVoters(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      option_id: option_id,
      offset: offset,
      limit: limit,
    );
  }
}

/// Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag is set.
///
/// Returns [Ok].
class StopPoll extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "stopPoll";

  /// Identifier of the chat to which the poll belongs.
  late int chat_id;

  /// Identifier of the message containing the poll.
  late int message_id;

  /// The new message reply markup; pass null if none; for bots only.
  ReplyMarkup? reply_markup;

  /// Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag is set
  ///
  /// Returns [Ok]
  StopPoll(
      {required this.chat_id,
      required this.message_id,
      this.reply_markup,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'stopPoll',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'reply_markup': reply_markup
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StopPoll? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var reply_markup = ReplyMarkup.fromMap(_map['reply_markup']);
    return StopPoll(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      reply_markup: reply_markup,
    );
  }
}

/// Hides a suggested action.
///
/// Returns [Ok].
class HideSuggestedAction extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "hideSuggestedAction";

  /// Suggested action to hide.
  late SuggestedAction action;

  /// Hides a suggested action
  ///
  /// Returns [Ok]
  HideSuggestedAction({required this.action, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'hideSuggestedAction',
      if (extra != null) '@extra': extra,
      'action': action
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static HideSuggestedAction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var action = SuggestedAction.fromMap(_map['action'])!;
    return HideSuggestedAction(
      extra: extra,
      clientId: clientId,
      action: action,
    );
  }
}

/// Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button.
///
/// Returns [LoginUrlInfo].
class GetLoginUrlInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLoginUrlInfo";

  /// Chat identifier of the message with the button.
  late int chat_id;

  /// Message identifier of the message with the button.
  late int message_id;

  /// Button identifier.
  late int button_id;

  /// Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
  ///
  /// Returns [LoginUrlInfo]
  GetLoginUrlInfo(
      {required this.chat_id,
      required this.message_id,
      required this.button_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getLoginUrlInfo',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'button_id': button_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLoginUrlInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var button_id = _map['button_id']! as int;
    return GetLoginUrlInfo(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      button_id: button_id,
    );
  }
}

/// Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl..
///
/// Returns [HttpUrl].
class GetLoginUrl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLoginUrl";

  /// Chat identifier of the message with the button.
  late int chat_id;

  /// Message identifier of the message with the button.
  late int message_id;

  /// Button identifier.
  late int button_id;

  /// Pass true to allow the bot to send messages to the current user.
  late bool allow_write_access;

  /// Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
  ///
  /// Returns [HttpUrl]
  GetLoginUrl(
      {required this.chat_id,
      required this.message_id,
      required this.button_id,
      required this.allow_write_access,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getLoginUrl',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'button_id': button_id,
      'allow_write_access': allow_write_access
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLoginUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var button_id = _map['button_id']! as int;
    var allow_write_access = _map['allow_write_access']! as bool;
    return GetLoginUrl(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      button_id: button_id,
      allow_write_access: allow_write_access,
    );
  }
}

/// Shares a user after pressing a keyboardButtonTypeRequestUser button with the bot.
///
/// Returns [Ok].
class ShareUserWithBot extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "shareUserWithBot";

  /// Identifier of the chat with the bot.
  late int chat_id;

  /// Identifier of the message with the button.
  late int message_id;

  /// Identifier of the button.
  late int button_id;

  /// Identifier of the shared user.
  late int shared_user_id;

  /// Pass true to check that the user can be shared by the button instead of actually sharing them.
  late bool only_check;

  /// Shares a user after pressing a keyboardButtonTypeRequestUser button with the bot
  ///
  /// Returns [Ok]
  ShareUserWithBot(
      {required this.chat_id,
      required this.message_id,
      required this.button_id,
      required this.shared_user_id,
      required this.only_check,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'shareUserWithBot',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'button_id': button_id,
      'shared_user_id': shared_user_id,
      'only_check': only_check
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ShareUserWithBot? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var button_id = _map['button_id']! as int;
    var shared_user_id = _map['shared_user_id']! as int;
    var only_check = _map['only_check']! as bool;
    return ShareUserWithBot(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      button_id: button_id,
      shared_user_id: shared_user_id,
      only_check: only_check,
    );
  }
}

/// Shares a chat after pressing a keyboardButtonTypeRequestChat button with the bot.
///
/// Returns [Ok].
class ShareChatWithBot extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "shareChatWithBot";

  /// Identifier of the chat with the bot.
  late int chat_id;

  /// Identifier of the message with the button.
  late int message_id;

  /// Identifier of the button.
  late int button_id;

  /// Identifier of the shared chat.
  late int shared_chat_id;

  /// Pass true to check that the chat can be shared by the button instead of actually sharing it. Doesn't check bot_is_member and bot_administrator_rights restrictions..
  late bool only_check;

  /// Shares a chat after pressing a keyboardButtonTypeRequestChat button with the bot
  ///
  /// Returns [Ok]
  ShareChatWithBot(
      {required this.chat_id,
      required this.message_id,
      required this.button_id,
      required this.shared_chat_id,
      required this.only_check,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'shareChatWithBot',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'button_id': button_id,
      'shared_chat_id': shared_chat_id,
      'only_check': only_check
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ShareChatWithBot? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var button_id = _map['button_id']! as int;
    var shared_chat_id = _map['shared_chat_id']! as int;
    var only_check = _map['only_check']! as bool;
    return ShareChatWithBot(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      button_id: button_id,
      shared_chat_id: shared_chat_id,
      only_check: only_check,
    );
  }
}

/// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires.
///
/// Returns [InlineQueryResults].
class GetInlineQueryResults extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getInlineQueryResults";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// Identifier of the chat where the query was sent.
  late int chat_id;

  /// Location of the user; pass null if unknown or the bot doesn't need user's location.
  Location? user_location;

  /// Text of the query.
  late String query;

  /// Offset of the first entry to return; use empty string to get the first chunk of results.
  late String offset;

  /// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
  ///
  /// Returns [InlineQueryResults]
  GetInlineQueryResults(
      {required this.bot_user_id,
      required this.chat_id,
      this.user_location,
      required this.query,
      required this.offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getInlineQueryResults',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'chat_id': chat_id,
      'user_location': user_location,
      'query': query,
      'offset': offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetInlineQueryResults? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var chat_id = _map['chat_id']! as int;
    var user_location = Location.fromMap(_map['user_location']);
    var query = _map['query']! as String;
    var offset = _map['offset']! as String;
    return GetInlineQueryResults(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      chat_id: chat_id,
      user_location: user_location,
      query: query,
      offset: offset,
    );
  }
}

/// Sets the result of an inline query; for bots only.
///
/// Returns [Ok].
class AnswerInlineQuery extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "answerInlineQuery";

  /// Identifier of the inline query.
  /// ; string representation of int, use `int.parse`
  late int64 inline_query_id;

  /// Pass true if results may be cached and returned only for the user that sent the query. By default, results may be returned to any user who sends the same query.
  late bool is_personal;

  /// Button to be shown above inline query results; pass null if none.
  InlineQueryResultsButton? button;

  /// The results of the query.
  late List<InputInlineQueryResult> results;

  /// Allowed time to cache the results of the query, in seconds.
  late int cache_time;

  /// Offset for the next inline query; pass an empty string if there are no more results.
  late String next_offset;

  /// Sets the result of an inline query; for bots only
  ///
  /// Returns [Ok]
  AnswerInlineQuery(
      {required this.inline_query_id,
      required this.is_personal,
      this.button,
      required this.results,
      required this.cache_time,
      required this.next_offset,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'answerInlineQuery',
      if (extra != null) '@extra': extra,
      'inline_query_id': inline_query_id,
      'is_personal': is_personal,
      'button': button,
      'results': results,
      'cache_time': cache_time,
      'next_offset': next_offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AnswerInlineQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_query_id = _map['inline_query_id']! as int64;
    var is_personal = _map['is_personal']! as bool;
    var button = InlineQueryResultsButton.fromMap(_map['button']);
    var results = List<InputInlineQueryResult>.from(
      (_map["results"] ?? []).map(
        (e) => InputInlineQueryResult.fromMap(e),
      ),
    );
    var cache_time = _map['cache_time']! as int;
    var next_offset = _map['next_offset']! as String;
    return AnswerInlineQuery(
      extra: extra,
      clientId: clientId,
      inline_query_id: inline_query_id,
      is_personal: is_personal,
      button: button,
      results: results,
      cache_time: cache_time,
      next_offset: next_offset,
    );
  }
}

/// Returns information about a Web App by its short name. Returns a 404 error if the Web App is not found.
///
/// Returns [FoundWebApp].
class SearchWebApp extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchWebApp";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// Short name of the Web App.
  late String web_app_short_name;

  /// Returns information about a Web App by its short name. Returns a 404 error if the Web App is not found
  ///
  /// Returns [FoundWebApp]
  SearchWebApp(
      {required this.bot_user_id,
      required this.web_app_short_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchWebApp',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'web_app_short_name': web_app_short_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchWebApp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var web_app_short_name = _map['web_app_short_name']! as String;
    return SearchWebApp(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      web_app_short_name: web_app_short_name,
    );
  }
}

/// Returns an HTTPS URL of a Web App to open after a link of the type internalLinkTypeWebApp is clicked.
///
/// Returns [HttpUrl].
class GetWebAppLinkUrl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getWebAppLinkUrl";

  /// Identifier of the chat in which the link was clicked; pass 0 if none.
  late int chat_id;

  /// Identifier of the target bot.
  late int bot_user_id;

  /// Short name of the Web App.
  late String web_app_short_name;

  /// Start parameter from internalLinkTypeWebApp.
  late String start_parameter;

  /// Preferred Web App theme; pass null to use the default theme.
  ThemeParameters? theme;

  /// Short name of the application; 0-64 English letters, digits, and underscores.
  late String application_name;

  /// Pass true if the current user allowed the bot to send them messages.
  late bool allow_write_access;

  /// Returns an HTTPS URL of a Web App to open after a link of the type internalLinkTypeWebApp is clicked
  ///
  /// Returns [HttpUrl]
  GetWebAppLinkUrl(
      {required this.chat_id,
      required this.bot_user_id,
      required this.web_app_short_name,
      required this.start_parameter,
      this.theme,
      required this.application_name,
      required this.allow_write_access,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getWebAppLinkUrl',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'bot_user_id': bot_user_id,
      'web_app_short_name': web_app_short_name,
      'start_parameter': start_parameter,
      'theme': theme,
      'application_name': application_name,
      'allow_write_access': allow_write_access
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetWebAppLinkUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var bot_user_id = _map['bot_user_id']! as int;
    var web_app_short_name = _map['web_app_short_name']! as String;
    var start_parameter = _map['start_parameter']! as String;
    var theme = ThemeParameters.fromMap(_map['theme']);
    var application_name = _map['application_name']! as String;
    var allow_write_access = _map['allow_write_access']! as bool;
    return GetWebAppLinkUrl(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      bot_user_id: bot_user_id,
      web_app_short_name: web_app_short_name,
      start_parameter: start_parameter,
      theme: theme,
      application_name: application_name,
      allow_write_access: allow_write_access,
    );
  }
}

/// Returns an HTTPS URL of a Web App to open from the side menu, a keyboardButtonTypeWebApp button, an inlineQueryResultsButtonTypeWebApp button, or an internalLinkTypeSideMenuBot link.
///
/// Returns [HttpUrl].
class GetWebAppUrl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getWebAppUrl";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// The URL from a keyboardButtonTypeWebApp button, inlineQueryResultsButtonTypeWebApp button, an internalLinkTypeSideMenuBot link, or an empty when the bot is opened from the side menu.
  late String url;

  /// Preferred Web App theme; pass null to use the default theme.
  ThemeParameters? theme;

  /// Short name of the application; 0-64 English letters, digits, and underscores.
  late String application_name;

  /// Returns an HTTPS URL of a Web App to open from the side menu, a keyboardButtonTypeWebApp button, an inlineQueryResultsButtonTypeWebApp button, or an internalLinkTypeSideMenuBot link
  ///
  /// Returns [HttpUrl]
  GetWebAppUrl(
      {required this.bot_user_id,
      required this.url,
      this.theme,
      required this.application_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getWebAppUrl',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'url': url,
      'theme': theme,
      'application_name': application_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetWebAppUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var url = _map['url']! as String;
    var theme = ThemeParameters.fromMap(_map['theme']);
    var application_name = _map['application_name']! as String;
    return GetWebAppUrl(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      url: url,
      theme: theme,
      application_name: application_name,
    );
  }
}

/// Sends data received from a keyboardButtonTypeWebApp Web App to a bot.
///
/// Returns [Ok].
class SendWebAppData extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendWebAppData";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// Text of the keyboardButtonTypeWebApp button, which opened the Web App.
  late String button_text;

  /// The data.
  late String data;

  /// Sends data received from a keyboardButtonTypeWebApp Web App to a bot
  ///
  /// Returns [Ok]
  SendWebAppData(
      {required this.bot_user_id,
      required this.button_text,
      required this.data,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendWebAppData',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'button_text': button_text,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendWebAppData? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var button_text = _map['button_text']! as String;
    var data = _map['data']! as String;
    return SendWebAppData(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      button_text: button_text,
      data: data,
    );
  }
}

/// Informs TDLib that a Web App is being opened from the attachment menu, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp button..
///
/// Returns [WebAppInfo].
class OpenWebApp extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "openWebApp";

  /// Identifier of the chat in which the Web App is opened. The Web App can't be opened in secret chats.
  late int chat_id;

  /// Identifier of the bot, providing the Web App.
  late int bot_user_id;

  /// The URL from an inlineKeyboardButtonTypeWebApp button, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an empty string otherwise.
  late String url;

  /// Preferred Web App theme; pass null to use the default theme.
  ThemeParameters? theme;

  /// Short name of the application; 0-64 English letters, digits, and underscores.
  late String application_name;

  /// If not 0, a message thread identifier in which the message will be sent.
  late int message_thread_id;

  /// Identifier of the replied message or story for the message sent by the Web App; pass null if none.
  MessageReplyTo? reply_to;

  /// Informs TDLib that a Web App is being opened from the attachment menu, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp button.
  ///
  /// Returns [WebAppInfo]
  OpenWebApp(
      {required this.chat_id,
      required this.bot_user_id,
      required this.url,
      this.theme,
      required this.application_name,
      required this.message_thread_id,
      this.reply_to,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'openWebApp',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'bot_user_id': bot_user_id,
      'url': url,
      'theme': theme,
      'application_name': application_name,
      'message_thread_id': message_thread_id,
      'reply_to': reply_to
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OpenWebApp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var bot_user_id = _map['bot_user_id']! as int;
    var url = _map['url']! as String;
    var theme = ThemeParameters.fromMap(_map['theme']);
    var application_name = _map['application_name']! as String;
    var message_thread_id = _map['message_thread_id']! as int;
    var reply_to = MessageReplyTo.fromMap(_map['reply_to']);
    return OpenWebApp(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      bot_user_id: bot_user_id,
      url: url,
      theme: theme,
      application_name: application_name,
      message_thread_id: message_thread_id,
      reply_to: reply_to,
    );
  }
}

/// Informs TDLib that a previously opened Web App was closed.
///
/// Returns [Ok].
class CloseWebApp extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "closeWebApp";

  /// Identifier of Web App launch, received from openWebApp.
  /// ; string representation of int, use `int.parse`
  late int64 web_app_launch_id;

  /// Informs TDLib that a previously opened Web App was closed
  ///
  /// Returns [Ok]
  CloseWebApp({required this.web_app_launch_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'closeWebApp',
      if (extra != null) '@extra': extra,
      'web_app_launch_id': web_app_launch_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CloseWebApp? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var web_app_launch_id = _map['web_app_launch_id']! as int64;
    return CloseWebApp(
      extra: extra,
      clientId: clientId,
      web_app_launch_id: web_app_launch_id,
    );
  }
}

/// Sets the result of interaction with a Web App and sends corresponding message on behalf of the user to the chat from which the query originated; for bots only.
///
/// Returns [SentWebAppMessage].
class AnswerWebAppQuery extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "answerWebAppQuery";

  /// Identifier of the Web App query.
  late String web_app_query_id;

  /// The result of the query.
  late InputInlineQueryResult result;

  /// Sets the result of interaction with a Web App and sends corresponding message on behalf of the user to the chat from which the query originated; for bots only
  ///
  /// Returns [SentWebAppMessage]
  AnswerWebAppQuery(
      {required this.web_app_query_id,
      required this.result,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'answerWebAppQuery',
      if (extra != null) '@extra': extra,
      'web_app_query_id': web_app_query_id,
      'result': result
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AnswerWebAppQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var web_app_query_id = _map['web_app_query_id']! as String;
    var result = InputInlineQueryResult.fromMap(_map['result'])!;
    return AnswerWebAppQuery(
      extra: extra,
      clientId: clientId,
      web_app_query_id: web_app_query_id,
      result: result,
    );
  }
}

/// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires.
///
/// Returns [CallbackQueryAnswer].
class GetCallbackQueryAnswer extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCallbackQueryAnswer";

  /// Identifier of the chat with the message.
  late int chat_id;

  /// Identifier of the message from which the query originated.
  late int message_id;

  /// Query payload.
  late CallbackQueryPayload payload;

  /// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
  ///
  /// Returns [CallbackQueryAnswer]
  GetCallbackQueryAnswer(
      {required this.chat_id,
      required this.message_id,
      required this.payload,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getCallbackQueryAnswer',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'payload': payload
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCallbackQueryAnswer? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var payload = CallbackQueryPayload.fromMap(_map['payload'])!;
    return GetCallbackQueryAnswer(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      payload: payload,
    );
  }
}

/// Sets the result of a callback query; for bots only.
///
/// Returns [Ok].
class AnswerCallbackQuery extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "answerCallbackQuery";

  /// Identifier of the callback query.
  /// ; string representation of int, use `int.parse`
  late int64 callback_query_id;

  /// Text of the answer.
  late String text;

  /// Pass true to show an alert to the user instead of a toast notification.
  late bool show_alert;

  /// URL to be opened.
  late String url;

  /// Time during which the result of the query can be cached, in seconds.
  late int cache_time;

  /// Sets the result of a callback query; for bots only
  ///
  /// Returns [Ok]
  AnswerCallbackQuery(
      {required this.callback_query_id,
      required this.text,
      required this.show_alert,
      required this.url,
      required this.cache_time,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'answerCallbackQuery',
      if (extra != null) '@extra': extra,
      'callback_query_id': callback_query_id,
      'text': text,
      'show_alert': show_alert,
      'url': url,
      'cache_time': cache_time
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AnswerCallbackQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var callback_query_id = _map['callback_query_id']! as int64;
    var text = _map['text']! as String;
    var show_alert = _map['show_alert']! as bool;
    var url = _map['url']! as String;
    var cache_time = _map['cache_time']! as int;
    return AnswerCallbackQuery(
      extra: extra,
      clientId: clientId,
      callback_query_id: callback_query_id,
      text: text,
      show_alert: show_alert,
      url: url,
      cache_time: cache_time,
    );
  }
}

/// Sets the result of a shipping query; for bots only.
///
/// Returns [Ok].
class AnswerShippingQuery extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "answerShippingQuery";

  /// Identifier of the shipping query.
  /// ; string representation of int, use `int.parse`
  late int64 shipping_query_id;

  /// Available shipping options.
  late List<ShippingOption> shipping_options;

  /// An error message, empty on success.
  late String error_message;

  /// Sets the result of a shipping query; for bots only
  ///
  /// Returns [Ok]
  AnswerShippingQuery(
      {required this.shipping_query_id,
      required this.shipping_options,
      required this.error_message,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'answerShippingQuery',
      if (extra != null) '@extra': extra,
      'shipping_query_id': shipping_query_id,
      'shipping_options': shipping_options,
      'error_message': error_message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AnswerShippingQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var shipping_query_id = _map['shipping_query_id']! as int64;
    var shipping_options = List<ShippingOption>.from(
      (_map["shipping_options"] ?? []).map(
        (e) => ShippingOption.fromMap(e),
      ),
    );
    var error_message = _map['error_message']! as String;
    return AnswerShippingQuery(
      extra: extra,
      clientId: clientId,
      shipping_query_id: shipping_query_id,
      shipping_options: shipping_options,
      error_message: error_message,
    );
  }
}

/// Sets the result of a pre-checkout query; for bots only.
///
/// Returns [Ok].
class AnswerPreCheckoutQuery extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "answerPreCheckoutQuery";

  /// Identifier of the pre-checkout query.
  /// ; string representation of int, use `int.parse`
  late int64 pre_checkout_query_id;

  /// An error message, empty on success.
  late String error_message;

  /// Sets the result of a pre-checkout query; for bots only
  ///
  /// Returns [Ok]
  AnswerPreCheckoutQuery(
      {required this.pre_checkout_query_id,
      required this.error_message,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'answerPreCheckoutQuery',
      if (extra != null) '@extra': extra,
      'pre_checkout_query_id': pre_checkout_query_id,
      'error_message': error_message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AnswerPreCheckoutQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var pre_checkout_query_id = _map['pre_checkout_query_id']! as int64;
    var error_message = _map['error_message']! as String;
    return AnswerPreCheckoutQuery(
      extra: extra,
      clientId: clientId,
      pre_checkout_query_id: pre_checkout_query_id,
      error_message: error_message,
    );
  }
}

/// Updates the game score of the specified user in the game; for bots only.
///
/// Returns [Message].
class SetGameScore extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setGameScore";

  /// The chat to which the message with the game belongs.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// Pass true to edit the game message to include the current scoreboard.
  late bool edit_message;

  /// User identifier.
  late int user_id;

  /// The new score.
  late int score;

  /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table.
  late bool force;

  /// Updates the game score of the specified user in the game; for bots only
  ///
  /// Returns [Message]
  SetGameScore(
      {required this.chat_id,
      required this.message_id,
      required this.edit_message,
      required this.user_id,
      required this.score,
      required this.force,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setGameScore',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'edit_message': edit_message,
      'user_id': user_id,
      'score': score,
      'force': force
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetGameScore? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var edit_message = _map['edit_message']! as bool;
    var user_id = _map['user_id']! as int;
    var score = _map['score']! as int;
    var force = _map['force']! as bool;
    return SetGameScore(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      edit_message: edit_message,
      user_id: user_id,
      score: score,
      force: force,
    );
  }
}

/// Updates the game score of the specified user in a game; for bots only.
///
/// Returns [Ok].
class SetInlineGameScore extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setInlineGameScore";

  /// Inline message identifier.
  late String inline_message_id;

  /// Pass true to edit the game message to include the current scoreboard.
  late bool edit_message;

  /// User identifier.
  late int user_id;

  /// The new score.
  late int score;

  /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table.
  late bool force;

  /// Updates the game score of the specified user in a game; for bots only
  ///
  /// Returns [Ok]
  SetInlineGameScore(
      {required this.inline_message_id,
      required this.edit_message,
      required this.user_id,
      required this.score,
      required this.force,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setInlineGameScore',
      if (extra != null) '@extra': extra,
      'inline_message_id': inline_message_id,
      'edit_message': edit_message,
      'user_id': user_id,
      'score': score,
      'force': force
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetInlineGameScore? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_message_id = _map['inline_message_id']! as String;
    var edit_message = _map['edit_message']! as bool;
    var user_id = _map['user_id']! as int;
    var score = _map['score']! as int;
    var force = _map['force']! as bool;
    return SetInlineGameScore(
      extra: extra,
      clientId: clientId,
      inline_message_id: inline_message_id,
      edit_message: edit_message,
      user_id: user_id,
      score: score,
      force: force,
    );
  }
}

/// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only.
///
/// Returns [GameHighScores].
class GetGameHighScores extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getGameHighScores";

  /// The chat that contains the message with the game.
  late int chat_id;

  /// Identifier of the message.
  late int message_id;

  /// User identifier.
  late int user_id;

  /// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
  ///
  /// Returns [GameHighScores]
  GetGameHighScores(
      {required this.chat_id,
      required this.message_id,
      required this.user_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getGameHighScores',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetGameHighScores? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var user_id = _map['user_id']! as int;
    return GetGameHighScores(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      user_id: user_id,
    );
  }
}

/// Returns game high scores and some part of the high score table in the range of the specified user; for bots only.
///
/// Returns [GameHighScores].
class GetInlineGameHighScores extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getInlineGameHighScores";

  /// Inline message identifier.
  late String inline_message_id;

  /// User identifier.
  late int user_id;

  /// Returns game high scores and some part of the high score table in the range of the specified user; for bots only
  ///
  /// Returns [GameHighScores]
  GetInlineGameHighScores(
      {required this.inline_message_id,
      required this.user_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getInlineGameHighScores',
      if (extra != null) '@extra': extra,
      'inline_message_id': inline_message_id,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetInlineGameHighScores? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inline_message_id = _map['inline_message_id']! as String;
    var user_id = _map['user_id']! as int;
    return GetInlineGameHighScores(
      extra: extra,
      clientId: clientId,
      inline_message_id: inline_message_id,
      user_id: user_id,
    );
  }
}

/// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a replyMarkupForceReply reply markup has been used. An updateChatReplyMarkup update will be sent if the reply markup is changed.
///
/// Returns [Ok].
class DeleteChatReplyMarkup extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteChatReplyMarkup";

  /// Chat identifier.
  late int chat_id;

  /// The message identifier of the used keyboard.
  late int message_id;

  /// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a replyMarkupForceReply reply markup has been used. An updateChatReplyMarkup update will be sent if the reply markup is changed
  ///
  /// Returns [Ok]
  DeleteChatReplyMarkup(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteChatReplyMarkup',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteChatReplyMarkup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return DeleteChatReplyMarkup(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Sends a notification about user activity in a chat.
///
/// Returns [Ok].
class SendChatAction extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendChatAction";

  /// Chat identifier.
  late int chat_id;

  /// If not 0, a message thread identifier in which the action was performed.
  late int message_thread_id;

  /// The action description; pass null to cancel the currently active action.
  ChatAction? action;

  /// Sends a notification about user activity in a chat
  ///
  /// Returns [Ok]
  SendChatAction(
      {required this.chat_id,
      required this.message_thread_id,
      this.action,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendChatAction',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'action': action
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendChatAction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var action = ChatAction.fromMap(_map['action']);
    return SendChatAction(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      action: action,
    );
  }
}

/// Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats).
///
/// Returns [Ok].
class OpenChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "openChat";

  /// Chat identifier.
  late int chat_id;

  /// Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
  ///
  /// Returns [Ok]
  OpenChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'openChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OpenChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return OpenChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed.
///
/// Returns [Ok].
class CloseChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "closeChat";

  /// Chat identifier.
  late int chat_id;

  /// Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
  ///
  /// Returns [Ok]
  CloseChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'closeChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CloseChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return CloseChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Informs TDLib that messages are being viewed by the user. Sponsored messages must be marked as viewed only when the entire text of the message is shown on the screen (excluding the button)..
///
/// Returns [Ok].
class ViewMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "viewMessages";

  /// Chat identifier.
  late int chat_id;

  /// The identifiers of the messages being viewed.
  late List<int> message_ids;

  /// Source of the message view; pass null to guess the source based on chat open state.
  MessageSource? source;

  /// Pass true to mark as read the specified messages even the chat is closed.
  late bool force_read;

  /// Informs TDLib that messages are being viewed by the user. Sponsored messages must be marked as viewed only when the entire text of the message is shown on the screen (excluding the button).
  ///
  /// Returns [Ok]
  ViewMessages(
      {required this.chat_id,
      required this.message_ids,
      this.source,
      required this.force_read,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'viewMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_ids': message_ids,
      'source': source,
      'force_read': force_read
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ViewMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_ids = List<int>.from(
      (_map["message_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var source = MessageSource.fromMap(_map['source']);
    var force_read = _map['force_read']! as bool;
    return ViewMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_ids: message_ids,
      source: source,
      force_read: force_read,
    );
  }
}

/// Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message)..
///
/// Returns [Ok].
class OpenMessageContent extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "openMessageContent";

  /// Chat identifier of the message.
  late int chat_id;

  /// Identifier of the message with the opened content.
  late int message_id;

  /// Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message).
  ///
  /// Returns [Ok]
  OpenMessageContent(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'openMessageContent',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OpenMessageContent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return OpenMessageContent(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played.
///
/// Returns [Sticker].
class ClickAnimatedEmojiMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clickAnimatedEmojiMessage";

  /// Chat identifier of the message.
  late int chat_id;

  /// Identifier of the clicked message.
  late int message_id;

  /// Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played
  ///
  /// Returns [Sticker]
  ClickAnimatedEmojiMessage(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clickAnimatedEmojiMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClickAnimatedEmojiMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return ClickAnimatedEmojiMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Returns an HTTPS or a tg: link with the given type. Can be called before authorization.
///
/// Returns [HttpUrl].
class GetInternalLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getInternalLink";

  /// Expected type of the link.
  late InternalLinkType type;

  /// Pass true to create an HTTPS link (only available for some link types); pass false to create a tg: link.
  late bool is_http;

  /// Returns an HTTPS or a tg: link with the given type. Can be called before authorization
  ///
  /// Returns [HttpUrl]
  GetInternalLink(
      {required this.type, required this.is_http, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getInternalLink',
      if (extra != null) '@extra': extra,
      'type': type,
      'is_http': is_http
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetInternalLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = InternalLinkType.fromMap(_map['type'])!;
    var is_http = _map['is_http']! as bool;
    return GetInternalLink(
      extra: extra,
      clientId: clientId,
      type: type,
      is_http: is_http,
    );
  }
}

/// Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization.
///
/// Returns [InternalLinkType].
class GetInternalLinkType extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getInternalLinkType";

  /// The link.
  late String link;

  /// Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization
  ///
  /// Returns [InternalLinkType]
  GetInternalLinkType({required this.link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getInternalLinkType',
      if (extra != null) '@extra': extra,
      'link': link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetInternalLinkType? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = _map['link']! as String;
    return GetInternalLinkType(
      extra: extra,
      clientId: clientId,
      link: link,
    );
  }
}

/// Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats.
///
/// Returns [LoginUrlInfo].
class GetExternalLinkInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getExternalLinkInfo";

  /// The link.
  late String link;

  /// Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats
  ///
  /// Returns [LoginUrlInfo]
  GetExternalLinkInfo({required this.link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getExternalLinkInfo',
      if (extra != null) '@extra': extra,
      'link': link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetExternalLinkInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = _map['link']! as String;
    return GetExternalLinkInfo(
      extra: extra,
      clientId: clientId,
      link: link,
    );
  }
}

/// Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed.
///
/// Returns [HttpUrl].
class GetExternalLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getExternalLink";

  /// The HTTP link.
  late String link;

  /// Pass true if the current user allowed the bot, returned in getExternalLinkInfo, to send them messages.
  late bool allow_write_access;

  /// Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed
  ///
  /// Returns [HttpUrl]
  GetExternalLink(
      {required this.link,
      required this.allow_write_access,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getExternalLink',
      if (extra != null) '@extra': extra,
      'link': link,
      'allow_write_access': allow_write_access
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetExternalLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = _map['link']! as String;
    var allow_write_access = _map['allow_write_access']! as bool;
    return GetExternalLink(
      extra: extra,
      clientId: clientId,
      link: link,
      allow_write_access: allow_write_access,
    );
  }
}

/// Marks all mentions in a chat as read.
///
/// Returns [Ok].
class ReadAllChatMentions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "readAllChatMentions";

  /// Chat identifier.
  late int chat_id;

  /// Marks all mentions in a chat as read
  ///
  /// Returns [Ok]
  ReadAllChatMentions({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'readAllChatMentions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReadAllChatMentions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return ReadAllChatMentions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Marks all mentions in a forum topic as read.
///
/// Returns [Ok].
class ReadAllMessageThreadMentions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "readAllMessageThreadMentions";

  /// Chat identifier.
  late int chat_id;

  /// Message thread identifier in which mentions are marked as read.
  late int message_thread_id;

  /// Marks all mentions in a forum topic as read
  ///
  /// Returns [Ok]
  ReadAllMessageThreadMentions(
      {required this.chat_id,
      required this.message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'readAllMessageThreadMentions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReadAllMessageThreadMentions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    return ReadAllMessageThreadMentions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
    );
  }
}

/// Marks all reactions in a chat or a forum topic as read.
///
/// Returns [Ok].
class ReadAllChatReactions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "readAllChatReactions";

  /// Chat identifier.
  late int chat_id;

  /// Marks all reactions in a chat or a forum topic as read
  ///
  /// Returns [Ok]
  ReadAllChatReactions({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'readAllChatReactions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReadAllChatReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return ReadAllChatReactions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Marks all reactions in a forum topic as read.
///
/// Returns [Ok].
class ReadAllMessageThreadReactions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "readAllMessageThreadReactions";

  /// Chat identifier.
  late int chat_id;

  /// Message thread identifier in which reactions are marked as read.
  late int message_thread_id;

  /// Marks all reactions in a forum topic as read
  ///
  /// Returns [Ok]
  ReadAllMessageThreadReactions(
      {required this.chat_id,
      required this.message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'readAllMessageThreadReactions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReadAllMessageThreadReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    return ReadAllMessageThreadReactions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
    );
  }
}

/// Returns an existing chat corresponding to a given user.
///
/// Returns [Chat].
class CreatePrivateChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createPrivateChat";

  /// User identifier.
  late int user_id;

  /// Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect.
  late bool force;

  /// Returns an existing chat corresponding to a given user
  ///
  /// Returns [Chat]
  CreatePrivateChat(
      {required this.user_id, required this.force, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createPrivateChat',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'force': force
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreatePrivateChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var force = _map['force']! as bool;
    return CreatePrivateChat(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      force: force,
    );
  }
}

/// Returns an existing chat corresponding to a known basic group.
///
/// Returns [Chat].
class CreateBasicGroupChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createBasicGroupChat";

  /// Basic group identifier.
  late int basic_group_id;

  /// Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect.
  late bool force;

  /// Returns an existing chat corresponding to a known basic group
  ///
  /// Returns [Chat]
  CreateBasicGroupChat(
      {required this.basic_group_id,
      required this.force,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createBasicGroupChat',
      if (extra != null) '@extra': extra,
      'basic_group_id': basic_group_id,
      'force': force
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateBasicGroupChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var basic_group_id = _map['basic_group_id']! as int;
    var force = _map['force']! as bool;
    return CreateBasicGroupChat(
      extra: extra,
      clientId: clientId,
      basic_group_id: basic_group_id,
      force: force,
    );
  }
}

/// Returns an existing chat corresponding to a known supergroup or channel.
///
/// Returns [Chat].
class CreateSupergroupChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createSupergroupChat";

  /// Supergroup or channel identifier.
  late int supergroup_id;

  /// Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect.
  late bool force;

  /// Returns an existing chat corresponding to a known supergroup or channel
  ///
  /// Returns [Chat]
  CreateSupergroupChat(
      {required this.supergroup_id,
      required this.force,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createSupergroupChat',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'force': force
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateSupergroupChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var force = _map['force']! as bool;
    return CreateSupergroupChat(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      force: force,
    );
  }
}

/// Returns an existing chat corresponding to a known secret chat.
///
/// Returns [Chat].
class CreateSecretChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createSecretChat";

  /// Secret chat identifier.
  late int secret_chat_id;

  /// Returns an existing chat corresponding to a known secret chat
  ///
  /// Returns [Chat]
  CreateSecretChat({required this.secret_chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createSecretChat',
      if (extra != null) '@extra': extra,
      'secret_chat_id': secret_chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateSecretChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var secret_chat_id = _map['secret_chat_id']! as int;
    return CreateSecretChat(
      extra: extra,
      clientId: clientId,
      secret_chat_id: secret_chat_id,
    );
  }
}

/// Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat.
///
/// Returns [Chat].
class CreateNewBasicGroupChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createNewBasicGroupChat";

  /// Identifiers of users to be added to the basic group; may be empty to create a basic group without other members.
  late List<int> user_ids;

  /// Title of the new basic group; 1-128 characters.
  late String title;

  /// Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically.
  late int message_auto_delete_time;

  /// Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
  ///
  /// Returns [Chat]
  CreateNewBasicGroupChat(
      {required this.user_ids,
      required this.title,
      required this.message_auto_delete_time,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createNewBasicGroupChat',
      if (extra != null) '@extra': extra,
      'user_ids': user_ids,
      'title': title,
      'message_auto_delete_time': message_auto_delete_time
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateNewBasicGroupChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var title = _map['title']! as String;
    var message_auto_delete_time = _map['message_auto_delete_time']! as int;
    return CreateNewBasicGroupChat(
      extra: extra,
      clientId: clientId,
      user_ids: user_ids,
      title: title,
      message_auto_delete_time: message_auto_delete_time,
    );
  }
}

/// Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat.
///
/// Returns [Chat].
class CreateNewSupergroupChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createNewSupergroupChat";

  /// Title of the new chat; 1-128 characters.
  late String title;

  /// Pass true to create a forum supergroup chat.
  late bool is_forum;

  /// Pass true to create a channel chat; ignored if a forum is created.
  late bool is_channel;

  /// Chat description; 0-255 characters.
  late String description;

  /// Chat location if a location-based supergroup is being created; pass null to create an ordinary supergroup chat.
  ChatLocation? location;

  /// Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically.
  late int message_auto_delete_time;

  /// Pass true to create a supergroup for importing messages using importMessages.
  late bool for_import;

  /// Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
  ///
  /// Returns [Chat]
  CreateNewSupergroupChat(
      {required this.title,
      required this.is_forum,
      required this.is_channel,
      required this.description,
      this.location,
      required this.message_auto_delete_time,
      required this.for_import,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createNewSupergroupChat',
      if (extra != null) '@extra': extra,
      'title': title,
      'is_forum': is_forum,
      'is_channel': is_channel,
      'description': description,
      'location': location,
      'message_auto_delete_time': message_auto_delete_time,
      'for_import': for_import
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateNewSupergroupChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    var is_forum = _map['is_forum']! as bool;
    var is_channel = _map['is_channel']! as bool;
    var description = _map['description']! as String;
    var location = ChatLocation.fromMap(_map['location']);
    var message_auto_delete_time = _map['message_auto_delete_time']! as int;
    var for_import = _map['for_import']! as bool;
    return CreateNewSupergroupChat(
      extra: extra,
      clientId: clientId,
      title: title,
      is_forum: is_forum,
      is_channel: is_channel,
      description: description,
      location: location,
      message_auto_delete_time: message_auto_delete_time,
      for_import: for_import,
    );
  }
}

/// Creates a new secret chat. Returns the newly created chat.
///
/// Returns [Chat].
class CreateNewSecretChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createNewSecretChat";

  /// Identifier of the target user.
  late int user_id;

  /// Creates a new secret chat. Returns the newly created chat
  ///
  /// Returns [Chat]
  CreateNewSecretChat({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createNewSecretChat',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateNewSecretChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return CreateNewSecretChat(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group.
///
/// Returns [Chat].
class UpgradeBasicGroupChatToSupergroupChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "upgradeBasicGroupChatToSupergroupChat";

  /// Identifier of the chat to upgrade.
  late int chat_id;

  /// Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
  ///
  /// Returns [Chat]
  UpgradeBasicGroupChatToSupergroupChat(
      {required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'upgradeBasicGroupChatToSupergroupChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UpgradeBasicGroupChatToSupergroupChat? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return UpgradeBasicGroupChatToSupergroupChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Returns chat lists to which the chat can be added. This is an offline request.
///
/// Returns [ChatLists].
class GetChatListsToAddChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatListsToAddChat";

  /// Chat identifier.
  late int chat_id;

  /// Returns chat lists to which the chat can be added. This is an offline request
  ///
  /// Returns [ChatLists]
  GetChatListsToAddChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatListsToAddChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatListsToAddChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatListsToAddChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed.
///
/// Returns [Ok].
class AddChatToList extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addChatToList";

  /// Chat identifier.
  late int chat_id;

  /// The chat list. Use getChatListsToAddChat to get suitable chat lists.
  late ChatList chat_list;

  /// Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
  ///
  /// Returns [Ok]
  AddChatToList(
      {required this.chat_id,
      required this.chat_list,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addChatToList',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'chat_list': chat_list
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddChatToList? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var chat_list = ChatList.fromMap(_map['chat_list'])!;
    return AddChatToList(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      chat_list: chat_list,
    );
  }
}

/// Returns information about a chat folder by its identifier.
///
/// Returns [ChatFolder].
class GetChatFolder extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatFolder";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Returns information about a chat folder by its identifier
  ///
  /// Returns [ChatFolder]
  GetChatFolder({required this.chat_folder_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatFolder',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatFolder? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    return GetChatFolder(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
    );
  }
}

/// Creates new chat folder. Returns information about the created chat folder. There can be up to getOption("chat_folder_count_max") chat folders, but the limit can be increased with Telegram Premium.
///
/// Returns [ChatFolderInfo].
class CreateChatFolder extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createChatFolder";

  /// The new chat folder.
  late ChatFolder folder;

  /// Creates new chat folder. Returns information about the created chat folder. There can be up to getOption("chat_folder_count_max") chat folders, but the limit can be increased with Telegram Premium
  ///
  /// Returns [ChatFolderInfo]
  CreateChatFolder({required this.folder, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createChatFolder',
      if (extra != null) '@extra': extra,
      'folder': folder
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateChatFolder? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var folder = ChatFolder.fromMap(_map['folder'])!;
    return CreateChatFolder(
      extra: extra,
      clientId: clientId,
      folder: folder,
    );
  }
}

/// Edits existing chat folder. Returns information about the edited chat folder.
///
/// Returns [ChatFolderInfo].
class EditChatFolder extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editChatFolder";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// The edited chat folder.
  late ChatFolder folder;

  /// Edits existing chat folder. Returns information about the edited chat folder
  ///
  /// Returns [ChatFolderInfo]
  EditChatFolder(
      {required this.chat_folder_id,
      required this.folder,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editChatFolder',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id,
      'folder': folder
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditChatFolder? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    var folder = ChatFolder.fromMap(_map['folder'])!;
    return EditChatFolder(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
      folder: folder,
    );
  }
}

/// Deletes existing chat folder.
///
/// Returns [Ok].
class DeleteChatFolder extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteChatFolder";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Identifiers of the chats to leave. The chats must be pinned or always included in the folder.
  late List<int> leave_chat_ids;

  /// Deletes existing chat folder
  ///
  /// Returns [Ok]
  DeleteChatFolder(
      {required this.chat_folder_id,
      required this.leave_chat_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteChatFolder',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id,
      'leave_chat_ids': leave_chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteChatFolder? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    var leave_chat_ids = List<int>.from(
      (_map["leave_chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return DeleteChatFolder(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
      leave_chat_ids: leave_chat_ids,
    );
  }
}

/// Returns identifiers of pinned or always included chats from a chat folder, which are suggested to be left when the chat folder is deleted.
///
/// Returns [Chats].
class GetChatFolderChatsToLeave extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatFolderChatsToLeave";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Returns identifiers of pinned or always included chats from a chat folder, which are suggested to be left when the chat folder is deleted
  ///
  /// Returns [Chats]
  GetChatFolderChatsToLeave(
      {required this.chat_folder_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatFolderChatsToLeave',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatFolderChatsToLeave? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    return GetChatFolderChatsToLeave(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
    );
  }
}

/// Returns approximate number of chats in a being created chat folder. Main and archive chat lists must be fully preloaded for this function to work correctly.
///
/// Returns [Count].
class GetChatFolderChatCount extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatFolderChatCount";

  /// The new chat folder.
  late ChatFolder folder;

  /// Returns approximate number of chats in a being created chat folder. Main and archive chat lists must be fully preloaded for this function to work correctly
  ///
  /// Returns [Count]
  GetChatFolderChatCount({required this.folder, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatFolderChatCount',
      if (extra != null) '@extra': extra,
      'folder': folder
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatFolderChatCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var folder = ChatFolder.fromMap(_map['folder'])!;
    return GetChatFolderChatCount(
      extra: extra,
      clientId: clientId,
      folder: folder,
    );
  }
}

/// Changes the order of chat folders.
///
/// Returns [Ok].
class ReorderChatFolders extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reorderChatFolders";

  /// Identifiers of chat folders in the new correct order.
  late List<int> chat_folder_ids;

  /// Position of the main chat list among chat folders, 0-based. Can be non-zero only for Premium users.
  late int main_chat_list_position;

  /// Changes the order of chat folders
  ///
  /// Returns [Ok]
  ReorderChatFolders(
      {required this.chat_folder_ids,
      required this.main_chat_list_position,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reorderChatFolders',
      if (extra != null) '@extra': extra,
      'chat_folder_ids': chat_folder_ids,
      'main_chat_list_position': main_chat_list_position
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReorderChatFolders? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_ids = List<int>.from(
      (_map["chat_folder_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var main_chat_list_position = _map['main_chat_list_position']! as int;
    return ReorderChatFolders(
      extra: extra,
      clientId: clientId,
      chat_folder_ids: chat_folder_ids,
      main_chat_list_position: main_chat_list_position,
    );
  }
}

/// Returns recommended chat folders for the current user.
///
/// Returns [RecommendedChatFolders].
class GetRecommendedChatFolders extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getRecommendedChatFolders";

  /// Returns recommended chat folders for the current user
  ///
  /// Returns [RecommendedChatFolders]
  GetRecommendedChatFolders({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getRecommendedChatFolders',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetRecommendedChatFolders? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetRecommendedChatFolders(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns default icon name for a folder. Can be called synchronously.
///
/// Returns [ChatFolderIcon].
class GetChatFolderDefaultIconName extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatFolderDefaultIconName";

  /// Chat folder.
  late ChatFolder folder;

  /// Returns default icon name for a folder. Can be called synchronously
  ///
  /// Returns [ChatFolderIcon]
  GetChatFolderDefaultIconName(
      {required this.folder, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatFolderDefaultIconName',
      if (extra != null) '@extra': extra,
      'folder': folder
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatFolderDefaultIconName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var folder = ChatFolder.fromMap(_map['folder'])!;
    return GetChatFolderDefaultIconName(
      extra: extra,
      clientId: clientId,
      folder: folder,
    );
  }
}

/// Returns identifiers of chats from a chat folder, suitable for adding to a chat folder invite link.
///
/// Returns [Chats].
class GetChatsForChatFolderInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatsForChatFolderInviteLink";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Returns identifiers of chats from a chat folder, suitable for adding to a chat folder invite link
  ///
  /// Returns [Chats]
  GetChatsForChatFolderInviteLink(
      {required this.chat_folder_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatsForChatFolderInviteLink',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatsForChatFolderInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    return GetChatsForChatFolderInviteLink(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
    );
  }
}

/// Creates a new invite link for a chat folder. A link can be created for a chat folder if it has only pinned and included chats.
///
/// Returns [ChatFolderInviteLink].
class CreateChatFolderInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createChatFolderInviteLink";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Name of the link; 0-32 characters.
  late String name;

  /// Identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink to get suitable chats. Basic groups will be automatically converted to supergroups before link creation.
  late List<int> chat_ids;

  /// Creates a new invite link for a chat folder. A link can be created for a chat folder if it has only pinned and included chats
  ///
  /// Returns [ChatFolderInviteLink]
  CreateChatFolderInviteLink(
      {required this.chat_folder_id,
      required this.name,
      required this.chat_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createChatFolderInviteLink',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id,
      'name': name,
      'chat_ids': chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateChatFolderInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    var name = _map['name']! as String;
    var chat_ids = List<int>.from(
      (_map["chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return CreateChatFolderInviteLink(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
      name: name,
      chat_ids: chat_ids,
    );
  }
}

/// Returns invite links created by the current user for a shareable chat folder.
///
/// Returns [ChatFolderInviteLinks].
class GetChatFolderInviteLinks extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatFolderInviteLinks";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Returns invite links created by the current user for a shareable chat folder
  ///
  /// Returns [ChatFolderInviteLinks]
  GetChatFolderInviteLinks(
      {required this.chat_folder_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatFolderInviteLinks',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatFolderInviteLinks? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    return GetChatFolderInviteLinks(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
    );
  }
}

/// Edits an invite link for a chat folder.
///
/// Returns [ChatFolderInviteLink].
class EditChatFolderInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editChatFolderInviteLink";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Invite link to be edited.
  late String invite_link;

  /// New name of the link; 0-32 characters.
  late String name;

  /// New identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink to get suitable chats. Basic groups will be automatically converted to supergroups before link editing.
  late List<int> chat_ids;

  /// Edits an invite link for a chat folder
  ///
  /// Returns [ChatFolderInviteLink]
  EditChatFolderInviteLink(
      {required this.chat_folder_id,
      required this.invite_link,
      required this.name,
      required this.chat_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editChatFolderInviteLink',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id,
      'invite_link': invite_link,
      'name': name,
      'chat_ids': chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditChatFolderInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    var invite_link = _map['invite_link']! as String;
    var name = _map['name']! as String;
    var chat_ids = List<int>.from(
      (_map["chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return EditChatFolderInviteLink(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
      invite_link: invite_link,
      name: name,
      chat_ids: chat_ids,
    );
  }
}

/// Deletes an invite link for a chat folder.
///
/// Returns [Ok].
class DeleteChatFolderInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteChatFolderInviteLink";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Invite link to be deleted.
  late String invite_link;

  /// Deletes an invite link for a chat folder
  ///
  /// Returns [Ok]
  DeleteChatFolderInviteLink(
      {required this.chat_folder_id,
      required this.invite_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteChatFolderInviteLink',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteChatFolderInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    var invite_link = _map['invite_link']! as String;
    return DeleteChatFolderInviteLink(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
      invite_link: invite_link,
    );
  }
}

/// Checks the validity of an invite link for a chat folder and returns information about the corresponding chat folder.
///
/// Returns [ChatFolderInviteLinkInfo].
class CheckChatFolderInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkChatFolderInviteLink";

  /// Invite link to be checked.
  late String invite_link;

  /// Checks the validity of an invite link for a chat folder and returns information about the corresponding chat folder
  ///
  /// Returns [ChatFolderInviteLinkInfo]
  CheckChatFolderInviteLink(
      {required this.invite_link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChatFolderInviteLink',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChatFolderInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = _map['invite_link']! as String;
    return CheckChatFolderInviteLink(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
    );
  }
}

/// Adds a chat folder by an invite link.
///
/// Returns [Ok].
class AddChatFolderByInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addChatFolderByInviteLink";

  /// Invite link for the chat folder.
  late String invite_link;

  /// Identifiers of the chats added to the chat folder. The chats are automatically joined if they aren't joined yet.
  late List<int> chat_ids;

  /// Adds a chat folder by an invite link
  ///
  /// Returns [Ok]
  AddChatFolderByInviteLink(
      {required this.invite_link,
      required this.chat_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addChatFolderByInviteLink',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link,
      'chat_ids': chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddChatFolderByInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = _map['invite_link']! as String;
    var chat_ids = List<int>.from(
      (_map["chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return AddChatFolderByInviteLink(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
      chat_ids: chat_ids,
    );
  }
}

/// Returns new chats added to a shareable chat folder by its owner. The method must be called at most once in getOption("chat_folder_new_chats_update_period") for the given chat folder.
///
/// Returns [Chats].
class GetChatFolderNewChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatFolderNewChats";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Returns new chats added to a shareable chat folder by its owner. The method must be called at most once in getOption("chat_folder_new_chats_update_period") for the given chat folder
  ///
  /// Returns [Chats]
  GetChatFolderNewChats(
      {required this.chat_folder_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatFolderNewChats',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatFolderNewChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    return GetChatFolderNewChats(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
    );
  }
}

/// Process new chats added to a shareable chat folder by its owner.
///
/// Returns [Ok].
class ProcessChatFolderNewChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "processChatFolderNewChats";

  /// Chat folder identifier.
  late int chat_folder_id;

  /// Identifiers of the new chats, which are added to the chat folder. The chats are automatically joined if they aren't joined yet.
  late List<int> added_chat_ids;

  /// Process new chats added to a shareable chat folder by its owner
  ///
  /// Returns [Ok]
  ProcessChatFolderNewChats(
      {required this.chat_folder_id,
      required this.added_chat_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'processChatFolderNewChats',
      if (extra != null) '@extra': extra,
      'chat_folder_id': chat_folder_id,
      'added_chat_ids': added_chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ProcessChatFolderNewChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_folder_id = _map['chat_folder_id']! as int;
    var added_chat_ids = List<int>.from(
      (_map["added_chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return ProcessChatFolderNewChats(
      extra: extra,
      clientId: clientId,
      chat_folder_id: chat_folder_id,
      added_chat_ids: added_chat_ids,
    );
  }
}

/// Returns settings for automatic moving of chats to and from the Archive chat lists.
///
/// Returns [ArchiveChatListSettings].
class GetArchiveChatListSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getArchiveChatListSettings";

  /// Returns settings for automatic moving of chats to and from the Archive chat lists
  ///
  /// Returns [ArchiveChatListSettings]
  GetArchiveChatListSettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getArchiveChatListSettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetArchiveChatListSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetArchiveChatListSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Changes settings for automatic moving of chats to and from the Archive chat lists.
///
/// Returns [Ok].
class SetArchiveChatListSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setArchiveChatListSettings";

  /// New settings.
  late ArchiveChatListSettings settings;

  /// Changes settings for automatic moving of chats to and from the Archive chat lists
  ///
  /// Returns [Ok]
  SetArchiveChatListSettings(
      {required this.settings, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setArchiveChatListSettings',
      if (extra != null) '@extra': extra,
      'settings': settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetArchiveChatListSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var settings = ArchiveChatListSettings.fromMap(_map['settings'])!;
    return SetArchiveChatListSettings(
      extra: extra,
      clientId: clientId,
      settings: settings,
    );
  }
}

/// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right.
///
/// Returns [Ok].
class SetChatTitle extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatTitle";

  /// Chat identifier.
  late int chat_id;

  /// New title of the chat; 1-128 characters.
  late String title;

  /// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
  ///
  /// Returns [Ok]
  SetChatTitle(
      {required this.chat_id, required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatTitle',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatTitle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var title = _map['title']! as String;
    return SetChatTitle(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      title: title,
    );
  }
}

/// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right.
///
/// Returns [Ok].
class SetChatPhoto extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatPhoto";

  /// Chat identifier.
  late int chat_id;

  /// New chat photo; pass null to delete the chat photo.
  InputChatPhoto? photo;

  /// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
  ///
  /// Returns [Ok]
  SetChatPhoto({required this.chat_id, this.photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatPhoto',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'photo': photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var photo = InputChatPhoto.fromMap(_map['photo']);
    return SetChatPhoto(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      photo: photo,
    );
  }
}

/// Changes the message auto-delete or self-destruct (for secret chats) time in a chat. Requires change_info administrator right in basic groups, supergroups and channels.
///
/// Returns [Ok].
class SetChatMessageAutoDeleteTime extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatMessageAutoDeleteTime";

  /// Chat identifier.
  late int chat_id;

  /// New time value, in seconds; unless the chat is secret, it must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically.
  late int message_auto_delete_time;

  /// Changes the message auto-delete or self-destruct (for secret chats) time in a chat. Requires change_info administrator right in basic groups, supergroups and channels
  ///
  /// Returns [Ok]
  SetChatMessageAutoDeleteTime(
      {required this.chat_id,
      required this.message_auto_delete_time,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatMessageAutoDeleteTime',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_auto_delete_time': message_auto_delete_time
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatMessageAutoDeleteTime? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_auto_delete_time = _map['message_auto_delete_time']! as int;
    return SetChatMessageAutoDeleteTime(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_auto_delete_time: message_auto_delete_time,
    );
  }
}

/// Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right.
///
/// Returns [Ok].
class SetChatPermissions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatPermissions";

  /// Chat identifier.
  late int chat_id;

  /// New non-administrator members permissions in the chat.
  late ChatPermissions permissions;

  /// Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
  ///
  /// Returns [Ok]
  SetChatPermissions(
      {required this.chat_id,
      required this.permissions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatPermissions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'permissions': permissions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatPermissions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var permissions = ChatPermissions.fromMap(_map['permissions'])!;
    return SetChatPermissions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      permissions: permissions,
    );
  }
}

/// Changes the background in a specific chat. Supported only in private and secret chats with non-deleted users.
///
/// Returns [Ok].
class SetChatBackground extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatBackground";

  /// Chat identifier.
  late int chat_id;

  /// The input background to use; pass null to create a new filled background or to remove the current background.
  InputBackground? background;

  /// Background type; pass null to remove the current background.
  BackgroundType? type;

  /// Dimming of the background in dark themes, as a percentage; 0-100.
  late int dark_theme_dimming;

  /// Changes the background in a specific chat. Supported only in private and secret chats with non-deleted users
  ///
  /// Returns [Ok]
  SetChatBackground(
      {required this.chat_id,
      this.background,
      this.type,
      required this.dark_theme_dimming,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatBackground',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'background': background,
      'type': type,
      'dark_theme_dimming': dark_theme_dimming
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatBackground? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var background = InputBackground.fromMap(_map['background']);
    var type = BackgroundType.fromMap(_map['type']);
    var dark_theme_dimming = _map['dark_theme_dimming']! as int;
    return SetChatBackground(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      background: background,
      type: type,
      dark_theme_dimming: dark_theme_dimming,
    );
  }
}

/// Changes the chat theme. Supported only in private and secret chats.
///
/// Returns [Ok].
class SetChatTheme extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatTheme";

  /// Chat identifier.
  late int chat_id;

  /// Name of the new chat theme; pass an empty string to return the default theme.
  late String theme_name;

  /// Changes the chat theme. Supported only in private and secret chats
  ///
  /// Returns [Ok]
  SetChatTheme(
      {required this.chat_id,
      required this.theme_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatTheme',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'theme_name': theme_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatTheme? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var theme_name = _map['theme_name']! as String;
    return SetChatTheme(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      theme_name: theme_name,
    );
  }
}

/// Changes the draft message in a chat.
///
/// Returns [Ok].
class SetChatDraftMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatDraftMessage";

  /// Chat identifier.
  late int chat_id;

  /// If not 0, a message thread identifier in which the draft was changed.
  late int message_thread_id;

  /// New draft message; pass null to remove the draft.
  DraftMessage? draft_message;

  /// Changes the draft message in a chat
  ///
  /// Returns [Ok]
  SetChatDraftMessage(
      {required this.chat_id,
      required this.message_thread_id,
      this.draft_message,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatDraftMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id,
      'draft_message': draft_message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatDraftMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    var draft_message = DraftMessage.fromMap(_map['draft_message']);
    return SetChatDraftMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
      draft_message: draft_message,
    );
  }
}

/// Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed.
///
/// Returns [Ok].
class SetChatNotificationSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatNotificationSettings";

  /// Chat identifier.
  late int chat_id;

  /// New notification settings for the chat. If the chat is muted for more than 366 days, it is considered to be muted forever.
  late ChatNotificationSettings notification_settings;

  /// Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
  ///
  /// Returns [Ok]
  SetChatNotificationSettings(
      {required this.chat_id,
      required this.notification_settings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatNotificationSettings',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'notification_settings': notification_settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatNotificationSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var notification_settings =
        ChatNotificationSettings.fromMap(_map['notification_settings'])!;
    return SetChatNotificationSettings(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      notification_settings: notification_settings,
    );
  }
}

/// Changes the ability of users to save, forward, or copy chat content. Supported only for basic groups, supergroups and channels. Requires owner privileges.
///
/// Returns [Ok].
class ToggleChatHasProtectedContent extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleChatHasProtectedContent";

  /// Chat identifier.
  late int chat_id;

  /// New value of has_protected_content.
  late bool has_protected_content;

  /// Changes the ability of users to save, forward, or copy chat content. Supported only for basic groups, supergroups and channels. Requires owner privileges
  ///
  /// Returns [Ok]
  ToggleChatHasProtectedContent(
      {required this.chat_id,
      required this.has_protected_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleChatHasProtectedContent',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'has_protected_content': has_protected_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleChatHasProtectedContent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var has_protected_content = _map['has_protected_content']! as bool;
    return ToggleChatHasProtectedContent(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      has_protected_content: has_protected_content,
    );
  }
}

/// Changes the translatable state of a chat; for Telegram Premium users only.
///
/// Returns [Ok].
class ToggleChatIsTranslatable extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleChatIsTranslatable";

  /// Chat identifier.
  late int chat_id;

  /// New value of is_translatable.
  late bool is_translatable;

  /// Changes the translatable state of a chat; for Telegram Premium users only
  ///
  /// Returns [Ok]
  ToggleChatIsTranslatable(
      {required this.chat_id,
      required this.is_translatable,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleChatIsTranslatable',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'is_translatable': is_translatable
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleChatIsTranslatable? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var is_translatable = _map['is_translatable']! as bool;
    return ToggleChatIsTranslatable(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      is_translatable: is_translatable,
    );
  }
}

/// Changes the marked as unread state of a chat.
///
/// Returns [Ok].
class ToggleChatIsMarkedAsUnread extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleChatIsMarkedAsUnread";

  /// Chat identifier.
  late int chat_id;

  /// New value of is_marked_as_unread.
  late bool is_marked_as_unread;

  /// Changes the marked as unread state of a chat
  ///
  /// Returns [Ok]
  ToggleChatIsMarkedAsUnread(
      {required this.chat_id,
      required this.is_marked_as_unread,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleChatIsMarkedAsUnread',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'is_marked_as_unread': is_marked_as_unread
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleChatIsMarkedAsUnread? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var is_marked_as_unread = _map['is_marked_as_unread']! as bool;
    return ToggleChatIsMarkedAsUnread(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      is_marked_as_unread: is_marked_as_unread,
    );
  }
}

/// Changes the value of the default disable_notification parameter, used when a message is sent to a chat.
///
/// Returns [Ok].
class ToggleChatDefaultDisableNotification extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleChatDefaultDisableNotification";

  /// Chat identifier.
  late int chat_id;

  /// New value of default_disable_notification.
  late bool default_disable_notification;

  /// Changes the value of the default disable_notification parameter, used when a message is sent to a chat
  ///
  /// Returns [Ok]
  ToggleChatDefaultDisableNotification(
      {required this.chat_id,
      required this.default_disable_notification,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleChatDefaultDisableNotification',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'default_disable_notification': default_disable_notification
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleChatDefaultDisableNotification? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var default_disable_notification =
        _map['default_disable_notification']! as bool;
    return ToggleChatDefaultDisableNotification(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      default_disable_notification: default_disable_notification,
    );
  }
}

/// Changes reactions, available in a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right.
///
/// Returns [Ok].
class SetChatAvailableReactions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatAvailableReactions";

  /// Identifier of the chat.
  late int chat_id;

  /// Reactions available in the chat. All emoji reactions must be active.
  late ChatAvailableReactions available_reactions;

  /// Changes reactions, available in a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
  ///
  /// Returns [Ok]
  SetChatAvailableReactions(
      {required this.chat_id,
      required this.available_reactions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatAvailableReactions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'available_reactions': available_reactions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatAvailableReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var available_reactions =
        ChatAvailableReactions.fromMap(_map['available_reactions'])!;
    return SetChatAvailableReactions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      available_reactions: available_reactions,
    );
  }
}

/// Changes application-specific data associated with a chat.
///
/// Returns [Ok].
class SetChatClientData extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatClientData";

  /// Chat identifier.
  late int chat_id;

  /// New value of client_data.
  late String client_data;

  /// Changes application-specific data associated with a chat
  ///
  /// Returns [Ok]
  SetChatClientData(
      {required this.chat_id,
      required this.client_data,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatClientData',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'client_data': client_data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatClientData? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var client_data = _map['client_data']! as String;
    return SetChatClientData(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      client_data: client_data,
    );
  }
}

/// Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right.
///
/// Returns [Ok].
class SetChatDescription extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatDescription";

  /// Identifier of the chat.
  late int chat_id;

  /// New chat description; 0-255 characters.
  late String description;

  /// Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
  ///
  /// Returns [Ok]
  SetChatDescription(
      {required this.chat_id,
      required this.description,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatDescription',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'description': description
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatDescription? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var description = _map['description']! as String;
    return SetChatDescription(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      description: description,
    );
  }
}

/// Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified.
///
/// Returns [Ok].
class SetChatDiscussionGroup extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatDiscussionGroup";

  /// Identifier of the channel chat. Pass 0 to remove a link from the supergroup passed in the second argument to a linked channel chat (requires can_pin_messages rights in the supergroup).
  late int chat_id;

  /// Identifier of a new channel's discussion group. Use 0 to remove the discussion group. Use the method getSuitableDiscussionChats to find all suitable groups..
  late int discussion_chat_id;

  /// Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified
  ///
  /// Returns [Ok]
  SetChatDiscussionGroup(
      {required this.chat_id,
      required this.discussion_chat_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatDiscussionGroup',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'discussion_chat_id': discussion_chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatDiscussionGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var discussion_chat_id = _map['discussion_chat_id']! as int;
    return SetChatDiscussionGroup(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      discussion_chat_id: discussion_chat_id,
    );
  }
}

/// Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use.
///
/// Returns [Ok].
class SetChatLocation extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatLocation";

  /// Chat identifier.
  late int chat_id;

  /// New location for the chat; must be valid and not null.
  late ChatLocation location;

  /// Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
  ///
  /// Returns [Ok]
  SetChatLocation(
      {required this.chat_id,
      required this.location,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatLocation',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'location': location
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var location = ChatLocation.fromMap(_map['location'])!;
    return SetChatLocation(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      location: location,
    );
  }
}

/// Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights.
///
/// Returns [Ok].
class SetChatSlowModeDelay extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatSlowModeDelay";

  /// Chat identifier.
  late int chat_id;

  /// New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60, 300, 900, 3600.
  late int slow_mode_delay;

  /// Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
  ///
  /// Returns [Ok]
  SetChatSlowModeDelay(
      {required this.chat_id,
      required this.slow_mode_delay,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatSlowModeDelay',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'slow_mode_delay': slow_mode_delay
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatSlowModeDelay? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var slow_mode_delay = _map['slow_mode_delay']! as int;
    return SetChatSlowModeDelay(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      slow_mode_delay: slow_mode_delay,
    );
  }
}

/// Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel.
///
/// Returns [Ok].
class PinChatMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pinChatMessage";

  /// Identifier of the chat.
  late int chat_id;

  /// Identifier of the new pinned message.
  late int message_id;

  /// Pass true to disable notification about the pinned message. Notifications are always disabled in channels and private chats.
  late bool disable_notification;

  /// Pass true to pin the message only for self; private chats only.
  late bool only_for_self;

  /// Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel
  ///
  /// Returns [Ok]
  PinChatMessage(
      {required this.chat_id,
      required this.message_id,
      required this.disable_notification,
      required this.only_for_self,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pinChatMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'disable_notification': disable_notification,
      'only_for_self': only_for_self
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PinChatMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var disable_notification = _map['disable_notification']! as bool;
    var only_for_self = _map['only_for_self']! as bool;
    return PinChatMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      disable_notification: disable_notification,
      only_for_self: only_for_self,
    );
  }
}

/// Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel.
///
/// Returns [Ok].
class UnpinChatMessage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "unpinChatMessage";

  /// Identifier of the chat.
  late int chat_id;

  /// Identifier of the removed pinned message.
  late int message_id;

  /// Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
  ///
  /// Returns [Ok]
  UnpinChatMessage(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'unpinChatMessage',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UnpinChatMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return UnpinChatMessage(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel.
///
/// Returns [Ok].
class UnpinAllChatMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "unpinAllChatMessages";

  /// Identifier of the chat.
  late int chat_id;

  /// Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
  ///
  /// Returns [Ok]
  UnpinAllChatMessages({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'unpinAllChatMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UnpinAllChatMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return UnpinAllChatMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Removes all pinned messages from a forum topic; requires can_pin_messages rights in the supergroup.
///
/// Returns [Ok].
class UnpinAllMessageThreadMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "unpinAllMessageThreadMessages";

  /// Identifier of the chat.
  late int chat_id;

  /// Message thread identifier in which messages will be unpinned.
  late int message_thread_id;

  /// Removes all pinned messages from a forum topic; requires can_pin_messages rights in the supergroup
  ///
  /// Returns [Ok]
  UnpinAllMessageThreadMessages(
      {required this.chat_id,
      required this.message_thread_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'unpinAllMessageThreadMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_thread_id': message_thread_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UnpinAllMessageThreadMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_thread_id = _map['message_thread_id']! as int;
    return UnpinAllMessageThreadMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_thread_id: message_thread_id,
    );
  }
}

/// Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created.
///
/// Returns [Ok].
class JoinChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "joinChat";

  /// Chat identifier.
  late int chat_id;

  /// Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
  ///
  /// Returns [Ok]
  JoinChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'joinChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JoinChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return JoinChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Removes the current user from chat members. Private and secret chats can't be left using this method.
///
/// Returns [Ok].
class LeaveChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "leaveChat";

  /// Chat identifier.
  late int chat_id;

  /// Removes the current user from chat members. Private and secret chats can't be left using this method
  ///
  /// Returns [Ok]
  LeaveChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'leaveChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LeaveChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return LeaveChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Adds a new member to a chat. Members can't be added to private or secret chats.
///
/// Returns [Ok].
class AddChatMember extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addChatMember";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the user.
  late int user_id;

  /// The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels, or if the added user is a bot.
  late int forward_limit;

  /// Adds a new member to a chat. Members can't be added to private or secret chats
  ///
  /// Returns [Ok]
  AddChatMember(
      {required this.chat_id,
      required this.user_id,
      required this.forward_limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addChatMember',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'user_id': user_id,
      'forward_limit': forward_limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddChatMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var user_id = _map['user_id']! as int;
    var forward_limit = _map['forward_limit']! as int;
    return AddChatMember(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      user_id: user_id,
      forward_limit: forward_limit,
    );
  }
}

/// Adds multiple new members to a chat. Currently, this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members.
///
/// Returns [Ok].
class AddChatMembers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addChatMembers";

  /// Chat identifier.
  late int chat_id;

  /// Identifiers of the users to be added to the chat. The maximum number of added users is 20 for supergroups and 100 for channels.
  late List<int> user_ids;

  /// Adds multiple new members to a chat. Currently, this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members
  ///
  /// Returns [Ok]
  AddChatMembers(
      {required this.chat_id,
      required this.user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addChatMembers',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddChatMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return AddChatMembers(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      user_ids: user_ids,
    );
  }
}

/// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed.
///
/// Returns [Ok].
class SetChatMemberStatus extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatMemberStatus";

  /// Chat identifier.
  late int chat_id;

  /// Member identifier. Chats can be only banned and unbanned in supergroups and channels.
  late MessageSender member_id;

  /// The new status of the member in the chat.
  late ChatMemberStatus status;

  /// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed
  ///
  /// Returns [Ok]
  SetChatMemberStatus(
      {required this.chat_id,
      required this.member_id,
      required this.status,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatMemberStatus',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'member_id': member_id,
      'status': status
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatMemberStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var member_id = MessageSender.fromMap(_map['member_id'])!;
    var status = ChatMemberStatus.fromMap(_map['status'])!;
    return SetChatMemberStatus(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      member_id: member_id,
      status: status,
    );
  }
}

/// Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first.
///
/// Returns [Ok].
class BanChatMember extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "banChatMember";

  /// Chat identifier.
  late int chat_id;

  /// Member identifier.
  late MessageSender member_id;

  /// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Ignored in basic groups and if a chat is banned.
  late int banned_until_date;

  /// Pass true to delete all messages in the chat for the user that is being removed. Always true for supergroups and channels.
  late bool revoke_messages;

  /// Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first
  ///
  /// Returns [Ok]
  BanChatMember(
      {required this.chat_id,
      required this.member_id,
      required this.banned_until_date,
      required this.revoke_messages,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'banChatMember',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'member_id': member_id,
      'banned_until_date': banned_until_date,
      'revoke_messages': revoke_messages
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BanChatMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var member_id = MessageSender.fromMap(_map['member_id'])!;
    var banned_until_date = _map['banned_until_date']! as int;
    var revoke_messages = _map['revoke_messages']! as bool;
    return BanChatMember(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      member_id: member_id,
      banned_until_date: banned_until_date,
      revoke_messages: revoke_messages,
    );
  }
}

/// Checks whether the current session can be used to transfer a chat ownership to another user.
///
/// Returns [CanTransferOwnershipResult].
class CanTransferOwnership extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canTransferOwnership";

  /// Checks whether the current session can be used to transfer a chat ownership to another user
  ///
  /// Returns [CanTransferOwnershipResult]
  CanTransferOwnership({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canTransferOwnership',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanTransferOwnership? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return CanTransferOwnership(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats.
///
/// Returns [Ok].
class TransferChatOwnership extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "transferChatOwnership";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the user to which transfer the ownership. The ownership can't be transferred to a bot or to a deleted user.
  late int user_id;

  /// The 2-step verification password of the current user.
  late String password;

  /// Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
  ///
  /// Returns [Ok]
  TransferChatOwnership(
      {required this.chat_id,
      required this.user_id,
      required this.password,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'transferChatOwnership',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'user_id': user_id,
      'password': password
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TransferChatOwnership? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var user_id = _map['user_id']! as int;
    var password = _map['password']! as String;
    return TransferChatOwnership(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      user_id: user_id,
      password: password,
    );
  }
}

/// Returns information about a single member of a chat.
///
/// Returns [ChatMember].
class GetChatMember extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatMember";

  /// Chat identifier.
  late int chat_id;

  /// Member identifier.
  late MessageSender member_id;

  /// Returns information about a single member of a chat
  ///
  /// Returns [ChatMember]
  GetChatMember(
      {required this.chat_id,
      required this.member_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatMember',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'member_id': member_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatMember? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var member_id = MessageSender.fromMap(_map['member_id'])!;
    return GetChatMember(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      member_id: member_id,
    );
  }
}

/// Searches for a specified query in the first name, last name and usernames of the members of a specified chat. Requires administrator rights in channels.
///
/// Returns [ChatMembers].
class SearchChatMembers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchChatMembers";

  /// Chat identifier.
  late int chat_id;

  /// Query to search for.
  late String query;

  /// The maximum number of users to be returned; up to 200.
  late int limit;

  /// The type of users to search for; pass null to search among all chat members.
  ChatMembersFilter? filter;

  /// Searches for a specified query in the first name, last name and usernames of the members of a specified chat. Requires administrator rights in channels
  ///
  /// Returns [ChatMembers]
  SearchChatMembers(
      {required this.chat_id,
      required this.query,
      required this.limit,
      this.filter,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchChatMembers',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'query': query,
      'limit': limit,
      'filter': filter
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchChatMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var query = _map['query']! as String;
    var limit = _map['limit']! as int;
    var filter = ChatMembersFilter.fromMap(_map['filter']);
    return SearchChatMembers(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      query: query,
      limit: limit,
      filter: filter,
    );
  }
}

/// Returns a list of administrators of the chat with their custom titles.
///
/// Returns [ChatAdministrators].
class GetChatAdministrators extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatAdministrators";

  /// Chat identifier.
  late int chat_id;

  /// Returns a list of administrators of the chat with their custom titles
  ///
  /// Returns [ChatAdministrators]
  GetChatAdministrators({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatAdministrators',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatAdministrators? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatAdministrators(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Clears message drafts in all chats.
///
/// Returns [Ok].
class ClearAllDraftMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clearAllDraftMessages";

  /// Pass true to keep local message drafts in secret chats.
  late bool exclude_secret_chats;

  /// Clears message drafts in all chats
  ///
  /// Returns [Ok]
  ClearAllDraftMessages(
      {required this.exclude_secret_chats, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clearAllDraftMessages',
      if (extra != null) '@extra': extra,
      'exclude_secret_chats': exclude_secret_chats
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClearAllDraftMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var exclude_secret_chats = _map['exclude_secret_chats']! as bool;
    return ClearAllDraftMessages(
      extra: extra,
      clientId: clientId,
      exclude_secret_chats: exclude_secret_chats,
    );
  }
}

/// Returns saved notification sound by its identifier. Returns a 404 error if there is no saved notification sound with the specified identifier.
///
/// Returns [NotificationSounds].
class GetSavedNotificationSound extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSavedNotificationSound";

  /// Identifier of the notification sound.
  /// ; string representation of int, use `int.parse`
  late int64 notification_sound_id;

  /// Returns saved notification sound by its identifier. Returns a 404 error if there is no saved notification sound with the specified identifier
  ///
  /// Returns [NotificationSounds]
  GetSavedNotificationSound(
      {required this.notification_sound_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getSavedNotificationSound',
      if (extra != null) '@extra': extra,
      'notification_sound_id': notification_sound_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSavedNotificationSound? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var notification_sound_id = _map['notification_sound_id']! as int64;
    return GetSavedNotificationSound(
      extra: extra,
      clientId: clientId,
      notification_sound_id: notification_sound_id,
    );
  }
}

/// Returns list of saved notification sounds. If a sound isn't in the list, then default sound needs to be used.
///
/// Returns [NotificationSounds].
class GetSavedNotificationSounds extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSavedNotificationSounds";

  /// Returns list of saved notification sounds. If a sound isn't in the list, then default sound needs to be used
  ///
  /// Returns [NotificationSounds]
  GetSavedNotificationSounds({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getSavedNotificationSounds',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSavedNotificationSounds? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetSavedNotificationSounds(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Adds a new notification sound to the list of saved notification sounds. The new notification sound is added to the top of the list. If it is already in the list, its position isn't changed.
///
/// Returns [NotificationSound].
class AddSavedNotificationSound extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addSavedNotificationSound";

  /// Notification sound file to add.
  late InputFile sound;

  /// Adds a new notification sound to the list of saved notification sounds. The new notification sound is added to the top of the list. If it is already in the list, its position isn't changed
  ///
  /// Returns [NotificationSound]
  AddSavedNotificationSound({required this.sound, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addSavedNotificationSound',
      if (extra != null) '@extra': extra,
      'sound': sound
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddSavedNotificationSound? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sound = InputFile.fromMap(_map['sound'])!;
    return AddSavedNotificationSound(
      extra: extra,
      clientId: clientId,
      sound: sound,
    );
  }
}

/// Removes a notification sound from the list of saved notification sounds.
///
/// Returns [Ok].
class RemoveSavedNotificationSound extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeSavedNotificationSound";

  /// Identifier of the notification sound.
  /// ; string representation of int, use `int.parse`
  late int64 notification_sound_id;

  /// Removes a notification sound from the list of saved notification sounds
  ///
  /// Returns [Ok]
  RemoveSavedNotificationSound(
      {required this.notification_sound_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeSavedNotificationSound',
      if (extra != null) '@extra': extra,
      'notification_sound_id': notification_sound_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveSavedNotificationSound? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var notification_sound_id = _map['notification_sound_id']! as int64;
    return RemoveSavedNotificationSound(
      extra: extra,
      clientId: clientId,
      notification_sound_id: notification_sound_id,
    );
  }
}

/// Returns list of chats with non-default notification settings for new messages.
///
/// Returns [Chats].
class GetChatNotificationSettingsExceptions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatNotificationSettingsExceptions";

  /// If specified, only chats from the scope will be returned; pass null to return chats from all scopes.
  NotificationSettingsScope? scope;

  /// Pass true to include in the response chats with only non-default sound.
  late bool compare_sound;

  /// Returns list of chats with non-default notification settings for new messages
  ///
  /// Returns [Chats]
  GetChatNotificationSettingsExceptions(
      {this.scope, required this.compare_sound, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatNotificationSettingsExceptions',
      if (extra != null) '@extra': extra,
      'scope': scope,
      'compare_sound': compare_sound
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatNotificationSettingsExceptions? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scope = NotificationSettingsScope.fromMap(_map['scope']);
    var compare_sound = _map['compare_sound']! as bool;
    return GetChatNotificationSettingsExceptions(
      extra: extra,
      clientId: clientId,
      scope: scope,
      compare_sound: compare_sound,
    );
  }
}

/// Returns the notification settings for chats of a given type.
///
/// Returns [ScopeNotificationSettings].
class GetScopeNotificationSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getScopeNotificationSettings";

  /// Types of chats for which to return the notification settings information.
  late NotificationSettingsScope scope;

  /// Returns the notification settings for chats of a given type
  ///
  /// Returns [ScopeNotificationSettings]
  GetScopeNotificationSettings(
      {required this.scope, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getScopeNotificationSettings',
      if (extra != null) '@extra': extra,
      'scope': scope
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetScopeNotificationSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scope = NotificationSettingsScope.fromMap(_map['scope'])!;
    return GetScopeNotificationSettings(
      extra: extra,
      clientId: clientId,
      scope: scope,
    );
  }
}

/// Changes notification settings for chats of a given type.
///
/// Returns [Ok].
class SetScopeNotificationSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setScopeNotificationSettings";

  /// Types of chats for which to change the notification settings.
  late NotificationSettingsScope scope;

  /// The new notification settings for the given scope.
  late ScopeNotificationSettings notification_settings;

  /// Changes notification settings for chats of a given type
  ///
  /// Returns [Ok]
  SetScopeNotificationSettings(
      {required this.scope,
      required this.notification_settings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setScopeNotificationSettings',
      if (extra != null) '@extra': extra,
      'scope': scope,
      'notification_settings': notification_settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetScopeNotificationSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scope = NotificationSettingsScope.fromMap(_map['scope'])!;
    var notification_settings =
        ScopeNotificationSettings.fromMap(_map['notification_settings'])!;
    return SetScopeNotificationSettings(
      extra: extra,
      clientId: clientId,
      scope: scope,
      notification_settings: notification_settings,
    );
  }
}

/// Resets all notification settings to their default values. By default, all chats are unmuted and message previews are shown.
///
/// Returns [Ok].
class ResetAllNotificationSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resetAllNotificationSettings";

  /// Resets all notification settings to their default values. By default, all chats are unmuted and message previews are shown
  ///
  /// Returns [Ok]
  ResetAllNotificationSettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resetAllNotificationSettings',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResetAllNotificationSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResetAllNotificationSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Changes the pinned state of a chat. There can be up to getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/archive chat list. The limit can be increased with Telegram Premium.
///
/// Returns [Ok].
class ToggleChatIsPinned extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleChatIsPinned";

  /// Chat list in which to change the pinned state of the chat.
  late ChatList chat_list;

  /// Chat identifier.
  late int chat_id;

  /// Pass true to pin the chat; pass false to unpin it.
  late bool is_pinned;

  /// Changes the pinned state of a chat. There can be up to getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/archive chat list. The limit can be increased with Telegram Premium
  ///
  /// Returns [Ok]
  ToggleChatIsPinned(
      {required this.chat_list,
      required this.chat_id,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleChatIsPinned',
      if (extra != null) '@extra': extra,
      'chat_list': chat_list,
      'chat_id': chat_id,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleChatIsPinned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_list = ChatList.fromMap(_map['chat_list'])!;
    var chat_id = _map['chat_id']! as int;
    var is_pinned = _map['is_pinned']! as bool;
    return ToggleChatIsPinned(
      extra: extra,
      clientId: clientId,
      chat_list: chat_list,
      chat_id: chat_id,
      is_pinned: is_pinned,
    );
  }
}

/// Changes the order of pinned chats.
///
/// Returns [Ok].
class SetPinnedChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setPinnedChats";

  /// Chat list in which to change the order of pinned chats.
  late ChatList chat_list;

  /// The new list of pinned chats.
  late List<int> chat_ids;

  /// Changes the order of pinned chats
  ///
  /// Returns [Ok]
  SetPinnedChats(
      {required this.chat_list,
      required this.chat_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setPinnedChats',
      if (extra != null) '@extra': extra,
      'chat_list': chat_list,
      'chat_ids': chat_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetPinnedChats? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_list = ChatList.fromMap(_map['chat_list'])!;
    var chat_ids = List<int>.from(
      (_map["chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return SetPinnedChats(
      extra: extra,
      clientId: clientId,
      chat_list: chat_list,
      chat_ids: chat_ids,
    );
  }
}

/// Traverse all chats in a chat list and marks all messages in the chats as read.
///
/// Returns [Ok].
class ReadChatList extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "readChatList";

  /// Chat list in which to mark all chats as read.
  late ChatList chat_list;

  /// Traverse all chats in a chat list and marks all messages in the chats as read
  ///
  /// Returns [Ok]
  ReadChatList({required this.chat_list, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'readChatList',
      if (extra != null) '@extra': extra,
      'chat_list': chat_list
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReadChatList? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_list = ChatList.fromMap(_map['chat_list'])!;
    return ReadChatList(
      extra: extra,
      clientId: clientId,
      chat_list: chat_list,
    );
  }
}

/// Returns a story.
///
/// Returns [Story].
class GetStory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStory";

  /// Identifier of the chat that posted the story.
  late int story_sender_chat_id;

  /// Story identifier.
  late int story_id;

  /// Pass true to get only locally available information without sending network requests.
  late bool only_local;

  /// Returns a story
  ///
  /// Returns [Story]
  GetStory(
      {required this.story_sender_chat_id,
      required this.story_id,
      required this.only_local,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStory',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id,
      'only_local': only_local
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    var only_local = _map['only_local']! as bool;
    return GetStory(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
      only_local: only_local,
    );
  }
}

/// Returns channel chats in which the current user has the right to post stories. The chats must be rechecked with canSendStory before actually trying to post a story there.
///
/// Returns [Chats].
class GetChatsToSendStories extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatsToSendStories";

  /// Returns channel chats in which the current user has the right to post stories. The chats must be rechecked with canSendStory before actually trying to post a story there
  ///
  /// Returns [Chats]
  GetChatsToSendStories({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatsToSendStories',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatsToSendStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetChatsToSendStories(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks whether the current user can send a story on behalf of a chat; requires can_post_stories rights for channel chats.
///
/// Returns [CanSendStoryResult].
class CanSendStory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canSendStory";

  /// Chat identifier.
  late int chat_id;

  /// Checks whether the current user can send a story on behalf of a chat; requires can_post_stories rights for channel chats
  ///
  /// Returns [CanSendStoryResult]
  CanSendStory({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canSendStory',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanSendStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return CanSendStory(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Sends a new story to a chat; requires can_post_stories rights for channel chats. Returns a temporary story.
///
/// Returns [Story].
class SendStory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendStory";

  /// Identifier of the chat that will post the story.
  late int chat_id;

  /// Content of the story.
  late InputStoryContent content;

  /// Clickable rectangle areas to be shown on the story media; pass null if none.
  InputStoryAreas? areas;

  /// Story caption; pass null to use an empty caption; 0-getOption("story_caption_length_max") characters.
  FormattedText? caption;

  /// The privacy settings for the story.
  late StoryPrivacySettings privacy_settings;

  /// Period after which the story is moved to archive, in seconds; must be one of 6 * 3600, 12 * 3600, 86400, or 2 * 86400 for Telegram Premium users, and 86400 otherwise.
  late int active_period;

  /// Pass true to keep the story accessible after expiration.
  late bool is_pinned;

  /// Pass true if the content of the story must be protected from forwarding and screenshotting.
  late bool protect_content;

  /// Sends a new story to a chat; requires can_post_stories rights for channel chats. Returns a temporary story
  ///
  /// Returns [Story]
  SendStory(
      {required this.chat_id,
      required this.content,
      this.areas,
      this.caption,
      required this.privacy_settings,
      required this.active_period,
      required this.is_pinned,
      required this.protect_content,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendStory',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'content': content,
      'areas': areas,
      'caption': caption,
      'privacy_settings': privacy_settings,
      'active_period': active_period,
      'is_pinned': is_pinned,
      'protect_content': protect_content
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var content = InputStoryContent.fromMap(_map['content'])!;
    var areas = InputStoryAreas.fromMap(_map['areas']);
    var caption = FormattedText.fromMap(_map['caption']);
    var privacy_settings =
        StoryPrivacySettings.fromMap(_map['privacy_settings'])!;
    var active_period = _map['active_period']! as int;
    var is_pinned = _map['is_pinned']! as bool;
    var protect_content = _map['protect_content']! as bool;
    return SendStory(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      content: content,
      areas: areas,
      caption: caption,
      privacy_settings: privacy_settings,
      active_period: active_period,
      is_pinned: is_pinned,
      protect_content: protect_content,
    );
  }
}

/// Changes content and caption of a story. Can be called only if story.can_be_edited == true.
///
/// Returns [Ok].
class EditStory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editStory";

  /// Identifier of the chat that posted the story.
  late int story_sender_chat_id;

  /// Identifier of the story to edit.
  late int story_id;

  /// New content of the story; pass null to keep the current content.
  InputStoryContent? content;

  /// New clickable rectangle areas to be shown on the story media; pass null to keep the current areas. Areas can't be edited if story content isn't changed.
  InputStoryAreas? areas;

  /// New story caption; pass null to keep the current caption.
  FormattedText? caption;

  /// Changes content and caption of a story. Can be called only if story.can_be_edited == true
  ///
  /// Returns [Ok]
  EditStory(
      {required this.story_sender_chat_id,
      required this.story_id,
      this.content,
      this.areas,
      this.caption,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editStory',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id,
      'content': content,
      'areas': areas,
      'caption': caption
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    var content = InputStoryContent.fromMap(_map['content']);
    var areas = InputStoryAreas.fromMap(_map['areas']);
    var caption = FormattedText.fromMap(_map['caption']);
    return EditStory(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
      content: content,
      areas: areas,
      caption: caption,
    );
  }
}

/// Changes privacy settings of a story. Can be called only if story.can_be_edited == true.
///
/// Returns [Ok].
class SetStoryPrivacySettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setStoryPrivacySettings";

  /// Identifier of the chat that posted the story.
  late int story_sender_chat_id;

  /// Identifier of the story.
  late int story_id;

  /// The new privacy settigs for the story.
  late StoryPrivacySettings privacy_settings;

  /// Changes privacy settings of a story. Can be called only if story.can_be_edited == true
  ///
  /// Returns [Ok]
  SetStoryPrivacySettings(
      {required this.story_sender_chat_id,
      required this.story_id,
      required this.privacy_settings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setStoryPrivacySettings',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id,
      'privacy_settings': privacy_settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetStoryPrivacySettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    var privacy_settings =
        StoryPrivacySettings.fromMap(_map['privacy_settings'])!;
    return SetStoryPrivacySettings(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
      privacy_settings: privacy_settings,
    );
  }
}

/// Toggles whether a story is accessible after expiration. Can be called only if story.can_toggle_is_pinned == true.
///
/// Returns [Ok].
class ToggleStoryIsPinned extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleStoryIsPinned";

  /// Identifier of the chat that posted the story.
  late int story_sender_chat_id;

  /// Identifier of the story.
  late int story_id;

  /// Pass true to make the story accessible after expiration; pass false to make it private.
  late bool is_pinned;

  /// Toggles whether a story is accessible after expiration. Can be called only if story.can_toggle_is_pinned == true
  ///
  /// Returns [Ok]
  ToggleStoryIsPinned(
      {required this.story_sender_chat_id,
      required this.story_id,
      required this.is_pinned,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleStoryIsPinned',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id,
      'is_pinned': is_pinned
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleStoryIsPinned? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    var is_pinned = _map['is_pinned']! as bool;
    return ToggleStoryIsPinned(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
      is_pinned: is_pinned,
    );
  }
}

/// Deletes a previously sent story. Can be called only if story.can_be_deleted == true.
///
/// Returns [Ok].
class DeleteStory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteStory";

  /// Identifier of the chat that posted the story.
  late int story_sender_chat_id;

  /// Identifier of the story to delete.
  late int story_id;

  /// Deletes a previously sent story. Can be called only if story.can_be_deleted == true
  ///
  /// Returns [Ok]
  DeleteStory(
      {required this.story_sender_chat_id,
      required this.story_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteStory',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    return DeleteStory(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
    );
  }
}

/// Returns list of chats with non-default notification settings for stories.
///
/// Returns [Chats].
class GetStoryNotificationSettingsExceptions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStoryNotificationSettingsExceptions";

  /// Returns list of chats with non-default notification settings for stories
  ///
  /// Returns [Chats]
  GetStoryNotificationSettingsExceptions({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStoryNotificationSettingsExceptions',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStoryNotificationSettingsExceptions? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetStoryNotificationSettingsExceptions(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Loads more active stories from a story list. The loaded stories will be sent through updates. Active stories are sorted by.
///
/// Returns [Ok].
class LoadActiveStories extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "loadActiveStories";

  /// The story list in which to load active stories.
  late StoryList story_list;

  /// Loads more active stories from a story list. The loaded stories will be sent through updates. Active stories are sorted by
  ///
  /// Returns [Ok]
  LoadActiveStories({required this.story_list, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'loadActiveStories',
      if (extra != null) '@extra': extra,
      'story_list': story_list
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LoadActiveStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_list = StoryList.fromMap(_map['story_list'])!;
    return LoadActiveStories(
      extra: extra,
      clientId: clientId,
      story_list: story_list,
    );
  }
}

/// Changes story list in which stories from the chat are shown.
///
/// Returns [Ok].
class SetChatActiveStoriesList extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setChatActiveStoriesList";

  /// Identifier of the chat that posted stories.
  late int chat_id;

  /// New list for active stories posted by the chat.
  late StoryList story_list;

  /// Changes story list in which stories from the chat are shown
  ///
  /// Returns [Ok]
  SetChatActiveStoriesList(
      {required this.chat_id,
      required this.story_list,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setChatActiveStoriesList',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'story_list': story_list
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetChatActiveStoriesList? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var story_list = StoryList.fromMap(_map['story_list'])!;
    return SetChatActiveStoriesList(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      story_list: story_list,
    );
  }
}

/// Returns the list of active stories posted by the given chat.
///
/// Returns [ChatActiveStories].
class GetChatActiveStories extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatActiveStories";

  /// Chat identifier.
  late int chat_id;

  /// Returns the list of active stories posted by the given chat
  ///
  /// Returns [ChatActiveStories]
  GetChatActiveStories({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatActiveStories',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatActiveStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatActiveStories(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Returns the list of pinned stories posted by the given chat. The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id)..
///
/// Returns [Stories].
class GetChatPinnedStories extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatPinnedStories";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the story starting from which stories must be returned; use 0 to get results from the last story.
  late int from_story_id;

  /// The maximum number of stories to be returned.
  late int limit;

  /// Returns the list of pinned stories posted by the given chat. The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id).
  ///
  /// Returns [Stories]
  GetChatPinnedStories(
      {required this.chat_id,
      required this.from_story_id,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatPinnedStories',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'from_story_id': from_story_id,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatPinnedStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var from_story_id = _map['from_story_id']! as int;
    var limit = _map['limit']! as int;
    return GetChatPinnedStories(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      from_story_id: from_story_id,
      limit: limit,
    );
  }
}

/// Returns the list of all stories posted by the given chat; requires can_edit_stories rights for channel chats..
///
/// Returns [Stories].
class GetChatArchivedStories extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatArchivedStories";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the story starting from which stories must be returned; use 0 to get results from the last story.
  late int from_story_id;

  /// The maximum number of stories to be returned.
  late int limit;

  /// Returns the list of all stories posted by the given chat; requires can_edit_stories rights for channel chats.
  ///
  /// Returns [Stories]
  GetChatArchivedStories(
      {required this.chat_id,
      required this.from_story_id,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatArchivedStories',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'from_story_id': from_story_id,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatArchivedStories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var from_story_id = _map['from_story_id']! as int;
    var limit = _map['limit']! as int;
    return GetChatArchivedStories(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      from_story_id: from_story_id,
      limit: limit,
    );
  }
}

/// Informs TDLib that a story is opened and is being viewed by the user.
///
/// Returns [Ok].
class OpenStory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "openStory";

  /// The identifier of the sender of the opened story.
  late int story_sender_chat_id;

  /// The identifier of the story.
  late int story_id;

  /// Informs TDLib that a story is opened and is being viewed by the user
  ///
  /// Returns [Ok]
  OpenStory(
      {required this.story_sender_chat_id,
      required this.story_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'openStory',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OpenStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    return OpenStory(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
    );
  }
}

/// Informs TDLib that a story is closed by the user.
///
/// Returns [Ok].
class CloseStory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "closeStory";

  /// The identifier of the sender of the story to close.
  late int story_sender_chat_id;

  /// The identifier of the story.
  late int story_id;

  /// Informs TDLib that a story is closed by the user
  ///
  /// Returns [Ok]
  CloseStory(
      {required this.story_sender_chat_id,
      required this.story_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'closeStory',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CloseStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    return CloseStory(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
    );
  }
}

/// Returns reactions, which can be chosen for a story.
///
/// Returns [AvailableReactions].
class GetStoryAvailableReactions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStoryAvailableReactions";

  /// Number of reaction per row, 5-25.
  late int row_size;

  /// Returns reactions, which can be chosen for a story
  ///
  /// Returns [AvailableReactions]
  GetStoryAvailableReactions(
      {required this.row_size, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStoryAvailableReactions',
      if (extra != null) '@extra': extra,
      'row_size': row_size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStoryAvailableReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var row_size = _map['row_size']! as int;
    return GetStoryAvailableReactions(
      extra: extra,
      clientId: clientId,
      row_size: row_size,
    );
  }
}

/// Changes chosen reaction on a story.
///
/// Returns [Ok].
class SetStoryReaction extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setStoryReaction";

  /// The identifier of the sender of the story.
  late int story_sender_chat_id;

  /// The identifier of the story.
  late int story_id;

  /// Type of the reaction to set; pass null to remove the reaction. `reactionTypeCustomEmoji` reactions can be used only by Telegram Premium users.
  ReactionType? reaction_type;

  /// Pass true if the reaction needs to be added to recent reactions.
  late bool update_recent_reactions;

  /// Changes chosen reaction on a story
  ///
  /// Returns [Ok]
  SetStoryReaction(
      {required this.story_sender_chat_id,
      required this.story_id,
      this.reaction_type,
      required this.update_recent_reactions,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setStoryReaction',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id,
      'reaction_type': reaction_type,
      'update_recent_reactions': update_recent_reactions
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetStoryReaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    var reaction_type = ReactionType.fromMap(_map['reaction_type']);
    var update_recent_reactions = _map['update_recent_reactions']! as bool;
    return SetStoryReaction(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
      reaction_type: reaction_type,
      update_recent_reactions: update_recent_reactions,
    );
  }
}

/// Returns viewers of a story. The method can be called only for stories posted on behalf of the current user.
///
/// Returns [StoryViewers].
class GetStoryViewers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStoryViewers";

  /// Story identifier.
  late int story_id;

  /// Query to search for in names and usernames of the viewers; may be empty to get all relevant viewers.
  late String query;

  /// Pass true to get only contacts; pass false to get all relevant viewers.
  late bool only_contacts;

  /// Pass true to get viewers with reaction first; pass false to get viewers sorted just by view_date.
  late bool prefer_with_reaction;

  /// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results.
  late String offset;

  /// The maximum number of story viewers to return.
  late int limit;

  /// Returns viewers of a story. The method can be called only for stories posted on behalf of the current user
  ///
  /// Returns [StoryViewers]
  GetStoryViewers(
      {required this.story_id,
      required this.query,
      required this.only_contacts,
      required this.prefer_with_reaction,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStoryViewers',
      if (extra != null) '@extra': extra,
      'story_id': story_id,
      'query': query,
      'only_contacts': only_contacts,
      'prefer_with_reaction': prefer_with_reaction,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStoryViewers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_id = _map['story_id']! as int;
    var query = _map['query']! as String;
    var only_contacts = _map['only_contacts']! as bool;
    var prefer_with_reaction = _map['prefer_with_reaction']! as bool;
    var offset = _map['offset']! as String;
    var limit = _map['limit']! as int;
    return GetStoryViewers(
      extra: extra,
      clientId: clientId,
      story_id: story_id,
      query: query,
      only_contacts: only_contacts,
      prefer_with_reaction: prefer_with_reaction,
      offset: offset,
      limit: limit,
    );
  }
}

/// Reports a story to the Telegram moderators.
///
/// Returns [Ok].
class ReportStory extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportStory";

  /// The identifier of the sender of the story to report.
  late int story_sender_chat_id;

  /// The identifier of the story to report.
  late int story_id;

  /// The reason for reporting the story.
  late ReportReason reason;

  /// Additional report details; 0-1024 characters.
  late String text;

  /// Reports a story to the Telegram moderators
  ///
  /// Returns [Ok]
  ReportStory(
      {required this.story_sender_chat_id,
      required this.story_id,
      required this.reason,
      required this.text,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportStory',
      if (extra != null) '@extra': extra,
      'story_sender_chat_id': story_sender_chat_id,
      'story_id': story_id,
      'reason': reason,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportStory? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var story_sender_chat_id = _map['story_sender_chat_id']! as int;
    var story_id = _map['story_id']! as int;
    var reason = ReportReason.fromMap(_map['reason'])!;
    var text = _map['text']! as String;
    return ReportStory(
      extra: extra,
      clientId: clientId,
      story_sender_chat_id: story_sender_chat_id,
      story_id: story_id,
      reason: reason,
      text: text,
    );
  }
}

/// Activates stealth mode for stories, which hides all views of stories from the current user in the last "story_stealth_mode_past_period" seconds.
///
/// Returns [Ok].
class ActivateStoryStealthMode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "activateStoryStealthMode";

  /// Activates stealth mode for stories, which hides all views of stories from the current user in the last "story_stealth_mode_past_period" seconds
  ///
  /// Returns [Ok]
  ActivateStoryStealthMode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'activateStoryStealthMode',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ActivateStoryStealthMode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ActivateStoryStealthMode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns the current boost status for a channel chat.
///
/// Returns [ChatBoostStatus].
class GetChatBoostStatus extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatBoostStatus";

  /// Identifier of the channel chat.
  late int chat_id;

  /// Returns the current boost status for a channel chat
  ///
  /// Returns [ChatBoostStatus]
  GetChatBoostStatus({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatBoostStatus',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatBoostStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatBoostStatus(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Checks whether the current user can boost a chat.
///
/// Returns [CanBoostChatResult].
class CanBoostChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canBoostChat";

  /// Identifier of the chat.
  late int chat_id;

  /// Checks whether the current user can boost a chat
  ///
  /// Returns [CanBoostChatResult]
  CanBoostChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canBoostChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanBoostChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return CanBoostChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Boosts a chat.
///
/// Returns [Ok].
class BoostChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "boostChat";

  /// Identifier of the chat.
  late int chat_id;

  /// Boosts a chat
  ///
  /// Returns [Ok]
  BoostChat({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'boostChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BoostChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return BoostChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Returns an HTTPS link to boost the specified channel chat.
///
/// Returns [ChatBoostLink].
class GetChatBoostLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatBoostLink";

  /// Identifier of the chat.
  late int chat_id;

  /// Returns an HTTPS link to boost the specified channel chat
  ///
  /// Returns [ChatBoostLink]
  GetChatBoostLink({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatBoostLink',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatBoostLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatBoostLink(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Returns information about a link to boost a chat. Can be called for any internal link of the type internalLinkTypeChatBoost.
///
/// Returns [ChatBoostLinkInfo].
class GetChatBoostLinkInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatBoostLinkInfo";

  /// The link to boost a chat.
  late String url;

  /// Returns information about a link to boost a chat. Can be called for any internal link of the type internalLinkTypeChatBoost
  ///
  /// Returns [ChatBoostLinkInfo]
  GetChatBoostLinkInfo({required this.url, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatBoostLinkInfo',
      if (extra != null) '@extra': extra,
      'url': url
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatBoostLinkInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    return GetChatBoostLinkInfo(
      extra: extra,
      clientId: clientId,
      url: url,
    );
  }
}

/// Returns list of boosts applied to a chat. The user must be an administrator in the channel chat to get the list of boosts.
///
/// Returns [FoundChatBoosts].
class GetChatBoosts extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatBoosts";

  /// Identifier of the chat.
  late int chat_id;

  /// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results.
  late String offset;

  /// The maximum number of boosts to be returned; up to 100. For optimal performance, the number of returned boosts can be smaller than the specified limit.
  late int limit;

  /// Returns list of boosts applied to a chat. The user must be an administrator in the channel chat to get the list of boosts
  ///
  /// Returns [FoundChatBoosts]
  GetChatBoosts(
      {required this.chat_id,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatBoosts',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatBoosts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var offset = _map['offset']! as String;
    var limit = _map['limit']! as int;
    return GetChatBoosts(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      offset: offset,
      limit: limit,
    );
  }
}

/// Returns information about a bot that can be added to attachment or side menu.
///
/// Returns [AttachmentMenuBot].
class GetAttachmentMenuBot extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getAttachmentMenuBot";

  /// Bot's user identifier.
  late int bot_user_id;

  /// Returns information about a bot that can be added to attachment or side menu
  ///
  /// Returns [AttachmentMenuBot]
  GetAttachmentMenuBot({required this.bot_user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getAttachmentMenuBot',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetAttachmentMenuBot? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    return GetAttachmentMenuBot(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
    );
  }
}

/// Adds or removes a bot to attachment and side menu. Bot can be added to the menu, only if userTypeBot.can_be_added_to_attachment_menu == true.
///
/// Returns [Ok].
class ToggleBotIsAddedToAttachmentMenu extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleBotIsAddedToAttachmentMenu";

  /// Bot's user identifier.
  late int bot_user_id;

  /// Pass true to add the bot to attachment menu; pass false to remove the bot from attachment menu.
  late bool is_added;

  /// Pass true if the current user allowed the bot to send them messages. Ignored if is_added is false.
  late bool allow_write_access;

  /// Adds or removes a bot to attachment and side menu. Bot can be added to the menu, only if userTypeBot.can_be_added_to_attachment_menu == true
  ///
  /// Returns [Ok]
  ToggleBotIsAddedToAttachmentMenu(
      {required this.bot_user_id,
      required this.is_added,
      required this.allow_write_access,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleBotIsAddedToAttachmentMenu',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'is_added': is_added,
      'allow_write_access': allow_write_access
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleBotIsAddedToAttachmentMenu? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var is_added = _map['is_added']! as bool;
    var allow_write_access = _map['allow_write_access']! as bool;
    return ToggleBotIsAddedToAttachmentMenu(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      is_added: is_added,
      allow_write_access: allow_write_access,
    );
  }
}

/// Returns up to 8 emoji statuses, which must be shown right after the default Premium Badge in the emoji status list.
///
/// Returns [EmojiStatuses].
class GetThemedEmojiStatuses extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getThemedEmojiStatuses";

  /// Returns up to 8 emoji statuses, which must be shown right after the default Premium Badge in the emoji status list
  ///
  /// Returns [EmojiStatuses]
  GetThemedEmojiStatuses({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getThemedEmojiStatuses',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetThemedEmojiStatuses? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetThemedEmojiStatuses(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns recent emoji statuses.
///
/// Returns [EmojiStatuses].
class GetRecentEmojiStatuses extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getRecentEmojiStatuses";

  /// Returns recent emoji statuses
  ///
  /// Returns [EmojiStatuses]
  GetRecentEmojiStatuses({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getRecentEmojiStatuses',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetRecentEmojiStatuses? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetRecentEmojiStatuses(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns default emoji statuses.
///
/// Returns [EmojiStatuses].
class GetDefaultEmojiStatuses extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getDefaultEmojiStatuses";

  /// Returns default emoji statuses
  ///
  /// Returns [EmojiStatuses]
  GetDefaultEmojiStatuses({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getDefaultEmojiStatuses',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetDefaultEmojiStatuses? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetDefaultEmojiStatuses(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Clears the list of recently used emoji statuses.
///
/// Returns [Ok].
class ClearRecentEmojiStatuses extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clearRecentEmojiStatuses";

  /// Clears the list of recently used emoji statuses
  ///
  /// Returns [Ok]
  ClearRecentEmojiStatuses({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clearRecentEmojiStatuses',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClearRecentEmojiStatuses? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ClearRecentEmojiStatuses(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates.
///
/// Returns [File].
class DownloadFile extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "downloadFile";

  /// Identifier of the file to download.
  late int file_id;

  /// Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile/addFileToDownloads was called will be downloaded first.
  late int priority;

  /// The starting position from which the file needs to be downloaded.
  late int offset;

  /// Number of bytes which need to be downloaded starting from the "offset" position before the download will automatically be canceled; use 0 to download without a limit.
  late int limit;

  /// Pass true to return response only after the file download has succeeded, has failed, has been canceled, or a new downloadFile request with different offset/limit parameters was sent; pass false to return file state immediately, just after the download has been started.
  late bool synchronous;

  /// Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
  ///
  /// Returns [File]
  DownloadFile(
      {required this.file_id,
      required this.priority,
      required this.offset,
      required this.limit,
      required this.synchronous,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'downloadFile',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'priority': priority,
      'offset': offset,
      'limit': limit,
      'synchronous': synchronous
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DownloadFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var priority = _map['priority']! as int;
    var offset = _map['offset']! as int;
    var limit = _map['limit']! as int;
    var synchronous = _map['synchronous']! as bool;
    return DownloadFile(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      priority: priority,
      offset: offset,
      limit: limit,
      synchronous: synchronous,
    );
  }
}

/// Returns file downloaded prefix size from a given offset, in bytes.
///
/// Returns [FileDownloadedPrefixSize].
class GetFileDownloadedPrefixSize extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getFileDownloadedPrefixSize";

  /// Identifier of the file.
  late int file_id;

  /// Offset from which downloaded prefix size needs to be calculated.
  late int offset;

  /// Returns file downloaded prefix size from a given offset, in bytes
  ///
  /// Returns [FileDownloadedPrefixSize]
  GetFileDownloadedPrefixSize(
      {required this.file_id, required this.offset, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getFileDownloadedPrefixSize',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'offset': offset
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetFileDownloadedPrefixSize? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var offset = _map['offset']! as int;
    return GetFileDownloadedPrefixSize(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      offset: offset,
    );
  }
}

/// Stops the downloading of a file. If a file has already been downloaded, does nothing.
///
/// Returns [Ok].
class CancelDownloadFile extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "cancelDownloadFile";

  /// Identifier of a file to stop downloading.
  late int file_id;

  /// Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server.
  late bool only_if_pending;

  /// Stops the downloading of a file. If a file has already been downloaded, does nothing
  ///
  /// Returns [Ok]
  CancelDownloadFile(
      {required this.file_id,
      required this.only_if_pending,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'cancelDownloadFile',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'only_if_pending': only_if_pending
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CancelDownloadFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var only_if_pending = _map['only_if_pending']! as bool;
    return CancelDownloadFile(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      only_if_pending: only_if_pending,
    );
  }
}

/// Returns suggested name for saving a file in a given directory.
///
/// Returns [Text].
class GetSuggestedFileName extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSuggestedFileName";

  /// Identifier of the file.
  late int file_id;

  /// Directory in which the file is supposed to be saved.
  late String directory;

  /// Returns suggested name for saving a file in a given directory
  ///
  /// Returns [Text]
  GetSuggestedFileName(
      {required this.file_id,
      required this.directory,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getSuggestedFileName',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'directory': directory
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSuggestedFileName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var directory = _map['directory']! as String;
    return GetSuggestedFileName(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      directory: directory,
    );
  }
}

/// Preliminary uploads a file to the cloud before sending it in a message, which can be useful for uploading of being recorded voice and video notes. Updates updateFile will be used.
///
/// Returns [File].
class PreliminaryUploadFile extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "preliminaryUploadFile";

  /// File to upload.
  late InputFile file;

  /// File type; pass null if unknown.
  FileType? file_type;

  /// Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which preliminaryUploadFile was called will be uploaded first.
  late int priority;

  /// Preliminary uploads a file to the cloud before sending it in a message, which can be useful for uploading of being recorded voice and video notes. Updates updateFile will be used
  ///
  /// Returns [File]
  PreliminaryUploadFile(
      {required this.file,
      this.file_type,
      required this.priority,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'preliminaryUploadFile',
      if (extra != null) '@extra': extra,
      'file': file,
      'file_type': file_type,
      'priority': priority
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PreliminaryUploadFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file = InputFile.fromMap(_map['file'])!;
    var file_type = FileType.fromMap(_map['file_type']);
    var priority = _map['priority']! as int;
    return PreliminaryUploadFile(
      extra: extra,
      clientId: clientId,
      file: file,
      file_type: file_type,
      priority: priority,
    );
  }
}

/// Stops the preliminary uploading of a file. Supported only for files uploaded by using preliminaryUploadFile. For other files the behavior is undefined.
///
/// Returns [Ok].
class CancelPreliminaryUploadFile extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "cancelPreliminaryUploadFile";

  /// Identifier of the file to stop uploading.
  late int file_id;

  /// Stops the preliminary uploading of a file. Supported only for files uploaded by using preliminaryUploadFile. For other files the behavior is undefined
  ///
  /// Returns [Ok]
  CancelPreliminaryUploadFile(
      {required this.file_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'cancelPreliminaryUploadFile',
      if (extra != null) '@extra': extra,
      'file_id': file_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CancelPreliminaryUploadFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    return CancelPreliminaryUploadFile(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
    );
  }
}

/// Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file.
///
/// Returns [Ok].
class WriteGeneratedFilePart extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "writeGeneratedFilePart";

  /// The identifier of the generation process.
  /// ; string representation of int, use `int.parse`
  late int64 generation_id;

  /// The offset from which to write the data to the file.
  late int offset;

  /// The data to write.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
  ///
  /// Returns [Ok]
  WriteGeneratedFilePart(
      {required this.generation_id,
      required this.offset,
      required this.data,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'writeGeneratedFilePart',
      if (extra != null) '@extra': extra,
      'generation_id': generation_id,
      'offset': offset,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static WriteGeneratedFilePart? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var generation_id = _map['generation_id']! as int64;
    var offset = _map['offset']! as int;
    var data = _map['data']! as bytes;
    return WriteGeneratedFilePart(
      extra: extra,
      clientId: clientId,
      generation_id: generation_id,
      offset: offset,
      data: data,
    );
  }
}

/// Informs TDLib on a file generation progress.
///
/// Returns [Ok].
class SetFileGenerationProgress extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setFileGenerationProgress";

  /// The identifier of the generation process.
  /// ; string representation of int, use `int.parse`
  late int64 generation_id;

  /// Expected size of the generated file, in bytes; 0 if unknown.
  late int expected_size;

  /// The number of bytes already generated.
  late int local_prefix_size;

  /// Informs TDLib on a file generation progress
  ///
  /// Returns [Ok]
  SetFileGenerationProgress(
      {required this.generation_id,
      required this.expected_size,
      required this.local_prefix_size,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setFileGenerationProgress',
      if (extra != null) '@extra': extra,
      'generation_id': generation_id,
      'expected_size': expected_size,
      'local_prefix_size': local_prefix_size
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetFileGenerationProgress? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var generation_id = _map['generation_id']! as int64;
    var expected_size = _map['expected_size']! as int;
    var local_prefix_size = _map['local_prefix_size']! as int;
    return SetFileGenerationProgress(
      extra: extra,
      clientId: clientId,
      generation_id: generation_id,
      expected_size: expected_size,
      local_prefix_size: local_prefix_size,
    );
  }
}

/// Finishes the file generation.
///
/// Returns [Ok].
class FinishFileGeneration extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "finishFileGeneration";

  /// The identifier of the generation process.
  /// ; string representation of int, use `int.parse`
  late int64 generation_id;

  /// If passed, the file generation has failed and must be terminated; pass null if the file generation succeeded.
  Error? error;

  /// Finishes the file generation
  ///
  /// Returns [Ok]
  FinishFileGeneration(
      {required this.generation_id, this.error, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'finishFileGeneration',
      if (extra != null) '@extra': extra,
      'generation_id': generation_id,
      'error': error
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static FinishFileGeneration? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var generation_id = _map['generation_id']! as int64;
    var error = Error.fromMap(_map['error']);
    return FinishFileGeneration(
      extra: extra,
      clientId: clientId,
      generation_id: generation_id,
      error: error,
    );
  }
}

/// Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file.
///
/// Returns [FilePart].
class ReadFilePart extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "readFilePart";

  /// Identifier of the file. The file must be located in the TDLib file cache.
  late int file_id;

  /// The offset from which to read the file.
  late int offset;

  /// Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position.
  late int count;

  /// Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
  ///
  /// Returns [FilePart]
  ReadFilePart(
      {required this.file_id,
      required this.offset,
      required this.count,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'readFilePart',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'offset': offset,
      'count': count
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReadFilePart? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var offset = _map['offset']! as int;
    var count = _map['count']! as int;
    return ReadFilePart(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      offset: offset,
      count: count,
    );
  }
}

/// Deletes a file from the TDLib file cache.
///
/// Returns [Ok].
class DeleteFile extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteFile";

  /// Identifier of the file to delete.
  late int file_id;

  /// Deletes a file from the TDLib file cache
  ///
  /// Returns [Ok]
  DeleteFile({required this.file_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteFile',
      if (extra != null) '@extra': extra,
      'file_id': file_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    return DeleteFile(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
    );
  }
}

/// Adds a file from a message to the list of file downloads. Download progress and completion of the download will be notified through updateFile updates..
///
/// Returns [File].
class AddFileToDownloads extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addFileToDownloads";

  /// Identifier of the file to download.
  late int file_id;

  /// Chat identifier of the message with the file.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile/addFileToDownloads was called will be downloaded first.
  late int priority;

  /// Adds a file from a message to the list of file downloads. Download progress and completion of the download will be notified through updateFile updates.
  ///
  /// Returns [File]
  AddFileToDownloads(
      {required this.file_id,
      required this.chat_id,
      required this.message_id,
      required this.priority,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addFileToDownloads',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'chat_id': chat_id,
      'message_id': message_id,
      'priority': priority
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddFileToDownloads? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var priority = _map['priority']! as int;
    return AddFileToDownloads(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      chat_id: chat_id,
      message_id: message_id,
      priority: priority,
    );
  }
}

/// Changes pause state of a file in the file download list.
///
/// Returns [Ok].
class ToggleDownloadIsPaused extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleDownloadIsPaused";

  /// Identifier of the downloaded file.
  late int file_id;

  /// Pass true if the download is paused.
  late bool is_paused;

  /// Changes pause state of a file in the file download list
  ///
  /// Returns [Ok]
  ToggleDownloadIsPaused(
      {required this.file_id,
      required this.is_paused,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleDownloadIsPaused',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'is_paused': is_paused
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleDownloadIsPaused? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var is_paused = _map['is_paused']! as bool;
    return ToggleDownloadIsPaused(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      is_paused: is_paused,
    );
  }
}

/// Changes pause state of all files in the file download list.
///
/// Returns [Ok].
class ToggleAllDownloadsArePaused extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleAllDownloadsArePaused";

  /// Pass true to pause all downloads; pass false to unpause them.
  late bool are_paused;

  /// Changes pause state of all files in the file download list
  ///
  /// Returns [Ok]
  ToggleAllDownloadsArePaused(
      {required this.are_paused, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleAllDownloadsArePaused',
      if (extra != null) '@extra': extra,
      'are_paused': are_paused
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleAllDownloadsArePaused? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var are_paused = _map['are_paused']! as bool;
    return ToggleAllDownloadsArePaused(
      extra: extra,
      clientId: clientId,
      are_paused: are_paused,
    );
  }
}

/// Removes a file from the file download list.
///
/// Returns [Ok].
class RemoveFileFromDownloads extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeFileFromDownloads";

  /// Identifier of the downloaded file.
  late int file_id;

  /// Pass true to delete the file from the TDLib file cache.
  late bool delete_from_cache;

  /// Removes a file from the file download list
  ///
  /// Returns [Ok]
  RemoveFileFromDownloads(
      {required this.file_id,
      required this.delete_from_cache,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeFileFromDownloads',
      if (extra != null) '@extra': extra,
      'file_id': file_id,
      'delete_from_cache': delete_from_cache
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveFileFromDownloads? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    var delete_from_cache = _map['delete_from_cache']! as bool;
    return RemoveFileFromDownloads(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
      delete_from_cache: delete_from_cache,
    );
  }
}

/// Removes all files from the file download list.
///
/// Returns [Ok].
class RemoveAllFilesFromDownloads extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeAllFilesFromDownloads";

  /// Pass true to remove only active downloads, including paused.
  late bool only_active;

  /// Pass true to remove only completed downloads.
  late bool only_completed;

  /// Pass true to delete the file from the TDLib file cache.
  late bool delete_from_cache;

  /// Removes all files from the file download list
  ///
  /// Returns [Ok]
  RemoveAllFilesFromDownloads(
      {required this.only_active,
      required this.only_completed,
      required this.delete_from_cache,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeAllFilesFromDownloads',
      if (extra != null) '@extra': extra,
      'only_active': only_active,
      'only_completed': only_completed,
      'delete_from_cache': delete_from_cache
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveAllFilesFromDownloads? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var only_active = _map['only_active']! as bool;
    var only_completed = _map['only_completed']! as bool;
    var delete_from_cache = _map['delete_from_cache']! as bool;
    return RemoveAllFilesFromDownloads(
      extra: extra,
      clientId: clientId,
      only_active: only_active,
      only_completed: only_completed,
      delete_from_cache: delete_from_cache,
    );
  }
}

/// Searches for files in the file download list or recently downloaded files from the list.
///
/// Returns [FoundFileDownloads].
class SearchFileDownloads extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchFileDownloads";

  /// Query to search for; may be empty to return all downloaded files.
  late String query;

  /// Pass true to search only for active downloads, including paused.
  late bool only_active;

  /// Pass true to search only for completed downloads.
  late bool only_completed;

  /// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results.
  late String offset;

  /// The maximum number of files to be returned.
  late int limit;

  /// Searches for files in the file download list or recently downloaded files from the list
  ///
  /// Returns [FoundFileDownloads]
  SearchFileDownloads(
      {required this.query,
      required this.only_active,
      required this.only_completed,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchFileDownloads',
      if (extra != null) '@extra': extra,
      'query': query,
      'only_active': only_active,
      'only_completed': only_completed,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchFileDownloads? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    var only_active = _map['only_active']! as bool;
    var only_completed = _map['only_completed']! as bool;
    var offset = _map['offset']! as String;
    var limit = _map['limit']! as int;
    return SearchFileDownloads(
      extra: extra,
      clientId: clientId,
      query: query,
      only_active: only_active,
      only_completed: only_completed,
      offset: offset,
      limit: limit,
    );
  }
}

/// Returns information about a file with messages exported from another application.
///
/// Returns [MessageFileType].
class GetMessageFileType extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageFileType";

  /// Beginning of the message file; up to 100 first lines.
  late String message_file_head;

  /// Returns information about a file with messages exported from another application
  ///
  /// Returns [MessageFileType]
  GetMessageFileType(
      {required this.message_file_head, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageFileType',
      if (extra != null) '@extra': extra,
      'message_file_head': message_file_head
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageFileType? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_file_head = _map['message_file_head']! as String;
    return GetMessageFileType(
      extra: extra,
      clientId: clientId,
      message_file_head: message_file_head,
    );
  }
}

/// Returns a confirmation text to be shown to the user before starting message import.
///
/// Returns [Text].
class GetMessageImportConfirmationText extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageImportConfirmationText";

  /// Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right.
  late int chat_id;

  /// Returns a confirmation text to be shown to the user before starting message import
  ///
  /// Returns [Text]
  GetMessageImportConfirmationText(
      {required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageImportConfirmationText',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageImportConfirmationText? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetMessageImportConfirmationText(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Imports messages exported from another app.
///
/// Returns [Ok].
class ImportMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "importMessages";

  /// Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right.
  late int chat_id;

  /// File with messages to import. Only inputFileLocal and inputFileGenerated are supported. The file must not be previously uploaded.
  late InputFile message_file;

  /// Files used in the imported messages. Only inputFileLocal and inputFileGenerated are supported. The files must not be previously uploaded.
  late List<InputFile> attached_files;

  /// Imports messages exported from another app
  ///
  /// Returns [Ok]
  ImportMessages(
      {required this.chat_id,
      required this.message_file,
      required this.attached_files,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'importMessages',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_file': message_file,
      'attached_files': attached_files
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ImportMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_file = InputFile.fromMap(_map['message_file'])!;
    var attached_files = List<InputFile>.from(
      (_map["attached_files"] ?? []).map(
        (e) => InputFile.fromMap(e),
      ),
    );
    return ImportMessages(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_file: message_file,
      attached_files: attached_files,
    );
  }
}

/// Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right.
///
/// Returns [ChatInviteLink].
class ReplacePrimaryChatInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "replacePrimaryChatInviteLink";

  /// Chat identifier.
  late int chat_id;

  /// Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
  ///
  /// Returns [ChatInviteLink]
  ReplacePrimaryChatInviteLink(
      {required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'replacePrimaryChatInviteLink',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReplacePrimaryChatInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return ReplacePrimaryChatInviteLink(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat.
///
/// Returns [ChatInviteLink].
class CreateChatInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createChatInviteLink";

  /// Chat identifier.
  late int chat_id;

  /// Invite link name; 0-32 characters.
  late String name;

  /// Point in time (Unix timestamp) when the link will expire; pass 0 if never.
  late int expiration_date;

  /// The maximum number of chat members that can join the chat via the link simultaneously; 0-99999; pass 0 if not limited.
  late int member_limit;

  /// Pass true if users joining the chat via the link need to be approved by chat administrators. In this case, member_limit must be 0.
  late bool creates_join_request;

  /// Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat
  ///
  /// Returns [ChatInviteLink]
  CreateChatInviteLink(
      {required this.chat_id,
      required this.name,
      required this.expiration_date,
      required this.member_limit,
      required this.creates_join_request,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createChatInviteLink',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'name': name,
      'expiration_date': expiration_date,
      'member_limit': member_limit,
      'creates_join_request': creates_join_request
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateChatInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var name = _map['name']! as String;
    var expiration_date = _map['expiration_date']! as int;
    var member_limit = _map['member_limit']! as int;
    var creates_join_request = _map['creates_join_request']! as bool;
    return CreateChatInviteLink(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      name: name,
      expiration_date: expiration_date,
      member_limit: member_limit,
      creates_join_request: creates_join_request,
    );
  }
}

/// Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
///
/// Returns [ChatInviteLink].
class EditChatInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editChatInviteLink";

  /// Chat identifier.
  late int chat_id;

  /// Invite link to be edited.
  late String invite_link;

  /// Invite link name; 0-32 characters.
  late String name;

  /// Point in time (Unix timestamp) when the link will expire; pass 0 if never.
  late int expiration_date;

  /// The maximum number of chat members that can join the chat via the link simultaneously; 0-99999; pass 0 if not limited.
  late int member_limit;

  /// Pass true if users joining the chat via the link need to be approved by chat administrators. In this case, member_limit must be 0.
  late bool creates_join_request;

  /// Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
  ///
  /// Returns [ChatInviteLink]
  EditChatInviteLink(
      {required this.chat_id,
      required this.invite_link,
      required this.name,
      required this.expiration_date,
      required this.member_limit,
      required this.creates_join_request,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editChatInviteLink',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'invite_link': invite_link,
      'name': name,
      'expiration_date': expiration_date,
      'member_limit': member_limit,
      'creates_join_request': creates_join_request
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditChatInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var invite_link = _map['invite_link']! as String;
    var name = _map['name']! as String;
    var expiration_date = _map['expiration_date']! as int;
    var member_limit = _map['member_limit']! as int;
    var creates_join_request = _map['creates_join_request']! as bool;
    return EditChatInviteLink(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      invite_link: invite_link,
      name: name,
      expiration_date: expiration_date,
      member_limit: member_limit,
      creates_join_request: creates_join_request,
    );
  }
}

/// Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links.
///
/// Returns [ChatInviteLink].
class GetChatInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatInviteLink";

  /// Chat identifier.
  late int chat_id;

  /// Invite link to get.
  late String invite_link;

  /// Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
  ///
  /// Returns [ChatInviteLink]
  GetChatInviteLink(
      {required this.chat_id,
      required this.invite_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatInviteLink',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var invite_link = _map['invite_link']! as String;
    return GetChatInviteLink(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      invite_link: invite_link,
    );
  }
}

/// Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat.
///
/// Returns [ChatInviteLinkCounts].
class GetChatInviteLinkCounts extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatInviteLinkCounts";

  /// Chat identifier.
  late int chat_id;

  /// Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat
  ///
  /// Returns [ChatInviteLinkCounts]
  GetChatInviteLinkCounts({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatInviteLinkCounts',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatInviteLinkCounts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetChatInviteLinkCounts(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links.
///
/// Returns [ChatInviteLinks].
class GetChatInviteLinks extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatInviteLinks";

  /// Chat identifier.
  late int chat_id;

  /// User identifier of a chat administrator. Must be an identifier of the current user for non-owner.
  late int creator_user_id;

  /// Pass true if revoked links needs to be returned instead of active or expired.
  late bool is_revoked;

  /// Creation date of an invite link starting after which to return invite links; use 0 to get results from the beginning.
  late int offset_date;

  /// Invite link starting after which to return invite links; use empty string to get results from the beginning.
  late String offset_invite_link;

  /// The maximum number of invite links to return; up to 100.
  late int limit;

  /// Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
  ///
  /// Returns [ChatInviteLinks]
  GetChatInviteLinks(
      {required this.chat_id,
      required this.creator_user_id,
      required this.is_revoked,
      required this.offset_date,
      required this.offset_invite_link,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatInviteLinks',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'creator_user_id': creator_user_id,
      'is_revoked': is_revoked,
      'offset_date': offset_date,
      'offset_invite_link': offset_invite_link,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatInviteLinks? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var creator_user_id = _map['creator_user_id']! as int;
    var is_revoked = _map['is_revoked']! as bool;
    var offset_date = _map['offset_date']! as int;
    var offset_invite_link = _map['offset_invite_link']! as String;
    var limit = _map['limit']! as int;
    return GetChatInviteLinks(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      creator_user_id: creator_user_id,
      is_revoked: is_revoked,
      offset_date: offset_date,
      offset_invite_link: offset_invite_link,
      limit: limit,
    );
  }
}

/// Returns chat members joined a chat via an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
///
/// Returns [ChatInviteLinkMembers].
class GetChatInviteLinkMembers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatInviteLinkMembers";

  /// Chat identifier.
  late int chat_id;

  /// Invite link for which to return chat members.
  late String invite_link;

  /// A chat member from which to return next chat members; pass null to get results from the beginning.
  ChatInviteLinkMember? offset_member;

  /// The maximum number of chat members to return; up to 100.
  late int limit;

  /// Returns chat members joined a chat via an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
  ///
  /// Returns [ChatInviteLinkMembers]
  GetChatInviteLinkMembers(
      {required this.chat_id,
      required this.invite_link,
      this.offset_member,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatInviteLinkMembers',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'invite_link': invite_link,
      'offset_member': offset_member,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatInviteLinkMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var invite_link = _map['invite_link']! as String;
    var offset_member = ChatInviteLinkMember.fromMap(_map['offset_member']);
    var limit = _map['limit']! as int;
    return GetChatInviteLinkMembers(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      invite_link: invite_link,
      offset_member: offset_member,
      limit: limit,
    );
  }
}

/// Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links..
///
/// Returns [ChatInviteLinks].
class RevokeChatInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "revokeChatInviteLink";

  /// Chat identifier.
  late int chat_id;

  /// Invite link to be revoked.
  late String invite_link;

  /// Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
  ///
  /// Returns [ChatInviteLinks]
  RevokeChatInviteLink(
      {required this.chat_id,
      required this.invite_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'revokeChatInviteLink',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RevokeChatInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var invite_link = _map['invite_link']! as String;
    return RevokeChatInviteLink(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      invite_link: invite_link,
    );
  }
}

/// Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
///
/// Returns [Ok].
class DeleteRevokedChatInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteRevokedChatInviteLink";

  /// Chat identifier.
  late int chat_id;

  /// Invite link to revoke.
  late String invite_link;

  /// Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
  ///
  /// Returns [Ok]
  DeleteRevokedChatInviteLink(
      {required this.chat_id,
      required this.invite_link,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteRevokedChatInviteLink',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteRevokedChatInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var invite_link = _map['invite_link']! as String;
    return DeleteRevokedChatInviteLink(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      invite_link: invite_link,
    );
  }
}

/// Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
///
/// Returns [Ok].
class DeleteAllRevokedChatInviteLinks extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteAllRevokedChatInviteLinks";

  /// Chat identifier.
  late int chat_id;

  /// User identifier of a chat administrator, which links will be deleted. Must be an identifier of the current user for non-owner.
  late int creator_user_id;

  /// Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
  ///
  /// Returns [Ok]
  DeleteAllRevokedChatInviteLinks(
      {required this.chat_id,
      required this.creator_user_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteAllRevokedChatInviteLinks',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'creator_user_id': creator_user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteAllRevokedChatInviteLinks? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var creator_user_id = _map['creator_user_id']! as int;
    return DeleteAllRevokedChatInviteLinks(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      creator_user_id: creator_user_id,
    );
  }
}

/// Checks the validity of an invite link for a chat and returns information about the corresponding chat.
///
/// Returns [ChatInviteLinkInfo].
class CheckChatInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkChatInviteLink";

  /// Invite link to be checked.
  late String invite_link;

  /// Checks the validity of an invite link for a chat and returns information about the corresponding chat
  ///
  /// Returns [ChatInviteLinkInfo]
  CheckChatInviteLink({required this.invite_link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChatInviteLink',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChatInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = _map['invite_link']! as String;
    return CheckChatInviteLink(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
    );
  }
}

/// Uses an invite link to add the current user to the chat if possible. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created.
///
/// Returns [Chat].
class JoinChatByInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "joinChatByInviteLink";

  /// Invite link to use.
  late String invite_link;

  /// Uses an invite link to add the current user to the chat if possible. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
  ///
  /// Returns [Chat]
  JoinChatByInviteLink({required this.invite_link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'joinChatByInviteLink',
      if (extra != null) '@extra': extra,
      'invite_link': invite_link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JoinChatByInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invite_link = _map['invite_link']! as String;
    return JoinChatByInviteLink(
      extra: extra,
      clientId: clientId,
      invite_link: invite_link,
    );
  }
}

/// Returns pending join requests in a chat.
///
/// Returns [ChatJoinRequests].
class GetChatJoinRequests extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatJoinRequests";

  /// Chat identifier.
  late int chat_id;

  /// Invite link for which to return join requests. If empty, all join requests will be returned. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
  String? invite_link;

  /// A query to search for in the first names, last names and usernames of the users to return.
  late String query;

  /// A chat join request from which to return next requests; pass null to get results from the beginning.
  ChatJoinRequest? offset_request;

  /// The maximum number of requests to join the chat to return.
  late int limit;

  /// Returns pending join requests in a chat
  ///
  /// Returns [ChatJoinRequests]
  GetChatJoinRequests(
      {required this.chat_id,
      this.invite_link,
      required this.query,
      this.offset_request,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatJoinRequests',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'invite_link': invite_link,
      'query': query,
      'offset_request': offset_request,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatJoinRequests? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var invite_link = _map['invite_link'] as String?;
    var query = _map['query']! as String;
    var offset_request = ChatJoinRequest.fromMap(_map['offset_request']);
    var limit = _map['limit']! as int;
    return GetChatJoinRequests(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      invite_link: invite_link,
      query: query,
      offset_request: offset_request,
      limit: limit,
    );
  }
}

/// Handles a pending join request in a chat.
///
/// Returns [Ok].
class ProcessChatJoinRequest extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "processChatJoinRequest";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the user that sent the request.
  late int user_id;

  /// Pass true to approve the request; pass false to decline it.
  late bool approve;

  /// Handles a pending join request in a chat
  ///
  /// Returns [Ok]
  ProcessChatJoinRequest(
      {required this.chat_id,
      required this.user_id,
      required this.approve,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'processChatJoinRequest',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'user_id': user_id,
      'approve': approve
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ProcessChatJoinRequest? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var user_id = _map['user_id']! as int;
    var approve = _map['approve']! as bool;
    return ProcessChatJoinRequest(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      user_id: user_id,
      approve: approve,
    );
  }
}

/// Handles all pending join requests for a given link in a chat.
///
/// Returns [Ok].
class ProcessChatJoinRequests extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "processChatJoinRequests";

  /// Chat identifier.
  late int chat_id;

  /// Invite link for which to process join requests. If empty, all join requests will be processed. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
  String? invite_link;

  /// Pass true to approve all requests; pass false to decline them.
  late bool approve;

  /// Handles all pending join requests for a given link in a chat
  ///
  /// Returns [Ok]
  ProcessChatJoinRequests(
      {required this.chat_id,
      this.invite_link,
      required this.approve,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'processChatJoinRequests',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'invite_link': invite_link,
      'approve': approve
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ProcessChatJoinRequests? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var invite_link = _map['invite_link'] as String?;
    var approve = _map['approve']! as bool;
    return ProcessChatJoinRequests(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      invite_link: invite_link,
      approve: approve,
    );
  }
}

/// Creates a new call.
///
/// Returns [CallId].
class CreateCall extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createCall";

  /// Identifier of the user to be called.
  late int user_id;

  /// The call protocols supported by the application.
  late CallProtocol protocol;

  /// Pass true to create a video call.
  late bool is_video;

  /// Creates a new call
  ///
  /// Returns [CallId]
  CreateCall(
      {required this.user_id,
      required this.protocol,
      required this.is_video,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createCall',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'protocol': protocol,
      'is_video': is_video
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var protocol = CallProtocol.fromMap(_map['protocol'])!;
    var is_video = _map['is_video']! as bool;
    return CreateCall(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      protocol: protocol,
      is_video: is_video,
    );
  }
}

/// Accepts an incoming call.
///
/// Returns [Ok].
class AcceptCall extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "acceptCall";

  /// Call identifier.
  late int call_id;

  /// The call protocols supported by the application.
  late CallProtocol protocol;

  /// Accepts an incoming call
  ///
  /// Returns [Ok]
  AcceptCall(
      {required this.call_id,
      required this.protocol,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'acceptCall',
      if (extra != null) '@extra': extra,
      'call_id': call_id,
      'protocol': protocol
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AcceptCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var call_id = _map['call_id']! as int;
    var protocol = CallProtocol.fromMap(_map['protocol'])!;
    return AcceptCall(
      extra: extra,
      clientId: clientId,
      call_id: call_id,
      protocol: protocol,
    );
  }
}

/// Sends call signaling data.
///
/// Returns [Ok].
class SendCallSignalingData extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendCallSignalingData";

  /// Call identifier.
  late int call_id;

  /// The data.
  /// ; base64-encoded bytes `List<int>`
  late bytes data;

  /// Sends call signaling data
  ///
  /// Returns [Ok]
  SendCallSignalingData(
      {required this.call_id, required this.data, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendCallSignalingData',
      if (extra != null) '@extra': extra,
      'call_id': call_id,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendCallSignalingData? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var call_id = _map['call_id']! as int;
    var data = _map['data']! as bytes;
    return SendCallSignalingData(
      extra: extra,
      clientId: clientId,
      call_id: call_id,
      data: data,
    );
  }
}

/// Discards a call.
///
/// Returns [Ok].
class DiscardCall extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "discardCall";

  /// Call identifier.
  late int call_id;

  /// Pass true if the user was disconnected.
  late bool is_disconnected;

  /// The call duration, in seconds.
  late int duration;

  /// Pass true if the call was a video call.
  late bool is_video;

  /// Identifier of the connection used during the call.
  /// ; string representation of int, use `int.parse`
  late int64 connection_id;

  /// Discards a call
  ///
  /// Returns [Ok]
  DiscardCall(
      {required this.call_id,
      required this.is_disconnected,
      required this.duration,
      required this.is_video,
      required this.connection_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'discardCall',
      if (extra != null) '@extra': extra,
      'call_id': call_id,
      'is_disconnected': is_disconnected,
      'duration': duration,
      'is_video': is_video,
      'connection_id': connection_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DiscardCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var call_id = _map['call_id']! as int;
    var is_disconnected = _map['is_disconnected']! as bool;
    var duration = _map['duration']! as int;
    var is_video = _map['is_video']! as bool;
    var connection_id = _map['connection_id']! as int64;
    return DiscardCall(
      extra: extra,
      clientId: clientId,
      call_id: call_id,
      is_disconnected: is_disconnected,
      duration: duration,
      is_video: is_video,
      connection_id: connection_id,
    );
  }
}

/// Sends a call rating.
///
/// Returns [Ok].
class SendCallRating extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendCallRating";

  /// Call identifier.
  late int call_id;

  /// Call rating; 1-5.
  late int rating;

  /// An optional user comment if the rating is less than 5.
  late String comment;

  /// List of the exact types of problems with the call, specified by the user.
  late List<CallProblem> problems;

  /// Sends a call rating
  ///
  /// Returns [Ok]
  SendCallRating(
      {required this.call_id,
      required this.rating,
      required this.comment,
      required this.problems,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendCallRating',
      if (extra != null) '@extra': extra,
      'call_id': call_id,
      'rating': rating,
      'comment': comment,
      'problems': problems
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendCallRating? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var call_id = _map['call_id']! as int;
    var rating = _map['rating']! as int;
    var comment = _map['comment']! as String;
    var problems = List<CallProblem>.from(
      (_map["problems"] ?? []).map(
        (e) => CallProblem.fromMap(e),
      ),
    );
    return SendCallRating(
      extra: extra,
      clientId: clientId,
      call_id: call_id,
      rating: rating,
      comment: comment,
      problems: problems,
    );
  }
}

/// Sends debug information for a call to Telegram servers.
///
/// Returns [Ok].
class SendCallDebugInformation extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendCallDebugInformation";

  /// Call identifier.
  late int call_id;

  /// Debug information in application-specific format.
  late String debug_information;

  /// Sends debug information for a call to Telegram servers
  ///
  /// Returns [Ok]
  SendCallDebugInformation(
      {required this.call_id,
      required this.debug_information,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendCallDebugInformation',
      if (extra != null) '@extra': extra,
      'call_id': call_id,
      'debug_information': debug_information
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendCallDebugInformation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var call_id = _map['call_id']! as int;
    var debug_information = _map['debug_information']! as String;
    return SendCallDebugInformation(
      extra: extra,
      clientId: clientId,
      call_id: call_id,
      debug_information: debug_information,
    );
  }
}

/// Sends log file for a call to Telegram servers.
///
/// Returns [Ok].
class SendCallLog extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendCallLog";

  /// Call identifier.
  late int call_id;

  /// Call log file. Only inputFileLocal and inputFileGenerated are supported.
  late InputFile log_file;

  /// Sends log file for a call to Telegram servers
  ///
  /// Returns [Ok]
  SendCallLog(
      {required this.call_id,
      required this.log_file,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendCallLog',
      if (extra != null) '@extra': extra,
      'call_id': call_id,
      'log_file': log_file
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendCallLog? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var call_id = _map['call_id']! as int;
    var log_file = InputFile.fromMap(_map['log_file'])!;
    return SendCallLog(
      extra: extra,
      clientId: clientId,
      call_id: call_id,
      log_file: log_file,
    );
  }
}

/// Returns list of participant identifiers, on whose behalf a video chat in the chat can be joined.
///
/// Returns [MessageSenders].
class GetVideoChatAvailableParticipants extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getVideoChatAvailableParticipants";

  /// Chat identifier.
  late int chat_id;

  /// Returns list of participant identifiers, on whose behalf a video chat in the chat can be joined
  ///
  /// Returns [MessageSenders]
  GetVideoChatAvailableParticipants(
      {required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getVideoChatAvailableParticipants',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetVideoChatAvailableParticipants? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetVideoChatAvailableParticipants(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Changes default participant identifier, on whose behalf a video chat in the chat will be joined.
///
/// Returns [Ok].
class SetVideoChatDefaultParticipant extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setVideoChatDefaultParticipant";

  /// Chat identifier.
  late int chat_id;

  /// Default group call participant identifier to join the video chats.
  late MessageSender default_participant_id;

  /// Changes default participant identifier, on whose behalf a video chat in the chat will be joined
  ///
  /// Returns [Ok]
  SetVideoChatDefaultParticipant(
      {required this.chat_id,
      required this.default_participant_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setVideoChatDefaultParticipant',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'default_participant_id': default_participant_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetVideoChatDefaultParticipant? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var default_participant_id =
        MessageSender.fromMap(_map['default_participant_id'])!;
    return SetVideoChatDefaultParticipant(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      default_participant_id: default_participant_id,
    );
  }
}

/// Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights.
///
/// Returns [GroupCallId].
class CreateVideoChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createVideoChat";

  /// Identifier of a chat in which the video chat will be created.
  late int chat_id;

  /// Group call title; if empty, chat title will be used.
  String? title;

  /// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 to start the video chat immediately. The date must be at least 10 seconds and at most 8 days in the future.
  late int start_date;

  /// Pass true to create an RTMP stream instead of an ordinary video chat; requires creator privileges.
  late bool is_rtmp_stream;

  /// Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights
  ///
  /// Returns [GroupCallId]
  CreateVideoChat(
      {required this.chat_id,
      this.title,
      required this.start_date,
      required this.is_rtmp_stream,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createVideoChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'title': title,
      'start_date': start_date,
      'is_rtmp_stream': is_rtmp_stream
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateVideoChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var title = _map['title'] as String?;
    var start_date = _map['start_date']! as int;
    var is_rtmp_stream = _map['is_rtmp_stream']! as bool;
    return CreateVideoChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      title: title,
      start_date: start_date,
      is_rtmp_stream: is_rtmp_stream,
    );
  }
}

/// Returns RTMP URL for streaming to the chat; requires creator privileges.
///
/// Returns [RtmpUrl].
class GetVideoChatRtmpUrl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getVideoChatRtmpUrl";

  /// Chat identifier.
  late int chat_id;

  /// Returns RTMP URL for streaming to the chat; requires creator privileges
  ///
  /// Returns [RtmpUrl]
  GetVideoChatRtmpUrl({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getVideoChatRtmpUrl',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetVideoChatRtmpUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return GetVideoChatRtmpUrl(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Replaces the current RTMP URL for streaming to the chat; requires creator privileges.
///
/// Returns [RtmpUrl].
class ReplaceVideoChatRtmpUrl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "replaceVideoChatRtmpUrl";

  /// Chat identifier.
  late int chat_id;

  /// Replaces the current RTMP URL for streaming to the chat; requires creator privileges
  ///
  /// Returns [RtmpUrl]
  ReplaceVideoChatRtmpUrl({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'replaceVideoChatRtmpUrl',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReplaceVideoChatRtmpUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return ReplaceVideoChatRtmpUrl(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Returns information about a group call.
///
/// Returns [GroupCall].
class GetGroupCall extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getGroupCall";

  /// Group call identifier.
  late int group_call_id;

  /// Returns information about a group call
  ///
  /// Returns [GroupCall]
  GetGroupCall({required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getGroupCall',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetGroupCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return GetGroupCall(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// Starts a scheduled group call.
///
/// Returns [Ok].
class StartScheduledGroupCall extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "startScheduledGroupCall";

  /// Group call identifier.
  late int group_call_id;

  /// Starts a scheduled group call
  ///
  /// Returns [Ok]
  StartScheduledGroupCall(
      {required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'startScheduledGroupCall',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StartScheduledGroupCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return StartScheduledGroupCall(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// Toggles whether the current user will receive a notification when the group call will start; scheduled group calls only.
///
/// Returns [Ok].
class ToggleGroupCallEnabledStartNotification extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleGroupCallEnabledStartNotification";

  /// Group call identifier.
  late int group_call_id;

  /// New value of the enabled_start_notification setting.
  late bool enabled_start_notification;

  /// Toggles whether the current user will receive a notification when the group call will start; scheduled group calls only
  ///
  /// Returns [Ok]
  ToggleGroupCallEnabledStartNotification(
      {required this.group_call_id,
      required this.enabled_start_notification,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleGroupCallEnabledStartNotification',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'enabled_start_notification': enabled_start_notification
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleGroupCallEnabledStartNotification? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var enabled_start_notification =
        _map['enabled_start_notification']! as bool;
    return ToggleGroupCallEnabledStartNotification(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      enabled_start_notification: enabled_start_notification,
    );
  }
}

/// Joins an active group call. Returns join response payload for tgcalls.
///
/// Returns [Text].
class JoinGroupCall extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "joinGroupCall";

  /// Group call identifier.
  late int group_call_id;

  /// Identifier of a group call participant, which will be used to join the call; pass null to join as self; video chats only.
  MessageSender? participant_id;

  /// Caller audio channel synchronization source identifier; received from tgcalls.
  late int audio_source_id;

  /// Group call join payload; received from tgcalls.
  late String payload;

  /// Pass true to join the call with muted microphone.
  late bool is_muted;

  /// Pass true if the user's video is enabled.
  late bool is_my_video_enabled;

  /// If non-empty, invite hash to be used to join the group call without being muted by administrators.
  late String invite_hash;

  /// Joins an active group call. Returns join response payload for tgcalls
  ///
  /// Returns [Text]
  JoinGroupCall(
      {required this.group_call_id,
      this.participant_id,
      required this.audio_source_id,
      required this.payload,
      required this.is_muted,
      required this.is_my_video_enabled,
      required this.invite_hash,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'joinGroupCall',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'participant_id': participant_id,
      'audio_source_id': audio_source_id,
      'payload': payload,
      'is_muted': is_muted,
      'is_my_video_enabled': is_my_video_enabled,
      'invite_hash': invite_hash
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static JoinGroupCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var participant_id = MessageSender.fromMap(_map['participant_id']);
    var audio_source_id = _map['audio_source_id']! as int;
    var payload = _map['payload']! as String;
    var is_muted = _map['is_muted']! as bool;
    var is_my_video_enabled = _map['is_my_video_enabled']! as bool;
    var invite_hash = _map['invite_hash']! as String;
    return JoinGroupCall(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      participant_id: participant_id,
      audio_source_id: audio_source_id,
      payload: payload,
      is_muted: is_muted,
      is_my_video_enabled: is_my_video_enabled,
      invite_hash: invite_hash,
    );
  }
}

/// Starts screen sharing in a joined group call. Returns join response payload for tgcalls.
///
/// Returns [Text].
class StartGroupCallScreenSharing extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "startGroupCallScreenSharing";

  /// Group call identifier.
  late int group_call_id;

  /// Screen sharing audio channel synchronization source identifier; received from tgcalls.
  late int audio_source_id;

  /// Group call join payload; received from tgcalls.
  late String payload;

  /// Starts screen sharing in a joined group call. Returns join response payload for tgcalls
  ///
  /// Returns [Text]
  StartGroupCallScreenSharing(
      {required this.group_call_id,
      required this.audio_source_id,
      required this.payload,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'startGroupCallScreenSharing',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'audio_source_id': audio_source_id,
      'payload': payload
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StartGroupCallScreenSharing? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var audio_source_id = _map['audio_source_id']! as int;
    var payload = _map['payload']! as String;
    return StartGroupCallScreenSharing(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      audio_source_id: audio_source_id,
      payload: payload,
    );
  }
}

/// Pauses or unpauses screen sharing in a joined group call.
///
/// Returns [Ok].
class ToggleGroupCallScreenSharingIsPaused extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleGroupCallScreenSharingIsPaused";

  /// Group call identifier.
  late int group_call_id;

  /// Pass true to pause screen sharing; pass false to unpause it.
  late bool is_paused;

  /// Pauses or unpauses screen sharing in a joined group call
  ///
  /// Returns [Ok]
  ToggleGroupCallScreenSharingIsPaused(
      {required this.group_call_id,
      required this.is_paused,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleGroupCallScreenSharingIsPaused',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'is_paused': is_paused
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleGroupCallScreenSharingIsPaused? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var is_paused = _map['is_paused']! as bool;
    return ToggleGroupCallScreenSharingIsPaused(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      is_paused: is_paused,
    );
  }
}

/// Ends screen sharing in a joined group call.
///
/// Returns [Ok].
class EndGroupCallScreenSharing extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "endGroupCallScreenSharing";

  /// Group call identifier.
  late int group_call_id;

  /// Ends screen sharing in a joined group call
  ///
  /// Returns [Ok]
  EndGroupCallScreenSharing(
      {required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'endGroupCallScreenSharing',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EndGroupCallScreenSharing? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return EndGroupCallScreenSharing(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// Sets group call title. Requires groupCall.can_be_managed group call flag.
///
/// Returns [Ok].
class SetGroupCallTitle extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setGroupCallTitle";

  /// Group call identifier.
  late int group_call_id;

  /// New group call title; 1-64 characters.
  late String title;

  /// Sets group call title. Requires groupCall.can_be_managed group call flag
  ///
  /// Returns [Ok]
  SetGroupCallTitle(
      {required this.group_call_id,
      required this.title,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setGroupCallTitle',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetGroupCallTitle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var title = _map['title']! as String;
    return SetGroupCallTitle(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      title: title,
    );
  }
}

/// Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag.
///
/// Returns [Ok].
class ToggleGroupCallMuteNewParticipants extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleGroupCallMuteNewParticipants";

  /// Group call identifier.
  late int group_call_id;

  /// New value of the mute_new_participants setting.
  late bool mute_new_participants;

  /// Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag
  ///
  /// Returns [Ok]
  ToggleGroupCallMuteNewParticipants(
      {required this.group_call_id,
      required this.mute_new_participants,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleGroupCallMuteNewParticipants',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'mute_new_participants': mute_new_participants
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleGroupCallMuteNewParticipants? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var mute_new_participants = _map['mute_new_participants']! as bool;
    return ToggleGroupCallMuteNewParticipants(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      mute_new_participants: mute_new_participants,
    );
  }
}

/// Invites users to an active group call. Sends a service message of type messageInviteVideoChatParticipants for video chats.
///
/// Returns [Ok].
class InviteGroupCallParticipants extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "inviteGroupCallParticipants";

  /// Group call identifier.
  late int group_call_id;

  /// User identifiers. At most 10 users can be invited simultaneously.
  late List<int> user_ids;

  /// Invites users to an active group call. Sends a service message of type messageInviteVideoChatParticipants for video chats
  ///
  /// Returns [Ok]
  InviteGroupCallParticipants(
      {required this.group_call_id,
      required this.user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'inviteGroupCallParticipants',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static InviteGroupCallParticipants? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return InviteGroupCallParticipants(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      user_ids: user_ids,
    );
  }
}

/// Returns invite link to a video chat in a public chat.
///
/// Returns [HttpUrl].
class GetGroupCallInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getGroupCallInviteLink";

  /// Group call identifier.
  late int group_call_id;

  /// Pass true if the invite link needs to contain an invite hash, passing which to joinGroupCall would allow the invited user to unmute themselves. Requires groupCall.can_be_managed group call flag.
  late bool can_self_unmute;

  /// Returns invite link to a video chat in a public chat
  ///
  /// Returns [HttpUrl]
  GetGroupCallInviteLink(
      {required this.group_call_id,
      required this.can_self_unmute,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getGroupCallInviteLink',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'can_self_unmute': can_self_unmute
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetGroupCallInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var can_self_unmute = _map['can_self_unmute']! as bool;
    return GetGroupCallInviteLink(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      can_self_unmute: can_self_unmute,
    );
  }
}

/// Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag.
///
/// Returns [Ok].
class RevokeGroupCallInviteLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "revokeGroupCallInviteLink";

  /// Group call identifier.
  late int group_call_id;

  /// Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag
  ///
  /// Returns [Ok]
  RevokeGroupCallInviteLink(
      {required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'revokeGroupCallInviteLink',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RevokeGroupCallInviteLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return RevokeGroupCallInviteLink(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// Starts recording of an active group call. Requires groupCall.can_be_managed group call flag.
///
/// Returns [Ok].
class StartGroupCallRecording extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "startGroupCallRecording";

  /// Group call identifier.
  late int group_call_id;

  /// Group call recording title; 0-64 characters.
  late String title;

  /// Pass true to record a video file instead of an audio file.
  late bool record_video;

  /// Pass true to use portrait orientation for video instead of landscape one.
  late bool use_portrait_orientation;

  /// Starts recording of an active group call. Requires groupCall.can_be_managed group call flag
  ///
  /// Returns [Ok]
  StartGroupCallRecording(
      {required this.group_call_id,
      required this.title,
      required this.record_video,
      required this.use_portrait_orientation,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'startGroupCallRecording',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'title': title,
      'record_video': record_video,
      'use_portrait_orientation': use_portrait_orientation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static StartGroupCallRecording? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var title = _map['title']! as String;
    var record_video = _map['record_video']! as bool;
    var use_portrait_orientation = _map['use_portrait_orientation']! as bool;
    return StartGroupCallRecording(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      title: title,
      record_video: record_video,
      use_portrait_orientation: use_portrait_orientation,
    );
  }
}

/// Ends recording of an active group call. Requires groupCall.can_be_managed group call flag.
///
/// Returns [Ok].
class EndGroupCallRecording extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "endGroupCallRecording";

  /// Group call identifier.
  late int group_call_id;

  /// Ends recording of an active group call. Requires groupCall.can_be_managed group call flag
  ///
  /// Returns [Ok]
  EndGroupCallRecording(
      {required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'endGroupCallRecording',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EndGroupCallRecording? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return EndGroupCallRecording(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// Toggles whether current user's video is paused.
///
/// Returns [Ok].
class ToggleGroupCallIsMyVideoPaused extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleGroupCallIsMyVideoPaused";

  /// Group call identifier.
  late int group_call_id;

  /// Pass true if the current user's video is paused.
  late bool is_my_video_paused;

  /// Toggles whether current user's video is paused
  ///
  /// Returns [Ok]
  ToggleGroupCallIsMyVideoPaused(
      {required this.group_call_id,
      required this.is_my_video_paused,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleGroupCallIsMyVideoPaused',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'is_my_video_paused': is_my_video_paused
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleGroupCallIsMyVideoPaused? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var is_my_video_paused = _map['is_my_video_paused']! as bool;
    return ToggleGroupCallIsMyVideoPaused(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      is_my_video_paused: is_my_video_paused,
    );
  }
}

/// Toggles whether current user's video is enabled.
///
/// Returns [Ok].
class ToggleGroupCallIsMyVideoEnabled extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleGroupCallIsMyVideoEnabled";

  /// Group call identifier.
  late int group_call_id;

  /// Pass true if the current user's video is enabled.
  late bool is_my_video_enabled;

  /// Toggles whether current user's video is enabled
  ///
  /// Returns [Ok]
  ToggleGroupCallIsMyVideoEnabled(
      {required this.group_call_id,
      required this.is_my_video_enabled,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleGroupCallIsMyVideoEnabled',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'is_my_video_enabled': is_my_video_enabled
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleGroupCallIsMyVideoEnabled? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var is_my_video_enabled = _map['is_my_video_enabled']! as bool;
    return ToggleGroupCallIsMyVideoEnabled(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      is_my_video_enabled: is_my_video_enabled,
    );
  }
}

/// Informs TDLib that speaking state of a participant of an active group has changed.
///
/// Returns [Ok].
class SetGroupCallParticipantIsSpeaking extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setGroupCallParticipantIsSpeaking";

  /// Group call identifier.
  late int group_call_id;

  /// Group call participant's synchronization audio source identifier, or 0 for the current user.
  late int audio_source;

  /// Pass true if the user is speaking.
  late bool is_speaking;

  /// Informs TDLib that speaking state of a participant of an active group has changed
  ///
  /// Returns [Ok]
  SetGroupCallParticipantIsSpeaking(
      {required this.group_call_id,
      required this.audio_source,
      required this.is_speaking,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setGroupCallParticipantIsSpeaking',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'audio_source': audio_source,
      'is_speaking': is_speaking
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetGroupCallParticipantIsSpeaking? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var audio_source = _map['audio_source']! as int;
    var is_speaking = _map['is_speaking']! as bool;
    return SetGroupCallParticipantIsSpeaking(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      audio_source: audio_source,
      is_speaking: is_speaking,
    );
  }
}

/// Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves.
///
/// Returns [Ok].
class ToggleGroupCallParticipantIsMuted extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleGroupCallParticipantIsMuted";

  /// Group call identifier.
  late int group_call_id;

  /// Participant identifier.
  late MessageSender participant_id;

  /// Pass true to mute the user; pass false to unmute them.
  late bool is_muted;

  /// Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves
  ///
  /// Returns [Ok]
  ToggleGroupCallParticipantIsMuted(
      {required this.group_call_id,
      required this.participant_id,
      required this.is_muted,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleGroupCallParticipantIsMuted',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'participant_id': participant_id,
      'is_muted': is_muted
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleGroupCallParticipantIsMuted? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var participant_id = MessageSender.fromMap(_map['participant_id'])!;
    var is_muted = _map['is_muted']! as bool;
    return ToggleGroupCallParticipantIsMuted(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      participant_id: participant_id,
      is_muted: is_muted,
    );
  }
}

/// Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level.
///
/// Returns [Ok].
class SetGroupCallParticipantVolumeLevel extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setGroupCallParticipantVolumeLevel";

  /// Group call identifier.
  late int group_call_id;

  /// Participant identifier.
  late MessageSender participant_id;

  /// New participant's volume level; 1-20000 in hundreds of percents.
  late int volume_level;

  /// Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level
  ///
  /// Returns [Ok]
  SetGroupCallParticipantVolumeLevel(
      {required this.group_call_id,
      required this.participant_id,
      required this.volume_level,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setGroupCallParticipantVolumeLevel',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'participant_id': participant_id,
      'volume_level': volume_level
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetGroupCallParticipantVolumeLevel? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var participant_id = MessageSender.fromMap(_map['participant_id'])!;
    var volume_level = _map['volume_level']! as int;
    return SetGroupCallParticipantVolumeLevel(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      participant_id: participant_id,
      volume_level: volume_level,
    );
  }
}

/// Toggles whether a group call participant hand is rased.
///
/// Returns [Ok].
class ToggleGroupCallParticipantIsHandRaised extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleGroupCallParticipantIsHandRaised";

  /// Group call identifier.
  late int group_call_id;

  /// Participant identifier.
  late MessageSender participant_id;

  /// Pass true if the user's hand needs to be raised. Only self hand can be raised. Requires groupCall.can_be_managed group call flag to lower other's hand.
  late bool is_hand_raised;

  /// Toggles whether a group call participant hand is rased
  ///
  /// Returns [Ok]
  ToggleGroupCallParticipantIsHandRaised(
      {required this.group_call_id,
      required this.participant_id,
      required this.is_hand_raised,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleGroupCallParticipantIsHandRaised',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'participant_id': participant_id,
      'is_hand_raised': is_hand_raised
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleGroupCallParticipantIsHandRaised? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var participant_id = MessageSender.fromMap(_map['participant_id'])!;
    var is_hand_raised = _map['is_hand_raised']! as bool;
    return ToggleGroupCallParticipantIsHandRaised(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      participant_id: participant_id,
      is_hand_raised: is_hand_raised,
    );
  }
}

/// Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded.
///
/// Returns [Ok].
class LoadGroupCallParticipants extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "loadGroupCallParticipants";

  /// Group call identifier. The group call must be previously received through getGroupCall and must be joined or being joined.
  late int group_call_id;

  /// The maximum number of participants to load; up to 100.
  late int limit;

  /// Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded
  ///
  /// Returns [Ok]
  LoadGroupCallParticipants(
      {required this.group_call_id,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'loadGroupCallParticipants',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LoadGroupCallParticipants? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var limit = _map['limit']! as int;
    return LoadGroupCallParticipants(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      limit: limit,
    );
  }
}

/// Leaves a group call.
///
/// Returns [Ok].
class LeaveGroupCall extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "leaveGroupCall";

  /// Group call identifier.
  late int group_call_id;

  /// Leaves a group call
  ///
  /// Returns [Ok]
  LeaveGroupCall({required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'leaveGroupCall',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static LeaveGroupCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return LeaveGroupCall(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// Ends a group call. Requires groupCall.can_be_managed.
///
/// Returns [Ok].
class EndGroupCall extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "endGroupCall";

  /// Group call identifier.
  late int group_call_id;

  /// Ends a group call. Requires groupCall.can_be_managed
  ///
  /// Returns [Ok]
  EndGroupCall({required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'endGroupCall',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EndGroupCall? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return EndGroupCall(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// Returns information about available group call streams.
///
/// Returns [GroupCallStreams].
class GetGroupCallStreams extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getGroupCallStreams";

  /// Group call identifier.
  late int group_call_id;

  /// Returns information about available group call streams
  ///
  /// Returns [GroupCallStreams]
  GetGroupCallStreams({required this.group_call_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getGroupCallStreams',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetGroupCallStreams? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    return GetGroupCallStreams(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
    );
  }
}

/// Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video.
///
/// Returns [FilePart].
class GetGroupCallStreamSegment extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getGroupCallStreamSegment";

  /// Group call identifier.
  late int group_call_id;

  /// Point in time when the stream segment begins; Unix timestamp in milliseconds.
  late int time_offset;

  /// Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds.
  late int scale;

  /// Identifier of an audio/video channel to get as received from tgcalls.
  late int channel_id;

  /// Video quality as received from tgcalls; pass null to get the worst available quality.
  GroupCallVideoQuality? video_quality;

  /// Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video
  ///
  /// Returns [FilePart]
  GetGroupCallStreamSegment(
      {required this.group_call_id,
      required this.time_offset,
      required this.scale,
      required this.channel_id,
      this.video_quality,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getGroupCallStreamSegment',
      if (extra != null) '@extra': extra,
      'group_call_id': group_call_id,
      'time_offset': time_offset,
      'scale': scale,
      'channel_id': channel_id,
      'video_quality': video_quality
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetGroupCallStreamSegment? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var group_call_id = _map['group_call_id']! as int;
    var time_offset = _map['time_offset']! as int;
    var scale = _map['scale']! as int;
    var channel_id = _map['channel_id']! as int;
    var video_quality = GroupCallVideoQuality.fromMap(_map['video_quality']);
    return GetGroupCallStreamSegment(
      extra: extra,
      clientId: clientId,
      group_call_id: group_call_id,
      time_offset: time_offset,
      scale: scale,
      channel_id: channel_id,
      video_quality: video_quality,
    );
  }
}

/// Changes the block list of a message sender. Currently, only users and supergroup chats can be blocked.
///
/// Returns [Ok].
class SetMessageSenderBlockList extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setMessageSenderBlockList";

  /// Identifier of a message sender to block/unblock.
  late MessageSender sender_id;

  /// New block list for the message sender; pass null to unblock the message sender.
  BlockList? block_list;

  /// Changes the block list of a message sender. Currently, only users and supergroup chats can be blocked
  ///
  /// Returns [Ok]
  SetMessageSenderBlockList(
      {required this.sender_id, this.block_list, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setMessageSenderBlockList',
      if (extra != null) '@extra': extra,
      'sender_id': sender_id,
      'block_list': block_list
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetMessageSenderBlockList? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sender_id = MessageSender.fromMap(_map['sender_id'])!;
    var block_list = BlockList.fromMap(_map['block_list']);
    return SetMessageSenderBlockList(
      extra: extra,
      clientId: clientId,
      sender_id: sender_id,
      block_list: block_list,
    );
  }
}

/// Blocks an original sender of a message in the Replies chat.
///
/// Returns [Ok].
class BlockMessageSenderFromReplies extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "blockMessageSenderFromReplies";

  /// The identifier of an incoming message in the Replies chat.
  late int message_id;

  /// Pass true to delete the message.
  late bool delete_message;

  /// Pass true to delete all messages from the same sender.
  late bool delete_all_messages;

  /// Pass true to report the sender to the Telegram moderators.
  late bool report_spam;

  /// Blocks an original sender of a message in the Replies chat
  ///
  /// Returns [Ok]
  BlockMessageSenderFromReplies(
      {required this.message_id,
      required this.delete_message,
      required this.delete_all_messages,
      required this.report_spam,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'blockMessageSenderFromReplies',
      if (extra != null) '@extra': extra,
      'message_id': message_id,
      'delete_message': delete_message,
      'delete_all_messages': delete_all_messages,
      'report_spam': report_spam
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static BlockMessageSenderFromReplies? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_id = _map['message_id']! as int;
    var delete_message = _map['delete_message']! as bool;
    var delete_all_messages = _map['delete_all_messages']! as bool;
    var report_spam = _map['report_spam']! as bool;
    return BlockMessageSenderFromReplies(
      extra: extra,
      clientId: clientId,
      message_id: message_id,
      delete_message: delete_message,
      delete_all_messages: delete_all_messages,
      report_spam: report_spam,
    );
  }
}

/// Returns users and chats that were blocked by the current user.
///
/// Returns [MessageSenders].
class GetBlockedMessageSenders extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getBlockedMessageSenders";

  /// Block list from which to return users.
  late BlockList block_list;

  /// Number of users and chats to skip in the result; must be non-negative.
  late int offset;

  /// The maximum number of users and chats to return; up to 100.
  late int limit;

  /// Returns users and chats that were blocked by the current user
  ///
  /// Returns [MessageSenders]
  GetBlockedMessageSenders(
      {required this.block_list,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getBlockedMessageSenders',
      if (extra != null) '@extra': extra,
      'block_list': block_list,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetBlockedMessageSenders? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var block_list = BlockList.fromMap(_map['block_list'])!;
    var offset = _map['offset']! as int;
    var limit = _map['limit']! as int;
    return GetBlockedMessageSenders(
      extra: extra,
      clientId: clientId,
      block_list: block_list,
      offset: offset,
      limit: limit,
    );
  }
}

/// Adds a user to the contact list or edits an existing contact by their user identifier.
///
/// Returns [Ok].
class AddContact extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addContact";

  /// The contact to add or edit; phone number may be empty and needs to be specified only if known, vCard is ignored.
  late Contact contact;

  /// Pass true to share the current user's phone number with the new contact. A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed..
  late bool share_phone_number;

  /// Adds a user to the contact list or edits an existing contact by their user identifier
  ///
  /// Returns [Ok]
  AddContact(
      {required this.contact,
      required this.share_phone_number,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addContact',
      if (extra != null) '@extra': extra,
      'contact': contact,
      'share_phone_number': share_phone_number
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddContact? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var contact = Contact.fromMap(_map['contact'])!;
    var share_phone_number = _map['share_phone_number']! as bool;
    return AddContact(
      extra: extra,
      clientId: clientId,
      contact: contact,
      share_phone_number: share_phone_number,
    );
  }
}

/// Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored.
///
/// Returns [ImportedContacts].
class ImportContacts extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "importContacts";

  /// The list of contacts to import or edit; contacts' vCard are ignored and are not imported.
  late List<Contact> contacts;

  /// Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
  ///
  /// Returns [ImportedContacts]
  ImportContacts({required this.contacts, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'importContacts',
      if (extra != null) '@extra': extra,
      'contacts': contacts
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ImportContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var contacts = List<Contact>.from(
      (_map["contacts"] ?? []).map(
        (e) => Contact.fromMap(e),
      ),
    );
    return ImportContacts(
      extra: extra,
      clientId: clientId,
      contacts: contacts,
    );
  }
}

/// Returns all contacts of the user.
///
/// Returns [Users].
class GetContacts extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getContacts";

  /// Returns all contacts of the user
  ///
  /// Returns [Users]
  GetContacts({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getContacts', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetContacts(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Searches for the specified query in the first names, last names and usernames of the known user contacts.
///
/// Returns [Users].
class SearchContacts extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchContacts";

  /// Query to search for; may be empty to return all contacts.
  late String query;

  /// The maximum number of users to be returned.
  late int limit;

  /// Searches for the specified query in the first names, last names and usernames of the known user contacts
  ///
  /// Returns [Users]
  SearchContacts(
      {required this.query, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchContacts',
      if (extra != null) '@extra': extra,
      'query': query,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    var limit = _map['limit']! as int;
    return SearchContacts(
      extra: extra,
      clientId: clientId,
      query: query,
      limit: limit,
    );
  }
}

/// Removes users from the contact list.
///
/// Returns [Ok].
class RemoveContacts extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeContacts";

  /// Identifiers of users to be deleted.
  late List<int> user_ids;

  /// Removes users from the contact list
  ///
  /// Returns [Ok]
  RemoveContacts({required this.user_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeContacts',
      if (extra != null) '@extra': extra,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return RemoveContacts(
      extra: extra,
      clientId: clientId,
      user_ids: user_ids,
    );
  }
}

/// Returns the total number of imported contacts.
///
/// Returns [Count].
class GetImportedContactCount extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getImportedContactCount";

  /// Returns the total number of imported contacts
  ///
  /// Returns [Count]
  GetImportedContactCount({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getImportedContactCount',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetImportedContactCount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetImportedContactCount(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts..
///
/// Returns [ImportedContacts].
class ChangeImportedContacts extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "changeImportedContacts";

  /// The new list of contacts, contact's vCard are ignored and are not imported.
  late List<Contact> contacts;

  /// Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts.
  ///
  /// Returns [ImportedContacts]
  ChangeImportedContacts({required this.contacts, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'changeImportedContacts',
      if (extra != null) '@extra': extra,
      'contacts': contacts
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChangeImportedContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var contacts = List<Contact>.from(
      (_map["contacts"] ?? []).map(
        (e) => Contact.fromMap(e),
      ),
    );
    return ChangeImportedContacts(
      extra: extra,
      clientId: clientId,
      contacts: contacts,
    );
  }
}

/// Clears all imported contacts, contact list remains unchanged.
///
/// Returns [Ok].
class ClearImportedContacts extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clearImportedContacts";

  /// Clears all imported contacts, contact list remains unchanged
  ///
  /// Returns [Ok]
  ClearImportedContacts({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clearImportedContacts',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClearImportedContacts? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ClearImportedContacts(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Changes the list of close friends of the current user.
///
/// Returns [Ok].
class SetCloseFriends extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setCloseFriends";

  /// User identifiers of close friends; the users must be contacts of the current user.
  late List<int> user_ids;

  /// Changes the list of close friends of the current user
  ///
  /// Returns [Ok]
  SetCloseFriends({required this.user_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setCloseFriends',
      if (extra != null) '@extra': extra,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetCloseFriends? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return SetCloseFriends(
      extra: extra,
      clientId: clientId,
      user_ids: user_ids,
    );
  }
}

/// Returns all close friends of the current user.
///
/// Returns [Users].
class GetCloseFriends extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCloseFriends";

  /// Returns all close friends of the current user
  ///
  /// Returns [Users]
  GetCloseFriends({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getCloseFriends', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCloseFriends? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetCloseFriends(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Changes a personal profile photo of a contact user.
///
/// Returns [Ok].
class SetUserPersonalProfilePhoto extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setUserPersonalProfilePhoto";

  /// User identifier.
  late int user_id;

  /// Profile photo to set; pass null to delete the photo; inputChatPhotoPrevious isn't supported in this function.
  InputChatPhoto? photo;

  /// Changes a personal profile photo of a contact user
  ///
  /// Returns [Ok]
  SetUserPersonalProfilePhoto(
      {required this.user_id, this.photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setUserPersonalProfilePhoto',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'photo': photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetUserPersonalProfilePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var photo = InputChatPhoto.fromMap(_map['photo']);
    return SetUserPersonalProfilePhoto(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      photo: photo,
    );
  }
}

/// Suggests a profile photo to another regular user with common messages.
///
/// Returns [Ok].
class SuggestUserProfilePhoto extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "suggestUserProfilePhoto";

  /// User identifier.
  late int user_id;

  /// Profile photo to suggest; inputChatPhotoPrevious isn't supported in this function.
  late InputChatPhoto photo;

  /// Suggests a profile photo to another regular user with common messages
  ///
  /// Returns [Ok]
  SuggestUserProfilePhoto(
      {required this.user_id, required this.photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'suggestUserProfilePhoto',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'photo': photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SuggestUserProfilePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var photo = InputChatPhoto.fromMap(_map['photo'])!;
    return SuggestUserProfilePhoto(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      photo: photo,
    );
  }
}

/// Searches a user by their phone number. Returns a 404 error if the user can't be found.
///
/// Returns [User].
class SearchUserByPhoneNumber extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchUserByPhoneNumber";

  /// Phone number to search for.
  late String phone_number;

  /// Searches a user by their phone number. Returns a 404 error if the user can't be found
  ///
  /// Returns [User]
  SearchUserByPhoneNumber(
      {required this.phone_number, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchUserByPhoneNumber',
      if (extra != null) '@extra': extra,
      'phone_number': phone_number
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchUserByPhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number = _map['phone_number']! as String;
    return SearchUserByPhoneNumber(
      extra: extra,
      clientId: clientId,
      phone_number: phone_number,
    );
  }
}

/// Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber.
///
/// Returns [Ok].
class SharePhoneNumber extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sharePhoneNumber";

  /// Identifier of the user with whom to share the phone number. The user must be a mutual contact.
  late int user_id;

  /// Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
  ///
  /// Returns [Ok]
  SharePhoneNumber({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sharePhoneNumber',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SharePhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return SharePhoneNumber(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// Returns the profile photos of a user. Personal and public photo aren't returned.
///
/// Returns [ChatPhotos].
class GetUserProfilePhotos extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getUserProfilePhotos";

  /// User identifier.
  late int user_id;

  /// The number of photos to skip; must be non-negative.
  late int offset;

  /// The maximum number of photos to be returned; up to 100.
  late int limit;

  /// Returns the profile photos of a user. Personal and public photo aren't returned
  ///
  /// Returns [ChatPhotos]
  GetUserProfilePhotos(
      {required this.user_id,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getUserProfilePhotos',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetUserProfilePhotos? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var offset = _map['offset']! as int;
    var limit = _map['limit']! as int;
    return GetUserProfilePhotos(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      offset: offset,
      limit: limit,
    );
  }
}

/// Returns stickers from the installed sticker sets that correspond to any of the given emoji or can be found by sticker-specific keywords. If the query is non-empty, then favorite, recently used or trending stickers may also be returned.
///
/// Returns [Stickers].
class GetStickers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStickers";

  /// Type of the stickers to return.
  late StickerType sticker_type;

  /// Search query; a space-separated list of emoji or a keyword prefix. If empty, returns all known installed stickers.
  String? query;

  /// The maximum number of stickers to be returned.
  late int limit;

  /// Chat identifier for which to return stickers. Available custom emoji stickers may be different for different chats.
  late int chat_id;

  /// Returns stickers from the installed sticker sets that correspond to any of the given emoji or can be found by sticker-specific keywords. If the query is non-empty, then favorite, recently used or trending stickers may also be returned
  ///
  /// Returns [Stickers]
  GetStickers(
      {required this.sticker_type,
      this.query,
      required this.limit,
      required this.chat_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStickers',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type,
      'query': query,
      'limit': limit,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var query = _map['query'] as String?;
    var limit = _map['limit']! as int;
    var chat_id = _map['chat_id']! as int;
    return GetStickers(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
      query: query,
      limit: limit,
      chat_id: chat_id,
    );
  }
}

/// Returns unique emoji that correspond to stickers to be found by the getStickers(sticker_type, query, 1000000, chat_id).
///
/// Returns [Emojis].
class GetAllStickerEmojis extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getAllStickerEmojis";

  /// Type of the stickers to search for.
  late StickerType sticker_type;

  /// Search query.
  late String query;

  /// Chat identifier for which to find stickers.
  late int chat_id;

  /// Pass true if only main emoji for each found sticker must be included in the result.
  late bool return_only_main_emoji;

  /// Returns unique emoji that correspond to stickers to be found by the getStickers(sticker_type, query, 1000000, chat_id)
  ///
  /// Returns [Emojis]
  GetAllStickerEmojis(
      {required this.sticker_type,
      required this.query,
      required this.chat_id,
      required this.return_only_main_emoji,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getAllStickerEmojis',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type,
      'query': query,
      'chat_id': chat_id,
      'return_only_main_emoji': return_only_main_emoji
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetAllStickerEmojis? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var query = _map['query']! as String;
    var chat_id = _map['chat_id']! as int;
    var return_only_main_emoji = _map['return_only_main_emoji']! as bool;
    return GetAllStickerEmojis(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
      query: query,
      chat_id: chat_id,
      return_only_main_emoji: return_only_main_emoji,
    );
  }
}

/// Searches for stickers from public sticker sets that correspond to any of the given emoji.
///
/// Returns [Stickers].
class SearchStickers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchStickers";

  /// Type of the stickers to return.
  late StickerType sticker_type;

  /// Space-separated list of emoji to search for; must be non-empty.
  late String emojis;

  /// The maximum number of stickers to be returned; 0-100.
  late int limit;

  /// Searches for stickers from public sticker sets that correspond to any of the given emoji
  ///
  /// Returns [Stickers]
  SearchStickers(
      {required this.sticker_type,
      required this.emojis,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchStickers',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type,
      'emojis': emojis,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var emojis = _map['emojis']! as String;
    var limit = _map['limit']! as int;
    return SearchStickers(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
      emojis: emojis,
      limit: limit,
    );
  }
}

/// Returns premium stickers from regular sticker sets.
///
/// Returns [Stickers].
class GetPremiumStickers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPremiumStickers";

  /// The maximum number of stickers to be returned; 0-100.
  late int limit;

  /// Returns premium stickers from regular sticker sets
  ///
  /// Returns [Stickers]
  GetPremiumStickers({required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPremiumStickers',
      if (extra != null) '@extra': extra,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPremiumStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var limit = _map['limit']! as int;
    return GetPremiumStickers(
      extra: extra,
      clientId: clientId,
      limit: limit,
    );
  }
}

/// Returns a list of installed sticker sets.
///
/// Returns [StickerSets].
class GetInstalledStickerSets extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getInstalledStickerSets";

  /// Type of the sticker sets to return.
  late StickerType sticker_type;

  /// Returns a list of installed sticker sets
  ///
  /// Returns [StickerSets]
  GetInstalledStickerSets(
      {required this.sticker_type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getInstalledStickerSets',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetInstalledStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    return GetInstalledStickerSets(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
    );
  }
}

/// Returns a list of archived sticker sets.
///
/// Returns [StickerSets].
class GetArchivedStickerSets extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getArchivedStickerSets";

  /// Type of the sticker sets to return.
  late StickerType sticker_type;

  /// Identifier of the sticker set from which to return the result.
  /// ; string representation of int, use `int.parse`
  late int64 offset_sticker_set_id;

  /// The maximum number of sticker sets to return; up to 100.
  late int limit;

  /// Returns a list of archived sticker sets
  ///
  /// Returns [StickerSets]
  GetArchivedStickerSets(
      {required this.sticker_type,
      required this.offset_sticker_set_id,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getArchivedStickerSets',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type,
      'offset_sticker_set_id': offset_sticker_set_id,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetArchivedStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var offset_sticker_set_id = _map['offset_sticker_set_id']! as int64;
    var limit = _map['limit']! as int;
    return GetArchivedStickerSets(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
      offset_sticker_set_id: offset_sticker_set_id,
      limit: limit,
    );
  }
}

/// Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib.
///
/// Returns [TrendingStickerSets].
class GetTrendingStickerSets extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getTrendingStickerSets";

  /// Type of the sticker sets to return.
  late StickerType sticker_type;

  /// The offset from which to return the sticker sets; must be non-negative.
  late int offset;

  /// The maximum number of sticker sets to be returned; up to 100. For optimal performance, the number of returned sticker sets is chosen by TDLib and can be smaller than the specified limit, even if the end of the list has not been reached.
  late int limit;

  /// Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib
  ///
  /// Returns [TrendingStickerSets]
  GetTrendingStickerSets(
      {required this.sticker_type,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getTrendingStickerSets',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetTrendingStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var offset = _map['offset']! as int;
    var limit = _map['limit']! as int;
    return GetTrendingStickerSets(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
      offset: offset,
      limit: limit,
    );
  }
}

/// Returns a list of sticker sets attached to a file, including regular, mask, and emoji sticker sets. Currently, only animations, photos, and videos can have attached sticker sets.
///
/// Returns [StickerSets].
class GetAttachedStickerSets extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getAttachedStickerSets";

  /// File identifier.
  late int file_id;

  /// Returns a list of sticker sets attached to a file, including regular, mask, and emoji sticker sets. Currently, only animations, photos, and videos can have attached sticker sets
  ///
  /// Returns [StickerSets]
  GetAttachedStickerSets({required this.file_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getAttachedStickerSets',
      if (extra != null) '@extra': extra,
      'file_id': file_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetAttachedStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var file_id = _map['file_id']! as int;
    return GetAttachedStickerSets(
      extra: extra,
      clientId: clientId,
      file_id: file_id,
    );
  }
}

/// Returns information about a sticker set by its identifier.
///
/// Returns [StickerSet].
class GetStickerSet extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStickerSet";

  /// Identifier of the sticker set.
  /// ; string representation of int, use `int.parse`
  late int64 set_id;

  /// Returns information about a sticker set by its identifier
  ///
  /// Returns [StickerSet]
  GetStickerSet({required this.set_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStickerSet',
      if (extra != null) '@extra': extra,
      'set_id': set_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var set_id = _map['set_id']! as int64;
    return GetStickerSet(
      extra: extra,
      clientId: clientId,
      set_id: set_id,
    );
  }
}

/// Searches for a sticker set by its name.
///
/// Returns [StickerSet].
class SearchStickerSet extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchStickerSet";

  /// Name of the sticker set.
  late String name;

  /// Searches for a sticker set by its name
  ///
  /// Returns [StickerSet]
  SearchStickerSet({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchStickerSet',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchStickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return SearchStickerSet(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// Searches for installed sticker sets by looking for specified query in their title and name.
///
/// Returns [StickerSets].
class SearchInstalledStickerSets extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchInstalledStickerSets";

  /// Type of the sticker sets to search for.
  late StickerType sticker_type;

  /// Query to search for.
  late String query;

  /// The maximum number of sticker sets to return.
  late int limit;

  /// Searches for installed sticker sets by looking for specified query in their title and name
  ///
  /// Returns [StickerSets]
  SearchInstalledStickerSets(
      {required this.sticker_type,
      required this.query,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchInstalledStickerSets',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type,
      'query': query,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchInstalledStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var query = _map['query']! as String;
    var limit = _map['limit']! as int;
    return SearchInstalledStickerSets(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
      query: query,
      limit: limit,
    );
  }
}

/// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results.
///
/// Returns [StickerSets].
class SearchStickerSets extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchStickerSets";

  /// Query to search for.
  late String query;

  /// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
  ///
  /// Returns [StickerSets]
  SearchStickerSets({required this.query, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchStickerSets',
      if (extra != null) '@extra': extra,
      'query': query
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var query = _map['query']! as String;
    return SearchStickerSets(
      extra: extra,
      clientId: clientId,
      query: query,
    );
  }
}

/// Installs/uninstalls or activates/archives a sticker set.
///
/// Returns [Ok].
class ChangeStickerSet extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "changeStickerSet";

  /// Identifier of the sticker set.
  /// ; string representation of int, use `int.parse`
  late int64 set_id;

  /// The new value of is_installed.
  late bool is_installed;

  /// The new value of is_archived. A sticker set can't be installed and archived simultaneously.
  late bool is_archived;

  /// Installs/uninstalls or activates/archives a sticker set
  ///
  /// Returns [Ok]
  ChangeStickerSet(
      {required this.set_id,
      required this.is_installed,
      required this.is_archived,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'changeStickerSet',
      if (extra != null) '@extra': extra,
      'set_id': set_id,
      'is_installed': is_installed,
      'is_archived': is_archived
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChangeStickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var set_id = _map['set_id']! as int64;
    var is_installed = _map['is_installed']! as bool;
    var is_archived = _map['is_archived']! as bool;
    return ChangeStickerSet(
      extra: extra,
      clientId: clientId,
      set_id: set_id,
      is_installed: is_installed,
      is_archived: is_archived,
    );
  }
}

/// Informs the server that some trending sticker sets have been viewed by the user.
///
/// Returns [Ok].
class ViewTrendingStickerSets extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "viewTrendingStickerSets";

  /// Identifiers of viewed trending sticker sets.
  late List<int64> sticker_set_ids;

  /// Informs the server that some trending sticker sets have been viewed by the user
  ///
  /// Returns [Ok]
  ViewTrendingStickerSets(
      {required this.sticker_set_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'viewTrendingStickerSets',
      if (extra != null) '@extra': extra,
      'sticker_set_ids': sticker_set_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ViewTrendingStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_set_ids = List<int64>.from(
      (_map["sticker_set_ids"] ?? []).map(
        (e) => e as int64,
      ),
    );
    return ViewTrendingStickerSets(
      extra: extra,
      clientId: clientId,
      sticker_set_ids: sticker_set_ids,
    );
  }
}

/// Changes the order of installed sticker sets.
///
/// Returns [Ok].
class ReorderInstalledStickerSets extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reorderInstalledStickerSets";

  /// Type of the sticker sets to reorder.
  late StickerType sticker_type;

  /// Identifiers of installed sticker sets in the new correct order.
  late List<int64> sticker_set_ids;

  /// Changes the order of installed sticker sets
  ///
  /// Returns [Ok]
  ReorderInstalledStickerSets(
      {required this.sticker_type,
      required this.sticker_set_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reorderInstalledStickerSets',
      if (extra != null) '@extra': extra,
      'sticker_type': sticker_type,
      'sticker_set_ids': sticker_set_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReorderInstalledStickerSets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var sticker_set_ids = List<int64>.from(
      (_map["sticker_set_ids"] ?? []).map(
        (e) => e as int64,
      ),
    );
    return ReorderInstalledStickerSets(
      extra: extra,
      clientId: clientId,
      sticker_type: sticker_type,
      sticker_set_ids: sticker_set_ids,
    );
  }
}

/// Returns a list of recently used stickers.
///
/// Returns [Stickers].
class GetRecentStickers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getRecentStickers";

  /// Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers.
  late bool is_attached;

  /// Returns a list of recently used stickers
  ///
  /// Returns [Stickers]
  GetRecentStickers({required this.is_attached, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getRecentStickers',
      if (extra != null) '@extra': extra,
      'is_attached': is_attached
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetRecentStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_attached = _map['is_attached']! as bool;
    return GetRecentStickers(
      extra: extra,
      clientId: clientId,
      is_attached: is_attached,
    );
  }
}

/// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first..
///
/// Returns [Stickers].
class AddRecentSticker extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addRecentSticker";

  /// Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers.
  late bool is_attached;

  /// Sticker file to add.
  late InputFile sticker;

  /// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
  ///
  /// Returns [Stickers]
  AddRecentSticker(
      {required this.is_attached,
      required this.sticker,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addRecentSticker',
      if (extra != null) '@extra': extra,
      'is_attached': is_attached,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddRecentSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_attached = _map['is_attached']! as bool;
    var sticker = InputFile.fromMap(_map['sticker'])!;
    return AddRecentSticker(
      extra: extra,
      clientId: clientId,
      is_attached: is_attached,
      sticker: sticker,
    );
  }
}

/// Removes a sticker from the list of recently used stickers.
///
/// Returns [Ok].
class RemoveRecentSticker extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeRecentSticker";

  /// Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers.
  late bool is_attached;

  /// Sticker file to delete.
  late InputFile sticker;

  /// Removes a sticker from the list of recently used stickers
  ///
  /// Returns [Ok]
  RemoveRecentSticker(
      {required this.is_attached,
      required this.sticker,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeRecentSticker',
      if (extra != null) '@extra': extra,
      'is_attached': is_attached,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveRecentSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_attached = _map['is_attached']! as bool;
    var sticker = InputFile.fromMap(_map['sticker'])!;
    return RemoveRecentSticker(
      extra: extra,
      clientId: clientId,
      is_attached: is_attached,
      sticker: sticker,
    );
  }
}

/// Clears the list of recently used stickers.
///
/// Returns [Ok].
class ClearRecentStickers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clearRecentStickers";

  /// Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers.
  late bool is_attached;

  /// Clears the list of recently used stickers
  ///
  /// Returns [Ok]
  ClearRecentStickers({required this.is_attached, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clearRecentStickers',
      if (extra != null) '@extra': extra,
      'is_attached': is_attached
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClearRecentStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var is_attached = _map['is_attached']! as bool;
    return ClearRecentStickers(
      extra: extra,
      clientId: clientId,
      is_attached: is_attached,
    );
  }
}

/// Returns favorite stickers.
///
/// Returns [Stickers].
class GetFavoriteStickers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getFavoriteStickers";

  /// Returns favorite stickers
  ///
  /// Returns [Stickers]
  GetFavoriteStickers({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getFavoriteStickers', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetFavoriteStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetFavoriteStickers(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first..
///
/// Returns [Ok].
class AddFavoriteSticker extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addFavoriteSticker";

  /// Sticker file to add.
  late InputFile sticker;

  /// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
  ///
  /// Returns [Ok]
  AddFavoriteSticker({required this.sticker, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addFavoriteSticker',
      if (extra != null) '@extra': extra,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddFavoriteSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    return AddFavoriteSticker(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
    );
  }
}

/// Removes a sticker from the list of favorite stickers.
///
/// Returns [Ok].
class RemoveFavoriteSticker extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeFavoriteSticker";

  /// Sticker file to delete from the list.
  late InputFile sticker;

  /// Removes a sticker from the list of favorite stickers
  ///
  /// Returns [Ok]
  RemoveFavoriteSticker({required this.sticker, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeFavoriteSticker',
      if (extra != null) '@extra': extra,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveFavoriteSticker? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    return RemoveFavoriteSticker(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
    );
  }
}

/// Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object.
///
/// Returns [Emojis].
class GetStickerEmojis extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStickerEmojis";

  /// Sticker file identifier.
  late InputFile sticker;

  /// Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
  ///
  /// Returns [Emojis]
  GetStickerEmojis({required this.sticker, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStickerEmojis',
      if (extra != null) '@extra': extra,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStickerEmojis? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    return GetStickerEmojis(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
    );
  }
}

/// Searches for emojis by keywords. Supported only if the file database is enabled.
///
/// Returns [Emojis].
class SearchEmojis extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchEmojis";

  /// Text to search for.
  late String text;

  /// Pass true if only emojis, which exactly match the text, needs to be returned.
  late bool exact_match;

  /// List of possible IETF language tags of the user's input language; may be empty if unknown.
  late List<String> input_language_codes;

  /// Searches for emojis by keywords. Supported only if the file database is enabled
  ///
  /// Returns [Emojis]
  SearchEmojis(
      {required this.text,
      required this.exact_match,
      required this.input_language_codes,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchEmojis',
      if (extra != null) '@extra': extra,
      'text': text,
      'exact_match': exact_match,
      'input_language_codes': input_language_codes
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchEmojis? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = _map['text']! as String;
    var exact_match = _map['exact_match']! as bool;
    var input_language_codes = List<String>.from(
      (_map["input_language_codes"] ?? []).map(
        (e) => e as String,
      ),
    );
    return SearchEmojis(
      extra: extra,
      clientId: clientId,
      text: text,
      exact_match: exact_match,
      input_language_codes: input_language_codes,
    );
  }
}

/// Returns available emojis categories.
///
/// Returns [EmojiCategories].
class GetEmojiCategories extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getEmojiCategories";

  /// Type of emoji categories to return; pass null to get default emoji categories.
  EmojiCategoryType? type;

  /// Returns available emojis categories
  ///
  /// Returns [EmojiCategories]
  GetEmojiCategories({this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getEmojiCategories',
      if (extra != null) '@extra': extra,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetEmojiCategories? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = EmojiCategoryType.fromMap(_map['type']);
    return GetEmojiCategories(
      extra: extra,
      clientId: clientId,
      type: type,
    );
  }
}

/// Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji.
///
/// Returns [AnimatedEmoji].
class GetAnimatedEmoji extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getAnimatedEmoji";

  /// The emoji.
  late String emoji;

  /// Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji
  ///
  /// Returns [AnimatedEmoji]
  GetAnimatedEmoji({required this.emoji, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getAnimatedEmoji',
      if (extra != null) '@extra': extra,
      'emoji': emoji
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetAnimatedEmoji? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emoji = _map['emoji']! as String;
    return GetAnimatedEmoji(
      extra: extra,
      clientId: clientId,
      emoji: emoji,
    );
  }
}

/// Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation.
///
/// Returns [HttpUrl].
class GetEmojiSuggestionsUrl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getEmojiSuggestionsUrl";

  /// Language code for which the emoji replacements will be suggested.
  late String language_code;

  /// Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
  ///
  /// Returns [HttpUrl]
  GetEmojiSuggestionsUrl(
      {required this.language_code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getEmojiSuggestionsUrl',
      if (extra != null) '@extra': extra,
      'language_code': language_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetEmojiSuggestionsUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_code = _map['language_code']! as String;
    return GetEmojiSuggestionsUrl(
      extra: extra,
      clientId: clientId,
      language_code: language_code,
    );
  }
}

/// Returns list of custom emoji stickers by their identifiers. Stickers are returned in arbitrary order. Only found stickers are returned.
///
/// Returns [Stickers].
class GetCustomEmojiStickers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCustomEmojiStickers";

  /// Identifiers of custom emoji stickers. At most 200 custom emoji stickers can be received simultaneously.
  late List<int64> custom_emoji_ids;

  /// Returns list of custom emoji stickers by their identifiers. Stickers are returned in arbitrary order. Only found stickers are returned
  ///
  /// Returns [Stickers]
  GetCustomEmojiStickers(
      {required this.custom_emoji_ids, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getCustomEmojiStickers',
      if (extra != null) '@extra': extra,
      'custom_emoji_ids': custom_emoji_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCustomEmojiStickers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_emoji_ids = List<int64>.from(
      (_map["custom_emoji_ids"] ?? []).map(
        (e) => e as int64,
      ),
    );
    return GetCustomEmojiStickers(
      extra: extra,
      clientId: clientId,
      custom_emoji_ids: custom_emoji_ids,
    );
  }
}

/// Returns default list of custom emoji stickers for placing on a chat photo.
///
/// Returns [Stickers].
class GetDefaultChatPhotoCustomEmojiStickers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getDefaultChatPhotoCustomEmojiStickers";

  /// Returns default list of custom emoji stickers for placing on a chat photo
  ///
  /// Returns [Stickers]
  GetDefaultChatPhotoCustomEmojiStickers({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getDefaultChatPhotoCustomEmojiStickers',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetDefaultChatPhotoCustomEmojiStickers? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetDefaultChatPhotoCustomEmojiStickers(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns default list of custom emoji stickers for placing on a profile photo.
///
/// Returns [Stickers].
class GetDefaultProfilePhotoCustomEmojiStickers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getDefaultProfilePhotoCustomEmojiStickers";

  /// Returns default list of custom emoji stickers for placing on a profile photo
  ///
  /// Returns [Stickers]
  GetDefaultProfilePhotoCustomEmojiStickers({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getDefaultProfilePhotoCustomEmojiStickers',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetDefaultProfilePhotoCustomEmojiStickers? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetDefaultProfilePhotoCustomEmojiStickers(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns saved animations.
///
/// Returns [Animations].
class GetSavedAnimations extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSavedAnimations";

  /// Returns saved animations
  ///
  /// Returns [Animations]
  GetSavedAnimations({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getSavedAnimations', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSavedAnimations? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetSavedAnimations(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list.
///
/// Returns [Ok].
class AddSavedAnimation extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addSavedAnimation";

  /// The animation file to be added. Only animations known to the server (i.e., successfully sent via a message) can be added to the list.
  late InputFile animation;

  /// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
  ///
  /// Returns [Ok]
  AddSavedAnimation({required this.animation, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addSavedAnimation',
      if (extra != null) '@extra': extra,
      'animation': animation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddSavedAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animation = InputFile.fromMap(_map['animation'])!;
    return AddSavedAnimation(
      extra: extra,
      clientId: clientId,
      animation: animation,
    );
  }
}

/// Removes an animation from the list of saved animations.
///
/// Returns [Ok].
class RemoveSavedAnimation extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeSavedAnimation";

  /// Animation file to be removed.
  late InputFile animation;

  /// Removes an animation from the list of saved animations
  ///
  /// Returns [Ok]
  RemoveSavedAnimation({required this.animation, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeSavedAnimation',
      if (extra != null) '@extra': extra,
      'animation': animation
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveSavedAnimation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var animation = InputFile.fromMap(_map['animation'])!;
    return RemoveSavedAnimation(
      extra: extra,
      clientId: clientId,
      animation: animation,
    );
  }
}

/// Returns up to 20 recently used inline bots in the order of their last usage.
///
/// Returns [Users].
class GetRecentInlineBots extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getRecentInlineBots";

  /// Returns up to 20 recently used inline bots in the order of their last usage
  ///
  /// Returns [Users]
  GetRecentInlineBots({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getRecentInlineBots', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetRecentInlineBots? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetRecentInlineBots(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Searches for recently used hashtags by their prefix.
///
/// Returns [Hashtags].
class SearchHashtags extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchHashtags";

  /// Hashtag prefix to search for.
  late String prefix;

  /// The maximum number of hashtags to be returned.
  late int limit;

  /// Searches for recently used hashtags by their prefix
  ///
  /// Returns [Hashtags]
  SearchHashtags(
      {required this.prefix, required this.limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchHashtags',
      if (extra != null) '@extra': extra,
      'prefix': prefix,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchHashtags? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var prefix = _map['prefix']! as String;
    var limit = _map['limit']! as int;
    return SearchHashtags(
      extra: extra,
      clientId: clientId,
      prefix: prefix,
      limit: limit,
    );
  }
}

/// Removes a hashtag from the list of recently used hashtags.
///
/// Returns [Ok].
class RemoveRecentHashtag extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeRecentHashtag";

  /// Hashtag to delete.
  late String hashtag;

  /// Removes a hashtag from the list of recently used hashtags
  ///
  /// Returns [Ok]
  RemoveRecentHashtag({required this.hashtag, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeRecentHashtag',
      if (extra != null) '@extra': extra,
      'hashtag': hashtag
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveRecentHashtag? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var hashtag = _map['hashtag']! as String;
    return RemoveRecentHashtag(
      extra: extra,
      clientId: clientId,
      hashtag: hashtag,
    );
  }
}

/// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview.
///
/// Returns [WebPage].
class GetWebPagePreview extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getWebPagePreview";

  /// Message text with formatting.
  late FormattedText text;

  /// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview
  ///
  /// Returns [WebPage]
  GetWebPagePreview({required this.text, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getWebPagePreview',
      if (extra != null) '@extra': extra,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetWebPagePreview? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var text = FormattedText.fromMap(_map['text'])!;
    return GetWebPagePreview(
      extra: extra,
      clientId: clientId,
      text: text,
    );
  }
}

/// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page.
///
/// Returns [WebPageInstantView].
class GetWebPageInstantView extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getWebPageInstantView";

  /// The web page URL.
  late String url;

  /// Pass true to get full instant view for the web page.
  late bool force_full;

  /// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
  ///
  /// Returns [WebPageInstantView]
  GetWebPageInstantView(
      {required this.url, required this.force_full, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getWebPageInstantView',
      if (extra != null) '@extra': extra,
      'url': url,
      'force_full': force_full
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetWebPageInstantView? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var url = _map['url']! as String;
    var force_full = _map['force_full']! as bool;
    return GetWebPageInstantView(
      extra: extra,
      clientId: clientId,
      url: url,
      force_full: force_full,
    );
  }
}

/// Changes a profile photo for the current user.
///
/// Returns [Ok].
class SetProfilePhoto extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setProfilePhoto";

  /// Profile photo to set.
  late InputChatPhoto photo;

  /// Pass true to set a public photo, which will be visible even the main photo is hidden by privacy settings.
  late bool is_public;

  /// Changes a profile photo for the current user
  ///
  /// Returns [Ok]
  SetProfilePhoto(
      {required this.photo,
      required this.is_public,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setProfilePhoto',
      if (extra != null) '@extra': extra,
      'photo': photo,
      'is_public': is_public
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetProfilePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var photo = InputChatPhoto.fromMap(_map['photo'])!;
    var is_public = _map['is_public']! as bool;
    return SetProfilePhoto(
      extra: extra,
      clientId: clientId,
      photo: photo,
      is_public: is_public,
    );
  }
}

/// Deletes a profile photo.
///
/// Returns [Ok].
class DeleteProfilePhoto extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteProfilePhoto";

  /// Identifier of the profile photo to delete.
  /// ; string representation of int, use `int.parse`
  late int64 profile_photo_id;

  /// Deletes a profile photo
  ///
  /// Returns [Ok]
  DeleteProfilePhoto(
      {required this.profile_photo_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteProfilePhoto',
      if (extra != null) '@extra': extra,
      'profile_photo_id': profile_photo_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteProfilePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var profile_photo_id = _map['profile_photo_id']! as int64;
    return DeleteProfilePhoto(
      extra: extra,
      clientId: clientId,
      profile_photo_id: profile_photo_id,
    );
  }
}

/// Changes the first and last name of the current user.
///
/// Returns [Ok].
class SetName extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setName";

  /// The new value of the first name for the current user; 1-64 characters.
  late String first_name;

  /// The new value of the optional last name for the current user; 0-64 characters.
  late String last_name;

  /// Changes the first and last name of the current user
  ///
  /// Returns [Ok]
  SetName(
      {required this.first_name,
      required this.last_name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setName',
      if (extra != null) '@extra': extra,
      'first_name': first_name,
      'last_name': last_name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var first_name = _map['first_name']! as String;
    var last_name = _map['last_name']! as String;
    return SetName(
      extra: extra,
      clientId: clientId,
      first_name: first_name,
      last_name: last_name,
    );
  }
}

/// Changes the bio of the current user.
///
/// Returns [Ok].
class SetBio extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setBio";

  /// The new value of the user bio; 0-getOption("bio_length_max") characters without line feeds.
  late String bio;

  /// Changes the bio of the current user
  ///
  /// Returns [Ok]
  SetBio({required this.bio, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'setBio', if (extra != null) '@extra': extra, 'bio': bio};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetBio? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bio = _map['bio']! as String;
    return SetBio(
      extra: extra,
      clientId: clientId,
      bio: bio,
    );
  }
}

/// Changes the editable username of the current user.
///
/// Returns [Ok].
class SetUsername extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setUsername";

  /// The new value of the username. Use an empty string to remove the username. The username can't be completely removed if there is another active or disabled username.
  late String username;

  /// Changes the editable username of the current user
  ///
  /// Returns [Ok]
  SetUsername({required this.username, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setUsername',
      if (extra != null) '@extra': extra,
      'username': username
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetUsername? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var username = _map['username']! as String;
    return SetUsername(
      extra: extra,
      clientId: clientId,
      username: username,
    );
  }
}

/// Changes active state for a username of the current user. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached.
///
/// Returns [Ok].
class ToggleUsernameIsActive extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleUsernameIsActive";

  /// The username to change.
  late String username;

  /// Pass true to activate the username; pass false to disable it.
  late bool is_active;

  /// Changes active state for a username of the current user. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
  ///
  /// Returns [Ok]
  ToggleUsernameIsActive(
      {required this.username,
      required this.is_active,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleUsernameIsActive',
      if (extra != null) '@extra': extra,
      'username': username,
      'is_active': is_active
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleUsernameIsActive? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var username = _map['username']! as String;
    var is_active = _map['is_active']! as bool;
    return ToggleUsernameIsActive(
      extra: extra,
      clientId: clientId,
      username: username,
      is_active: is_active,
    );
  }
}

/// Changes order of active usernames of the current user.
///
/// Returns [Ok].
class ReorderActiveUsernames extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reorderActiveUsernames";

  /// The new order of active usernames. All currently active usernames must be specified.
  late List<String> usernames;

  /// Changes order of active usernames of the current user
  ///
  /// Returns [Ok]
  ReorderActiveUsernames({required this.usernames, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reorderActiveUsernames',
      if (extra != null) '@extra': extra,
      'usernames': usernames
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReorderActiveUsernames? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var usernames = List<String>.from(
      (_map["usernames"] ?? []).map(
        (e) => e as String,
      ),
    );
    return ReorderActiveUsernames(
      extra: extra,
      clientId: clientId,
      usernames: usernames,
    );
  }
}

/// Changes the emoji status of the current user; for Telegram Premium users only.
///
/// Returns [Ok].
class SetEmojiStatus extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setEmojiStatus";

  /// New emoji status; pass null to switch to the default badge.
  EmojiStatus? emoji_status;

  /// Changes the emoji status of the current user; for Telegram Premium users only
  ///
  /// Returns [Ok]
  SetEmojiStatus({this.emoji_status, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setEmojiStatus',
      if (extra != null) '@extra': extra,
      'emoji_status': emoji_status
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetEmojiStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var emoji_status = EmojiStatus.fromMap(_map['emoji_status']);
    return SetEmojiStatus(
      extra: extra,
      clientId: clientId,
      emoji_status: emoji_status,
    );
  }
}

/// Changes the location of the current user. Needs to be called if getOption("is_location_visible") is true and location changes for more than 1 kilometer.
///
/// Returns [Ok].
class SetLocation extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setLocation";

  /// The new location of the user.
  late Location location;

  /// Changes the location of the current user. Needs to be called if getOption("is_location_visible") is true and location changes for more than 1 kilometer
  ///
  /// Returns [Ok]
  SetLocation({required this.location, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setLocation',
      if (extra != null) '@extra': extra,
      'location': location
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetLocation? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    return SetLocation(
      extra: extra,
      clientId: clientId,
      location: location,
    );
  }
}

/// Changes the phone number of the user and sends an authentication code to the user's new phone number; for official Android and iOS applications only. On success, returns information about the sent code.
///
/// Returns [AuthenticationCodeInfo].
class ChangePhoneNumber extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "changePhoneNumber";

  /// The new phone number of the user in international format.
  late String phone_number;

  /// Settings for the authentication of the user's phone number; pass null to use default settings.
  PhoneNumberAuthenticationSettings? settings;

  /// Changes the phone number of the user and sends an authentication code to the user's new phone number; for official Android and iOS applications only. On success, returns information about the sent code
  ///
  /// Returns [AuthenticationCodeInfo]
  ChangePhoneNumber(
      {required this.phone_number, this.settings, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'changePhoneNumber',
      if (extra != null) '@extra': extra,
      'phone_number': phone_number,
      'settings': settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ChangePhoneNumber? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number = _map['phone_number']! as String;
    var settings = PhoneNumberAuthenticationSettings.fromMap(_map['settings']);
    return ChangePhoneNumber(
      extra: extra,
      clientId: clientId,
      phone_number: phone_number,
      settings: settings,
    );
  }
}

/// Resends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed.
///
/// Returns [AuthenticationCodeInfo].
class ResendChangePhoneNumberCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resendChangePhoneNumberCode";

  /// Resends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed
  ///
  /// Returns [AuthenticationCodeInfo]
  ResendChangePhoneNumberCode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resendChangePhoneNumberCode',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResendChangePhoneNumberCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResendChangePhoneNumberCode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks the authentication code sent to confirm a new phone number of the user.
///
/// Returns [Ok].
class CheckChangePhoneNumberCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkChangePhoneNumberCode";

  /// Authentication code to check.
  late String code;

  /// Checks the authentication code sent to confirm a new phone number of the user
  ///
  /// Returns [Ok]
  CheckChangePhoneNumberCode({required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkChangePhoneNumberCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckChangePhoneNumberCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = _map['code']! as String;
    return CheckChangePhoneNumberCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// Returns an HTTPS link, which can be used to get information about the current user.
///
/// Returns [UserLink].
class GetUserLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getUserLink";

  /// Returns an HTTPS link, which can be used to get information about the current user
  ///
  /// Returns [UserLink]
  GetUserLink({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getUserLink', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetUserLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetUserLink(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Searches a user by a token from the user's link.
///
/// Returns [User].
class SearchUserByToken extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchUserByToken";

  /// Token to search for.
  late String token;

  /// Searches a user by a token from the user's link
  ///
  /// Returns [User]
  SearchUserByToken({required this.token, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchUserByToken',
      if (extra != null) '@extra': extra,
      'token': token
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchUserByToken? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var token = _map['token']! as String;
    return SearchUserByToken(
      extra: extra,
      clientId: clientId,
      token: token,
    );
  }
}

/// Sets the list of commands supported by the bot for the given user scope and language; for bots only.
///
/// Returns [Ok].
class SetCommands extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setCommands";

  /// The scope to which the commands are relevant; pass null to change commands in the default bot command scope.
  BotCommandScope? scope;

  /// A two-letter ISO 639-1 language code. If empty, the commands will be applied to all users from the given scope, for which language there are no dedicated commands.
  String? language_code;

  /// List of the bot's commands.
  late List<BotCommand> commands;

  /// Sets the list of commands supported by the bot for the given user scope and language; for bots only
  ///
  /// Returns [Ok]
  SetCommands(
      {this.scope,
      this.language_code,
      required this.commands,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setCommands',
      if (extra != null) '@extra': extra,
      'scope': scope,
      'language_code': language_code,
      'commands': commands
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetCommands? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scope = BotCommandScope.fromMap(_map['scope']);
    var language_code = _map['language_code'] as String?;
    var commands = List<BotCommand>.from(
      (_map["commands"] ?? []).map(
        (e) => BotCommand.fromMap(e),
      ),
    );
    return SetCommands(
      extra: extra,
      clientId: clientId,
      scope: scope,
      language_code: language_code,
      commands: commands,
    );
  }
}

/// Deletes commands supported by the bot for the given user scope and language; for bots only.
///
/// Returns [Ok].
class DeleteCommands extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteCommands";

  /// The scope to which the commands are relevant; pass null to delete commands in the default bot command scope.
  BotCommandScope? scope;

  /// A two-letter ISO 639-1 language code or an empty string.
  late String language_code;

  /// Deletes commands supported by the bot for the given user scope and language; for bots only
  ///
  /// Returns [Ok]
  DeleteCommands(
      {this.scope, required this.language_code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteCommands',
      if (extra != null) '@extra': extra,
      'scope': scope,
      'language_code': language_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteCommands? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scope = BotCommandScope.fromMap(_map['scope']);
    var language_code = _map['language_code']! as String;
    return DeleteCommands(
      extra: extra,
      clientId: clientId,
      scope: scope,
      language_code: language_code,
    );
  }
}

/// Returns list of commands supported by the bot for the given user scope and language; for bots only.
///
/// Returns [BotCommands].
class GetCommands extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCommands";

  /// The scope to which the commands are relevant; pass null to get commands in the default bot command scope.
  BotCommandScope? scope;

  /// A two-letter ISO 639-1 language code or an empty string.
  late String language_code;

  /// Returns list of commands supported by the bot for the given user scope and language; for bots only
  ///
  /// Returns [BotCommands]
  GetCommands(
      {this.scope, required this.language_code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getCommands',
      if (extra != null) '@extra': extra,
      'scope': scope,
      'language_code': language_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCommands? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scope = BotCommandScope.fromMap(_map['scope']);
    var language_code = _map['language_code']! as String;
    return GetCommands(
      extra: extra,
      clientId: clientId,
      scope: scope,
      language_code: language_code,
    );
  }
}

/// Sets menu button for the given user or for all users; for bots only.
///
/// Returns [Ok].
class SetMenuButton extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setMenuButton";

  /// Identifier of the user or 0 to set menu button for all users.
  late int user_id;

  /// New menu button.
  late BotMenuButton menu_button;

  /// Sets menu button for the given user or for all users; for bots only
  ///
  /// Returns [Ok]
  SetMenuButton(
      {required this.user_id,
      required this.menu_button,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setMenuButton',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'menu_button': menu_button
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetMenuButton? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var menu_button = BotMenuButton.fromMap(_map['menu_button'])!;
    return SetMenuButton(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      menu_button: menu_button,
    );
  }
}

/// Returns menu button set by the bot for the given user; for bots only.
///
/// Returns [BotMenuButton].
class GetMenuButton extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMenuButton";

  /// Identifier of the user or 0 to get the default menu button.
  late int user_id;

  /// Returns menu button set by the bot for the given user; for bots only
  ///
  /// Returns [BotMenuButton]
  GetMenuButton({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMenuButton',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMenuButton? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return GetMenuButton(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// Sets default administrator rights for adding the bot to basic group and supergroup chats; for bots only.
///
/// Returns [Ok].
class SetDefaultGroupAdministratorRights extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setDefaultGroupAdministratorRights";

  /// Default administrator rights for adding the bot to basic group and supergroup chats; pass null to remove default rights.
  ChatAdministratorRights? default_group_administrator_rights;

  /// Sets default administrator rights for adding the bot to basic group and supergroup chats; for bots only
  ///
  /// Returns [Ok]
  SetDefaultGroupAdministratorRights(
      {this.default_group_administrator_rights, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setDefaultGroupAdministratorRights',
      if (extra != null) '@extra': extra,
      'default_group_administrator_rights': default_group_administrator_rights
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetDefaultGroupAdministratorRights? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var default_group_administrator_rights = ChatAdministratorRights.fromMap(
        _map['default_group_administrator_rights']);
    return SetDefaultGroupAdministratorRights(
      extra: extra,
      clientId: clientId,
      default_group_administrator_rights: default_group_administrator_rights,
    );
  }
}

/// Sets default administrator rights for adding the bot to channel chats; for bots only.
///
/// Returns [Ok].
class SetDefaultChannelAdministratorRights extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setDefaultChannelAdministratorRights";

  /// Default administrator rights for adding the bot to channels; pass null to remove default rights.
  ChatAdministratorRights? default_channel_administrator_rights;

  /// Sets default administrator rights for adding the bot to channel chats; for bots only
  ///
  /// Returns [Ok]
  SetDefaultChannelAdministratorRights(
      {this.default_channel_administrator_rights, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setDefaultChannelAdministratorRights',
      if (extra != null) '@extra': extra,
      'default_channel_administrator_rights':
          default_channel_administrator_rights
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetDefaultChannelAdministratorRights? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var default_channel_administrator_rights = ChatAdministratorRights.fromMap(
        _map['default_channel_administrator_rights']);
    return SetDefaultChannelAdministratorRights(
      extra: extra,
      clientId: clientId,
      default_channel_administrator_rights:
          default_channel_administrator_rights,
    );
  }
}

/// Checks whether the specified bot can send messages to the user. Returns a 404 error if can't and the access can be granted by call to allowBotToSendMessages.
///
/// Returns [Ok].
class CanBotSendMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canBotSendMessages";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// Checks whether the specified bot can send messages to the user. Returns a 404 error if can't and the access can be granted by call to allowBotToSendMessages
  ///
  /// Returns [Ok]
  CanBotSendMessages({required this.bot_user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canBotSendMessages',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanBotSendMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    return CanBotSendMessages(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
    );
  }
}

/// Allows the specified bot to send messages to the user.
///
/// Returns [Ok].
class AllowBotToSendMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "allowBotToSendMessages";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// Allows the specified bot to send messages to the user
  ///
  /// Returns [Ok]
  AllowBotToSendMessages(
      {required this.bot_user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'allowBotToSendMessages',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AllowBotToSendMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    return AllowBotToSendMessages(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
    );
  }
}

/// Sends a custom request from a Web App.
///
/// Returns [CustomRequestResult].
class SendWebAppCustomRequest extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendWebAppCustomRequest";

  /// Identifier of the bot.
  late int bot_user_id;

  /// The method name.
  late String method;

  /// JSON-serialized method parameters.
  late String parameters;

  /// Sends a custom request from a Web App
  ///
  /// Returns [CustomRequestResult]
  SendWebAppCustomRequest(
      {required this.bot_user_id,
      required this.method,
      required this.parameters,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendWebAppCustomRequest',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'method': method,
      'parameters': parameters
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendWebAppCustomRequest? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var method = _map['method']! as String;
    var parameters = _map['parameters']! as String;
    return SendWebAppCustomRequest(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      method: method,
      parameters: parameters,
    );
  }
}

/// Sets the name of a bot. Can be called only if userTypeBot.can_be_edited == true.
///
/// Returns [Ok].
class SetBotName extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setBotName";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// A two-letter ISO 639-1 language code. If empty, the name will be shown to all users for whose languages there is no dedicated name.
  String? language_code;

  /// New bot's name on the specified language; 0-64 characters; must be non-empty if language code is empty.
  late String name;

  /// Sets the name of a bot. Can be called only if userTypeBot.can_be_edited == true
  ///
  /// Returns [Ok]
  SetBotName(
      {required this.bot_user_id,
      this.language_code,
      required this.name,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setBotName',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'language_code': language_code,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetBotName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var language_code = _map['language_code'] as String?;
    var name = _map['name']! as String;
    return SetBotName(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      language_code: language_code,
      name: name,
    );
  }
}

/// Returns the name of a bot in the given language. Can be called only if userTypeBot.can_be_edited == true.
///
/// Returns [Text].
class GetBotName extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getBotName";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// A two-letter ISO 639-1 language code or an empty string.
  late String language_code;

  /// Returns the name of a bot in the given language. Can be called only if userTypeBot.can_be_edited == true
  ///
  /// Returns [Text]
  GetBotName(
      {required this.bot_user_id,
      required this.language_code,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getBotName',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'language_code': language_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetBotName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var language_code = _map['language_code']! as String;
    return GetBotName(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      language_code: language_code,
    );
  }
}

/// Changes a profile photo for a bot.
///
/// Returns [Ok].
class SetBotProfilePhoto extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setBotProfilePhoto";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// Profile photo to set; pass null to delete the chat photo.
  InputChatPhoto? photo;

  /// Changes a profile photo for a bot
  ///
  /// Returns [Ok]
  SetBotProfilePhoto(
      {required this.bot_user_id, this.photo, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setBotProfilePhoto',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'photo': photo
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetBotProfilePhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var photo = InputChatPhoto.fromMap(_map['photo']);
    return SetBotProfilePhoto(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      photo: photo,
    );
  }
}

/// Changes active state for a username of a bot. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached. Can be called only if userTypeBot.can_be_edited == true.
///
/// Returns [Ok].
class ToggleBotUsernameIsActive extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleBotUsernameIsActive";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// The username to change.
  late String username;

  /// Pass true to activate the username; pass false to disable it.
  late bool is_active;

  /// Changes active state for a username of a bot. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached. Can be called only if userTypeBot.can_be_edited == true
  ///
  /// Returns [Ok]
  ToggleBotUsernameIsActive(
      {required this.bot_user_id,
      required this.username,
      required this.is_active,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleBotUsernameIsActive',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'username': username,
      'is_active': is_active
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleBotUsernameIsActive? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var username = _map['username']! as String;
    var is_active = _map['is_active']! as bool;
    return ToggleBotUsernameIsActive(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      username: username,
      is_active: is_active,
    );
  }
}

/// Changes order of active usernames of a bot. Can be called only if userTypeBot.can_be_edited == true.
///
/// Returns [Ok].
class ReorderBotActiveUsernames extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reorderBotActiveUsernames";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// The new order of active usernames. All currently active usernames must be specified.
  late List<String> usernames;

  /// Changes order of active usernames of a bot. Can be called only if userTypeBot.can_be_edited == true
  ///
  /// Returns [Ok]
  ReorderBotActiveUsernames(
      {required this.bot_user_id,
      required this.usernames,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reorderBotActiveUsernames',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'usernames': usernames
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReorderBotActiveUsernames? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var usernames = List<String>.from(
      (_map["usernames"] ?? []).map(
        (e) => e as String,
      ),
    );
    return ReorderBotActiveUsernames(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      usernames: usernames,
    );
  }
}

/// Sets the text shown in the chat with a bot if the chat is empty. Can be called only if userTypeBot.can_be_edited == true.
///
/// Returns [Ok].
class SetBotInfoDescription extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setBotInfoDescription";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// A two-letter ISO 639-1 language code. If empty, the description will be shown to all users for whose languages there is no dedicated description.
  String? language_code;

  /// New bot's description on the specified language.
  late String description;

  /// Sets the text shown in the chat with a bot if the chat is empty. Can be called only if userTypeBot.can_be_edited == true
  ///
  /// Returns [Ok]
  SetBotInfoDescription(
      {required this.bot_user_id,
      this.language_code,
      required this.description,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setBotInfoDescription',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'language_code': language_code,
      'description': description
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetBotInfoDescription? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var language_code = _map['language_code'] as String?;
    var description = _map['description']! as String;
    return SetBotInfoDescription(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      language_code: language_code,
      description: description,
    );
  }
}

/// Returns the text shown in the chat with a bot if the chat is empty in the given language. Can be called only if userTypeBot.can_be_edited == true.
///
/// Returns [Text].
class GetBotInfoDescription extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getBotInfoDescription";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// A two-letter ISO 639-1 language code or an empty string.
  late String language_code;

  /// Returns the text shown in the chat with a bot if the chat is empty in the given language. Can be called only if userTypeBot.can_be_edited == true
  ///
  /// Returns [Text]
  GetBotInfoDescription(
      {required this.bot_user_id,
      required this.language_code,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getBotInfoDescription',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'language_code': language_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetBotInfoDescription? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var language_code = _map['language_code']! as String;
    return GetBotInfoDescription(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      language_code: language_code,
    );
  }
}

/// Sets the text shown on a bot's profile page and sent together with the link when users share the bot. Can be called only if userTypeBot.can_be_edited == true.
///
/// Returns [Ok].
class SetBotInfoShortDescription extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setBotInfoShortDescription";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// A two-letter ISO 639-1 language code. If empty, the short description will be shown to all users for whose languages there is no dedicated description.
  String? language_code;

  /// New bot's short description on the specified language.
  late String short_description;

  /// Sets the text shown on a bot's profile page and sent together with the link when users share the bot. Can be called only if userTypeBot.can_be_edited == true
  ///
  /// Returns [Ok]
  SetBotInfoShortDescription(
      {required this.bot_user_id,
      this.language_code,
      required this.short_description,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setBotInfoShortDescription',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'language_code': language_code,
      'short_description': short_description
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetBotInfoShortDescription? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var language_code = _map['language_code'] as String?;
    var short_description = _map['short_description']! as String;
    return SetBotInfoShortDescription(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      language_code: language_code,
      short_description: short_description,
    );
  }
}

/// Returns the text shown on a bot's profile page and sent together with the link when users share the bot in the given language. Can be called only if userTypeBot.can_be_edited == true.
///
/// Returns [Text].
class GetBotInfoShortDescription extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getBotInfoShortDescription";

  /// Identifier of the target bot.
  late int bot_user_id;

  /// A two-letter ISO 639-1 language code or an empty string.
  late String language_code;

  /// Returns the text shown on a bot's profile page and sent together with the link when users share the bot in the given language. Can be called only if userTypeBot.can_be_edited == true
  ///
  /// Returns [Text]
  GetBotInfoShortDescription(
      {required this.bot_user_id,
      required this.language_code,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getBotInfoShortDescription',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'language_code': language_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetBotInfoShortDescription? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var language_code = _map['language_code']! as String;
    return GetBotInfoShortDescription(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      language_code: language_code,
    );
  }
}

/// Returns all active sessions of the current user.
///
/// Returns [Sessions].
class GetActiveSessions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getActiveSessions";

  /// Returns all active sessions of the current user
  ///
  /// Returns [Sessions]
  GetActiveSessions({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getActiveSessions', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetActiveSessions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetActiveSessions(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Terminates a session of the current user.
///
/// Returns [Ok].
class TerminateSession extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "terminateSession";

  /// Session identifier.
  /// ; string representation of int, use `int.parse`
  late int64 session_id;

  /// Terminates a session of the current user
  ///
  /// Returns [Ok]
  TerminateSession({required this.session_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'terminateSession',
      if (extra != null) '@extra': extra,
      'session_id': session_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TerminateSession? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var session_id = _map['session_id']! as int64;
    return TerminateSession(
      extra: extra,
      clientId: clientId,
      session_id: session_id,
    );
  }
}

/// Terminates all other sessions of the current user.
///
/// Returns [Ok].
class TerminateAllOtherSessions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "terminateAllOtherSessions";

  /// Terminates all other sessions of the current user
  ///
  /// Returns [Ok]
  TerminateAllOtherSessions({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'terminateAllOtherSessions',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TerminateAllOtherSessions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TerminateAllOtherSessions(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Confirms an unconfirmed session of the current user from another device.
///
/// Returns [Ok].
class ConfirmSession extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "confirmSession";

  /// Session identifier.
  /// ; string representation of int, use `int.parse`
  late int64 session_id;

  /// Confirms an unconfirmed session of the current user from another device
  ///
  /// Returns [Ok]
  ConfirmSession({required this.session_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'confirmSession',
      if (extra != null) '@extra': extra,
      'session_id': session_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ConfirmSession? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var session_id = _map['session_id']! as int64;
    return ConfirmSession(
      extra: extra,
      clientId: clientId,
      session_id: session_id,
    );
  }
}

/// Toggles whether a session can accept incoming calls.
///
/// Returns [Ok].
class ToggleSessionCanAcceptCalls extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSessionCanAcceptCalls";

  /// Session identifier.
  /// ; string representation of int, use `int.parse`
  late int64 session_id;

  /// Pass true to allow accepting incoming calls by the session; pass false otherwise.
  late bool can_accept_calls;

  /// Toggles whether a session can accept incoming calls
  ///
  /// Returns [Ok]
  ToggleSessionCanAcceptCalls(
      {required this.session_id,
      required this.can_accept_calls,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSessionCanAcceptCalls',
      if (extra != null) '@extra': extra,
      'session_id': session_id,
      'can_accept_calls': can_accept_calls
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSessionCanAcceptCalls? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var session_id = _map['session_id']! as int64;
    var can_accept_calls = _map['can_accept_calls']! as bool;
    return ToggleSessionCanAcceptCalls(
      extra: extra,
      clientId: clientId,
      session_id: session_id,
      can_accept_calls: can_accept_calls,
    );
  }
}

/// Toggles whether a session can accept incoming secret chats.
///
/// Returns [Ok].
class ToggleSessionCanAcceptSecretChats extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSessionCanAcceptSecretChats";

  /// Session identifier.
  /// ; string representation of int, use `int.parse`
  late int64 session_id;

  /// Pass true to allow accepting secret chats by the session; pass false otherwise.
  late bool can_accept_secret_chats;

  /// Toggles whether a session can accept incoming secret chats
  ///
  /// Returns [Ok]
  ToggleSessionCanAcceptSecretChats(
      {required this.session_id,
      required this.can_accept_secret_chats,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSessionCanAcceptSecretChats',
      if (extra != null) '@extra': extra,
      'session_id': session_id,
      'can_accept_secret_chats': can_accept_secret_chats
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSessionCanAcceptSecretChats? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var session_id = _map['session_id']! as int64;
    var can_accept_secret_chats = _map['can_accept_secret_chats']! as bool;
    return ToggleSessionCanAcceptSecretChats(
      extra: extra,
      clientId: clientId,
      session_id: session_id,
      can_accept_secret_chats: can_accept_secret_chats,
    );
  }
}

/// Changes the period of inactivity after which sessions will automatically be terminated.
///
/// Returns [Ok].
class SetInactiveSessionTtl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setInactiveSessionTtl";

  /// New number of days of inactivity before sessions will be automatically terminated; 1-366 days.
  late int inactive_session_ttl_days;

  /// Changes the period of inactivity after which sessions will automatically be terminated
  ///
  /// Returns [Ok]
  SetInactiveSessionTtl(
      {required this.inactive_session_ttl_days, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setInactiveSessionTtl',
      if (extra != null) '@extra': extra,
      'inactive_session_ttl_days': inactive_session_ttl_days
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetInactiveSessionTtl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var inactive_session_ttl_days = _map['inactive_session_ttl_days']! as int;
    return SetInactiveSessionTtl(
      extra: extra,
      clientId: clientId,
      inactive_session_ttl_days: inactive_session_ttl_days,
    );
  }
}

/// Returns all website where the current user used Telegram to log in.
///
/// Returns [ConnectedWebsites].
class GetConnectedWebsites extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getConnectedWebsites";

  /// Returns all website where the current user used Telegram to log in
  ///
  /// Returns [ConnectedWebsites]
  GetConnectedWebsites({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getConnectedWebsites',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetConnectedWebsites? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetConnectedWebsites(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Disconnects website from the current user's Telegram account.
///
/// Returns [Ok].
class DisconnectWebsite extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "disconnectWebsite";

  /// Website identifier.
  /// ; string representation of int, use `int.parse`
  late int64 website_id;

  /// Disconnects website from the current user's Telegram account
  ///
  /// Returns [Ok]
  DisconnectWebsite({required this.website_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'disconnectWebsite',
      if (extra != null) '@extra': extra,
      'website_id': website_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DisconnectWebsite? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var website_id = _map['website_id']! as int64;
    return DisconnectWebsite(
      extra: extra,
      clientId: clientId,
      website_id: website_id,
    );
  }
}

/// Disconnects all websites from the current user's Telegram account.
///
/// Returns [Ok].
class DisconnectAllWebsites extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "disconnectAllWebsites";

  /// Disconnects all websites from the current user's Telegram account
  ///
  /// Returns [Ok]
  DisconnectAllWebsites({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'disconnectAllWebsites',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DisconnectAllWebsites? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return DisconnectAllWebsites(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Changes the editable username of a supergroup or channel, requires owner privileges in the supergroup or channel.
///
/// Returns [Ok].
class SetSupergroupUsername extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setSupergroupUsername";

  /// Identifier of the supergroup or channel.
  late int supergroup_id;

  /// New value of the username. Use an empty string to remove the username. The username can't be completely removed if there is another active or disabled username.
  late String username;

  /// Changes the editable username of a supergroup or channel, requires owner privileges in the supergroup or channel
  ///
  /// Returns [Ok]
  SetSupergroupUsername(
      {required this.supergroup_id,
      required this.username,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setSupergroupUsername',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'username': username
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetSupergroupUsername? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var username = _map['username']! as String;
    return SetSupergroupUsername(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      username: username,
    );
  }
}

/// Changes active state for a username of a supergroup or channel, requires owner privileges in the supergroup or channel. The editable username can't be disabled..
///
/// Returns [Ok].
class ToggleSupergroupUsernameIsActive extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSupergroupUsernameIsActive";

  /// Identifier of the supergroup or channel.
  late int supergroup_id;

  /// The username to change.
  late String username;

  /// Pass true to activate the username; pass false to disable it.
  late bool is_active;

  /// Changes active state for a username of a supergroup or channel, requires owner privileges in the supergroup or channel. The editable username can't be disabled.
  ///
  /// Returns [Ok]
  ToggleSupergroupUsernameIsActive(
      {required this.supergroup_id,
      required this.username,
      required this.is_active,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSupergroupUsernameIsActive',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'username': username,
      'is_active': is_active
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSupergroupUsernameIsActive? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var username = _map['username']! as String;
    var is_active = _map['is_active']! as bool;
    return ToggleSupergroupUsernameIsActive(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      username: username,
      is_active: is_active,
    );
  }
}

/// Disables all active non-editable usernames of a supergroup or channel, requires owner privileges in the supergroup or channel.
///
/// Returns [Ok].
class DisableAllSupergroupUsernames extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "disableAllSupergroupUsernames";

  /// Identifier of the supergroup or channel.
  late int supergroup_id;

  /// Disables all active non-editable usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
  ///
  /// Returns [Ok]
  DisableAllSupergroupUsernames(
      {required this.supergroup_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'disableAllSupergroupUsernames',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DisableAllSupergroupUsernames? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    return DisableAllSupergroupUsernames(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
    );
  }
}

/// Changes order of active usernames of a supergroup or channel, requires owner privileges in the supergroup or channel.
///
/// Returns [Ok].
class ReorderSupergroupActiveUsernames extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reorderSupergroupActiveUsernames";

  /// Identifier of the supergroup or channel.
  late int supergroup_id;

  /// The new order of active usernames. All currently active usernames must be specified.
  late List<String> usernames;

  /// Changes order of active usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
  ///
  /// Returns [Ok]
  ReorderSupergroupActiveUsernames(
      {required this.supergroup_id,
      required this.usernames,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reorderSupergroupActiveUsernames',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'usernames': usernames
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReorderSupergroupActiveUsernames? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var usernames = List<String>.from(
      (_map["usernames"] ?? []).map(
        (e) => e as String,
      ),
    );
    return ReorderSupergroupActiveUsernames(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      usernames: usernames,
    );
  }
}

/// Changes the sticker set of a supergroup; requires can_change_info administrator right.
///
/// Returns [Ok].
class SetSupergroupStickerSet extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setSupergroupStickerSet";

  /// Identifier of the supergroup.
  late int supergroup_id;

  /// New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set.
  /// ; string representation of int, use `int.parse`
  late int64 sticker_set_id;

  /// Changes the sticker set of a supergroup; requires can_change_info administrator right
  ///
  /// Returns [Ok]
  SetSupergroupStickerSet(
      {required this.supergroup_id,
      required this.sticker_set_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setSupergroupStickerSet',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'sticker_set_id': sticker_set_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetSupergroupStickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var sticker_set_id = _map['sticker_set_id']! as int64;
    return SetSupergroupStickerSet(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      sticker_set_id: sticker_set_id,
    );
  }
}

/// Toggles whether sender signature is added to sent messages in a channel; requires can_change_info administrator right.
///
/// Returns [Ok].
class ToggleSupergroupSignMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSupergroupSignMessages";

  /// Identifier of the channel.
  late int supergroup_id;

  /// New value of sign_messages.
  late bool sign_messages;

  /// Toggles whether sender signature is added to sent messages in a channel; requires can_change_info administrator right
  ///
  /// Returns [Ok]
  ToggleSupergroupSignMessages(
      {required this.supergroup_id,
      required this.sign_messages,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSupergroupSignMessages',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'sign_messages': sign_messages
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSupergroupSignMessages? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var sign_messages = _map['sign_messages']! as bool;
    return ToggleSupergroupSignMessages(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      sign_messages: sign_messages,
    );
  }
}

/// Toggles whether joining is mandatory to send messages to a discussion supergroup; requires can_restrict_members administrator right.
///
/// Returns [Ok].
class ToggleSupergroupJoinToSendMessages extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSupergroupJoinToSendMessages";

  /// Identifier of the supergroup.
  late int supergroup_id;

  /// New value of join_to_send_messages.
  late bool join_to_send_messages;

  /// Toggles whether joining is mandatory to send messages to a discussion supergroup; requires can_restrict_members administrator right
  ///
  /// Returns [Ok]
  ToggleSupergroupJoinToSendMessages(
      {required this.supergroup_id,
      required this.join_to_send_messages,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSupergroupJoinToSendMessages',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'join_to_send_messages': join_to_send_messages
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSupergroupJoinToSendMessages? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var join_to_send_messages = _map['join_to_send_messages']! as bool;
    return ToggleSupergroupJoinToSendMessages(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      join_to_send_messages: join_to_send_messages,
    );
  }
}

/// Toggles whether all users directly joining the supergroup need to be approved by supergroup administrators; requires can_restrict_members administrator right.
///
/// Returns [Ok].
class ToggleSupergroupJoinByRequest extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSupergroupJoinByRequest";

  /// Identifier of the channel.
  late int supergroup_id;

  /// New value of join_by_request.
  late bool join_by_request;

  /// Toggles whether all users directly joining the supergroup need to be approved by supergroup administrators; requires can_restrict_members administrator right
  ///
  /// Returns [Ok]
  ToggleSupergroupJoinByRequest(
      {required this.supergroup_id,
      required this.join_by_request,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSupergroupJoinByRequest',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'join_by_request': join_by_request
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSupergroupJoinByRequest? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var join_by_request = _map['join_by_request']! as bool;
    return ToggleSupergroupJoinByRequest(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      join_by_request: join_by_request,
    );
  }
}

/// Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right.
///
/// Returns [Ok].
class ToggleSupergroupIsAllHistoryAvailable extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSupergroupIsAllHistoryAvailable";

  /// The identifier of the supergroup.
  late int supergroup_id;

  /// The new value of is_all_history_available.
  late bool is_all_history_available;

  /// Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right
  ///
  /// Returns [Ok]
  ToggleSupergroupIsAllHistoryAvailable(
      {required this.supergroup_id,
      required this.is_all_history_available,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSupergroupIsAllHistoryAvailable',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'is_all_history_available': is_all_history_available
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSupergroupIsAllHistoryAvailable? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var is_all_history_available = _map['is_all_history_available']! as bool;
    return ToggleSupergroupIsAllHistoryAvailable(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      is_all_history_available: is_all_history_available,
    );
  }
}

/// Toggles whether non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers. Can be called only if supergroupFullInfo.can_hide_members == true.
///
/// Returns [Ok].
class ToggleSupergroupHasHiddenMembers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSupergroupHasHiddenMembers";

  /// Identifier of the supergroup.
  late int supergroup_id;

  /// New value of has_hidden_members.
  late bool has_hidden_members;

  /// Toggles whether non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers. Can be called only if supergroupFullInfo.can_hide_members == true
  ///
  /// Returns [Ok]
  ToggleSupergroupHasHiddenMembers(
      {required this.supergroup_id,
      required this.has_hidden_members,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSupergroupHasHiddenMembers',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'has_hidden_members': has_hidden_members
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSupergroupHasHiddenMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var has_hidden_members = _map['has_hidden_members']! as bool;
    return ToggleSupergroupHasHiddenMembers(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      has_hidden_members: has_hidden_members,
    );
  }
}

/// Toggles whether aggressive anti-spam checks are enabled in the supergroup. Can be called only if supergroupFullInfo.can_toggle_aggressive_anti_spam == true.
///
/// Returns [Ok].
class ToggleSupergroupHasAggressiveAntiSpamEnabled extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "toggleSupergroupHasAggressiveAntiSpamEnabled";

  /// The identifier of the supergroup, which isn't a broadcast group.
  late int supergroup_id;

  /// The new value of has_aggressive_anti_spam_enabled.
  late bool has_aggressive_anti_spam_enabled;

  /// Toggles whether aggressive anti-spam checks are enabled in the supergroup. Can be called only if supergroupFullInfo.can_toggle_aggressive_anti_spam == true
  ///
  /// Returns [Ok]
  ToggleSupergroupHasAggressiveAntiSpamEnabled(
      {required this.supergroup_id,
      required this.has_aggressive_anti_spam_enabled,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSupergroupHasAggressiveAntiSpamEnabled',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'has_aggressive_anti_spam_enabled': has_aggressive_anti_spam_enabled
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSupergroupHasAggressiveAntiSpamEnabled? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var has_aggressive_anti_spam_enabled =
        _map['has_aggressive_anti_spam_enabled']! as bool;
    return ToggleSupergroupHasAggressiveAntiSpamEnabled(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      has_aggressive_anti_spam_enabled: has_aggressive_anti_spam_enabled,
    );
  }
}

/// Toggles whether the supergroup is a forum; requires owner privileges in the supergroup. Discussion supergroups can't be converted to forums.
///
/// Returns [Ok].
class ToggleSupergroupIsForum extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSupergroupIsForum";

  /// Identifier of the supergroup.
  late int supergroup_id;

  /// New value of is_forum.
  late bool is_forum;

  /// Toggles whether the supergroup is a forum; requires owner privileges in the supergroup. Discussion supergroups can't be converted to forums
  ///
  /// Returns [Ok]
  ToggleSupergroupIsForum(
      {required this.supergroup_id,
      required this.is_forum,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSupergroupIsForum',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'is_forum': is_forum
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSupergroupIsForum? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var is_forum = _map['is_forum']! as bool;
    return ToggleSupergroupIsForum(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      is_forum: is_forum,
    );
  }
}

/// Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup.
///
/// Returns [Ok].
class ToggleSupergroupIsBroadcastGroup extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "toggleSupergroupIsBroadcastGroup";

  /// Identifier of the supergroup.
  late int supergroup_id;

  /// Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup
  ///
  /// Returns [Ok]
  ToggleSupergroupIsBroadcastGroup(
      {required this.supergroup_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'toggleSupergroupIsBroadcastGroup',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ToggleSupergroupIsBroadcastGroup? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    return ToggleSupergroupIsBroadcastGroup(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
    );
  }
}

/// Reports messages in a supergroup as spam; requires administrator rights in the supergroup.
///
/// Returns [Ok].
class ReportSupergroupSpam extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportSupergroupSpam";

  /// Supergroup identifier.
  late int supergroup_id;

  /// Identifiers of messages to report.
  late List<int> message_ids;

  /// Reports messages in a supergroup as spam; requires administrator rights in the supergroup
  ///
  /// Returns [Ok]
  ReportSupergroupSpam(
      {required this.supergroup_id,
      required this.message_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportSupergroupSpam',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'message_ids': message_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportSupergroupSpam? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var message_ids = List<int>.from(
      (_map["message_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return ReportSupergroupSpam(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      message_ids: message_ids,
    );
  }
}

/// Reports a false deletion of a message by aggressive anti-spam checks; requires administrator rights in the supergroup. Can be called only for messages from chatEventMessageDeleted with can_report_anti_spam_false_positive == true.
///
/// Returns [Ok].
class ReportSupergroupAntiSpamFalsePositive extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportSupergroupAntiSpamFalsePositive";

  /// Supergroup identifier.
  late int supergroup_id;

  /// Identifier of the erroneously deleted message.
  late int message_id;

  /// Reports a false deletion of a message by aggressive anti-spam checks; requires administrator rights in the supergroup. Can be called only for messages from chatEventMessageDeleted with can_report_anti_spam_false_positive == true
  ///
  /// Returns [Ok]
  ReportSupergroupAntiSpamFalsePositive(
      {required this.supergroup_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportSupergroupAntiSpamFalsePositive',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportSupergroupAntiSpamFalsePositive? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var message_id = _map['message_id']! as int;
    return ReportSupergroupAntiSpamFalsePositive(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      message_id: message_id,
    );
  }
}

/// Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters.
///
/// Returns [ChatMembers].
class GetSupergroupMembers extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSupergroupMembers";

  /// Identifier of the supergroup or channel.
  late int supergroup_id;

  /// The type of users to return; pass null to use supergroupMembersFilterRecent.
  SupergroupMembersFilter? filter;

  /// Number of users to skip.
  late int offset;

  /// The maximum number of users be returned; up to 200.
  late int limit;

  /// Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
  ///
  /// Returns [ChatMembers]
  GetSupergroupMembers(
      {required this.supergroup_id,
      this.filter,
      required this.offset,
      required this.limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getSupergroupMembers',
      if (extra != null) '@extra': extra,
      'supergroup_id': supergroup_id,
      'filter': filter,
      'offset': offset,
      'limit': limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSupergroupMembers? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var supergroup_id = _map['supergroup_id']! as int;
    var filter = SupergroupMembersFilter.fromMap(_map['filter']);
    var offset = _map['offset']! as int;
    var limit = _map['limit']! as int;
    return GetSupergroupMembers(
      extra: extra,
      clientId: clientId,
      supergroup_id: supergroup_id,
      filter: filter,
      offset: offset,
      limit: limit,
    );
  }
}

/// Closes a secret chat, effectively transferring its state to secretChatStateClosed.
///
/// Returns [Ok].
class CloseSecretChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "closeSecretChat";

  /// Secret chat identifier.
  late int secret_chat_id;

  /// Closes a secret chat, effectively transferring its state to secretChatStateClosed
  ///
  /// Returns [Ok]
  CloseSecretChat({required this.secret_chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'closeSecretChat',
      if (extra != null) '@extra': extra,
      'secret_chat_id': secret_chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CloseSecretChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var secret_chat_id = _map['secret_chat_id']! as int;
    return CloseSecretChat(
      extra: extra,
      clientId: clientId,
      secret_chat_id: secret_chat_id,
    );
  }
}

/// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i.e., in order of decreasing event_id).
///
/// Returns [ChatEvents].
class GetChatEventLog extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatEventLog";

  /// Chat identifier.
  late int chat_id;

  /// Search query by which to filter events.
  late String query;

  /// Identifier of an event from which to return results. Use 0 to get results from the latest events.
  /// ; string representation of int, use `int.parse`
  late int64 from_event_id;

  /// The maximum number of events to return; up to 100.
  late int limit;

  /// The types of events to return; pass null to get chat events of all types.
  ChatEventLogFilters? filters;

  /// User identifiers by which to filter events. By default, events relating to all users will be returned.
  late List<int> user_ids;

  /// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i.e., in order of decreasing event_id)
  ///
  /// Returns [ChatEvents]
  GetChatEventLog(
      {required this.chat_id,
      required this.query,
      required this.from_event_id,
      required this.limit,
      this.filters,
      required this.user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatEventLog',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'query': query,
      'from_event_id': from_event_id,
      'limit': limit,
      'filters': filters,
      'user_ids': user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatEventLog? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var query = _map['query']! as String;
    var from_event_id = _map['from_event_id']! as int64;
    var limit = _map['limit']! as int;
    var filters = ChatEventLogFilters.fromMap(_map['filters']);
    var user_ids = List<int>.from(
      (_map["user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return GetChatEventLog(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      query: query,
      from_event_id: from_event_id,
      limit: limit,
      filters: filters,
      user_ids: user_ids,
    );
  }
}

/// Returns an invoice payment form. This method must be called when the user presses inline button of the type inlineKeyboardButtonTypeBuy.
///
/// Returns [PaymentForm].
class GetPaymentForm extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPaymentForm";

  /// The invoice.
  late InputInvoice input_invoice;

  /// Preferred payment form theme; pass null to use the default theme.
  ThemeParameters? theme;

  /// Returns an invoice payment form. This method must be called when the user presses inline button of the type inlineKeyboardButtonTypeBuy
  ///
  /// Returns [PaymentForm]
  GetPaymentForm(
      {required this.input_invoice, this.theme, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPaymentForm',
      if (extra != null) '@extra': extra,
      'input_invoice': input_invoice,
      'theme': theme
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPaymentForm? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var input_invoice = InputInvoice.fromMap(_map['input_invoice'])!;
    var theme = ThemeParameters.fromMap(_map['theme']);
    return GetPaymentForm(
      extra: extra,
      clientId: clientId,
      input_invoice: input_invoice,
      theme: theme,
    );
  }
}

/// Validates the order information provided by a user and returns the available shipping options for a flexible invoice.
///
/// Returns [ValidatedOrderInfo].
class ValidateOrderInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "validateOrderInfo";

  /// The invoice.
  late InputInvoice input_invoice;

  /// The order information, provided by the user; pass null if empty.
  OrderInfo? order_info;

  /// Pass true to save the order information.
  late bool allow_save;

  /// Validates the order information provided by a user and returns the available shipping options for a flexible invoice
  ///
  /// Returns [ValidatedOrderInfo]
  ValidateOrderInfo(
      {required this.input_invoice,
      this.order_info,
      required this.allow_save,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'validateOrderInfo',
      if (extra != null) '@extra': extra,
      'input_invoice': input_invoice,
      'order_info': order_info,
      'allow_save': allow_save
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ValidateOrderInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var input_invoice = InputInvoice.fromMap(_map['input_invoice'])!;
    var order_info = OrderInfo.fromMap(_map['order_info']);
    var allow_save = _map['allow_save']! as bool;
    return ValidateOrderInfo(
      extra: extra,
      clientId: clientId,
      input_invoice: input_invoice,
      order_info: order_info,
      allow_save: allow_save,
    );
  }
}

/// Sends a filled-out payment form to the bot for final verification.
///
/// Returns [PaymentResult].
class SendPaymentForm extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendPaymentForm";

  /// The invoice.
  late InputInvoice input_invoice;

  /// Payment form identifier returned by getPaymentForm.
  /// ; string representation of int, use `int.parse`
  late int64 payment_form_id;

  /// Identifier returned by validateOrderInfo, or an empty string.
  late String order_info_id;

  /// Identifier of a chosen shipping option, if applicable.
  late String shipping_option_id;

  /// The credentials chosen by user for payment.
  late InputCredentials credentials;

  /// Chosen by the user amount of tip in the smallest units of the currency.
  late int tip_amount;

  /// Sends a filled-out payment form to the bot for final verification
  ///
  /// Returns [PaymentResult]
  SendPaymentForm(
      {required this.input_invoice,
      required this.payment_form_id,
      required this.order_info_id,
      required this.shipping_option_id,
      required this.credentials,
      required this.tip_amount,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendPaymentForm',
      if (extra != null) '@extra': extra,
      'input_invoice': input_invoice,
      'payment_form_id': payment_form_id,
      'order_info_id': order_info_id,
      'shipping_option_id': shipping_option_id,
      'credentials': credentials,
      'tip_amount': tip_amount
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendPaymentForm? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var input_invoice = InputInvoice.fromMap(_map['input_invoice'])!;
    var payment_form_id = _map['payment_form_id']! as int64;
    var order_info_id = _map['order_info_id']! as String;
    var shipping_option_id = _map['shipping_option_id']! as String;
    var credentials = InputCredentials.fromMap(_map['credentials'])!;
    var tip_amount = _map['tip_amount']! as int;
    return SendPaymentForm(
      extra: extra,
      clientId: clientId,
      input_invoice: input_invoice,
      payment_form_id: payment_form_id,
      order_info_id: order_info_id,
      shipping_option_id: shipping_option_id,
      credentials: credentials,
      tip_amount: tip_amount,
    );
  }
}

/// Returns information about a successful payment.
///
/// Returns [PaymentReceipt].
class GetPaymentReceipt extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPaymentReceipt";

  /// Chat identifier of the messagePaymentSuccessful message.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// Returns information about a successful payment
  ///
  /// Returns [PaymentReceipt]
  GetPaymentReceipt(
      {required this.chat_id,
      required this.message_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPaymentReceipt',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPaymentReceipt? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    return GetPaymentReceipt(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
    );
  }
}

/// Returns saved order information. Returns a 404 error if there is no saved order information.
///
/// Returns [OrderInfo].
class GetSavedOrderInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSavedOrderInfo";

  /// Returns saved order information. Returns a 404 error if there is no saved order information
  ///
  /// Returns [OrderInfo]
  GetSavedOrderInfo({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getSavedOrderInfo', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSavedOrderInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetSavedOrderInfo(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Deletes saved order information.
///
/// Returns [Ok].
class DeleteSavedOrderInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteSavedOrderInfo";

  /// Deletes saved order information
  ///
  /// Returns [Ok]
  DeleteSavedOrderInfo({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteSavedOrderInfo',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteSavedOrderInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return DeleteSavedOrderInfo(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Deletes saved credentials for all payment provider bots.
///
/// Returns [Ok].
class DeleteSavedCredentials extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteSavedCredentials";

  /// Deletes saved credentials for all payment provider bots
  ///
  /// Returns [Ok]
  DeleteSavedCredentials({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteSavedCredentials',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteSavedCredentials? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return DeleteSavedCredentials(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Creates a link for the given invoice; for bots only.
///
/// Returns [HttpUrl].
class CreateInvoiceLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createInvoiceLink";

  /// Information about the invoice of the type inputMessageInvoice.
  late InputMessageContent invoice;

  /// Creates a link for the given invoice; for bots only
  ///
  /// Returns [HttpUrl]
  CreateInvoiceLink({required this.invoice, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createInvoiceLink',
      if (extra != null) '@extra': extra,
      'invoice': invoice
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateInvoiceLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var invoice = InputMessageContent.fromMap(_map['invoice'])!;
    return CreateInvoiceLink(
      extra: extra,
      clientId: clientId,
      invoice: invoice,
    );
  }
}

/// Returns a user that can be contacted to get support.
///
/// Returns [User].
class GetSupportUser extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSupportUser";

  /// Returns a user that can be contacted to get support
  ///
  /// Returns [User]
  GetSupportUser({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getSupportUser', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSupportUser? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetSupportUser(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns backgrounds installed by the user.
///
/// Returns [Backgrounds].
class GetBackgrounds extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getBackgrounds";

  /// Pass true to order returned backgrounds for a dark theme.
  late bool for_dark_theme;

  /// Returns backgrounds installed by the user
  ///
  /// Returns [Backgrounds]
  GetBackgrounds({required this.for_dark_theme, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getBackgrounds',
      if (extra != null) '@extra': extra,
      'for_dark_theme': for_dark_theme
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetBackgrounds? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var for_dark_theme = _map['for_dark_theme']! as bool;
    return GetBackgrounds(
      extra: extra,
      clientId: clientId,
      for_dark_theme: for_dark_theme,
    );
  }
}

/// Constructs a persistent HTTP URL for a background.
///
/// Returns [HttpUrl].
class GetBackgroundUrl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getBackgroundUrl";

  /// Background name.
  late String name;

  /// Background type.
  late BackgroundType type;

  /// Constructs a persistent HTTP URL for a background
  ///
  /// Returns [HttpUrl]
  GetBackgroundUrl(
      {required this.name, required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getBackgroundUrl',
      if (extra != null) '@extra': extra,
      'name': name,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetBackgroundUrl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var type = BackgroundType.fromMap(_map['type'])!;
    return GetBackgroundUrl(
      extra: extra,
      clientId: clientId,
      name: name,
      type: type,
    );
  }
}

/// Searches for a background by its name.
///
/// Returns [Background].
class SearchBackground extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchBackground";

  /// The name of the background.
  late String name;

  /// Searches for a background by its name
  ///
  /// Returns [Background]
  SearchBackground({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchBackground',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchBackground? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return SearchBackground(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// Changes the background selected by the user; adds background to the list of installed backgrounds.
///
/// Returns [Background].
class SetBackground extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setBackground";

  /// The input background to use; pass null to create a new filled background or to remove the current background.
  InputBackground? background;

  /// Background type; pass null to use the default type of the remote background or to remove the current background.
  BackgroundType? type;

  /// Pass true if the background is changed for a dark theme.
  late bool for_dark_theme;

  /// Changes the background selected by the user; adds background to the list of installed backgrounds
  ///
  /// Returns [Background]
  SetBackground(
      {this.background,
      this.type,
      required this.for_dark_theme,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setBackground',
      if (extra != null) '@extra': extra,
      'background': background,
      'type': type,
      'for_dark_theme': for_dark_theme
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetBackground? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var background = InputBackground.fromMap(_map['background']);
    var type = BackgroundType.fromMap(_map['type']);
    var for_dark_theme = _map['for_dark_theme']! as bool;
    return SetBackground(
      extra: extra,
      clientId: clientId,
      background: background,
      type: type,
      for_dark_theme: for_dark_theme,
    );
  }
}

/// Removes background from the list of installed backgrounds.
///
/// Returns [Ok].
class RemoveBackground extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeBackground";

  /// The background identifier.
  /// ; string representation of int, use `int.parse`
  late int64 background_id;

  /// Removes background from the list of installed backgrounds
  ///
  /// Returns [Ok]
  RemoveBackground({required this.background_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeBackground',
      if (extra != null) '@extra': extra,
      'background_id': background_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveBackground? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var background_id = _map['background_id']! as int64;
    return RemoveBackground(
      extra: extra,
      clientId: clientId,
      background_id: background_id,
    );
  }
}

/// Resets list of installed backgrounds to its default value.
///
/// Returns [Ok].
class ResetBackgrounds extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resetBackgrounds";

  /// Resets list of installed backgrounds to its default value
  ///
  /// Returns [Ok]
  ResetBackgrounds({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'resetBackgrounds', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResetBackgrounds? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResetBackgrounds(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization.
///
/// Returns [LocalizationTargetInfo].
class GetLocalizationTargetInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLocalizationTargetInfo";

  /// Pass true to get only locally available information without sending network requests.
  late bool only_local;

  /// Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
  ///
  /// Returns [LocalizationTargetInfo]
  GetLocalizationTargetInfo(
      {required this.only_local, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getLocalizationTargetInfo',
      if (extra != null) '@extra': extra,
      'only_local': only_local
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLocalizationTargetInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var only_local = _map['only_local']! as bool;
    return GetLocalizationTargetInfo(
      extra: extra,
      clientId: clientId,
      only_local: only_local,
    );
  }
}

/// Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization.
///
/// Returns [LanguagePackInfo].
class GetLanguagePackInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLanguagePackInfo";

  /// Language pack identifier.
  late String language_pack_id;

  /// Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
  ///
  /// Returns [LanguagePackInfo]
  GetLanguagePackInfo(
      {required this.language_pack_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getLanguagePackInfo',
      if (extra != null) '@extra': extra,
      'language_pack_id': language_pack_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLanguagePackInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_pack_id = _map['language_pack_id']! as String;
    return GetLanguagePackInfo(
      extra: extra,
      clientId: clientId,
      language_pack_id: language_pack_id,
    );
  }
}

/// Returns strings from a language pack in the current localization target by their keys. Can be called before authorization.
///
/// Returns [LanguagePackStrings].
class GetLanguagePackStrings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLanguagePackStrings";

  /// Language pack identifier of the strings to be returned.
  late String language_pack_id;

  /// Language pack keys of the strings to be returned; leave empty to request all available strings.
  late List<String> keys;

  /// Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
  ///
  /// Returns [LanguagePackStrings]
  GetLanguagePackStrings(
      {required this.language_pack_id,
      required this.keys,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getLanguagePackStrings',
      if (extra != null) '@extra': extra,
      'language_pack_id': language_pack_id,
      'keys': keys
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLanguagePackStrings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_pack_id = _map['language_pack_id']! as String;
    var keys = List<String>.from(
      (_map["keys"] ?? []).map(
        (e) => e as String,
      ),
    );
    return GetLanguagePackStrings(
      extra: extra,
      clientId: clientId,
      language_pack_id: language_pack_id,
      keys: keys,
    );
  }
}

/// Fetches the latest versions of all strings from a language pack in the current localization target from the server..
///
/// Returns [Ok].
class SynchronizeLanguagePack extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "synchronizeLanguagePack";

  /// Language pack identifier.
  late String language_pack_id;

  /// Fetches the latest versions of all strings from a language pack in the current localization target from the server.
  ///
  /// Returns [Ok]
  SynchronizeLanguagePack(
      {required this.language_pack_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'synchronizeLanguagePack',
      if (extra != null) '@extra': extra,
      'language_pack_id': language_pack_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SynchronizeLanguagePack? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_pack_id = _map['language_pack_id']! as String;
    return SynchronizeLanguagePack(
      extra: extra,
      clientId: clientId,
      language_pack_id: language_pack_id,
    );
  }
}

/// Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization.
///
/// Returns [Ok].
class AddCustomServerLanguagePack extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addCustomServerLanguagePack";

  /// Identifier of a language pack to be added.
  late String language_pack_id;

  /// Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
  ///
  /// Returns [Ok]
  AddCustomServerLanguagePack(
      {required this.language_pack_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addCustomServerLanguagePack',
      if (extra != null) '@extra': extra,
      'language_pack_id': language_pack_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddCustomServerLanguagePack? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_pack_id = _map['language_pack_id']! as String;
    return AddCustomServerLanguagePack(
      extra: extra,
      clientId: clientId,
      language_pack_id: language_pack_id,
    );
  }
}

/// Adds or changes a custom local language pack to the current localization target.
///
/// Returns [Ok].
class SetCustomLanguagePack extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setCustomLanguagePack";

  /// Information about the language pack. Language pack identifier must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization.
  late LanguagePackInfo info;

  /// Strings of the new language pack.
  late List<LanguagePackString> strings;

  /// Adds or changes a custom local language pack to the current localization target
  ///
  /// Returns [Ok]
  SetCustomLanguagePack(
      {required this.info, required this.strings, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setCustomLanguagePack',
      if (extra != null) '@extra': extra,
      'info': info,
      'strings': strings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetCustomLanguagePack? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var info = LanguagePackInfo.fromMap(_map['info'])!;
    var strings = List<LanguagePackString>.from(
      (_map["strings"] ?? []).map(
        (e) => LanguagePackString.fromMap(e),
      ),
    );
    return SetCustomLanguagePack(
      extra: extra,
      clientId: clientId,
      info: info,
      strings: strings,
    );
  }
}

/// Edits information about a custom local language pack in the current localization target. Can be called before authorization.
///
/// Returns [Ok].
class EditCustomLanguagePackInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editCustomLanguagePackInfo";

  /// New information about the custom local language pack.
  late LanguagePackInfo info;

  /// Edits information about a custom local language pack in the current localization target. Can be called before authorization
  ///
  /// Returns [Ok]
  EditCustomLanguagePackInfo({required this.info, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editCustomLanguagePackInfo',
      if (extra != null) '@extra': extra,
      'info': info
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditCustomLanguagePackInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var info = LanguagePackInfo.fromMap(_map['info'])!;
    return EditCustomLanguagePackInfo(
      extra: extra,
      clientId: clientId,
      info: info,
    );
  }
}

/// Adds, edits or deletes a string in a custom local language pack. Can be called before authorization.
///
/// Returns [Ok].
class SetCustomLanguagePackString extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setCustomLanguagePackString";

  /// Identifier of a previously added custom local language pack in the current localization target.
  late String language_pack_id;

  /// New language pack string.
  late LanguagePackString new_string;

  /// Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
  ///
  /// Returns [Ok]
  SetCustomLanguagePackString(
      {required this.language_pack_id,
      required this.new_string,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setCustomLanguagePackString',
      if (extra != null) '@extra': extra,
      'language_pack_id': language_pack_id,
      'new_string': new_string
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetCustomLanguagePackString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_pack_id = _map['language_pack_id']! as String;
    var new_string = LanguagePackString.fromMap(_map['new_string'])!;
    return SetCustomLanguagePackString(
      extra: extra,
      clientId: clientId,
      language_pack_id: language_pack_id,
      new_string: new_string,
    );
  }
}

/// Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted..
///
/// Returns [Ok].
class DeleteLanguagePack extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteLanguagePack";

  /// Identifier of the language pack to delete.
  late String language_pack_id;

  /// Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted.
  ///
  /// Returns [Ok]
  DeleteLanguagePack(
      {required this.language_pack_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteLanguagePack',
      if (extra != null) '@extra': extra,
      'language_pack_id': language_pack_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteLanguagePack? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_pack_id = _map['language_pack_id']! as String;
    return DeleteLanguagePack(
      extra: extra,
      clientId: clientId,
      language_pack_id: language_pack_id,
    );
  }
}

/// Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription.
///
/// Returns [PushReceiverId].
class RegisterDevice extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "registerDevice";

  /// Device token.
  late DeviceToken device_token;

  /// List of user identifiers of other users currently using the application.
  late List<int> other_user_ids;

  /// Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
  ///
  /// Returns [PushReceiverId]
  RegisterDevice(
      {required this.device_token,
      required this.other_user_ids,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'registerDevice',
      if (extra != null) '@extra': extra,
      'device_token': device_token,
      'other_user_ids': other_user_ids
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RegisterDevice? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var device_token = DeviceToken.fromMap(_map['device_token'])!;
    var other_user_ids = List<int>.from(
      (_map["other_user_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    return RegisterDevice(
      extra: extra,
      clientId: clientId,
      device_token: device_token,
      other_user_ids: other_user_ids,
    );
  }
}

/// Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization.
///
/// Returns [Ok].
class ProcessPushNotification extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "processPushNotification";

  /// JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added.
  late String payload;

  /// Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
  ///
  /// Returns [Ok]
  ProcessPushNotification({required this.payload, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'processPushNotification',
      if (extra != null) '@extra': extra,
      'payload': payload
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ProcessPushNotification? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var payload = _map['payload']! as String;
    return ProcessPushNotification(
      extra: extra,
      clientId: clientId,
      payload: payload,
    );
  }
}

/// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously.
///
/// Returns [PushReceiverId].
class GetPushReceiverId extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPushReceiverId";

  /// JSON-encoded push notification payload.
  late String payload;

  /// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
  ///
  /// Returns [PushReceiverId]
  GetPushReceiverId({required this.payload, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPushReceiverId',
      if (extra != null) '@extra': extra,
      'payload': payload
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPushReceiverId? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var payload = _map['payload']! as String;
    return GetPushReceiverId(
      extra: extra,
      clientId: clientId,
      payload: payload,
    );
  }
}

/// Returns t.me URLs recently visited by a newly registered user.
///
/// Returns [TMeUrls].
class GetRecentlyVisitedTMeUrls extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getRecentlyVisitedTMeUrls";

  /// Google Play referrer to identify the user.
  late String referrer;

  /// Returns t.me URLs recently visited by a newly registered user
  ///
  /// Returns [TMeUrls]
  GetRecentlyVisitedTMeUrls(
      {required this.referrer, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getRecentlyVisitedTMeUrls',
      if (extra != null) '@extra': extra,
      'referrer': referrer
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetRecentlyVisitedTMeUrls? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var referrer = _map['referrer']! as String;
    return GetRecentlyVisitedTMeUrls(
      extra: extra,
      clientId: clientId,
      referrer: referrer,
    );
  }
}

/// Changes user privacy settings.
///
/// Returns [Ok].
class SetUserPrivacySettingRules extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setUserPrivacySettingRules";

  /// The privacy setting.
  late UserPrivacySetting setting;

  /// The new privacy rules.
  late UserPrivacySettingRules rules;

  /// Changes user privacy settings
  ///
  /// Returns [Ok]
  SetUserPrivacySettingRules(
      {required this.setting, required this.rules, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setUserPrivacySettingRules',
      if (extra != null) '@extra': extra,
      'setting': setting,
      'rules': rules
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetUserPrivacySettingRules? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var setting = UserPrivacySetting.fromMap(_map['setting'])!;
    var rules = UserPrivacySettingRules.fromMap(_map['rules'])!;
    return SetUserPrivacySettingRules(
      extra: extra,
      clientId: clientId,
      setting: setting,
      rules: rules,
    );
  }
}

/// Returns the current privacy settings.
///
/// Returns [UserPrivacySettingRules].
class GetUserPrivacySettingRules extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getUserPrivacySettingRules";

  /// The privacy setting.
  late UserPrivacySetting setting;

  /// Returns the current privacy settings
  ///
  /// Returns [UserPrivacySettingRules]
  GetUserPrivacySettingRules(
      {required this.setting, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getUserPrivacySettingRules',
      if (extra != null) '@extra': extra,
      'setting': setting
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetUserPrivacySettingRules? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var setting = UserPrivacySetting.fromMap(_map['setting'])!;
    return GetUserPrivacySettingRules(
      extra: extra,
      clientId: clientId,
      setting: setting,
    );
  }
}

/// Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization. Can be called synchronously for options "version" and "commit_hash".
///
/// Returns [OptionValue].
class GetOption extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getOption";

  /// The name of the option.
  late String name;

  /// Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization. Can be called synchronously for options "version" and "commit_hash"
  ///
  /// Returns [OptionValue]
  GetOption({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getOption',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetOption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return GetOption(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization.
///
/// Returns [Ok].
class SetOption extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setOption";

  /// The name of the option.
  late String name;

  /// The new value of the option; pass null to reset option value to a default value.
  OptionValue? value;

  /// Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
  ///
  /// Returns [Ok]
  SetOption({required this.name, this.value, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setOption',
      if (extra != null) '@extra': extra,
      'name': name,
      'value': value
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetOption? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var value = OptionValue.fromMap(_map['value']);
    return SetOption(
      extra: extra,
      clientId: clientId,
      name: name,
      value: value,
    );
  }
}

/// Changes the period of inactivity after which the account of the current user will automatically be deleted.
///
/// Returns [Ok].
class SetAccountTtl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setAccountTtl";

  /// New account TTL.
  late AccountTtl ttl;

  /// Changes the period of inactivity after which the account of the current user will automatically be deleted
  ///
  /// Returns [Ok]
  SetAccountTtl({required this.ttl, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setAccountTtl',
      if (extra != null) '@extra': extra,
      'ttl': ttl
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetAccountTtl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var ttl = AccountTtl.fromMap(_map['ttl'])!;
    return SetAccountTtl(
      extra: extra,
      clientId: clientId,
      ttl: ttl,
    );
  }
}

/// Returns the period of inactivity after which the account of the current user will automatically be deleted.
///
/// Returns [AccountTtl].
class GetAccountTtl extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getAccountTtl";

  /// Returns the period of inactivity after which the account of the current user will automatically be deleted
  ///
  /// Returns [AccountTtl]
  GetAccountTtl({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getAccountTtl', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetAccountTtl? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetAccountTtl(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account..
///
/// Returns [Ok].
class DeleteAccount extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteAccount";

  /// The reason why the account was deleted; optional.
  late String reason;

  /// The 2-step verification password of the current user. If not specified, account deletion can be canceled within one week.
  late String password;

  /// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account.
  ///
  /// Returns [Ok]
  DeleteAccount(
      {required this.reason,
      required this.password,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteAccount',
      if (extra != null) '@extra': extra,
      'reason': reason,
      'password': password
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteAccount? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var reason = _map['reason']! as String;
    var password = _map['password']! as String;
    return DeleteAccount(
      extra: extra,
      clientId: clientId,
      reason: reason,
      password: password,
    );
  }
}

/// Changes the default message auto-delete time for new chats.
///
/// Returns [Ok].
class SetDefaultMessageAutoDeleteTime extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setDefaultMessageAutoDeleteTime";

  /// New default message auto-delete time; must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically.
  late MessageAutoDeleteTime message_auto_delete_time;

  /// Changes the default message auto-delete time for new chats
  ///
  /// Returns [Ok]
  SetDefaultMessageAutoDeleteTime(
      {required this.message_auto_delete_time, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setDefaultMessageAutoDeleteTime',
      if (extra != null) '@extra': extra,
      'message_auto_delete_time': message_auto_delete_time
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetDefaultMessageAutoDeleteTime? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var message_auto_delete_time =
        MessageAutoDeleteTime.fromMap(_map['message_auto_delete_time'])!;
    return SetDefaultMessageAutoDeleteTime(
      extra: extra,
      clientId: clientId,
      message_auto_delete_time: message_auto_delete_time,
    );
  }
}

/// Returns default message auto-delete time setting for new chats.
///
/// Returns [MessageAutoDeleteTime].
class GetDefaultMessageAutoDeleteTime extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getDefaultMessageAutoDeleteTime";

  /// Returns default message auto-delete time setting for new chats
  ///
  /// Returns [MessageAutoDeleteTime]
  GetDefaultMessageAutoDeleteTime({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getDefaultMessageAutoDeleteTime',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetDefaultMessageAutoDeleteTime? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetDefaultMessageAutoDeleteTime(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Removes a chat action bar without any other action.
///
/// Returns [Ok].
class RemoveChatActionBar extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeChatActionBar";

  /// Chat identifier.
  late int chat_id;

  /// Removes a chat action bar without any other action
  ///
  /// Returns [Ok]
  RemoveChatActionBar({required this.chat_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeChatActionBar',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveChatActionBar? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    return RemoveChatActionBar(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
    );
  }
}

/// Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if chat.can_be_reported.
///
/// Returns [Ok].
class ReportChat extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportChat";

  /// Chat identifier.
  late int chat_id;

  /// Identifiers of reported messages; may be empty to report the whole chat.
  late List<int> message_ids;

  /// The reason for reporting the chat.
  late ReportReason reason;

  /// Additional report details; 0-1024 characters.
  late String text;

  /// Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if chat.can_be_reported
  ///
  /// Returns [Ok]
  ReportChat(
      {required this.chat_id,
      required this.message_ids,
      required this.reason,
      required this.text,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportChat',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_ids': message_ids,
      'reason': reason,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportChat? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_ids = List<int>.from(
      (_map["message_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var reason = ReportReason.fromMap(_map['reason'])!;
    var text = _map['text']! as String;
    return ReportChat(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_ids: message_ids,
      reason: reason,
      text: text,
    );
  }
}

/// Reports a chat photo to the Telegram moderators. A chat photo can be reported only if chat.can_be_reported.
///
/// Returns [Ok].
class ReportChatPhoto extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportChatPhoto";

  /// Chat identifier.
  late int chat_id;

  /// Identifier of the photo to report. Only full photos from chatPhoto can be reported.
  late int file_id;

  /// The reason for reporting the chat photo.
  late ReportReason reason;

  /// Additional report details; 0-1024 characters.
  late String text;

  /// Reports a chat photo to the Telegram moderators. A chat photo can be reported only if chat.can_be_reported
  ///
  /// Returns [Ok]
  ReportChatPhoto(
      {required this.chat_id,
      required this.file_id,
      required this.reason,
      required this.text,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportChatPhoto',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'file_id': file_id,
      'reason': reason,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportChatPhoto? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var file_id = _map['file_id']! as int;
    var reason = ReportReason.fromMap(_map['reason'])!;
    var text = _map['text']! as String;
    return ReportChatPhoto(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      file_id: file_id,
      reason: reason,
      text: text,
    );
  }
}

/// Reports reactions set on a message to the Telegram moderators. Reactions on a message can be reported only if message.can_report_reactions.
///
/// Returns [Ok].
class ReportMessageReactions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "reportMessageReactions";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// Identifier of the sender, which added the reaction.
  late MessageSender sender_id;

  /// Reports reactions set on a message to the Telegram moderators. Reactions on a message can be reported only if message.can_report_reactions
  ///
  /// Returns [Ok]
  ReportMessageReactions(
      {required this.chat_id,
      required this.message_id,
      required this.sender_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'reportMessageReactions',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'sender_id': sender_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ReportMessageReactions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var sender_id = MessageSender.fromMap(_map['sender_id'])!;
    return ReportMessageReactions(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      sender_id: sender_id,
    );
  }
}

/// Returns detailed statistics about a chat. Currently, this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true.
///
/// Returns [ChatStatistics].
class GetChatStatistics extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getChatStatistics";

  /// Chat identifier.
  late int chat_id;

  /// Pass true if a dark theme is used by the application.
  late bool is_dark;

  /// Returns detailed statistics about a chat. Currently, this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true
  ///
  /// Returns [ChatStatistics]
  GetChatStatistics(
      {required this.chat_id,
      required this.is_dark,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getChatStatistics',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'is_dark': is_dark
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetChatStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var is_dark = _map['is_dark']! as bool;
    return GetChatStatistics(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      is_dark: is_dark,
    );
  }
}

/// Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true.
///
/// Returns [MessageStatistics].
class GetMessageStatistics extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMessageStatistics";

  /// Chat identifier.
  late int chat_id;

  /// Message identifier.
  late int message_id;

  /// Pass true if a dark theme is used by the application.
  late bool is_dark;

  /// Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true
  ///
  /// Returns [MessageStatistics]
  GetMessageStatistics(
      {required this.chat_id,
      required this.message_id,
      required this.is_dark,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMessageStatistics',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'message_id': message_id,
      'is_dark': is_dark
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMessageStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var message_id = _map['message_id']! as int;
    var is_dark = _map['is_dark']! as bool;
    return GetMessageStatistics(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      message_id: message_id,
      is_dark: is_dark,
    );
  }
}

/// Loads an asynchronous or a zoomed in statistical graph.
///
/// Returns [StatisticalGraph].
class GetStatisticalGraph extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStatisticalGraph";

  /// Chat identifier.
  late int chat_id;

  /// The token for graph loading.
  late String token;

  /// X-value for zoomed in graph or 0 otherwise.
  late int x;

  /// Loads an asynchronous or a zoomed in statistical graph
  ///
  /// Returns [StatisticalGraph]
  GetStatisticalGraph(
      {required this.chat_id,
      required this.token,
      required this.x,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStatisticalGraph',
      if (extra != null) '@extra': extra,
      'chat_id': chat_id,
      'token': token,
      'x': x
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStatisticalGraph? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_id = _map['chat_id']! as int;
    var token = _map['token']! as String;
    var x = _map['x']! as int;
    return GetStatisticalGraph(
      extra: extra,
      clientId: clientId,
      chat_id: chat_id,
      token: token,
      x: x,
    );
  }
}

/// Returns storage usage statistics. Can be called before authorization.
///
/// Returns [StorageStatistics].
class GetStorageStatistics extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStorageStatistics";

  /// The maximum number of chats with the largest storage usage for which separate statistics need to be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0.
  late int chat_limit;

  /// Returns storage usage statistics. Can be called before authorization
  ///
  /// Returns [StorageStatistics]
  GetStorageStatistics({required this.chat_limit, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStorageStatistics',
      if (extra != null) '@extra': extra,
      'chat_limit': chat_limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStorageStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var chat_limit = _map['chat_limit']! as int;
    return GetStorageStatistics(
      extra: extra,
      clientId: clientId,
      chat_limit: chat_limit,
    );
  }
}

/// Quickly returns approximate storage usage statistics. Can be called before authorization.
///
/// Returns [StorageStatisticsFast].
class GetStorageStatisticsFast extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getStorageStatisticsFast";

  /// Quickly returns approximate storage usage statistics. Can be called before authorization
  ///
  /// Returns [StorageStatisticsFast]
  GetStorageStatisticsFast({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getStorageStatisticsFast',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetStorageStatisticsFast? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetStorageStatisticsFast(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns database statistics.
///
/// Returns [DatabaseStatistics].
class GetDatabaseStatistics extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getDatabaseStatistics";

  /// Returns database statistics
  ///
  /// Returns [DatabaseStatistics]
  GetDatabaseStatistics({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getDatabaseStatistics',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetDatabaseStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetDatabaseStatistics(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted.
///
/// Returns [StorageStatistics].
class OptimizeStorage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "optimizeStorage";

  /// Limit on the total size of files after deletion, in bytes. Pass -1 to use the default limit.
  late int size;

  /// Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit.
  late int ttl;

  /// Limit on the total number of files after deletion. Pass -1 to use the default limit.
  late int count;

  /// The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value.
  late int immunity_delay;

  /// If non-empty, only files with the given types are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted.
  late List<FileType> file_types;

  /// If non-empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos).
  late List<int> chat_ids;

  /// If non-empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos).
  late List<int> exclude_chat_ids;

  /// Pass true if statistics about the files that were deleted must be returned instead of the whole storage usage statistics. Affects only returned statistics.
  late bool return_deleted_file_statistics;

  /// Same as in getStorageStatistics. Affects only returned statistics.
  late int chat_limit;

  /// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
  ///
  /// Returns [StorageStatistics]
  OptimizeStorage(
      {required this.size,
      required this.ttl,
      required this.count,
      required this.immunity_delay,
      required this.file_types,
      required this.chat_ids,
      required this.exclude_chat_ids,
      required this.return_deleted_file_statistics,
      required this.chat_limit,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'optimizeStorage',
      if (extra != null) '@extra': extra,
      'size': size,
      'ttl': ttl,
      'count': count,
      'immunity_delay': immunity_delay,
      'file_types': file_types,
      'chat_ids': chat_ids,
      'exclude_chat_ids': exclude_chat_ids,
      'return_deleted_file_statistics': return_deleted_file_statistics,
      'chat_limit': chat_limit
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static OptimizeStorage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var size = _map['size']! as int;
    var ttl = _map['ttl']! as int;
    var count = _map['count']! as int;
    var immunity_delay = _map['immunity_delay']! as int;
    var file_types = List<FileType>.from(
      (_map["file_types"] ?? []).map(
        (e) => FileType.fromMap(e),
      ),
    );
    var chat_ids = List<int>.from(
      (_map["chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var exclude_chat_ids = List<int>.from(
      (_map["exclude_chat_ids"] ?? []).map(
        (e) => e as int,
      ),
    );
    var return_deleted_file_statistics =
        _map['return_deleted_file_statistics']! as bool;
    var chat_limit = _map['chat_limit']! as int;
    return OptimizeStorage(
      extra: extra,
      clientId: clientId,
      size: size,
      ttl: ttl,
      count: count,
      immunity_delay: immunity_delay,
      file_types: file_types,
      chat_ids: chat_ids,
      exclude_chat_ids: exclude_chat_ids,
      return_deleted_file_statistics: return_deleted_file_statistics,
      chat_limit: chat_limit,
    );
  }
}

/// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks,.
///
/// Returns [Ok].
class SetNetworkType extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setNetworkType";

  /// The new network type; pass null to set network type to networkTypeOther.
  NetworkType? type;

  /// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks,
  ///
  /// Returns [Ok]
  SetNetworkType({this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setNetworkType',
      if (extra != null) '@extra': extra,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetNetworkType? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = NetworkType.fromMap(_map['type']);
    return SetNetworkType(
      extra: extra,
      clientId: clientId,
      type: type,
    );
  }
}

/// Returns network data usage statistics. Can be called before authorization.
///
/// Returns [NetworkStatistics].
class GetNetworkStatistics extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getNetworkStatistics";

  /// Pass true to get statistics only for the current library launch.
  late bool only_current;

  /// Returns network data usage statistics. Can be called before authorization
  ///
  /// Returns [NetworkStatistics]
  GetNetworkStatistics({required this.only_current, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getNetworkStatistics',
      if (extra != null) '@extra': extra,
      'only_current': only_current
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetNetworkStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var only_current = _map['only_current']! as bool;
    return GetNetworkStatistics(
      extra: extra,
      clientId: clientId,
      only_current: only_current,
    );
  }
}

/// Adds the specified data to data usage statistics. Can be called before authorization.
///
/// Returns [Ok].
class AddNetworkStatistics extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addNetworkStatistics";

  /// The network statistics entry with the data to be added to statistics.
  late NetworkStatisticsEntry entry;

  /// Adds the specified data to data usage statistics. Can be called before authorization
  ///
  /// Returns [Ok]
  AddNetworkStatistics({required this.entry, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addNetworkStatistics',
      if (extra != null) '@extra': extra,
      'entry': entry
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddNetworkStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var entry = NetworkStatisticsEntry.fromMap(_map['entry'])!;
    return AddNetworkStatistics(
      extra: extra,
      clientId: clientId,
      entry: entry,
    );
  }
}

/// Resets all network data usage statistics to zero. Can be called before authorization.
///
/// Returns [Ok].
class ResetNetworkStatistics extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resetNetworkStatistics";

  /// Resets all network data usage statistics to zero. Can be called before authorization
  ///
  /// Returns [Ok]
  ResetNetworkStatistics({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resetNetworkStatistics',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResetNetworkStatistics? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResetNetworkStatistics(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns auto-download settings presets for the current user.
///
/// Returns [AutoDownloadSettingsPresets].
class GetAutoDownloadSettingsPresets extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getAutoDownloadSettingsPresets";

  /// Returns auto-download settings presets for the current user
  ///
  /// Returns [AutoDownloadSettingsPresets]
  GetAutoDownloadSettingsPresets({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getAutoDownloadSettingsPresets',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetAutoDownloadSettingsPresets? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetAutoDownloadSettingsPresets(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Sets auto-download settings.
///
/// Returns [Ok].
class SetAutoDownloadSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setAutoDownloadSettings";

  /// New user auto-download settings.
  late AutoDownloadSettings settings;

  /// Type of the network for which the new settings are relevant.
  late NetworkType type;

  /// Sets auto-download settings
  ///
  /// Returns [Ok]
  SetAutoDownloadSettings(
      {required this.settings, required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setAutoDownloadSettings',
      if (extra != null) '@extra': extra,
      'settings': settings,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetAutoDownloadSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var settings = AutoDownloadSettings.fromMap(_map['settings'])!;
    var type = NetworkType.fromMap(_map['type'])!;
    return SetAutoDownloadSettings(
      extra: extra,
      clientId: clientId,
      settings: settings,
      type: type,
    );
  }
}

/// Returns autosave settings for the current user.
///
/// Returns [AutosaveSettings].
class GetAutosaveSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getAutosaveSettings";

  /// Returns autosave settings for the current user
  ///
  /// Returns [AutosaveSettings]
  GetAutosaveSettings({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getAutosaveSettings', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetAutosaveSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetAutosaveSettings(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Sets autosave settings for the given scope. The method is guaranteed to work only after at least one call to getAutosaveSettings.
///
/// Returns [Ok].
class SetAutosaveSettings extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setAutosaveSettings";

  /// Autosave settings scope.
  late AutosaveSettingsScope scope;

  /// New autosave settings for the scope; pass null to set autosave settings to default.
  ScopeAutosaveSettings? settings;

  /// Sets autosave settings for the given scope. The method is guaranteed to work only after at least one call to getAutosaveSettings
  ///
  /// Returns [Ok]
  SetAutosaveSettings(
      {required this.scope, this.settings, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setAutosaveSettings',
      if (extra != null) '@extra': extra,
      'scope': scope,
      'settings': settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetAutosaveSettings? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var scope = AutosaveSettingsScope.fromMap(_map['scope'])!;
    var settings = ScopeAutosaveSettings.fromMap(_map['settings']);
    return SetAutosaveSettings(
      extra: extra,
      clientId: clientId,
      scope: scope,
      settings: settings,
    );
  }
}

/// Clears the list of all autosave settings exceptions. The method is guaranteed to work only after at least one call to getAutosaveSettings.
///
/// Returns [Ok].
class ClearAutosaveSettingsExceptions extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clearAutosaveSettingsExceptions";

  /// Clears the list of all autosave settings exceptions. The method is guaranteed to work only after at least one call to getAutosaveSettings
  ///
  /// Returns [Ok]
  ClearAutosaveSettingsExceptions({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clearAutosaveSettingsExceptions',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClearAutosaveSettingsExceptions? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ClearAutosaveSettingsExceptions(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns information about a bank card.
///
/// Returns [BankCardInfo].
class GetBankCardInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getBankCardInfo";

  /// The bank card number.
  late String bank_card_number;

  /// Returns information about a bank card
  ///
  /// Returns [BankCardInfo]
  GetBankCardInfo({required this.bank_card_number, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getBankCardInfo',
      if (extra != null) '@extra': extra,
      'bank_card_number': bank_card_number
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetBankCardInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bank_card_number = _map['bank_card_number']! as String;
    return GetBankCardInfo(
      extra: extra,
      clientId: clientId,
      bank_card_number: bank_card_number,
    );
  }
}

/// Returns one of the available Telegram Passport elements.
///
/// Returns [PassportElement].
class GetPassportElement extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPassportElement";

  /// Telegram Passport element type.
  late PassportElementType type;

  /// The 2-step verification password of the current user.
  late String password;

  /// Returns one of the available Telegram Passport elements
  ///
  /// Returns [PassportElement]
  GetPassportElement(
      {required this.type, required this.password, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPassportElement',
      if (extra != null) '@extra': extra,
      'type': type,
      'password': password
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPassportElement? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = PassportElementType.fromMap(_map['type'])!;
    var password = _map['password']! as String;
    return GetPassportElement(
      extra: extra,
      clientId: clientId,
      type: type,
      password: password,
    );
  }
}

/// Returns all available Telegram Passport elements.
///
/// Returns [PassportElements].
class GetAllPassportElements extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getAllPassportElements";

  /// The 2-step verification password of the current user.
  late String password;

  /// Returns all available Telegram Passport elements
  ///
  /// Returns [PassportElements]
  GetAllPassportElements({required this.password, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getAllPassportElements',
      if (extra != null) '@extra': extra,
      'password': password
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetAllPassportElements? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var password = _map['password']! as String;
    return GetAllPassportElements(
      extra: extra,
      clientId: clientId,
      password: password,
    );
  }
}

/// Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first.
///
/// Returns [PassportElement].
class SetPassportElement extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setPassportElement";

  /// Input Telegram Passport element.
  late InputPassportElement element;

  /// The 2-step verification password of the current user.
  late String password;

  /// Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
  ///
  /// Returns [PassportElement]
  SetPassportElement(
      {required this.element,
      required this.password,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setPassportElement',
      if (extra != null) '@extra': extra,
      'element': element,
      'password': password
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetPassportElement? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var element = InputPassportElement.fromMap(_map['element'])!;
    var password = _map['password']! as String;
    return SetPassportElement(
      extra: extra,
      clientId: clientId,
      element: element,
      password: password,
    );
  }
}

/// Deletes a Telegram Passport element.
///
/// Returns [Ok].
class DeletePassportElement extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deletePassportElement";

  /// Element type.
  late PassportElementType type;

  /// Deletes a Telegram Passport element
  ///
  /// Returns [Ok]
  DeletePassportElement({required this.type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deletePassportElement',
      if (extra != null) '@extra': extra,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeletePassportElement? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = PassportElementType.fromMap(_map['type'])!;
    return DeletePassportElement(
      extra: extra,
      clientId: clientId,
      type: type,
    );
  }
}

/// Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed.
///
/// Returns [Ok].
class SetPassportElementErrors extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setPassportElementErrors";

  /// User identifier.
  late int user_id;

  /// The errors.
  late List<InputPassportElementError> errors;

  /// Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
  ///
  /// Returns [Ok]
  SetPassportElementErrors(
      {required this.user_id, required this.errors, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setPassportElementErrors',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'errors': errors
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetPassportElementErrors? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var errors = List<InputPassportElementError>.from(
      (_map["errors"] ?? []).map(
        (e) => InputPassportElementError.fromMap(e),
      ),
    );
    return SetPassportElementErrors(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      errors: errors,
    );
  }
}

/// Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown.
///
/// Returns [Text].
class GetPreferredCountryLanguage extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPreferredCountryLanguage";

  /// A two-letter ISO 3166-1 alpha-2 country code.
  late String country_code;

  /// Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
  ///
  /// Returns [Text]
  GetPreferredCountryLanguage(
      {required this.country_code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPreferredCountryLanguage',
      if (extra != null) '@extra': extra,
      'country_code': country_code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPreferredCountryLanguage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var country_code = _map['country_code']! as String;
    return GetPreferredCountryLanguage(
      extra: extra,
      clientId: clientId,
      country_code: country_code,
    );
  }
}

/// Sends a code to verify a phone number to be added to a user's Telegram Passport.
///
/// Returns [AuthenticationCodeInfo].
class SendPhoneNumberVerificationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendPhoneNumberVerificationCode";

  /// The phone number of the user, in international format.
  late String phone_number;

  /// Settings for the authentication of the user's phone number; pass null to use default settings.
  PhoneNumberAuthenticationSettings? settings;

  /// Sends a code to verify a phone number to be added to a user's Telegram Passport
  ///
  /// Returns [AuthenticationCodeInfo]
  SendPhoneNumberVerificationCode(
      {required this.phone_number, this.settings, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendPhoneNumberVerificationCode',
      if (extra != null) '@extra': extra,
      'phone_number': phone_number,
      'settings': settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendPhoneNumberVerificationCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number = _map['phone_number']! as String;
    var settings = PhoneNumberAuthenticationSettings.fromMap(_map['settings']);
    return SendPhoneNumberVerificationCode(
      extra: extra,
      clientId: clientId,
      phone_number: phone_number,
      settings: settings,
    );
  }
}

/// Resends the code to verify a phone number to be added to a user's Telegram Passport.
///
/// Returns [AuthenticationCodeInfo].
class ResendPhoneNumberVerificationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resendPhoneNumberVerificationCode";

  /// Resends the code to verify a phone number to be added to a user's Telegram Passport
  ///
  /// Returns [AuthenticationCodeInfo]
  ResendPhoneNumberVerificationCode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resendPhoneNumberVerificationCode',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResendPhoneNumberVerificationCode? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResendPhoneNumberVerificationCode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks the phone number verification code for Telegram Passport.
///
/// Returns [Ok].
class CheckPhoneNumberVerificationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkPhoneNumberVerificationCode";

  /// Verification code to check.
  late String code;

  /// Checks the phone number verification code for Telegram Passport
  ///
  /// Returns [Ok]
  CheckPhoneNumberVerificationCode(
      {required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkPhoneNumberVerificationCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckPhoneNumberVerificationCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = _map['code']! as String;
    return CheckPhoneNumberVerificationCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// Sends a code to verify an email address to be added to a user's Telegram Passport.
///
/// Returns [EmailAddressAuthenticationCodeInfo].
class SendEmailAddressVerificationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendEmailAddressVerificationCode";

  /// Email address.
  late String email_address;

  /// Sends a code to verify an email address to be added to a user's Telegram Passport
  ///
  /// Returns [EmailAddressAuthenticationCodeInfo]
  SendEmailAddressVerificationCode(
      {required this.email_address, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendEmailAddressVerificationCode',
      if (extra != null) '@extra': extra,
      'email_address': email_address
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendEmailAddressVerificationCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var email_address = _map['email_address']! as String;
    return SendEmailAddressVerificationCode(
      extra: extra,
      clientId: clientId,
      email_address: email_address,
    );
  }
}

/// Resends the code to verify an email address to be added to a user's Telegram Passport.
///
/// Returns [EmailAddressAuthenticationCodeInfo].
class ResendEmailAddressVerificationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resendEmailAddressVerificationCode";

  /// Resends the code to verify an email address to be added to a user's Telegram Passport
  ///
  /// Returns [EmailAddressAuthenticationCodeInfo]
  ResendEmailAddressVerificationCode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resendEmailAddressVerificationCode',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResendEmailAddressVerificationCode? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResendEmailAddressVerificationCode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks the email address verification code for Telegram Passport.
///
/// Returns [Ok].
class CheckEmailAddressVerificationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkEmailAddressVerificationCode";

  /// Verification code to check.
  late String code;

  /// Checks the email address verification code for Telegram Passport
  ///
  /// Returns [Ok]
  CheckEmailAddressVerificationCode(
      {required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkEmailAddressVerificationCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckEmailAddressVerificationCode? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = _map['code']! as String;
    return CheckEmailAddressVerificationCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// Returns a Telegram Passport authorization form for sharing data with a service.
///
/// Returns [PassportAuthorizationForm].
class GetPassportAuthorizationForm extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPassportAuthorizationForm";

  /// User identifier of the service's bot.
  late int bot_user_id;

  /// Telegram Passport element types requested by the service.
  late String scope;

  /// Service's public key.
  late String public_key;

  /// Unique request identifier provided by the service.
  late String nonce;

  /// Returns a Telegram Passport authorization form for sharing data with a service
  ///
  /// Returns [PassportAuthorizationForm]
  GetPassportAuthorizationForm(
      {required this.bot_user_id,
      required this.scope,
      required this.public_key,
      required this.nonce,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPassportAuthorizationForm',
      if (extra != null) '@extra': extra,
      'bot_user_id': bot_user_id,
      'scope': scope,
      'public_key': public_key,
      'nonce': nonce
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPassportAuthorizationForm? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var bot_user_id = _map['bot_user_id']! as int;
    var scope = _map['scope']! as String;
    var public_key = _map['public_key']! as String;
    var nonce = _map['nonce']! as String;
    return GetPassportAuthorizationForm(
      extra: extra,
      clientId: clientId,
      bot_user_id: bot_user_id,
      scope: scope,
      public_key: public_key,
      nonce: nonce,
    );
  }
}

/// Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form.
///
/// Returns [PassportElementsWithErrors].
class GetPassportAuthorizationFormAvailableElements extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR =
      "getPassportAuthorizationFormAvailableElements";

  /// Authorization form identifier.
  late int authorization_form_id;

  /// The 2-step verification password of the current user.
  late String password;

  /// Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
  ///
  /// Returns [PassportElementsWithErrors]
  GetPassportAuthorizationFormAvailableElements(
      {required this.authorization_form_id,
      required this.password,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPassportAuthorizationFormAvailableElements',
      if (extra != null) '@extra': extra,
      'authorization_form_id': authorization_form_id,
      'password': password
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPassportAuthorizationFormAvailableElements? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var authorization_form_id = _map['authorization_form_id']! as int;
    var password = _map['password']! as String;
    return GetPassportAuthorizationFormAvailableElements(
      extra: extra,
      clientId: clientId,
      authorization_form_id: authorization_form_id,
      password: password,
    );
  }
}

/// Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused.
///
/// Returns [Ok].
class SendPassportAuthorizationForm extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendPassportAuthorizationForm";

  /// Authorization form identifier.
  late int authorization_form_id;

  /// Types of Telegram Passport elements chosen by user to complete the authorization form.
  late List<PassportElementType> types;

  /// Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused
  ///
  /// Returns [Ok]
  SendPassportAuthorizationForm(
      {required this.authorization_form_id,
      required this.types,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendPassportAuthorizationForm',
      if (extra != null) '@extra': extra,
      'authorization_form_id': authorization_form_id,
      'types': types
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendPassportAuthorizationForm? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var authorization_form_id = _map['authorization_form_id']! as int;
    var types = List<PassportElementType>.from(
      (_map["types"] ?? []).map(
        (e) => PassportElementType.fromMap(e),
      ),
    );
    return SendPassportAuthorizationForm(
      extra: extra,
      clientId: clientId,
      authorization_form_id: authorization_form_id,
      types: types,
    );
  }
}

/// Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation.
///
/// Returns [AuthenticationCodeInfo].
class SendPhoneNumberConfirmationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendPhoneNumberConfirmationCode";

  /// Hash value from the link.
  late String hash;

  /// Phone number value from the link.
  late String phone_number;

  /// Settings for the authentication of the user's phone number; pass null to use default settings.
  PhoneNumberAuthenticationSettings? settings;

  /// Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation
  ///
  /// Returns [AuthenticationCodeInfo]
  SendPhoneNumberConfirmationCode(
      {required this.hash,
      required this.phone_number,
      this.settings,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendPhoneNumberConfirmationCode',
      if (extra != null) '@extra': extra,
      'hash': hash,
      'phone_number': phone_number,
      'settings': settings
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendPhoneNumberConfirmationCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var hash = _map['hash']! as String;
    var phone_number = _map['phone_number']! as String;
    var settings = PhoneNumberAuthenticationSettings.fromMap(_map['settings']);
    return SendPhoneNumberConfirmationCode(
      extra: extra,
      clientId: clientId,
      hash: hash,
      phone_number: phone_number,
      settings: settings,
    );
  }
}

/// Resends phone number confirmation code.
///
/// Returns [AuthenticationCodeInfo].
class ResendPhoneNumberConfirmationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "resendPhoneNumberConfirmationCode";

  /// Resends phone number confirmation code
  ///
  /// Returns [AuthenticationCodeInfo]
  ResendPhoneNumberConfirmationCode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'resendPhoneNumberConfirmationCode',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ResendPhoneNumberConfirmationCode? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ResendPhoneNumberConfirmationCode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks phone number confirmation code.
///
/// Returns [Ok].
class CheckPhoneNumberConfirmationCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkPhoneNumberConfirmationCode";

  /// Confirmation code to check.
  late String code;

  /// Checks phone number confirmation code
  ///
  /// Returns [Ok]
  CheckPhoneNumberConfirmationCode(
      {required this.code, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkPhoneNumberConfirmationCode',
      if (extra != null) '@extra': extra,
      'code': code
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckPhoneNumberConfirmationCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var code = _map['code']! as String;
    return CheckPhoneNumberConfirmationCode(
      extra: extra,
      clientId: clientId,
      code: code,
    );
  }
}

/// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only.
///
/// Returns [Ok].
class SetBotUpdatesStatus extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setBotUpdatesStatus";

  /// The number of pending updates.
  late int pending_update_count;

  /// The last error message.
  late String error_message;

  /// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
  ///
  /// Returns [Ok]
  SetBotUpdatesStatus(
      {required this.pending_update_count,
      required this.error_message,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setBotUpdatesStatus',
      if (extra != null) '@extra': extra,
      'pending_update_count': pending_update_count,
      'error_message': error_message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetBotUpdatesStatus? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var pending_update_count = _map['pending_update_count']! as int;
    var error_message = _map['error_message']! as String;
    return SetBotUpdatesStatus(
      extra: extra,
      clientId: clientId,
      pending_update_count: pending_update_count,
      error_message: error_message,
    );
  }
}

/// Uploads a file with a sticker; returns the uploaded file.
///
/// Returns [File].
class UploadStickerFile extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "uploadStickerFile";

  /// Sticker file owner; ignored for regular users.
  late int user_id;

  /// Sticker format.
  late StickerFormat sticker_format;

  /// File file to upload; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side..
  late InputFile sticker;

  /// Uploads a file with a sticker; returns the uploaded file
  ///
  /// Returns [File]
  UploadStickerFile(
      {required this.user_id,
      required this.sticker_format,
      required this.sticker,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'uploadStickerFile',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'sticker_format': sticker_format,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static UploadStickerFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var sticker_format = StickerFormat.fromMap(_map['sticker_format'])!;
    var sticker = InputFile.fromMap(_map['sticker'])!;
    return UploadStickerFile(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      sticker_format: sticker_format,
      sticker: sticker,
    );
  }
}

/// Returns a suggested name for a new sticker set with a given title.
///
/// Returns [Text].
class GetSuggestedStickerSetName extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSuggestedStickerSetName";

  /// Sticker set title; 1-64 characters.
  late String title;

  /// Returns a suggested name for a new sticker set with a given title
  ///
  /// Returns [Text]
  GetSuggestedStickerSetName({required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getSuggestedStickerSetName',
      if (extra != null) '@extra': extra,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSuggestedStickerSetName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var title = _map['title']! as String;
    return GetSuggestedStickerSetName(
      extra: extra,
      clientId: clientId,
      title: title,
    );
  }
}

/// Checks whether a name can be used for a new sticker set.
///
/// Returns [CheckStickerSetNameResult].
class CheckStickerSetName extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "checkStickerSetName";

  /// Name to be checked.
  late String name;

  /// Checks whether a name can be used for a new sticker set
  ///
  /// Returns [CheckStickerSetNameResult]
  CheckStickerSetName({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'checkStickerSetName',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CheckStickerSetName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return CheckStickerSetName(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// Creates a new sticker set. Returns the newly created sticker set.
///
/// Returns [StickerSet].
class CreateNewStickerSet extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "createNewStickerSet";

  /// Sticker set owner; ignored for regular users.
  late int user_id;

  /// Sticker set title; 1-64 characters.
  late String title;

  /// Sticker set name. Can contain only English letters, digits and underscores. Must end with *"_by_<bot username>"* (*<bot_username>* is case insensitive) for bots; 1-64 characters.
  late String name;

  /// Format of the stickers in the set.
  late StickerFormat sticker_format;

  /// Type of the stickers in the set.
  late StickerType sticker_type;

  /// Pass true if stickers in the sticker set must be repainted; for custom emoji sticker sets only.
  late bool needs_repainting;

  /// List of stickers to be added to the set; must be non-empty. All stickers must have the same format. For TGS stickers, uploadStickerFile must be used before the sticker is shown.
  late List<InputSticker> stickers;

  /// Source of the sticker set; may be empty if unknown.
  late String source;

  /// Creates a new sticker set. Returns the newly created sticker set
  ///
  /// Returns [StickerSet]
  CreateNewStickerSet(
      {required this.user_id,
      required this.title,
      required this.name,
      required this.sticker_format,
      required this.sticker_type,
      required this.needs_repainting,
      required this.stickers,
      required this.source,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'createNewStickerSet',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'title': title,
      'name': name,
      'sticker_format': sticker_format,
      'sticker_type': sticker_type,
      'needs_repainting': needs_repainting,
      'stickers': stickers,
      'source': source
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CreateNewStickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var title = _map['title']! as String;
    var name = _map['name']! as String;
    var sticker_format = StickerFormat.fromMap(_map['sticker_format'])!;
    var sticker_type = StickerType.fromMap(_map['sticker_type'])!;
    var needs_repainting = _map['needs_repainting']! as bool;
    var stickers = List<InputSticker>.from(
      (_map["stickers"] ?? []).map(
        (e) => InputSticker.fromMap(e),
      ),
    );
    var source = _map['source']! as String;
    return CreateNewStickerSet(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      title: title,
      name: name,
      sticker_format: sticker_format,
      sticker_type: sticker_type,
      needs_repainting: needs_repainting,
      stickers: stickers,
      source: source,
    );
  }
}

/// Adds a new sticker to a set; for bots only.
///
/// Returns [Ok].
class AddStickerToSet extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addStickerToSet";

  /// Sticker set owner.
  late int user_id;

  /// Sticker set name.
  late String name;

  /// Sticker to add to the set.
  late InputSticker sticker;

  /// Adds a new sticker to a set; for bots only
  ///
  /// Returns [Ok]
  AddStickerToSet(
      {required this.user_id,
      required this.name,
      required this.sticker,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addStickerToSet',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'name': name,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddStickerToSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var name = _map['name']! as String;
    var sticker = InputSticker.fromMap(_map['sticker'])!;
    return AddStickerToSet(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      name: name,
      sticker: sticker,
    );
  }
}

/// Sets a sticker set thumbnail; for bots only.
///
/// Returns [Ok].
class SetStickerSetThumbnail extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setStickerSetThumbnail";

  /// Sticker set owner.
  late int user_id;

  /// Sticker set name.
  late String name;

  /// Thumbnail to set in PNG, TGS, or WEBM format; pass null to remove the sticker set thumbnail. Thumbnail format must match the format of stickers in the set.
  InputFile? thumbnail;

  /// Sets a sticker set thumbnail; for bots only
  ///
  /// Returns [Ok]
  SetStickerSetThumbnail(
      {required this.user_id,
      required this.name,
      this.thumbnail,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setStickerSetThumbnail',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'name': name,
      'thumbnail': thumbnail
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetStickerSetThumbnail? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var name = _map['name']! as String;
    var thumbnail = InputFile.fromMap(_map['thumbnail']);
    return SetStickerSetThumbnail(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      name: name,
      thumbnail: thumbnail,
    );
  }
}

/// Sets a custom emoji sticker set thumbnail; for bots only.
///
/// Returns [Ok].
class SetCustomEmojiStickerSetThumbnail extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setCustomEmojiStickerSetThumbnail";

  /// Sticker set name.
  late String name;

  /// Identifier of the custom emoji from the sticker set, which will be set as sticker set thumbnail; pass 0 to remove the sticker set thumbnail.
  /// ; string representation of int, use `int.parse`
  late int64 custom_emoji_id;

  /// Sets a custom emoji sticker set thumbnail; for bots only
  ///
  /// Returns [Ok]
  SetCustomEmojiStickerSetThumbnail(
      {required this.name,
      required this.custom_emoji_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setCustomEmojiStickerSetThumbnail',
      if (extra != null) '@extra': extra,
      'name': name,
      'custom_emoji_id': custom_emoji_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetCustomEmojiStickerSetThumbnail? fromMap(
      Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var custom_emoji_id = _map['custom_emoji_id']! as int64;
    return SetCustomEmojiStickerSetThumbnail(
      extra: extra,
      clientId: clientId,
      name: name,
      custom_emoji_id: custom_emoji_id,
    );
  }
}

/// Sets a sticker set title; for bots only.
///
/// Returns [Ok].
class SetStickerSetTitle extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setStickerSetTitle";

  /// Sticker set name.
  late String name;

  /// New sticker set title.
  late String title;

  /// Sets a sticker set title; for bots only
  ///
  /// Returns [Ok]
  SetStickerSetTitle(
      {required this.name, required this.title, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setStickerSetTitle',
      if (extra != null) '@extra': extra,
      'name': name,
      'title': title
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetStickerSetTitle? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    var title = _map['title']! as String;
    return SetStickerSetTitle(
      extra: extra,
      clientId: clientId,
      name: name,
      title: title,
    );
  }
}

/// Deleted a sticker set; for bots only.
///
/// Returns [Ok].
class DeleteStickerSet extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "deleteStickerSet";

  /// Sticker set name.
  late String name;

  /// Deleted a sticker set; for bots only
  ///
  /// Returns [Ok]
  DeleteStickerSet({required this.name, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'deleteStickerSet',
      if (extra != null) '@extra': extra,
      'name': name
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DeleteStickerSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var name = _map['name']! as String;
    return DeleteStickerSet(
      extra: extra,
      clientId: clientId,
      name: name,
    );
  }
}

/// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot.
///
/// Returns [Ok].
class SetStickerPositionInSet extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setStickerPositionInSet";

  /// Sticker.
  late InputFile sticker;

  /// New position of the sticker in the set, 0-based.
  late int position;

  /// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
  ///
  /// Returns [Ok]
  SetStickerPositionInSet(
      {required this.sticker,
      required this.position,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setStickerPositionInSet',
      if (extra != null) '@extra': extra,
      'sticker': sticker,
      'position': position
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetStickerPositionInSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    var position = _map['position']! as int;
    return SetStickerPositionInSet(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
      position: position,
    );
  }
}

/// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot.
///
/// Returns [Ok].
class RemoveStickerFromSet extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeStickerFromSet";

  /// Sticker.
  late InputFile sticker;

  /// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
  ///
  /// Returns [Ok]
  RemoveStickerFromSet({required this.sticker, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeStickerFromSet',
      if (extra != null) '@extra': extra,
      'sticker': sticker
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveStickerFromSet? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    return RemoveStickerFromSet(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
    );
  }
}

/// Changes the list of emoji corresponding to a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot.
///
/// Returns [Ok].
class SetStickerEmojis extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setStickerEmojis";

  /// Sticker.
  late InputFile sticker;

  /// New string with 1-20 emoji corresponding to the sticker.
  late String emojis;

  /// Changes the list of emoji corresponding to a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
  ///
  /// Returns [Ok]
  SetStickerEmojis(
      {required this.sticker, required this.emojis, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setStickerEmojis',
      if (extra != null) '@extra': extra,
      'sticker': sticker,
      'emojis': emojis
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetStickerEmojis? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    var emojis = _map['emojis']! as String;
    return SetStickerEmojis(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
      emojis: emojis,
    );
  }
}

/// Changes the list of keywords of a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot.
///
/// Returns [Ok].
class SetStickerKeywords extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setStickerKeywords";

  /// Sticker.
  late InputFile sticker;

  /// List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker.
  late List<String> keywords;

  /// Changes the list of keywords of a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
  ///
  /// Returns [Ok]
  SetStickerKeywords(
      {required this.sticker,
      required this.keywords,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setStickerKeywords',
      if (extra != null) '@extra': extra,
      'sticker': sticker,
      'keywords': keywords
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetStickerKeywords? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    var keywords = List<String>.from(
      (_map["keywords"] ?? []).map(
        (e) => e as String,
      ),
    );
    return SetStickerKeywords(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
      keywords: keywords,
    );
  }
}

/// Changes the mask position of a mask sticker; for bots only. The sticker must belong to a mask sticker set created by the bot.
///
/// Returns [Ok].
class SetStickerMaskPosition extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setStickerMaskPosition";

  /// Sticker.
  late InputFile sticker;

  /// Position where the mask is placed; pass null to remove mask position.
  MaskPosition? mask_position;

  /// Changes the mask position of a mask sticker; for bots only. The sticker must belong to a mask sticker set created by the bot
  ///
  /// Returns [Ok]
  SetStickerMaskPosition(
      {required this.sticker, this.mask_position, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setStickerMaskPosition',
      if (extra != null) '@extra': extra,
      'sticker': sticker,
      'mask_position': mask_position
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetStickerMaskPosition? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var sticker = InputFile.fromMap(_map['sticker'])!;
    var mask_position = MaskPosition.fromMap(_map['mask_position']);
    return SetStickerMaskPosition(
      extra: extra,
      clientId: clientId,
      sticker: sticker,
      mask_position: mask_position,
    );
  }
}

/// Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded.
///
/// Returns [File].
class GetMapThumbnailFile extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getMapThumbnailFile";

  /// Location of the map center.
  late Location location;

  /// Map zoom level; 13-20.
  late int zoom;

  /// Map width in pixels before applying scale; 16-1024.
  late int width;

  /// Map height in pixels before applying scale; 16-1024.
  late int height;

  /// Map scale; 1-3.
  late int scale;

  /// Identifier of a chat in which the thumbnail will be shown. Use 0 if unknown.
  late int chat_id;

  /// Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
  ///
  /// Returns [File]
  GetMapThumbnailFile(
      {required this.location,
      required this.zoom,
      required this.width,
      required this.height,
      required this.scale,
      required this.chat_id,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getMapThumbnailFile',
      if (extra != null) '@extra': extra,
      'location': location,
      'zoom': zoom,
      'width': width,
      'height': height,
      'scale': scale,
      'chat_id': chat_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetMapThumbnailFile? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var location = Location.fromMap(_map['location'])!;
    var zoom = _map['zoom']! as int;
    var width = _map['width']! as int;
    var height = _map['height']! as int;
    var scale = _map['scale']! as int;
    var chat_id = _map['chat_id']! as int;
    return GetMapThumbnailFile(
      extra: extra,
      clientId: clientId,
      location: location,
      zoom: zoom,
      width: width,
      height: height,
      scale: scale,
      chat_id: chat_id,
    );
  }
}

/// Returns information about a limit, increased for Premium users. Returns a 404 error if the limit is unknown.
///
/// Returns [PremiumLimit].
class GetPremiumLimit extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPremiumLimit";

  /// Type of the limit.
  late PremiumLimitType limit_type;

  /// Returns information about a limit, increased for Premium users. Returns a 404 error if the limit is unknown
  ///
  /// Returns [PremiumLimit]
  GetPremiumLimit({required this.limit_type, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPremiumLimit',
      if (extra != null) '@extra': extra,
      'limit_type': limit_type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPremiumLimit? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var limit_type = PremiumLimitType.fromMap(_map['limit_type'])!;
    return GetPremiumLimit(
      extra: extra,
      clientId: clientId,
      limit_type: limit_type,
    );
  }
}

/// Returns information about features, available to Premium users.
///
/// Returns [PremiumFeatures].
class GetPremiumFeatures extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPremiumFeatures";

  /// Source of the request; pass null if the method is called from some non-standard source.
  PremiumSource? source;

  /// Returns information about features, available to Premium users
  ///
  /// Returns [PremiumFeatures]
  GetPremiumFeatures({this.source, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPremiumFeatures',
      if (extra != null) '@extra': extra,
      'source': source
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPremiumFeatures? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var source = PremiumSource.fromMap(_map['source']);
    return GetPremiumFeatures(
      extra: extra,
      clientId: clientId,
      source: source,
    );
  }
}

/// Returns examples of premium stickers for demonstration purposes.
///
/// Returns [Stickers].
class GetPremiumStickerExamples extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPremiumStickerExamples";

  /// Returns examples of premium stickers for demonstration purposes
  ///
  /// Returns [Stickers]
  GetPremiumStickerExamples({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPremiumStickerExamples',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPremiumStickerExamples? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetPremiumStickerExamples(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Informs TDLib that the user viewed detailed information about a Premium feature on the Premium features screen.
///
/// Returns [Ok].
class ViewPremiumFeature extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "viewPremiumFeature";

  /// The viewed premium feature.
  late PremiumFeature feature;

  /// Informs TDLib that the user viewed detailed information about a Premium feature on the Premium features screen
  ///
  /// Returns [Ok]
  ViewPremiumFeature({required this.feature, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'viewPremiumFeature',
      if (extra != null) '@extra': extra,
      'feature': feature
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ViewPremiumFeature? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var feature = PremiumFeature.fromMap(_map['feature'])!;
    return ViewPremiumFeature(
      extra: extra,
      clientId: clientId,
      feature: feature,
    );
  }
}

/// Informs TDLib that the user clicked Premium subscription button on the Premium features screen.
///
/// Returns [Ok].
class ClickPremiumSubscriptionButton extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "clickPremiumSubscriptionButton";

  /// Informs TDLib that the user clicked Premium subscription button on the Premium features screen
  ///
  /// Returns [Ok]
  ClickPremiumSubscriptionButton({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'clickPremiumSubscriptionButton',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static ClickPremiumSubscriptionButton? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return ClickPremiumSubscriptionButton(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns state of Telegram Premium subscription and promotion videos for Premium features.
///
/// Returns [PremiumState].
class GetPremiumState extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPremiumState";

  /// Returns state of Telegram Premium subscription and promotion videos for Premium features
  ///
  /// Returns [PremiumState]
  GetPremiumState({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getPremiumState', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPremiumState? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetPremiumState(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Checks whether Telegram Premium purchase is possible. Must be called before in-store Premium purchase.
///
/// Returns [Ok].
class CanPurchasePremium extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "canPurchasePremium";

  /// Transaction purpose.
  late StorePaymentPurpose purpose;

  /// Checks whether Telegram Premium purchase is possible. Must be called before in-store Premium purchase
  ///
  /// Returns [Ok]
  CanPurchasePremium({required this.purpose, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'canPurchasePremium',
      if (extra != null) '@extra': extra,
      'purpose': purpose
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static CanPurchasePremium? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var purpose = StorePaymentPurpose.fromMap(_map['purpose'])!;
    return CanPurchasePremium(
      extra: extra,
      clientId: clientId,
      purpose: purpose,
    );
  }
}

/// Informs server about a purchase through App Store. For official applications only.
///
/// Returns [Ok].
class AssignAppStoreTransaction extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "assignAppStoreTransaction";

  /// App Store receipt.
  /// ; base64-encoded bytes `List<int>`
  late bytes receipt;

  /// Transaction purpose.
  late StorePaymentPurpose purpose;

  /// Informs server about a purchase through App Store. For official applications only
  ///
  /// Returns [Ok]
  AssignAppStoreTransaction(
      {required this.receipt,
      required this.purpose,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'assignAppStoreTransaction',
      if (extra != null) '@extra': extra,
      'receipt': receipt,
      'purpose': purpose
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AssignAppStoreTransaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var receipt = _map['receipt']! as bytes;
    var purpose = StorePaymentPurpose.fromMap(_map['purpose'])!;
    return AssignAppStoreTransaction(
      extra: extra,
      clientId: clientId,
      receipt: receipt,
      purpose: purpose,
    );
  }
}

/// Informs server about a purchase through Google Play. For official applications only.
///
/// Returns [Ok].
class AssignGooglePlayTransaction extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "assignGooglePlayTransaction";

  /// Application package name.
  late String package_name;

  /// Identifier of the purchased store product.
  late String store_product_id;

  /// Google Play purchase token.
  late String purchase_token;

  /// Transaction purpose.
  late StorePaymentPurpose purpose;

  /// Informs server about a purchase through Google Play. For official applications only
  ///
  /// Returns [Ok]
  AssignGooglePlayTransaction(
      {required this.package_name,
      required this.store_product_id,
      required this.purchase_token,
      required this.purpose,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'assignGooglePlayTransaction',
      if (extra != null) '@extra': extra,
      'package_name': package_name,
      'store_product_id': store_product_id,
      'purchase_token': purchase_token,
      'purpose': purpose
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AssignGooglePlayTransaction? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var package_name = _map['package_name']! as String;
    var store_product_id = _map['store_product_id']! as String;
    var purchase_token = _map['purchase_token']! as String;
    var purpose = StorePaymentPurpose.fromMap(_map['purpose'])!;
    return AssignGooglePlayTransaction(
      extra: extra,
      clientId: clientId,
      package_name: package_name,
      store_product_id: store_product_id,
      purchase_token: purchase_token,
      purpose: purpose,
    );
  }
}

/// Accepts Telegram terms of services.
///
/// Returns [Ok].
class AcceptTermsOfService extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "acceptTermsOfService";

  /// Terms of service identifier.
  late String terms_of_service_id;

  /// Accepts Telegram terms of services
  ///
  /// Returns [Ok]
  AcceptTermsOfService(
      {required this.terms_of_service_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'acceptTermsOfService',
      if (extra != null) '@extra': extra,
      'terms_of_service_id': terms_of_service_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AcceptTermsOfService? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var terms_of_service_id = _map['terms_of_service_id']! as String;
    return AcceptTermsOfService(
      extra: extra,
      clientId: clientId,
      terms_of_service_id: terms_of_service_id,
    );
  }
}

/// Searches specified query by word prefixes in the provided strings. Returns 0-based positions of strings that matched. Can be called synchronously.
///
/// Returns [FoundPositions].
class SearchStringsByPrefix extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "searchStringsByPrefix";

  /// The strings to search in for the query.
  late List<String> strings;

  /// Query to search for.
  late String query;

  /// The maximum number of objects to return.
  late int limit;

  /// Pass true to receive no results for an empty query.
  late bool return_none_for_empty_query;

  /// Searches specified query by word prefixes in the provided strings. Returns 0-based positions of strings that matched. Can be called synchronously
  ///
  /// Returns [FoundPositions]
  SearchStringsByPrefix(
      {required this.strings,
      required this.query,
      required this.limit,
      required this.return_none_for_empty_query,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'searchStringsByPrefix',
      if (extra != null) '@extra': extra,
      'strings': strings,
      'query': query,
      'limit': limit,
      'return_none_for_empty_query': return_none_for_empty_query
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SearchStringsByPrefix? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var strings = List<String>.from(
      (_map["strings"] ?? []).map(
        (e) => e as String,
      ),
    );
    var query = _map['query']! as String;
    var limit = _map['limit']! as int;
    var return_none_for_empty_query =
        _map['return_none_for_empty_query']! as bool;
    return SearchStringsByPrefix(
      extra: extra,
      clientId: clientId,
      strings: strings,
      query: query,
      limit: limit,
      return_none_for_empty_query: return_none_for_empty_query,
    );
  }
}

/// Sends a custom request; for bots only.
///
/// Returns [CustomRequestResult].
class SendCustomRequest extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "sendCustomRequest";

  /// The method name.
  late String method;

  /// JSON-serialized method parameters.
  late String parameters;

  /// Sends a custom request; for bots only
  ///
  /// Returns [CustomRequestResult]
  SendCustomRequest(
      {required this.method,
      required this.parameters,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'sendCustomRequest',
      if (extra != null) '@extra': extra,
      'method': method,
      'parameters': parameters
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SendCustomRequest? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var method = _map['method']! as String;
    var parameters = _map['parameters']! as String;
    return SendCustomRequest(
      extra: extra,
      clientId: clientId,
      method: method,
      parameters: parameters,
    );
  }
}

/// Answers a custom query; for bots only.
///
/// Returns [Ok].
class AnswerCustomQuery extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "answerCustomQuery";

  /// Identifier of a custom query.
  /// ; string representation of int, use `int.parse`
  late int64 custom_query_id;

  /// JSON-serialized answer to the query.
  late String data;

  /// Answers a custom query; for bots only
  ///
  /// Returns [Ok]
  AnswerCustomQuery(
      {required this.custom_query_id,
      required this.data,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'answerCustomQuery',
      if (extra != null) '@extra': extra,
      'custom_query_id': custom_query_id,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AnswerCustomQuery? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var custom_query_id = _map['custom_query_id']! as int64;
    var data = _map['data']! as String;
    return AnswerCustomQuery(
      extra: extra,
      clientId: clientId,
      custom_query_id: custom_query_id,
      data: data,
    );
  }
}

/// Succeeds after a specified amount of time has passed. Can be called before initialization.
///
/// Returns [Ok].
class SetAlarm extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setAlarm";

  /// Number of seconds before the function returns.
  late double seconds;

  /// Succeeds after a specified amount of time has passed. Can be called before initialization
  ///
  /// Returns [Ok]
  SetAlarm({required this.seconds, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setAlarm',
      if (extra != null) '@extra': extra,
      'seconds': seconds
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetAlarm? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var seconds = _map['seconds']! as double;
    return SetAlarm(
      extra: extra,
      clientId: clientId,
      seconds: seconds,
    );
  }
}

/// Returns information about existing countries. Can be called before authorization.
///
/// Returns [Countries].
class GetCountries extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCountries";

  /// Returns information about existing countries. Can be called before authorization
  ///
  /// Returns [Countries]
  GetCountries({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getCountries', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCountries? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetCountries(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization.
///
/// Returns [Text].
class GetCountryCode extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getCountryCode";

  /// Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
  ///
  /// Returns [Text]
  GetCountryCode({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getCountryCode', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetCountryCode? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetCountryCode(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns information about a phone number by its prefix. Can be called before authorization.
///
/// Returns [PhoneNumberInfo].
class GetPhoneNumberInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPhoneNumberInfo";

  /// The phone number prefix.
  late String phone_number_prefix;

  /// Returns information about a phone number by its prefix. Can be called before authorization
  ///
  /// Returns [PhoneNumberInfo]
  GetPhoneNumberInfo(
      {required this.phone_number_prefix, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPhoneNumberInfo',
      if (extra != null) '@extra': extra,
      'phone_number_prefix': phone_number_prefix
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPhoneNumberInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var phone_number_prefix = _map['phone_number_prefix']! as String;
    return GetPhoneNumberInfo(
      extra: extra,
      clientId: clientId,
      phone_number_prefix: phone_number_prefix,
    );
  }
}

/// Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously.
///
/// Returns [PhoneNumberInfo].
class GetPhoneNumberInfoSync extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getPhoneNumberInfoSync";

  /// A two-letter ISO 639-1 language code for country information localization.
  late String language_code;

  /// The phone number prefix.
  late String phone_number_prefix;

  /// Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
  ///
  /// Returns [PhoneNumberInfo]
  GetPhoneNumberInfoSync(
      {required this.language_code,
      required this.phone_number_prefix,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getPhoneNumberInfoSync',
      if (extra != null) '@extra': extra,
      'language_code': language_code,
      'phone_number_prefix': phone_number_prefix
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetPhoneNumberInfoSync? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var language_code = _map['language_code']! as String;
    var phone_number_prefix = _map['phone_number_prefix']! as String;
    return GetPhoneNumberInfoSync(
      extra: extra,
      clientId: clientId,
      language_code: language_code,
      phone_number_prefix: phone_number_prefix,
    );
  }
}

/// Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization.
///
/// Returns [DeepLinkInfo].
class GetDeepLinkInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getDeepLinkInfo";

  /// The link.
  late String link;

  /// Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
  ///
  /// Returns [DeepLinkInfo]
  GetDeepLinkInfo({required this.link, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getDeepLinkInfo',
      if (extra != null) '@extra': extra,
      'link': link
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetDeepLinkInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var link = _map['link']! as String;
    return GetDeepLinkInfo(
      extra: extra,
      clientId: clientId,
      link: link,
    );
  }
}

/// Returns application config, provided by the server. Can be called before authorization.
///
/// Returns [JsonValue].
class GetApplicationConfig extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getApplicationConfig";

  /// Returns application config, provided by the server. Can be called before authorization
  ///
  /// Returns [JsonValue]
  GetApplicationConfig({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getApplicationConfig',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetApplicationConfig? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetApplicationConfig(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Adds server-provided application changelog as messages to the chat 777000 (Telegram) or as a stories; for official applications only. Returns a 404 error if nothing changed.
///
/// Returns [Ok].
class AddApplicationChangelog extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addApplicationChangelog";

  /// The previous application version.
  late String previous_application_version;

  /// Adds server-provided application changelog as messages to the chat 777000 (Telegram) or as a stories; for official applications only. Returns a 404 error if nothing changed
  ///
  /// Returns [Ok]
  AddApplicationChangelog(
      {required this.previous_application_version, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addApplicationChangelog',
      if (extra != null) '@extra': extra,
      'previous_application_version': previous_application_version
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddApplicationChangelog? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var previous_application_version =
        _map['previous_application_version']! as String;
    return AddApplicationChangelog(
      extra: extra,
      clientId: clientId,
      previous_application_version: previous_application_version,
    );
  }
}

/// Saves application log event on the server. Can be called before authorization.
///
/// Returns [Ok].
class SaveApplicationLogEvent extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "saveApplicationLogEvent";

  /// Event type.
  late String type;

  /// Optional chat identifier, associated with the event.
  late int chat_id;

  /// The log event data.
  late JsonValue data;

  /// Saves application log event on the server. Can be called before authorization
  ///
  /// Returns [Ok]
  SaveApplicationLogEvent(
      {required this.type,
      required this.chat_id,
      required this.data,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'saveApplicationLogEvent',
      if (extra != null) '@extra': extra,
      'type': type,
      'chat_id': chat_id,
      'data': data
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SaveApplicationLogEvent? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var type = _map['type']! as String;
    var chat_id = _map['chat_id']! as int;
    var data = JsonValue.fromMap(_map['data'])!;
    return SaveApplicationLogEvent(
      extra: extra,
      clientId: clientId,
      type: type,
      chat_id: chat_id,
      data: data,
    );
  }
}

/// Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram.
///
/// Returns [HttpUrl].
class GetApplicationDownloadLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getApplicationDownloadLink";

  /// Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram
  ///
  /// Returns [HttpUrl]
  GetApplicationDownloadLink({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getApplicationDownloadLink',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetApplicationDownloadLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetApplicationDownloadLink(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Adds a proxy server for network requests. Can be called before authorization.
///
/// Returns [Proxy].
class AddProxy extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addProxy";

  /// Proxy server domain or IP address.
  late String server;

  /// Proxy server port.
  late int port;

  /// Pass true to immediately enable the proxy.
  late bool enable;

  /// Proxy type.
  late ProxyType type;

  /// Adds a proxy server for network requests. Can be called before authorization
  ///
  /// Returns [Proxy]
  AddProxy(
      {required this.server,
      required this.port,
      required this.enable,
      required this.type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addProxy',
      if (extra != null) '@extra': extra,
      'server': server,
      'port': port,
      'enable': enable,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var server = _map['server']! as String;
    var port = _map['port']! as int;
    var enable = _map['enable']! as bool;
    var type = ProxyType.fromMap(_map['type'])!;
    return AddProxy(
      extra: extra,
      clientId: clientId,
      server: server,
      port: port,
      enable: enable,
      type: type,
    );
  }
}

/// Edits an existing proxy server for network requests. Can be called before authorization.
///
/// Returns [Proxy].
class EditProxy extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "editProxy";

  /// Proxy identifier.
  late int proxy_id;

  /// Proxy server domain or IP address.
  late String server;

  /// Proxy server port.
  late int port;

  /// Pass true to immediately enable the proxy.
  late bool enable;

  /// Proxy type.
  late ProxyType type;

  /// Edits an existing proxy server for network requests. Can be called before authorization
  ///
  /// Returns [Proxy]
  EditProxy(
      {required this.proxy_id,
      required this.server,
      required this.port,
      required this.enable,
      required this.type,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'editProxy',
      if (extra != null) '@extra': extra,
      'proxy_id': proxy_id,
      'server': server,
      'port': port,
      'enable': enable,
      'type': type
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EditProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var proxy_id = _map['proxy_id']! as int;
    var server = _map['server']! as String;
    var port = _map['port']! as int;
    var enable = _map['enable']! as bool;
    var type = ProxyType.fromMap(_map['type'])!;
    return EditProxy(
      extra: extra,
      clientId: clientId,
      proxy_id: proxy_id,
      server: server,
      port: port,
      enable: enable,
      type: type,
    );
  }
}

/// Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization.
///
/// Returns [Ok].
class EnableProxy extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "enableProxy";

  /// Proxy identifier.
  late int proxy_id;

  /// Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
  ///
  /// Returns [Ok]
  EnableProxy({required this.proxy_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'enableProxy',
      if (extra != null) '@extra': extra,
      'proxy_id': proxy_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static EnableProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var proxy_id = _map['proxy_id']! as int;
    return EnableProxy(
      extra: extra,
      clientId: clientId,
      proxy_id: proxy_id,
    );
  }
}

/// Disables the currently enabled proxy. Can be called before authorization.
///
/// Returns [Ok].
class DisableProxy extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "disableProxy";

  /// Disables the currently enabled proxy. Can be called before authorization
  ///
  /// Returns [Ok]
  DisableProxy({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'disableProxy', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static DisableProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return DisableProxy(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Removes a proxy server. Can be called before authorization.
///
/// Returns [Ok].
class RemoveProxy extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "removeProxy";

  /// Proxy identifier.
  late int proxy_id;

  /// Removes a proxy server. Can be called before authorization
  ///
  /// Returns [Ok]
  RemoveProxy({required this.proxy_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'removeProxy',
      if (extra != null) '@extra': extra,
      'proxy_id': proxy_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static RemoveProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var proxy_id = _map['proxy_id']! as int;
    return RemoveProxy(
      extra: extra,
      clientId: clientId,
      proxy_id: proxy_id,
    );
  }
}

/// Returns list of proxies that are currently set up. Can be called before authorization.
///
/// Returns [Proxies].
class GetProxies extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getProxies";

  /// Returns list of proxies that are currently set up. Can be called before authorization
  ///
  /// Returns [Proxies]
  GetProxies({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getProxies', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetProxies? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetProxies(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization.
///
/// Returns [HttpUrl].
class GetProxyLink extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getProxyLink";

  /// Proxy identifier.
  late int proxy_id;

  /// Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
  ///
  /// Returns [HttpUrl]
  GetProxyLink({required this.proxy_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getProxyLink',
      if (extra != null) '@extra': extra,
      'proxy_id': proxy_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetProxyLink? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var proxy_id = _map['proxy_id']! as int;
    return GetProxyLink(
      extra: extra,
      clientId: clientId,
      proxy_id: proxy_id,
    );
  }
}

/// Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization.
///
/// Returns [Seconds].
class PingProxy extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "pingProxy";

  /// Proxy identifier. Use 0 to ping a Telegram server without a proxy.
  late int proxy_id;

  /// Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
  ///
  /// Returns [Seconds]
  PingProxy({required this.proxy_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'pingProxy',
      if (extra != null) '@extra': extra,
      'proxy_id': proxy_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static PingProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var proxy_id = _map['proxy_id']! as int;
    return PingProxy(
      extra: extra,
      clientId: clientId,
      proxy_id: proxy_id,
    );
  }
}

/// Sets new log stream for internal logging of TDLib. Can be called synchronously.
///
/// Returns [Ok].
class SetLogStream extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setLogStream";

  /// New log stream.
  late LogStream log_stream;

  /// Sets new log stream for internal logging of TDLib. Can be called synchronously
  ///
  /// Returns [Ok]
  SetLogStream({required this.log_stream, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setLogStream',
      if (extra != null) '@extra': extra,
      'log_stream': log_stream
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetLogStream? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var log_stream = LogStream.fromMap(_map['log_stream'])!;
    return SetLogStream(
      extra: extra,
      clientId: clientId,
      log_stream: log_stream,
    );
  }
}

/// Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously.
///
/// Returns [LogStream].
class GetLogStream extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLogStream";

  /// Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
  ///
  /// Returns [LogStream]
  GetLogStream({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getLogStream', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLogStream? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetLogStream(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Sets the verbosity level of the internal logging of TDLib. Can be called synchronously.
///
/// Returns [Ok].
class SetLogVerbosityLevel extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setLogVerbosityLevel";

  /// New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings,.
  late int new_verbosity_level;

  /// Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
  ///
  /// Returns [Ok]
  SetLogVerbosityLevel(
      {required this.new_verbosity_level, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setLogVerbosityLevel',
      if (extra != null) '@extra': extra,
      'new_verbosity_level': new_verbosity_level
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetLogVerbosityLevel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var new_verbosity_level = _map['new_verbosity_level']! as int;
    return SetLogVerbosityLevel(
      extra: extra,
      clientId: clientId,
      new_verbosity_level: new_verbosity_level,
    );
  }
}

/// Returns current verbosity level of the internal logging of TDLib. Can be called synchronously.
///
/// Returns [LogVerbosityLevel].
class GetLogVerbosityLevel extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLogVerbosityLevel";

  /// Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
  ///
  /// Returns [LogVerbosityLevel]
  GetLogVerbosityLevel({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getLogVerbosityLevel',
      if (extra != null) '@extra': extra
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLogVerbosityLevel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetLogVerbosityLevel(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously.
///
/// Returns [LogTags].
class GetLogTags extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLogTags";

  /// Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
  ///
  /// Returns [LogTags]
  GetLogTags({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getLogTags', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLogTags? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetLogTags(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously.
///
/// Returns [Ok].
class SetLogTagVerbosityLevel extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setLogTagVerbosityLevel";

  /// Logging tag to change verbosity level.
  late String tag;

  /// New verbosity level; 1-1024.
  late int new_verbosity_level;

  /// Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
  ///
  /// Returns [Ok]
  SetLogTagVerbosityLevel(
      {required this.tag,
      required this.new_verbosity_level,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setLogTagVerbosityLevel',
      if (extra != null) '@extra': extra,
      'tag': tag,
      'new_verbosity_level': new_verbosity_level
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetLogTagVerbosityLevel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var tag = _map['tag']! as String;
    var new_verbosity_level = _map['new_verbosity_level']! as int;
    return SetLogTagVerbosityLevel(
      extra: extra,
      clientId: clientId,
      tag: tag,
      new_verbosity_level: new_verbosity_level,
    );
  }
}

/// Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously.
///
/// Returns [LogVerbosityLevel].
class GetLogTagVerbosityLevel extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getLogTagVerbosityLevel";

  /// Logging tag to change verbosity level.
  late String tag;

  /// Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
  ///
  /// Returns [LogVerbosityLevel]
  GetLogTagVerbosityLevel({required this.tag, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getLogTagVerbosityLevel',
      if (extra != null) '@extra': extra,
      'tag': tag
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetLogTagVerbosityLevel? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var tag = _map['tag']! as String;
    return GetLogTagVerbosityLevel(
      extra: extra,
      clientId: clientId,
      tag: tag,
    );
  }
}

/// Adds a message to TDLib internal log. Can be called synchronously.
///
/// Returns [Ok].
class AddLogMessage extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "addLogMessage";

  /// The minimum verbosity level needed for the message to be logged; 0-1023.
  late int verbosity_level;

  /// Text of a message to log.
  late String text;

  /// Adds a message to TDLib internal log. Can be called synchronously
  ///
  /// Returns [Ok]
  AddLogMessage(
      {required this.verbosity_level,
      required this.text,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'addLogMessage',
      if (extra != null) '@extra': extra,
      'verbosity_level': verbosity_level,
      'text': text
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static AddLogMessage? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var verbosity_level = _map['verbosity_level']! as int;
    var text = _map['text']! as String;
    return AddLogMessage(
      extra: extra,
      clientId: clientId,
      verbosity_level: verbosity_level,
      text: text,
    );
  }
}

/// Returns support information for the given user; for Telegram support only.
///
/// Returns [UserSupportInfo].
class GetUserSupportInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getUserSupportInfo";

  /// User identifier.
  late int user_id;

  /// Returns support information for the given user; for Telegram support only
  ///
  /// Returns [UserSupportInfo]
  GetUserSupportInfo({required this.user_id, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'getUserSupportInfo',
      if (extra != null) '@extra': extra,
      'user_id': user_id
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetUserSupportInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    return GetUserSupportInfo(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
    );
  }
}

/// Sets support information for the given user; for Telegram support only.
///
/// Returns [UserSupportInfo].
class SetUserSupportInfo extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "setUserSupportInfo";

  /// User identifier.
  late int user_id;

  /// New information message.
  late FormattedText message;

  /// Sets support information for the given user; for Telegram support only
  ///
  /// Returns [UserSupportInfo]
  SetUserSupportInfo(
      {required this.user_id,
      required this.message,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'setUserSupportInfo',
      if (extra != null) '@extra': extra,
      'user_id': user_id,
      'message': message
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static SetUserSupportInfo? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var user_id = _map['user_id']! as int;
    var message = FormattedText.fromMap(_map['message'])!;
    return SetUserSupportInfo(
      extra: extra,
      clientId: clientId,
      user_id: user_id,
      message: message,
    );
  }
}

/// Returns localized name of the Telegram support user; for Telegram support only.
///
/// Returns [Text].
class GetSupportName extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "getSupportName";

  /// Returns localized name of the Telegram support user; for Telegram support only
  ///
  /// Returns [Text]
  GetSupportName({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'getSupportName', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static GetSupportName? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return GetSupportName(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Does nothing; for testing only. This is an offline method. Can be called before authorization.
///
/// Returns [Ok].
class TestCallEmpty extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testCallEmpty";

  /// Does nothing; for testing only. This is an offline method. Can be called before authorization
  ///
  /// Returns [Ok]
  TestCallEmpty({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'testCallEmpty', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestCallEmpty? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TestCallEmpty(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns the received string; for testing only. This is an offline method. Can be called before authorization.
///
/// Returns [TestString].
class TestCallString extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testCallString";

  /// String to return.
  late String x;

  /// Returns the received string; for testing only. This is an offline method. Can be called before authorization
  ///
  /// Returns [TestString]
  TestCallString({required this.x, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testCallString',
      if (extra != null) '@extra': extra,
      'x': x
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestCallString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var x = _map['x']! as String;
    return TestCallString(
      extra: extra,
      clientId: clientId,
      x: x,
    );
  }
}

/// Returns the received bytes; for testing only. This is an offline method. Can be called before authorization.
///
/// Returns [TestBytes].
class TestCallBytes extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testCallBytes";

  /// Bytes to return.
  /// ; base64-encoded bytes `List<int>`
  late bytes x;

  /// Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
  ///
  /// Returns [TestBytes]
  TestCallBytes({required this.x, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testCallBytes',
      if (extra != null) '@extra': extra,
      'x': x
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestCallBytes? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var x = _map['x']! as bytes;
    return TestCallBytes(
      extra: extra,
      clientId: clientId,
      x: x,
    );
  }
}

/// Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization.
///
/// Returns [TestVectorInt].
class TestCallVectorInt extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testCallVectorInt";

  /// Vector of numbers to return.
  late List<int> x;

  /// Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
  ///
  /// Returns [TestVectorInt]
  TestCallVectorInt({required this.x, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testCallVectorInt',
      if (extra != null) '@extra': extra,
      'x': x
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestCallVectorInt? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var x = List<int>.from(
      (_map["x"] ?? []).map(
        (e) => e as int,
      ),
    );
    return TestCallVectorInt(
      extra: extra,
      clientId: clientId,
      x: x,
    );
  }
}

/// Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization.
///
/// Returns [TestVectorIntObject].
class TestCallVectorIntObject extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testCallVectorIntObject";

  /// Vector of objects to return.
  late List<TestInt> x;

  /// Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
  ///
  /// Returns [TestVectorIntObject]
  TestCallVectorIntObject({required this.x, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testCallVectorIntObject',
      if (extra != null) '@extra': extra,
      'x': x
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestCallVectorIntObject? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var x = List<TestInt>.from(
      (_map["x"] ?? []).map(
        (e) => TestInt.fromMap(e),
      ),
    );
    return TestCallVectorIntObject(
      extra: extra,
      clientId: clientId,
      x: x,
    );
  }
}

/// Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization.
///
/// Returns [TestVectorString].
class TestCallVectorString extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testCallVectorString";

  /// Vector of strings to return.
  late List<String> x;

  /// Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
  ///
  /// Returns [TestVectorString]
  TestCallVectorString({required this.x, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testCallVectorString',
      if (extra != null) '@extra': extra,
      'x': x
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestCallVectorString? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var x = List<String>.from(
      (_map["x"] ?? []).map(
        (e) => e as String,
      ),
    );
    return TestCallVectorString(
      extra: extra,
      clientId: clientId,
      x: x,
    );
  }
}

/// Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization.
///
/// Returns [TestVectorStringObject].
class TestCallVectorStringObject extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testCallVectorStringObject";

  /// Vector of objects to return.
  late List<TestString> x;

  /// Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
  ///
  /// Returns [TestVectorStringObject]
  TestCallVectorStringObject({required this.x, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testCallVectorStringObject',
      if (extra != null) '@extra': extra,
      'x': x
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestCallVectorStringObject? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var x = List<TestString>.from(
      (_map["x"] ?? []).map(
        (e) => TestString.fromMap(e),
      ),
    );
    return TestCallVectorStringObject(
      extra: extra,
      clientId: clientId,
      x: x,
    );
  }
}

/// Returns the squared received number; for testing only. This is an offline method. Can be called before authorization.
///
/// Returns [TestInt].
class TestSquareInt extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testSquareInt";

  /// Number to square.
  late int x;

  /// Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
  ///
  /// Returns [TestInt]
  TestSquareInt({required this.x, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testSquareInt',
      if (extra != null) '@extra': extra,
      'x': x
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestSquareInt? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var x = _map['x']! as int;
    return TestSquareInt(
      extra: extra,
      clientId: clientId,
      x: x,
    );
  }
}

/// Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization.
///
/// Returns [Ok].
class TestNetwork extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testNetwork";

  /// Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
  ///
  /// Returns [Ok]
  TestNetwork({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'testNetwork', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestNetwork? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TestNetwork(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization.
///
/// Returns [Ok].
class TestProxy extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testProxy";

  /// Proxy server domain or IP address.
  late String server;

  /// Proxy server port.
  late int port;

  /// Proxy type.
  late ProxyType type;

  /// Identifier of a datacenter with which to test connection.
  late int dc_id;

  /// The maximum overall timeout for the request.
  late double timeout;

  /// Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
  ///
  /// Returns [Ok]
  TestProxy(
      {required this.server,
      required this.port,
      required this.type,
      required this.dc_id,
      required this.timeout,
      this.extra,
      this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testProxy',
      if (extra != null) '@extra': extra,
      'server': server,
      'port': port,
      'type': type,
      'dc_id': dc_id,
      'timeout': timeout
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestProxy? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var server = _map['server']! as String;
    var port = _map['port']! as int;
    var type = ProxyType.fromMap(_map['type'])!;
    var dc_id = _map['dc_id']! as int;
    var timeout = _map['timeout']! as double;
    return TestProxy(
      extra: extra,
      clientId: clientId,
      server: server,
      port: port,
      type: type,
      dc_id: dc_id,
      timeout: timeout,
    );
  }
}

/// Forces an updates.getDifference call to the Telegram servers; for testing only.
///
/// Returns [Ok].
class TestGetDifference extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testGetDifference";

  /// Forces an updates.getDifference call to the Telegram servers; for testing only
  ///
  /// Returns [Ok]
  TestGetDifference({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'testGetDifference', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestGetDifference? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TestGetDifference(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization.
///
/// Returns [Update].
class TestUseUpdate extends Func {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testUseUpdate";

  /// Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization
  ///
  /// Returns [Update]
  TestUseUpdate({this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {'@type': 'testUseUpdate', if (extra != null) '@extra': extra};
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestUseUpdate? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];

    return TestUseUpdate(
      extra: extra,
      clientId: clientId,
    );
  }
}

/// Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously.
///
/// Returns [Error].
class TestReturnError extends SyncFunc {
  /// Request identifier. Must be non-zero.
  int? extra;

  /// TDLib client instance identifier, for which the response was received.
  int? clientId;

  /// @type
  static const String CONSTRUCTOR = "testReturnError";

  /// The error to be returned.
  late Error error;

  /// Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
  ///
  /// Returns [Error]
  TestReturnError({required this.error, this.extra, this.clientId});

  @override
  Map<String, dynamic> toJson() {
    return {
      '@type': 'testReturnError',
      if (extra != null) '@extra': extra,
      'error': error
    };
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Construct from [Map].
  static TestReturnError? fromMap(Map<String, dynamic>? _map) {
    if (_map == null) return null;
    var _ = _map["@type"];
    if (_ != CONSTRUCTOR) return null;
    var extra = _map['@extra'];
    var clientId = _map['@clientId'];
    var error = Error.fromMap(_map['error'])!;
    return TestReturnError(
      extra: extra,
      clientId: clientId,
      error: error,
    );
  }
}
